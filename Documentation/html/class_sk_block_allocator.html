<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: SkBlockAllocator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_sk_block_allocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SkBlockAllocator Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_sk_block_allocator_8h_source.html">SkBlockAllocator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SkBlockAllocator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_sk_block_allocator.png" usemap="#SkBlockAllocator_map" alt=""/>
  <map id="SkBlockAllocator_map" name="SkBlockAllocator_map">
<area href="class_sk_noncopyable.html" alt="SkNoncopyable" shape="rect" coords="0,0,108,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator_1_1_block_iter.html">BlockIter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_block_allocator_1_1_byte_range.html">ByteRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2cb0d0bf04e26c69fda5e2beb8586c45"><td class="memItemLeft" align="right" valign="top"><a id="a2cb0d0bf04e26c69fda5e2beb8586c45"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>GrowthPolicy</b> : int { <br />
&#160;&#160;<b>kFixed</b>, 
<b>kLinear</b>, 
<b>kFibonacci</b>, 
<b>kExponential</b>, 
<br />
&#160;&#160;<b>kLast</b> = kExponential
<br />
 }</td></tr>
<tr class="separator:a2cb0d0bf04e26c69fda5e2beb8586c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa09201ce71382daed8db78a6239c6b"><td class="memItemLeft" align="right" valign="top"><a id="abfa09201ce71382daed8db78a6239c6b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ReserveFlags</b> : unsigned { <b>kIgnoreGrowthPolicy_Flag</b> = 0b01, 
<b>kIgnoreExistingBytes_Flag</b> = 0b10, 
<b>kNo_ReserveFlags</b> = 0b00
 }</td></tr>
<tr class="separator:abfa09201ce71382daed8db78a6239c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aca859622443c8a611b3befff678d38e5"><td class="memItemLeft" align="right" valign="top"><a id="aca859622443c8a611b3befff678d38e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SkBlockAllocator</b> (GrowthPolicy policy, size_t blockIncrementBytes, size_t additionalPreallocBytes=0)</td></tr>
<tr class="separator:aca859622443c8a611b3befff678d38e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8358e1051adb79e2a0933c440c0794e9"><td class="memItemLeft" align="right" valign="top"><a id="a8358e1051adb79e2a0933c440c0794e9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *p)</td></tr>
<tr class="separator:a8358e1051adb79e2a0933c440c0794e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a904b21efec9487223d952d164bef159e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#a904b21efec9487223d952d164bef159e">totalSize</a> () const</td></tr>
<tr class="separator:a904b21efec9487223d952d164bef159e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcfc637f3bc835a84eb0743d342bd6e7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#abcfc637f3bc835a84eb0743d342bd6e7">totalUsableSpace</a> () const</td></tr>
<tr class="separator:abcfc637f3bc835a84eb0743d342bd6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232fa348a798fefda7a00f456bef1ab1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#a232fa348a798fefda7a00f456bef1ab1">totalSpaceInUse</a> () const</td></tr>
<tr class="separator:a232fa348a798fefda7a00f456bef1ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab64924932b25c02e426c95a6f552ec9a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#ab64924932b25c02e426c95a6f552ec9a">preallocSize</a> () const</td></tr>
<tr class="separator:ab64924932b25c02e426c95a6f552ec9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631af1889f71b627419c1341660385cf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#a631af1889f71b627419c1341660385cf">preallocUsableSpace</a> () const</td></tr>
<tr class="separator:a631af1889f71b627419c1341660385cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa407213783ddfb0a05dd104849388a3a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#aa407213783ddfb0a05dd104849388a3a">metadata</a> () const</td></tr>
<tr class="separator:aa407213783ddfb0a05dd104849388a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6571df06fbfd507871869cd25a5e0396"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#a6571df06fbfd507871869cd25a5e0396">setMetadata</a> (int value)</td></tr>
<tr class="separator:a6571df06fbfd507871869cd25a5e0396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5238baa2e451f5ba69abb01a1c8a82"><td class="memTemplParams" colspan="2">template&lt;size_t Align, size_t Padding = 0&gt; </td></tr>
<tr class="memitem:a9d5238baa2e451f5ba69abb01a1c8a82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_sk_block_allocator_1_1_byte_range.html">ByteRange</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#a9d5238baa2e451f5ba69abb01a1c8a82">allocate</a> (size_t size)</td></tr>
<tr class="separator:a9d5238baa2e451f5ba69abb01a1c8a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3998492724e925aaddbde94e806c337a"><td class="memTemplParams" colspan="2">template&lt;size_t Align = 1, size_t Padding = 0&gt; </td></tr>
<tr class="memitem:a3998492724e925aaddbde94e806c337a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#a3998492724e925aaddbde94e806c337a">reserve</a> (size_t size, ReserveFlags flags=kNo_ReserveFlags)</td></tr>
<tr class="separator:a3998492724e925aaddbde94e806c337a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c042b9cde3495671025fe5b2c1435ce"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#a0c042b9cde3495671025fe5b2c1435ce">currentBlock</a> () const</td></tr>
<tr class="separator:a0c042b9cde3495671025fe5b2c1435ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f679a3c64fb066031848a2f709b1305"><td class="memItemLeft" align="right" valign="top"><a id="a2f679a3c64fb066031848a2f709b1305"></a>
<a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>currentBlock</b> ()</td></tr>
<tr class="separator:a2f679a3c64fb066031848a2f709b1305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5582ece6bd15fbdd93c01e6bc6fe221"><td class="memItemLeft" align="right" valign="top"><a id="ad5582ece6bd15fbdd93c01e6bc6fe221"></a>
const <a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>headBlock</b> () const</td></tr>
<tr class="separator:ad5582ece6bd15fbdd93c01e6bc6fe221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8916b6e0633783edbb9a2a9ee2c1c7ce"><td class="memItemLeft" align="right" valign="top"><a id="a8916b6e0633783edbb9a2a9ee2c1c7ce"></a>
<a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>headBlock</b> ()</td></tr>
<tr class="separator:a8916b6e0633783edbb9a2a9ee2c1c7ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af21b1520a07b555379a7394d4e3f6485"><td class="memTemplParams" colspan="2">template&lt;size_t Align, size_t Padding = 0&gt; </td></tr>
<tr class="memitem:af21b1520a07b555379a7394d4e3f6485"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#af21b1520a07b555379a7394d4e3f6485">owningBlock</a> (const void *ptr, int start)</td></tr>
<tr class="separator:af21b1520a07b555379a7394d4e3f6485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fad52c18ffdb2f9b8cdcfbb7d167e71"><td class="memTemplParams" colspan="2"><a id="a8fad52c18ffdb2f9b8cdcfbb7d167e71"></a>
template&lt;size_t Align, size_t Padding = 0&gt; </td></tr>
<tr class="memitem:a8fad52c18ffdb2f9b8cdcfbb7d167e71"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>owningBlock</b> (const void *ptr, int start) const</td></tr>
<tr class="separator:a8fad52c18ffdb2f9b8cdcfbb7d167e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc79159f461ad58e708d5c04c080f593"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#acc79159f461ad58e708d5c04c080f593">findOwningBlock</a> (const void *ptr)</td></tr>
<tr class="separator:acc79159f461ad58e708d5c04c080f593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9468f2779e4512f745eb42a5f7457907"><td class="memItemLeft" align="right" valign="top"><a id="a9468f2779e4512f745eb42a5f7457907"></a>
const <a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>findOwningBlock</b> (const void *ptr) const</td></tr>
<tr class="separator:a9468f2779e4512f745eb42a5f7457907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69341cd91a76c54ba1e0bf44068c3883"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#a69341cd91a76c54ba1e0bf44068c3883">releaseBlock</a> (<a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a> *block)</td></tr>
<tr class="separator:a69341cd91a76c54ba1e0bf44068c3883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9abf0eac7b7c326878304b765f661c55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#a9abf0eac7b7c326878304b765f661c55">stealHeapBlocks</a> (<a class="el" href="class_sk_block_allocator.html">SkBlockAllocator</a> *other)</td></tr>
<tr class="separator:a9abf0eac7b7c326878304b765f661c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84cddf7176b64d38c473141a1d957a44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#a84cddf7176b64d38c473141a1d957a44">reset</a> ()</td></tr>
<tr class="separator:a84cddf7176b64d38c473141a1d957a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b89d67e347bed5dc44c541cc75e211e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#a5b89d67e347bed5dc44c541cc75e211e">resetScratchSpace</a> ()</td></tr>
<tr class="separator:a5b89d67e347bed5dc44c541cc75e211e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50674e2cd30e0b78bc3e850e36cd2e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_block_allocator_1_1_block_iter.html">BlockIter</a>&lt; true, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#a50674e2cd30e0b78bc3e850e36cd2e04">blocks</a> ()</td></tr>
<tr class="separator:a50674e2cd30e0b78bc3e850e36cd2e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60ff682f906ba03a34f9aabd9a47a96d"><td class="memItemLeft" align="right" valign="top"><a id="a60ff682f906ba03a34f9aabd9a47a96d"></a>
<a class="el" href="class_sk_block_allocator_1_1_block_iter.html">BlockIter</a>&lt; true, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>blocks</b> () const</td></tr>
<tr class="separator:a60ff682f906ba03a34f9aabd9a47a96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6663ca5fa77a1e9017cffdacdd39e5a7"><td class="memItemLeft" align="right" valign="top"><a id="a6663ca5fa77a1e9017cffdacdd39e5a7"></a>
<a class="el" href="class_sk_block_allocator_1_1_block_iter.html">BlockIter</a>&lt; false, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>rblocks</b> ()</td></tr>
<tr class="separator:a6663ca5fa77a1e9017cffdacdd39e5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4c77c5dabaeb4f5d1c8d2d9c34f8e4"><td class="memItemLeft" align="right" valign="top"><a id="a8d4c77c5dabaeb4f5d1c8d2d9c34f8e4"></a>
<a class="el" href="class_sk_block_allocator_1_1_block_iter.html">BlockIter</a>&lt; false, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>rblocks</b> () const</td></tr>
<tr class="separator:a8d4c77c5dabaeb4f5d1c8d2d9c34f8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a01418c38a66c2b97545150a499da71a8"><td class="memTemplParams" colspan="2">template&lt;size_t Align = 1, size_t Padding = 0&gt; </td></tr>
<tr class="memitem:a01418c38a66c2b97545150a499da71a8"><td class="memTemplItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#a01418c38a66c2b97545150a499da71a8">BlockOverhead</a> ()</td></tr>
<tr class="separator:a01418c38a66c2b97545150a499da71a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef5b2860a3d68be14da639c644c1a9a"><td class="memTemplParams" colspan="2">template&lt;size_t Align = 1, size_t Padding = 0&gt; </td></tr>
<tr class="memitem:a3ef5b2860a3d68be14da639c644c1a9a"><td class="memTemplItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_sk_block_allocator.html#a3ef5b2860a3d68be14da639c644c1a9a">Overhead</a> ()</td></tr>
<tr class="separator:a3ef5b2860a3d68be14da639c644c1a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ada1ef370d6a4ecd6202a8f85b6b56a41"><td class="memItemLeft" align="right" valign="top"><a id="ada1ef370d6a4ecd6202a8f85b6b56a41"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kMaxAllocationSize</b> = 1 &lt;&lt; 29</td></tr>
<tr class="separator:ada1ef370d6a4ecd6202a8f85b6b56a41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ba2d03896050114c23b2ee6fe9f823"><td class="memItemLeft" align="right" valign="top"><a id="ac9ba2d03896050114c23b2ee6fe9f823"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kGrowthPolicyCount</b> = static_cast&lt;int&gt;(GrowthPolicy::kLast) + 1</td></tr>
<tr class="separator:ac9ba2d03896050114c23b2ee6fe9f823"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:af165934b4b15108fb9578072085cf6ba"><td class="memItemLeft" align="right" valign="top"><a id="af165934b4b15108fb9578072085cf6ba"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>BlockAllocatorTestAccess</b></td></tr>
<tr class="separator:af165934b4b15108fb9578072085cf6ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a888c86797386bd2e7e6f1c8f6d5ced55"><td class="memItemLeft" align="right" valign="top"><a id="a888c86797386bd2e7e6f1c8f6d5ced55"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TBlockListTestAccess</b></td></tr>
<tr class="separator:a888c86797386bd2e7e6f1c8f6d5ced55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_sk_block_allocator.html">SkBlockAllocator</a> provides low-level support for a block allocated arena with a dynamic tail that tracks space reservations within each block. Its APIs provide the ability to reserve space, resize reservations, and release reservations. It will automatically create new blocks if needed and destroy all remaining blocks when it is destructed. It assumes that anything allocated within its blocks has its destructors called externally. It is recommended that <a class="el" href="class_sk_block_allocator.html">SkBlockAllocator</a> is wrapped by a higher-level allocator that uses the low-level APIs to implement a simpler, purpose-focused API w/o having to worry as much about byte-level concerns.</p>
<p><a class="el" href="class_sk_block_allocator.html">SkBlockAllocator</a> has no limit to its total size, but each allocation is limited to 512MB (which should be sufficient for Skia's use cases). This upper allocation limit allows all internal operations to be performed using 'int' and avoid many overflow checks. Static asserts are used to ensure that those operations would not overflow when using the largest possible values.</p>
<p>Possible use modes:</p><ol type="1">
<li>No upfront allocation, either on the stack or as a field <a class="el" href="class_sk_block_allocator.html">SkBlockAllocator</a> allocator(policy, heapAllocSize);</li>
<li>In-place new'd void* mem = operator new(totalSize); SkBlockAllocator* allocator = new (mem) <a class="el" href="class_sk_block_allocator.html">SkBlockAllocator</a>(policy, heapAllocSize, totalSize- sizeof(SkBlockAllocator)); delete allocator;</li>
<li>Use <a class="el" href="class_sk_s_block_allocator.html">SkSBlockAllocator</a> to increase the preallocation size SkSBlockAllocator&lt;1024&gt; allocator(policy, heapAllocSize); sizeof(allocator) == 1024; </li>
</ol>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a9d5238baa2e451f5ba69abb01a1c8a82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d5238baa2e451f5ba69abb01a1c8a82">&#9670;&nbsp;</a></span>allocate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Align, size_t Padding&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_block_allocator_1_1_byte_range.html">SkBlockAllocator::ByteRange</a> SkBlockAllocator::allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reserve space that will hold 'size' bytes. This will automatically allocate a new block if there is not enough available space in the current block to provide 'size' bytes. The returned <a class="el" href="struct_sk_block_allocator_1_1_byte_range.html">ByteRange</a> tuple specifies the <a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a> owning the reserved memory, the full byte range, and the aligned offset within that range to use for the user-facing pointer. The following invariants hold:</p>
<ol type="1">
<li>block-&gt;ptr(alignedOffset) is aligned to Align</li>
<li>end - alignedOffset == size</li>
<li>Padding &lt;= alignedOffset - start &lt;= Padding + Align - 1</li>
</ol>
<p>Invariant #3, when Padding &gt; 0, allows intermediate allocators to embed metadata along with the allocations. If the Padding bytes are used for some 'struct <a class="el" href="struct_meta.html">Meta</a>', then ptr(alignedOffset - sizeof(Meta)) can be safely used as a Meta* if <a class="el" href="struct_meta.html">Meta</a>'s alignment requirements are less than or equal to the alignment specified in allocate&lt;&gt;. This can be easily guaranteed by using the pattern:</p>
<p>allocate&lt;max(UserAlign, alignof(Meta)), sizeof(Meta)&gt;(userSize);</p>
<p>This ensures that ptr(alignedOffset) will always satisfy UserAlign and ptr(alignedOffset - sizeof(Meta)) will always satisfy alignof(Meta). Alternatively, memcpy can be used to read and write values between start and alignedOffset without worrying about alignment requirements of the metadata.</p>
<p>For over-aligned allocations, the alignedOffset (as an int) may not be a multiple of Align, but the result of ptr(alignedOffset) will be a multiple of Align. </p>

</div>
</div>
<a id="a01418c38a66c2b97545150a499da71a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01418c38a66c2b97545150a499da71a8">&#9670;&nbsp;</a></span>BlockOverhead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Align, size_t Padding&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t SkBlockAllocator::BlockOverhead</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper to calculate the minimum number of bytes needed for heap block size, under the assumption that Align will be the requested alignment of the first call to <a class="el" href="class_sk_block_allocator.html#a9d5238baa2e451f5ba69abb01a1c8a82">allocate()</a>. Ex. To store N instances of T in a heap block, the 'blockIncrementBytes' should be set to BlockOverhead&lt;alignof(T)&gt;() + N * sizeof(T) when making the <a class="el" href="class_sk_block_allocator.html">SkBlockAllocator</a>. </p>

</div>
</div>
<a id="a50674e2cd30e0b78bc3e850e36cd2e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50674e2cd30e0b78bc3e850e36cd2e04">&#9670;&nbsp;</a></span>blocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_block_allocator_1_1_block_iter.html">SkBlockAllocator::BlockIter</a>&lt; true, true &gt; SkBlockAllocator::blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clients can iterate over all active Blocks in the <a class="el" href="class_sk_block_allocator.html">SkBlockAllocator</a> using for loops:</p>
<p>Forward iteration from head to tail block (or non-const variant): for (const Block* b : this-&gt;<a class="el" href="class_sk_block_allocator.html#a50674e2cd30e0b78bc3e850e36cd2e04">blocks()</a>) { } Reverse iteration from tail to head block: for (const Block* b : this-&gt;rblocks()) { }</p>
<p>It is safe to call <a class="el" href="class_sk_block_allocator.html#a69341cd91a76c54ba1e0bf44068c3883">releaseBlock()</a> on the active block while looping. </p>

</div>
</div>
<a id="a0c042b9cde3495671025fe5b2c1435ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c042b9cde3495671025fe5b2c1435ce">&#9670;&nbsp;</a></span>currentBlock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a>* SkBlockAllocator::currentBlock </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the start of the current block. This will never be null. </p>

</div>
</div>
<a id="acc79159f461ad58e708d5c04c080f593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc79159f461ad58e708d5c04c080f593">&#9670;&nbsp;</a></span>findOwningBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_block_allocator_1_1_block.html">SkBlockAllocator::Block</a> * SkBlockAllocator::findOwningBlock </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the owning block of the allocated pointer, 'p'. Without any additional information this is O(N) on the number of allocated blocks. </p>

</div>
</div>
<a id="aa407213783ddfb0a05dd104849388a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa407213783ddfb0a05dd104849388a3a">&#9670;&nbsp;</a></span>metadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SkBlockAllocator::metadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the current value of the allocator-level metadata (a user-oriented slot). This is separate from any block-level metadata, but can serve a similar purpose to compactly support data collections on top of <a class="el" href="class_sk_block_allocator.html">SkBlockAllocator</a>. </p>

</div>
</div>
<a id="a3ef5b2860a3d68be14da639c644c1a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef5b2860a3d68be14da639c644c1a9a">&#9670;&nbsp;</a></span>Overhead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Align, size_t Padding&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t SkBlockAllocator::Overhead</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper to calculate the minimum number of bytes needed for a preallocation, under the assumption that Align will be the requested alignment of the first call to <a class="el" href="class_sk_block_allocator.html#a9d5238baa2e451f5ba69abb01a1c8a82">allocate()</a>. Ex. To preallocate a <a class="el" href="class_sk_s_block_allocator.html">SkSBlockAllocator</a> to hold N instances of T, its arge should be Overhead&lt;alignof(T)&gt;() + N * sizeof(T) </p>

</div>
</div>
<a id="af21b1520a07b555379a7394d4e3f6485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af21b1520a07b555379a7394d4e3f6485">&#9670;&nbsp;</a></span>owningBlock()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Align, size_t Padding&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_block_allocator_1_1_block.html">SkBlockAllocator::Block</a> * SkBlockAllocator::owningBlock </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the block that owns the allocated 'ptr'. Assuming that earlier, an allocation was returned as {b, start, alignedOffset, end}, and 'p = b-&gt;ptr(alignedOffset)', then a call to 'owningBlock&lt;Align, Padding&gt;(p, start) == b'.</p>
<p>If calling code has already made a pointer to their metadata, i.e. 'm = p - Padding', then 'owningBlock&lt;Align, 0&gt;(m, start)' will also return b, allowing you to recover the block from the metadata pointer.</p>
<p>If calling code has access to the original alignedOffset, this function should not be used since the owning block is just 'p - alignedOffset', regardless of original Align or Padding. </p>

</div>
</div>
<a id="ab64924932b25c02e426c95a6f552ec9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab64924932b25c02e426c95a6f552ec9a">&#9670;&nbsp;</a></span>preallocSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SkBlockAllocator::preallocSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of bytes that were pre-allocated for the <a class="el" href="class_sk_block_allocator.html">SkBlockAllocator</a>. This will include 'additionalPreallocBytes' passed to the constructor, and represents what the total size would become after a call to <a class="el" href="class_sk_block_allocator.html#a84cddf7176b64d38c473141a1d957a44">reset()</a>. </p>

</div>
</div>
<a id="a631af1889f71b627419c1341660385cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631af1889f71b627419c1341660385cf">&#9670;&nbsp;</a></span>preallocUsableSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SkBlockAllocator::preallocUsableSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the usable size of the inline head block; this will be equal to 'additionalPreallocBytes' plus any alignment padding that the system had to add to <a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a>. The returned value represents what could be allocated before a heap block is be created. </p>

</div>
</div>
<a id="a69341cd91a76c54ba1e0bf44068c3883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69341cd91a76c54ba1e0bf44068c3883">&#9670;&nbsp;</a></span>releaseBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkBlockAllocator::releaseBlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a> *&#160;</td>
          <td class="paramname"><em>block</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Explicitly free an entire block, invalidating any remaining allocations from the block. <a class="el" href="class_sk_block_allocator.html">SkBlockAllocator</a> will release all alive blocks automatically when it is destroyed, but this function can be used to reclaim memory over the lifetime of the allocator. The provided 'block' pointer must have previously come from a call to currentBlock() or <a class="el" href="class_sk_block_allocator.html#a9d5238baa2e451f5ba69abb01a1c8a82">allocate()</a>.</p>
<p>If 'block' represents the inline-allocated head block, its cursor and metadata are instead reset to their defaults.</p>
<p>If the block is not the head block, it may be kept as a scratch block to be reused for subsequent allocation requests, instead of making an entirely new block. A scratch block is not visible when iterating over blocks but is reported in the total size of the allocator. </p>

</div>
</div>
<a id="a3998492724e925aaddbde94e806c337a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3998492724e925aaddbde94e806c337a">&#9670;&nbsp;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t Align, size_t Padding&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SkBlockAllocator::reserve </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReserveFlags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>kNo_ReserveFlags</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ensure the block allocator has 'size' contiguous available bytes. After calling this function, currentBlock()-&gt;avail&lt;Align, Padding&gt;() may still report less than 'size' if the reserved space was added as a scratch block. This is done so that anything remaining in the current block can still be used if a smaller-than-size allocation is requested. If 'size' is requested by a subsequent allocation, the scratch block will automatically be activated and the request will not itself trigger any malloc.</p>
<p>The optional 'flags' controls how the input size is allocated; by default it will attempt to use available contiguous bytes in the current block and will respect the growth policy of the allocator. </p>

</div>
</div>
<a id="a84cddf7176b64d38c473141a1d957a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84cddf7176b64d38c473141a1d957a44">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkBlockAllocator::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Explicitly free all blocks (invalidating all allocations), and resets the head block to its default state. The allocator-level metadata is reset to 0 as well. </p>

</div>
</div>
<a id="a5b89d67e347bed5dc44c541cc75e211e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b89d67e347bed5dc44c541cc75e211e">&#9670;&nbsp;</a></span>resetScratchSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkBlockAllocator::resetScratchSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove any reserved scratch space, either from calling <a class="el" href="class_sk_block_allocator.html#a3998492724e925aaddbde94e806c337a">reserve()</a> or <a class="el" href="class_sk_block_allocator.html#a69341cd91a76c54ba1e0bf44068c3883">releaseBlock()</a>. </p>

</div>
</div>
<a id="a6571df06fbfd507871869cd25a5e0396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6571df06fbfd507871869cd25a5e0396">&#9670;&nbsp;</a></span>setMetadata()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkBlockAllocator::setMetadata </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the current value of the allocator-level metadata. </p>

</div>
</div>
<a id="a9abf0eac7b7c326878304b765f661c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abf0eac7b7c326878304b765f661c55">&#9670;&nbsp;</a></span>stealHeapBlocks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkBlockAllocator::stealHeapBlocks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_block_allocator.html">SkBlockAllocator</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detach every heap-allocated block owned by 'other' and concatenate them to this allocator's list of blocks. This memory is now managed by this allocator. Since this only transfers ownership of a <a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a>, and a <a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a> itself does not move, any previous allocations remain valid and associated with their original <a class="el" href="class_sk_block_allocator_1_1_block.html">Block</a> instances. SkBlockAllocator-level functions that accept allocated pointers (e.g. findOwningBlock), must now use this allocator and not 'other' for these allocations.</p>
<p>The head block of 'other' cannot be stolen, so higher-level allocators and memory structures must handle that data differently. </p>

</div>
</div>
<a id="a904b21efec9487223d952d164bef159e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a904b21efec9487223d952d164bef159e">&#9670;&nbsp;</a></span>totalSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SkBlockAllocator::totalSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of bytes of the allocator, including its instance overhead, per-block overhead and space used for allocations. </p>

</div>
</div>
<a id="a232fa348a798fefda7a00f456bef1ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232fa348a798fefda7a00f456bef1ab1">&#9670;&nbsp;</a></span>totalSpaceInUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SkBlockAllocator::totalSpaceInUse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of usable bytes that have been reserved by allocations. This will be less than or equal to <a class="el" href="class_sk_block_allocator.html#abcfc637f3bc835a84eb0743d342bd6e7">totalUsableSpace()</a>. </p>

</div>
</div>
<a id="abcfc637f3bc835a84eb0743d342bd6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcfc637f3bc835a84eb0743d342bd6e7">&#9670;&nbsp;</a></span>totalUsableSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SkBlockAllocator::totalUsableSpace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the total number of bytes usable for allocations. This includes bytes that have been reserved already by a call to <a class="el" href="class_sk_block_allocator.html#a9d5238baa2e451f5ba69abb01a1c8a82">allocate()</a> and bytes that are still available. It is <a class="el" href="class_sk_block_allocator.html#a904b21efec9487223d952d164bef159e">totalSize()</a> minus all allocator and block-level overhead. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/src/core/<a class="el" href="_sk_block_allocator_8h_source.html">SkBlockAllocator.h</a></li>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/src/core/SkBlockAllocator.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
