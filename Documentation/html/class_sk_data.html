<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: SkData Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_sk_data-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SkData Class Reference<span class="mlabels"><span class="mlabel">final</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_sk_data_8h_source.html">SkData.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SkData:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_sk_data.png" usemap="#SkData_map" alt=""/>
  <map id="SkData_map" name="SkData_map">
<area href="class_sk_n_v_ref_cnt.html" alt="SkNVRefCnt&lt; SkData &gt;" shape="rect" coords="0,0,146,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a31c328f384cf55f14cee22dd7c554f8b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#a31c328f384cf55f14cee22dd7c554f8b">ReleaseProc</a>) (const void *ptr, void *context)</td></tr>
<tr class="separator:a31c328f384cf55f14cee22dd7c554f8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af0a8942d7354681e7b464eb08c2175dd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#af0a8942d7354681e7b464eb08c2175dd">size</a> () const</td></tr>
<tr class="separator:af0a8942d7354681e7b464eb08c2175dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af337786927fd597f027175516c953a5c"><td class="memItemLeft" align="right" valign="top"><a id="af337786927fd597f027175516c953a5c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>isEmpty</b> () const</td></tr>
<tr class="separator:af337786927fd597f027175516c953a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5ba46dccd5d65a464d8118974a21a8"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#a8d5ba46dccd5d65a464d8118974a21a8">data</a> () const</td></tr>
<tr class="separator:a8d5ba46dccd5d65a464d8118974a21a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc1e2dd78bb42b8950f90c7ad73ea6f"><td class="memItemLeft" align="right" valign="top">const uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#adcc1e2dd78bb42b8950f90c7ad73ea6f">bytes</a> () const</td></tr>
<tr class="separator:adcc1e2dd78bb42b8950f90c7ad73ea6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52c15d46ad1022b97e9bc6798aadfd4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#ad52c15d46ad1022b97e9bc6798aadfd4">writable_data</a> ()</td></tr>
<tr class="separator:ad52c15d46ad1022b97e9bc6798aadfd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242136fd8363522ff4cef7bc668047bf"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#a242136fd8363522ff4cef7bc668047bf">copyRange</a> (size_t offset, size_t length, void *<a class="el" href="structbuffer.html">buffer</a>) const</td></tr>
<tr class="separator:a242136fd8363522ff4cef7bc668047bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2be64efdc9654eca5ab5488fec6f5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#a3e2be64efdc9654eca5ab5488fec6f5e">equals</a> (const <a class="el" href="class_sk_data.html">SkData</a> *other) const</td></tr>
<tr class="separator:a3e2be64efdc9654eca5ab5488fec6f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_sk_n_v_ref_cnt"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_sk_n_v_ref_cnt')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_sk_n_v_ref_cnt.html">SkNVRefCnt&lt; SkData &gt;</a></td></tr>
<tr class="memitem:ab140de5848782b55929bf71b01cb3885 inherit pub_methods_class_sk_n_v_ref_cnt"><td class="memItemLeft" align="right" valign="top"><a id="ab140de5848782b55929bf71b01cb3885"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>unique</b> () const</td></tr>
<tr class="separator:ab140de5848782b55929bf71b01cb3885 inherit pub_methods_class_sk_n_v_ref_cnt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79bcf4d35933bc34ec7a05782eadde10 inherit pub_methods_class_sk_n_v_ref_cnt"><td class="memItemLeft" align="right" valign="top"><a id="a79bcf4d35933bc34ec7a05782eadde10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ref</b> () const</td></tr>
<tr class="separator:a79bcf4d35933bc34ec7a05782eadde10 inherit pub_methods_class_sk_n_v_ref_cnt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5114aeefdee77d97566cbc3c949c33f8 inherit pub_methods_class_sk_n_v_ref_cnt"><td class="memItemLeft" align="right" valign="top"><a id="a5114aeefdee77d97566cbc3c949c33f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>unref</b> () const</td></tr>
<tr class="separator:a5114aeefdee77d97566cbc3c949c33f8 inherit pub_methods_class_sk_n_v_ref_cnt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0ca4a2f13dea57dd89ce88ccb88fe3 inherit pub_methods_class_sk_n_v_ref_cnt"><td class="memItemLeft" align="right" valign="top"><a id="acf0ca4a2f13dea57dd89ce88ccb88fe3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>deref</b> () const</td></tr>
<tr class="separator:acf0ca4a2f13dea57dd89ce88ccb88fe3 inherit pub_methods_class_sk_n_v_ref_cnt"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a6e45b2613fbec32d4a2a69c76adbc inherit pub_methods_class_sk_n_v_ref_cnt"><td class="memItemLeft" align="right" valign="top"><a id="ab8a6e45b2613fbec32d4a2a69c76adbc"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>refCntGreaterThan</b> (int32_t threadIsolatedTestCnt) const</td></tr>
<tr class="separator:ab8a6e45b2613fbec32d4a2a69c76adbc inherit pub_methods_class_sk_n_v_ref_cnt"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aaa84b14c6b74e3f707f37ab1487fc88e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#aaa84b14c6b74e3f707f37ab1487fc88e">MakeWithCopy</a> (const void *<a class="el" href="class_sk_data.html#a8d5ba46dccd5d65a464d8118974a21a8">data</a>, size_t length)</td></tr>
<tr class="separator:aaa84b14c6b74e3f707f37ab1487fc88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b05487231e2da5dc8bbaf14a732b460"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#a3b05487231e2da5dc8bbaf14a732b460">MakeUninitialized</a> (size_t length)</td></tr>
<tr class="separator:a3b05487231e2da5dc8bbaf14a732b460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8ba6391c395e940697a74e71ef6814"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#a7f8ba6391c395e940697a74e71ef6814">MakeWithCString</a> (const char cstr[])</td></tr>
<tr class="separator:a7f8ba6391c395e940697a74e71ef6814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932340206a27ea58ce2d5342aa68f5da"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#a932340206a27ea58ce2d5342aa68f5da">MakeWithProc</a> (const void *ptr, size_t length, <a class="el" href="class_sk_data.html#a31c328f384cf55f14cee22dd7c554f8b">ReleaseProc</a> proc, void *ctx)</td></tr>
<tr class="separator:a932340206a27ea58ce2d5342aa68f5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d92a0c08dcf6ea12f18daa549daf774"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#a6d92a0c08dcf6ea12f18daa549daf774">MakeWithoutCopy</a> (const void *<a class="el" href="class_sk_data.html#a8d5ba46dccd5d65a464d8118974a21a8">data</a>, size_t length)</td></tr>
<tr class="separator:a6d92a0c08dcf6ea12f18daa549daf774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bb5637f48fbf0d502b4dd9e53f58a9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#a24bb5637f48fbf0d502b4dd9e53f58a9">MakeFromMalloc</a> (const void *<a class="el" href="class_sk_data.html#a8d5ba46dccd5d65a464d8118974a21a8">data</a>, size_t length)</td></tr>
<tr class="separator:a24bb5637f48fbf0d502b4dd9e53f58a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03a3bee58352e734963b220f5d8b389"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#ae03a3bee58352e734963b220f5d8b389">MakeFromFileName</a> (const char path[])</td></tr>
<tr class="separator:ae03a3bee58352e734963b220f5d8b389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd11b6db9baa02555b59bf0baa34484"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#a9dd11b6db9baa02555b59bf0baa34484">MakeFromFILE</a> (FILE *f)</td></tr>
<tr class="separator:a9dd11b6db9baa02555b59bf0baa34484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827e71e03fb8cc50d606424c6dae1f9d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#a827e71e03fb8cc50d606424c6dae1f9d">MakeFromFD</a> (int fd)</td></tr>
<tr class="separator:a827e71e03fb8cc50d606424c6dae1f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d9cd0aef39574f1d95afd8c71dfe3b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#ac3d9cd0aef39574f1d95afd8c71dfe3b">MakeFromStream</a> (<a class="el" href="class_sk_stream.html">SkStream</a> *, size_t <a class="el" href="class_sk_data.html#af0a8942d7354681e7b464eb08c2175dd">size</a>)</td></tr>
<tr class="separator:ac3d9cd0aef39574f1d95afd8c71dfe3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf99667744456ad53358ed2ccef2e84f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#aaf99667744456ad53358ed2ccef2e84f">MakeSubset</a> (const <a class="el" href="class_sk_data.html">SkData</a> *src, size_t offset, size_t length)</td></tr>
<tr class="separator:aaf99667744456ad53358ed2ccef2e84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad33f05448cdc8c748c8b82e308cf59e6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_data.html#ad33f05448cdc8c748c8b82e308cf59e6">MakeEmpty</a> ()</td></tr>
<tr class="separator:ad33f05448cdc8c748c8b82e308cf59e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a31ec01a9651a78d2e9fe229e6aaae630"><td class="memItemLeft" align="right" valign="top"><a id="a31ec01a9651a78d2e9fe229e6aaae630"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkNVRefCnt&lt; SkData &gt;</b></td></tr>
<tr class="separator:a31ec01a9651a78d2e9fe229e6aaae630"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_sk_data.html">SkData</a> holds an immutable data buffer. Not only is the data immutable, but the actual ptr that is returned (by <a class="el" href="class_sk_data.html#a8d5ba46dccd5d65a464d8118974a21a8">data()</a> or <a class="el" href="class_sk_data.html#adcc1e2dd78bb42b8950f90c7ad73ea6f">bytes()</a>) is guaranteed to always be the same for the life of this instance. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a31c328f384cf55f14cee22dd7c554f8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c328f384cf55f14cee22dd7c554f8b">&#9670;&nbsp;</a></span>ReleaseProc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SkData::ReleaseProc) (const void *ptr, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that, if provided, will be called when the <a class="el" href="class_sk_data.html">SkData</a> goes out of scope, allowing for custom allocation/freeing of the data's contents. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adcc1e2dd78bb42b8950f90c7ad73ea6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc1e2dd78bb42b8950f90c7ad73ea6f">&#9670;&nbsp;</a></span>bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t* SkData::bytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <a class="el" href="class_sk_data.html#a8d5ba46dccd5d65a464d8118974a21a8">data()</a>, returns a read-only ptr into the data, but in this case it is cast to uint8_t*, to make it easy to add an offset to it. </p>

</div>
</div>
<a id="a242136fd8363522ff4cef7bc668047bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242136fd8363522ff4cef7bc668047bf">&#9670;&nbsp;</a></span>copyRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SkData::copyRange </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper to copy a range of the data into a caller-provided buffer. Returns the actual number of bytes copied, after clamping offset and length to the size of the data. If buffer is NULL, it is ignored, and only the computed number of bytes is returned. </p>

</div>
</div>
<a id="a8d5ba46dccd5d65a464d8118974a21a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5ba46dccd5d65a464d8118974a21a8">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const void* SkData::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the ptr to the data. </p>

</div>
</div>
<a id="a3e2be64efdc9654eca5ab5488fec6f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2be64efdc9654eca5ab5488fec6f5e">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkData::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_data.html">SkData</a> *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if these two objects have the same length and contents, effectively returning 0 == memcmp(...) </p>

</div>
</div>
<a id="ad33f05448cdc8c748c8b82e308cf59e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad33f05448cdc8c748c8b82e308cf59e6">&#9670;&nbsp;</a></span>MakeEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt; SkData::MakeEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a new empty dataref (or a reference to a shared empty dataref). New or shared, the caller must see that unref() is eventually called. </p>

</div>
</div>
<a id="a827e71e03fb8cc50d606424c6dae1f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827e71e03fb8cc50d606424c6dae1f9d">&#9670;&nbsp;</a></span>MakeFromFD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt; SkData::MakeFromFD </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new dataref from a file descriptor. This does not take ownership of the file descriptor, nor close it. The caller is free to close the file descriptor at its convenience. The file descriptor must be open for reading only. Returns NULL on failure. </p>

</div>
</div>
<a id="a9dd11b6db9baa02555b59bf0baa34484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd11b6db9baa02555b59bf0baa34484">&#9670;&nbsp;</a></span>MakeFromFILE()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt; SkData::MakeFromFILE </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new dataref from a stdio FILE. This does not take ownership of the FILE, nor close it. The caller is free to close the FILE at its convenience. The FILE must be open for reading only. Returns NULL on failure. </p>

</div>
</div>
<a id="ae03a3bee58352e734963b220f5d8b389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03a3bee58352e734963b220f5d8b389">&#9670;&nbsp;</a></span>MakeFromFileName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt; SkData::MakeFromFileName </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>path</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new dataref the file with the specified path. If the file cannot be opened, this returns NULL. </p>

</div>
</div>
<a id="a24bb5637f48fbf0d502b4dd9e53f58a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bb5637f48fbf0d502b4dd9e53f58a9">&#9670;&nbsp;</a></span>MakeFromMalloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt; SkData::MakeFromMalloc </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new dataref from a pointer allocated by malloc. The Data object takes ownership of that allocation, and will handling calling sk_free. </p>

</div>
</div>
<a id="ac3d9cd0aef39574f1d95afd8c71dfe3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d9cd0aef39574f1d95afd8c71dfe3b">&#9670;&nbsp;</a></span>MakeFromStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt; SkData::MakeFromStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_stream.html">SkStream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to read size bytes into a <a class="el" href="class_sk_data.html">SkData</a>. If the read succeeds, return the data, else return NULL. Either way the stream's cursor may have been changed as a result of calling read(). </p>

</div>
</div>
<a id="aaf99667744456ad53358ed2ccef2e84f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf99667744456ad53358ed2ccef2e84f">&#9670;&nbsp;</a></span>MakeSubset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt; SkData::MakeSubset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_data.html">SkData</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new dataref using a subset of the data in the specified src dataref. </p>

</div>
</div>
<a id="a3b05487231e2da5dc8bbaf14a732b460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b05487231e2da5dc8bbaf14a732b460">&#9670;&nbsp;</a></span>MakeUninitialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt; SkData::MakeUninitialized </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new data with uninitialized contents. The caller should call <a class="el" href="class_sk_data.html#ad52c15d46ad1022b97e9bc6798aadfd4">writable_data()</a> to write into the buffer, but this must be done before another ref() is made. </p>

</div>
</div>
<a id="aaa84b14c6b74e3f707f37ab1487fc88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa84b14c6b74e3f707f37ab1487fc88e">&#9670;&nbsp;</a></span>MakeWithCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt; SkData::MakeWithCopy </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new dataref by copying the specified data </p>

</div>
</div>
<a id="a7f8ba6391c395e940697a74e71ef6814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8ba6391c395e940697a74e71ef6814">&#9670;&nbsp;</a></span>MakeWithCString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt; SkData::MakeWithCString </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>cstr</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new dataref by copying the specified c-string (a null-terminated array of bytes). The returned <a class="el" href="class_sk_data.html">SkData</a> will have <a class="el" href="class_sk_data.html#af0a8942d7354681e7b464eb08c2175dd">size()</a> equal to strlen(cstr) + 1. If cstr is NULL, it will be treated the same as "". </p>

</div>
</div>
<a id="a6d92a0c08dcf6ea12f18daa549daf774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d92a0c08dcf6ea12f18daa549daf774">&#9670;&nbsp;</a></span>MakeWithoutCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_data.html">SkData</a>&gt; SkData::MakeWithoutCopy </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call this when the data parameter is already const and will outlive the lifetime of the <a class="el" href="class_sk_data.html">SkData</a>. Suitable for with const globals. </p>

</div>
</div>
<a id="a932340206a27ea58ce2d5342aa68f5da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932340206a27ea58ce2d5342aa68f5da">&#9670;&nbsp;</a></span>MakeWithProc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt; SkData::MakeWithProc </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_data.html#a31c328f384cf55f14cee22dd7c554f8b">ReleaseProc</a>&#160;</td>
          <td class="paramname"><em>proc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ctx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new dataref, taking the ptr as is, and using the releaseproc to free it. The proc may be NULL. </p>

</div>
</div>
<a id="af0a8942d7354681e7b464eb08c2175dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a8942d7354681e7b464eb08c2175dd">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t SkData::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of bytes stored. </p>

</div>
</div>
<a id="ad52c15d46ad1022b97e9bc6798aadfd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52c15d46ad1022b97e9bc6798aadfd4">&#9670;&nbsp;</a></span>writable_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* SkData::writable_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>USE WITH CAUTION. This call will assert that the refcnt is 1, as a precaution against modifying the contents when another client/thread has access to the data. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/include/core/<a class="el" href="_sk_data_8h_source.html">SkData.h</a></li>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/src/core/SkData.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
