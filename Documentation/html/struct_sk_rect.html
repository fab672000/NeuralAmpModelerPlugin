<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: SkRect Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="struct_sk_rect-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SkRect Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_sk_rect_8h_source.html">SkRect.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac3538672f858058318ddee7873b75802"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#ac3538672f858058318ddee7873b75802">isEmpty</a> () const</td></tr>
<tr class="separator:ac3538672f858058318ddee7873b75802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7bf7c5d287b815e0021f3cd3ef95f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#aec7bf7c5d287b815e0021f3cd3ef95f6">isSorted</a> () const</td></tr>
<tr class="separator:aec7bf7c5d287b815e0021f3cd3ef95f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a423a349dd81b77e6b3d5e639b5802f87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a423a349dd81b77e6b3d5e639b5802f87">isFinite</a> () const</td></tr>
<tr class="separator:a423a349dd81b77e6b3d5e639b5802f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cc480105e5f210eee33b2cc995e1d9"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a61cc480105e5f210eee33b2cc995e1d9">x</a> () const</td></tr>
<tr class="separator:a61cc480105e5f210eee33b2cc995e1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039292b287cf0ffc64ad04d45590ec12"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a039292b287cf0ffc64ad04d45590ec12">y</a> () const</td></tr>
<tr class="separator:a039292b287cf0ffc64ad04d45590ec12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3276dbb9f87b1a64a1d09230bcf754b7"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a3276dbb9f87b1a64a1d09230bcf754b7">left</a> () const</td></tr>
<tr class="separator:a3276dbb9f87b1a64a1d09230bcf754b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba881f31c06e070d8985ecb8b64dbc04"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#aba881f31c06e070d8985ecb8b64dbc04">top</a> () const</td></tr>
<tr class="separator:aba881f31c06e070d8985ecb8b64dbc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c9fe4ed03a6499113e3c914d53add4"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a18c9fe4ed03a6499113e3c914d53add4">right</a> () const</td></tr>
<tr class="separator:a18c9fe4ed03a6499113e3c914d53add4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a05de53cb15d69a846a519746a113e"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a85a05de53cb15d69a846a519746a113e">bottom</a> () const</td></tr>
<tr class="separator:a85a05de53cb15d69a846a519746a113e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310ae07c04770654b18e6af8679c647e"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a310ae07c04770654b18e6af8679c647e">width</a> () const</td></tr>
<tr class="separator:a310ae07c04770654b18e6af8679c647e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253a231ae7ceec0bf81187964b4d7fbd"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a253a231ae7ceec0bf81187964b4d7fbd">height</a> () const</td></tr>
<tr class="separator:a253a231ae7ceec0bf81187964b4d7fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f842e7b8197ed90eff9829b89010d7"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a16f842e7b8197ed90eff9829b89010d7">centerX</a> () const</td></tr>
<tr class="separator:a16f842e7b8197ed90eff9829b89010d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f12fea1d1ee89fa388e1b7c8d46439"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a58f12fea1d1ee89fa388e1b7c8d46439">centerY</a> () const</td></tr>
<tr class="separator:a58f12fea1d1ee89fa388e1b7c8d46439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c64f14d3855d1947aa48e7cc7c9ba1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a1c64f14d3855d1947aa48e7cc7c9ba1f">toQuad</a> (<a class="el" href="struct_sk_point.html">SkPoint</a> quad[4]) const</td></tr>
<tr class="separator:a1c64f14d3855d1947aa48e7cc7c9ba1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af745695f16db12325af9b5770068ab93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#af745695f16db12325af9b5770068ab93">setEmpty</a> ()</td></tr>
<tr class="separator:af745695f16db12325af9b5770068ab93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0274cc20b107b6deecb1959e1a0cd88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#af0274cc20b107b6deecb1959e1a0cd88">set</a> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;src)</td></tr>
<tr class="separator:af0274cc20b107b6deecb1959e1a0cd88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a135fc03a19f7b41940ec6cc47550b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a0a135fc03a19f7b41940ec6cc47550b7">setLTRB</a> (SkScalar <a class="el" href="struct_sk_rect.html#a3276dbb9f87b1a64a1d09230bcf754b7">left</a>, SkScalar <a class="el" href="struct_sk_rect.html#aba881f31c06e070d8985ecb8b64dbc04">top</a>, SkScalar <a class="el" href="struct_sk_rect.html#a18c9fe4ed03a6499113e3c914d53add4">right</a>, SkScalar <a class="el" href="struct_sk_rect.html#a85a05de53cb15d69a846a519746a113e">bottom</a>)</td></tr>
<tr class="separator:a0a135fc03a19f7b41940ec6cc47550b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbecc852bda53e4bf57f83c7644b887d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#abbecc852bda53e4bf57f83c7644b887d">setBounds</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> pts[], int count)</td></tr>
<tr class="separator:abbecc852bda53e4bf57f83c7644b887d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6471738693c63a027cdc6be7271337b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#ab6471738693c63a027cdc6be7271337b">setBoundsCheck</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> pts[], int count)</td></tr>
<tr class="separator:ab6471738693c63a027cdc6be7271337b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada995b52374b12c1911942185058fb4b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#ada995b52374b12c1911942185058fb4b">setBoundsNoCheck</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> pts[], int count)</td></tr>
<tr class="separator:ada995b52374b12c1911942185058fb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b6c0846b2d171ca8e65b2db8ca3ab7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a77b6c0846b2d171ca8e65b2db8ca3ab7">set</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p0, const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p1)</td></tr>
<tr class="separator:a77b6c0846b2d171ca8e65b2db8ca3ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e31e863d5e50de184246e1dd3078ef3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a8e31e863d5e50de184246e1dd3078ef3">setXYWH</a> (SkScalar <a class="el" href="struct_sk_rect.html#a61cc480105e5f210eee33b2cc995e1d9">x</a>, SkScalar <a class="el" href="struct_sk_rect.html#a039292b287cf0ffc64ad04d45590ec12">y</a>, SkScalar <a class="el" href="struct_sk_rect.html#a310ae07c04770654b18e6af8679c647e">width</a>, SkScalar <a class="el" href="struct_sk_rect.html#a253a231ae7ceec0bf81187964b4d7fbd">height</a>)</td></tr>
<tr class="separator:a8e31e863d5e50de184246e1dd3078ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b7147cc72564905ffe8311bba898d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a32b7147cc72564905ffe8311bba898d6">setWH</a> (SkScalar <a class="el" href="struct_sk_rect.html#a310ae07c04770654b18e6af8679c647e">width</a>, SkScalar <a class="el" href="struct_sk_rect.html#a253a231ae7ceec0bf81187964b4d7fbd">height</a>)</td></tr>
<tr class="separator:a32b7147cc72564905ffe8311bba898d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa8db7efcf7dabfa45a2b4a2f070d5c"><td class="memItemLeft" align="right" valign="top"><a id="abaa8db7efcf7dabfa45a2b4a2f070d5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setIWH</b> (int32_t <a class="el" href="struct_sk_rect.html#a310ae07c04770654b18e6af8679c647e">width</a>, int32_t <a class="el" href="struct_sk_rect.html#a253a231ae7ceec0bf81187964b4d7fbd">height</a>)</td></tr>
<tr class="separator:abaa8db7efcf7dabfa45a2b4a2f070d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f3259cc3f2d5495403b8556f10536de"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_sk_rect.html">SkRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a7f3259cc3f2d5495403b8556f10536de">makeOffset</a> (SkScalar dx, SkScalar dy) const</td></tr>
<tr class="separator:a7f3259cc3f2d5495403b8556f10536de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a234f1130a519c5d9f98bb9deb2804"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_sk_rect.html">SkRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a01a234f1130a519c5d9f98bb9deb2804">makeOffset</a> (<a class="el" href="struct_sk_point.html">SkVector</a> v) const</td></tr>
<tr class="separator:a01a234f1130a519c5d9f98bb9deb2804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc3fdf46ec3d9cea40867ed22975a97f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_rect.html">SkRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#abc3fdf46ec3d9cea40867ed22975a97f">makeInset</a> (SkScalar dx, SkScalar dy) const</td></tr>
<tr class="separator:abc3fdf46ec3d9cea40867ed22975a97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59531061cfbe498266e68aa9c0416bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_rect.html">SkRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#aa59531061cfbe498266e68aa9c0416bf">makeOutset</a> (SkScalar dx, SkScalar dy) const</td></tr>
<tr class="separator:aa59531061cfbe498266e68aa9c0416bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614001ece824a30589cf08864a75fcc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a614001ece824a30589cf08864a75fcc1">offset</a> (SkScalar dx, SkScalar dy)</td></tr>
<tr class="separator:a614001ece824a30589cf08864a75fcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8f2bfd893aab26d02d78bf5cb40c71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a2c8f2bfd893aab26d02d78bf5cb40c71">offset</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;delta)</td></tr>
<tr class="separator:a2c8f2bfd893aab26d02d78bf5cb40c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11527364b7ff9ba8ba33f52581d8548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#ae11527364b7ff9ba8ba33f52581d8548">offsetTo</a> (SkScalar newX, SkScalar newY)</td></tr>
<tr class="separator:ae11527364b7ff9ba8ba33f52581d8548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf8f2bd4c93f9a5dc972685e070e4c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#addf8f2bd4c93f9a5dc972685e070e4c8">inset</a> (SkScalar dx, SkScalar dy)</td></tr>
<tr class="separator:addf8f2bd4c93f9a5dc972685e070e4c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2af43f4e6782402b26920c7ab9b4e3f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a2af43f4e6782402b26920c7ab9b4e3f2">outset</a> (SkScalar dx, SkScalar dy)</td></tr>
<tr class="separator:a2af43f4e6782402b26920c7ab9b4e3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a104c282e0ce09d01eaaf31d5d6aca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a50a104c282e0ce09d01eaaf31d5d6aca">intersect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;r)</td></tr>
<tr class="separator:a50a104c282e0ce09d01eaaf31d5d6aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e814d5ee07af540ff513579b4a71d5a"><td class="memItemLeft" align="right" valign="top">bool SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a0e814d5ee07af540ff513579b4a71d5a">intersect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;a, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;b)</td></tr>
<tr class="separator:a0e814d5ee07af540ff513579b4a71d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735d76d287864d0dbe5b8974658cd08b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a735d76d287864d0dbe5b8974658cd08b">intersects</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;r) const</td></tr>
<tr class="separator:a735d76d287864d0dbe5b8974658cd08b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca832d6819ffe5de53bfe959c5cdebb0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#aca832d6819ffe5de53bfe959c5cdebb0">join</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;r)</td></tr>
<tr class="separator:aca832d6819ffe5de53bfe959c5cdebb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2971d629dca3fb2e3065ef5147ceea1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a2971d629dca3fb2e3065ef5147ceea1d">joinNonEmptyArg</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;r)</td></tr>
<tr class="separator:a2971d629dca3fb2e3065ef5147ceea1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c792a9f8b3d18a7d3489de37128344e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a4c792a9f8b3d18a7d3489de37128344e">joinPossiblyEmptyRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;r)</td></tr>
<tr class="separator:a4c792a9f8b3d18a7d3489de37128344e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5aae2f63fce1f6775be01d9b86842c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a8a5aae2f63fce1f6775be01d9b86842c">contains</a> (SkScalar <a class="el" href="struct_sk_rect.html#a61cc480105e5f210eee33b2cc995e1d9">x</a>, SkScalar <a class="el" href="struct_sk_rect.html#a039292b287cf0ffc64ad04d45590ec12">y</a>) const</td></tr>
<tr class="separator:a8a5aae2f63fce1f6775be01d9b86842c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734432eec543e859ee657f40ba38b2bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a734432eec543e859ee657f40ba38b2bf">contains</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;r) const</td></tr>
<tr class="separator:a734432eec543e859ee657f40ba38b2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7982858921cef155f46c80a764418a80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a7982858921cef155f46c80a764418a80">contains</a> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;r) const</td></tr>
<tr class="separator:a7982858921cef155f46c80a764418a80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce1e87f8c407e6ff884993f8032003a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a9ce1e87f8c407e6ff884993f8032003a">round</a> (<a class="el" href="struct_sk_i_rect.html">SkIRect</a> *dst) const</td></tr>
<tr class="separator:a9ce1e87f8c407e6ff884993f8032003a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a82140d34549c4add33cd988c7dded8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a8a82140d34549c4add33cd988c7dded8">roundOut</a> (<a class="el" href="struct_sk_i_rect.html">SkIRect</a> *dst) const</td></tr>
<tr class="separator:a8a82140d34549c4add33cd988c7dded8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c49f7f74f9f67f623560b9794e0834c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a5c49f7f74f9f67f623560b9794e0834c">roundOut</a> (<a class="el" href="struct_sk_rect.html">SkRect</a> *dst) const</td></tr>
<tr class="separator:a5c49f7f74f9f67f623560b9794e0834c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d961d8314ba194b4f04f9b713ab29ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a4d961d8314ba194b4f04f9b713ab29ff">roundIn</a> (<a class="el" href="struct_sk_i_rect.html">SkIRect</a> *dst) const</td></tr>
<tr class="separator:a4d961d8314ba194b4f04f9b713ab29ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba14635425df0d4c700ff50ac26331c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_i_rect.html">SkIRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#aba14635425df0d4c700ff50ac26331c7">round</a> () const</td></tr>
<tr class="separator:aba14635425df0d4c700ff50ac26331c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81372adc2dd974149c5778e5aafcb020"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_i_rect.html">SkIRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a81372adc2dd974149c5778e5aafcb020">roundOut</a> () const</td></tr>
<tr class="separator:a81372adc2dd974149c5778e5aafcb020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8f75e18088804fdeebbb1fffc5a934"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_i_rect.html">SkIRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a9a8f75e18088804fdeebbb1fffc5a934">roundIn</a> () const</td></tr>
<tr class="separator:a9a8f75e18088804fdeebbb1fffc5a934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcd3ead21de8e1f10ef1ae64b5facad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#acfcd3ead21de8e1f10ef1ae64b5facad">sort</a> ()</td></tr>
<tr class="separator:acfcd3ead21de8e1f10ef1ae64b5facad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06eccd7253b2c6d8b7629b3255fd4c55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_rect.html">SkRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a06eccd7253b2c6d8b7629b3255fd4c55">makeSorted</a> () const</td></tr>
<tr class="separator:a06eccd7253b2c6d8b7629b3255fd4c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23f6ca16c61a3bcf18e2cf1dce1d5c4"><td class="memItemLeft" align="right" valign="top">const SkScalar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#aa23f6ca16c61a3bcf18e2cf1dce1d5c4">asScalars</a> () const</td></tr>
<tr class="separator:aa23f6ca16c61a3bcf18e2cf1dce1d5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1b0e4aa18e56444e506b7e5cb3459e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#af1b0e4aa18e56444e506b7e5cb3459e7">dump</a> (bool asHex) const</td></tr>
<tr class="separator:af1b0e4aa18e56444e506b7e5cb3459e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fcdca6f5bf759a1427653642cdffd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#ad3fcdca6f5bf759a1427653642cdffd9">dump</a> () const</td></tr>
<tr class="separator:ad3fcdca6f5bf759a1427653642cdffd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad808c52183e8e92e6d565aa99f203b27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#ad808c52183e8e92e6d565aa99f203b27">dumpHex</a> () const</td></tr>
<tr class="separator:ad808c52183e8e92e6d565aa99f203b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a058722ba4a7ab6a2024bd67e88dadb5b"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_sk_rect.html">SkRect</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a058722ba4a7ab6a2024bd67e88dadb5b">MakeEmpty</a> ()</td></tr>
<tr class="separator:a058722ba4a7ab6a2024bd67e88dadb5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22456b8e053e6ed4b764207b9aae28a6"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_sk_rect.html">SkRect</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a22456b8e053e6ed4b764207b9aae28a6">MakeWH</a> (SkScalar w, SkScalar h)</td></tr>
<tr class="separator:a22456b8e053e6ed4b764207b9aae28a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e47d3f2f60f07b7fdfbf0fb388cba0c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_sk_rect.html">SkRect</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a2e47d3f2f60f07b7fdfbf0fb388cba0c">MakeIWH</a> (int w, int h)</td></tr>
<tr class="separator:a2e47d3f2f60f07b7fdfbf0fb388cba0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b319932b7dcc45b5a8afe0db49bd326"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_sk_rect.html">SkRect</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a1b319932b7dcc45b5a8afe0db49bd326">MakeSize</a> (const <a class="el" href="struct_sk_size.html">SkSize</a> &amp;size)</td></tr>
<tr class="separator:a1b319932b7dcc45b5a8afe0db49bd326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac18108931cac5317e866dbbe12218b74"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_sk_rect.html">SkRect</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#ac18108931cac5317e866dbbe12218b74">MakeLTRB</a> (SkScalar l, SkScalar t, SkScalar r, SkScalar b)</td></tr>
<tr class="separator:ac18108931cac5317e866dbbe12218b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef01ba00dd9ab4489fed11413fb2cdc7"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_sk_rect.html">SkRect</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#aef01ba00dd9ab4489fed11413fb2cdc7">MakeXYWH</a> (SkScalar <a class="el" href="struct_sk_rect.html#a61cc480105e5f210eee33b2cc995e1d9">x</a>, SkScalar <a class="el" href="struct_sk_rect.html#a039292b287cf0ffc64ad04d45590ec12">y</a>, SkScalar w, SkScalar h)</td></tr>
<tr class="separator:aef01ba00dd9ab4489fed11413fb2cdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07aeab9a10302926fa7c4afe960b01bb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_sk_rect.html">SkRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a07aeab9a10302926fa7c4afe960b01bb">Make</a> (const <a class="el" href="struct_sk_i_size.html">SkISize</a> &amp;size)</td></tr>
<tr class="separator:a07aeab9a10302926fa7c4afe960b01bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf327eb61b4732222a59e22e93a2840e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="struct_sk_rect.html">SkRect</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#adf327eb61b4732222a59e22e93a2840e">Make</a> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;irect)</td></tr>
<tr class="separator:adf327eb61b4732222a59e22e93a2840e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a7df40f6cd57db2e6975242439b28f"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a19a7df40f6cd57db2e6975242439b28f">Intersects</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;a, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;b)</td></tr>
<tr class="separator:a19a7df40f6cd57db2e6975242439b28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a5105105e8ba040a17625edd0221768a6"><td class="memItemLeft" align="right" valign="top"><a id="a5105105e8ba040a17625edd0221768a6"></a>
SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a5105105e8ba040a17625edd0221768a6">fLeft</a></td></tr>
<tr class="memdesc:a5105105e8ba040a17625edd0221768a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">smaller x-axis bounds <br /></td></tr>
<tr class="separator:a5105105e8ba040a17625edd0221768a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af507e0e85766e2d3717c4d1ba269e0c2"><td class="memItemLeft" align="right" valign="top"><a id="af507e0e85766e2d3717c4d1ba269e0c2"></a>
SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#af507e0e85766e2d3717c4d1ba269e0c2">fTop</a></td></tr>
<tr class="memdesc:af507e0e85766e2d3717c4d1ba269e0c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">smaller y-axis bounds <br /></td></tr>
<tr class="separator:af507e0e85766e2d3717c4d1ba269e0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e5d3d82a6c9c5b8e4ea6ba635cac12a"><td class="memItemLeft" align="right" valign="top"><a id="a7e5d3d82a6c9c5b8e4ea6ba635cac12a"></a>
SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a7e5d3d82a6c9c5b8e4ea6ba635cac12a">fRight</a></td></tr>
<tr class="memdesc:a7e5d3d82a6c9c5b8e4ea6ba635cac12a"><td class="mdescLeft">&#160;</td><td class="mdescRight">larger x-axis bounds <br /></td></tr>
<tr class="separator:a7e5d3d82a6c9c5b8e4ea6ba635cac12a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab76ea1693ef29c10ddb9ec061af275"><td class="memItemLeft" align="right" valign="top"><a id="a1ab76ea1693ef29c10ddb9ec061af275"></a>
SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a1ab76ea1693ef29c10ddb9ec061af275">fBottom</a></td></tr>
<tr class="memdesc:a1ab76ea1693ef29c10ddb9ec061af275"><td class="mdescLeft">&#160;</td><td class="mdescRight">larger y-axis bounds <br /></td></tr>
<tr class="separator:a1ab76ea1693ef29c10ddb9ec061af275"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3f00109392160f744487428ced663eb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#a3f00109392160f744487428ced663eb7">operator==</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;a, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;b)</td></tr>
<tr class="separator:a3f00109392160f744487428ced663eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf0ac4ff19909f104a1178292cadcf83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_rect.html#adf0ac4ff19909f104a1178292cadcf83">operator!=</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;a, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;b)</td></tr>
<tr class="separator:adf0ac4ff19909f104a1178292cadcf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="struct_sk_rect.html">SkRect</a> holds four SkScalar coordinates describing the upper and lower bounds of a rectangle. <a class="el" href="struct_sk_rect.html">SkRect</a> may be created from outer bounds or from position, width, and height. <a class="el" href="struct_sk_rect.html">SkRect</a> describes an area; if its right is less than or equal to its left, or if its bottom is less than or equal to its top, it is considered empty. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aa23f6ca16c61a3bcf18e2cf1dce1d5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23f6ca16c61a3bcf18e2cf1dce1d5c4">&#9670;&nbsp;</a></span>asScalars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SkScalar* SkRect::asScalars </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns pointer to first scalar in <a class="el" href="struct_sk_rect.html">SkRect</a>, to treat it as an array with four entries.</p>
<dl class="section return"><dt>Returns</dt><dd>pointer to fLeft </dd></dl>

</div>
</div>
<a id="a85a05de53cb15d69a846a519746a113e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a05de53cb15d69a846a519746a113e">&#9670;&nbsp;</a></span>bottom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkRect::bottom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns bottom edge of <a class="el" href="struct_sk_rect.html">SkRect</a>, if sorted. Call <a class="el" href="struct_sk_rect.html#ac3538672f858058318ddee7873b75802">isEmpty()</a> to see if <a class="el" href="struct_sk_rect.html">SkRect</a> may be invalid, and <a class="el" href="struct_sk_rect.html#acfcd3ead21de8e1f10ef1ae64b5facad">sort()</a> to reverse fTop and fBottom if needed.</p>
<dl class="section return"><dt>Returns</dt><dd>fBottom </dd></dl>

</div>
</div>
<a id="a16f842e7b8197ed90eff9829b89010d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f842e7b8197ed90eff9829b89010d7">&#9670;&nbsp;</a></span>centerX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkRect::centerX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns average of left edge and right edge. Result does not change if <a class="el" href="struct_sk_rect.html">SkRect</a> is sorted. Result may overflow to infinity if <a class="el" href="struct_sk_rect.html">SkRect</a> is far from the origin.</p>
<dl class="section return"><dt>Returns</dt><dd>midpoint on x-axis </dd></dl>

</div>
</div>
<a id="a58f12fea1d1ee89fa388e1b7c8d46439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58f12fea1d1ee89fa388e1b7c8d46439">&#9670;&nbsp;</a></span>centerY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkRect::centerY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns average of top edge and bottom edge. Result does not change if <a class="el" href="struct_sk_rect.html">SkRect</a> is sorted.</p>
<dl class="section return"><dt>Returns</dt><dd>midpoint on y-axis </dd></dl>

</div>
</div>
<a id="a7982858921cef155f46c80a764418a80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7982858921cef155f46c80a764418a80">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkRect::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="struct_sk_rect.html">SkRect</a> contains r. Returns false if <a class="el" href="struct_sk_rect.html">SkRect</a> is empty or r is empty.</p>
<p><a class="el" href="struct_sk_rect.html">SkRect</a> contains r when <a class="el" href="struct_sk_rect.html">SkRect</a> area completely includes r area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td><a class="el" href="struct_sk_i_rect.html">SkIRect</a> contained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all sides of <a class="el" href="struct_sk_rect.html">SkRect</a> are outside r </dd></dl>

</div>
</div>
<a id="a734432eec543e859ee657f40ba38b2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734432eec543e859ee657f40ba38b2bf">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkRect::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="struct_sk_rect.html">SkRect</a> contains r. Returns false if <a class="el" href="struct_sk_rect.html">SkRect</a> is empty or r is empty.</p>
<p><a class="el" href="struct_sk_rect.html">SkRect</a> contains r when <a class="el" href="struct_sk_rect.html">SkRect</a> area completely includes r area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> contained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all sides of <a class="el" href="struct_sk_rect.html">SkRect</a> are outside r </dd></dl>

</div>
</div>
<a id="a8a5aae2f63fce1f6775be01d9b86842c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5aae2f63fce1f6775be01d9b86842c">&#9670;&nbsp;</a></span>contains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkRect::contains </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if: fLeft &lt;= x &lt; fRight &amp;&amp; fTop &lt;= y &lt; fBottom. Returns false if <a class="el" href="struct_sk_rect.html">SkRect</a> is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>test <a class="el" href="struct_sk_point.html">SkPoint</a> x-coordinate </td></tr>
    <tr><td class="paramname">y</td><td>test <a class="el" href="struct_sk_point.html">SkPoint</a> y-coordinate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if (x, y) is inside <a class="el" href="struct_sk_rect.html">SkRect</a> </dd></dl>

</div>
</div>
<a id="ad3fcdca6f5bf759a1427653642cdffd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3fcdca6f5bf759a1427653642cdffd9">&#9670;&nbsp;</a></span>dump() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes text representation of <a class="el" href="struct_sk_rect.html">SkRect</a> to standard output. The representation may be directly compiled as C++ code. Floating point values are written with limited precision; it may not be possible to reconstruct original <a class="el" href="struct_sk_rect.html">SkRect</a> from output. </p>

</div>
</div>
<a id="af1b0e4aa18e56444e506b7e5cb3459e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1b0e4aa18e56444e506b7e5cb3459e7">&#9670;&nbsp;</a></span>dump() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::dump </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>asHex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes text representation of <a class="el" href="struct_sk_rect.html">SkRect</a> to standard output. Set asHex to true to generate exact binary representations of floating point numbers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asHex</td><td>true if SkScalar values are written as hexadecimal</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Rect_dump">https://fiddle.skia.org/c/@Rect_dump</a> </p>

</div>
</div>
<a id="ad808c52183e8e92e6d565aa99f203b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad808c52183e8e92e6d565aa99f203b27">&#9670;&nbsp;</a></span>dumpHex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::dumpHex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Writes text representation of <a class="el" href="struct_sk_rect.html">SkRect</a> to standard output. The representation may be directly compiled as C++ code. Floating point values are written in hexadecimal to preserve their exact bit pattern. The output reconstructs the original <a class="el" href="struct_sk_rect.html">SkRect</a>.</p>
<p>Use instead of <a class="el" href="struct_sk_rect.html#af1b0e4aa18e56444e506b7e5cb3459e7">dump()</a> when submitting </p>

</div>
</div>
<a id="a253a231ae7ceec0bf81187964b4d7fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253a231ae7ceec0bf81187964b4d7fbd">&#9670;&nbsp;</a></span>height()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkRect::height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns span on the y-axis. This does not check if <a class="el" href="struct_sk_rect.html">SkRect</a> is sorted, or if result fits in 32-bit float; result may be negative or infinity.</p>
<dl class="section return"><dt>Returns</dt><dd>fBottom minus fTop </dd></dl>

</div>
</div>
<a id="addf8f2bd4c93f9a5dc972685e070e4c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf8f2bd4c93f9a5dc972685e070e4c8">&#9670;&nbsp;</a></span>inset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::inset </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insets <a class="el" href="struct_sk_rect.html">SkRect</a> by (dx, dy).</p>
<p>If dx is positive, makes <a class="el" href="struct_sk_rect.html">SkRect</a> narrower. If dx is negative, makes <a class="el" href="struct_sk_rect.html">SkRect</a> wider. If dy is positive, makes <a class="el" href="struct_sk_rect.html">SkRect</a> shorter. If dy is negative, makes <a class="el" href="struct_sk_rect.html">SkRect</a> taller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>added to fLeft and subtracted from fRight </td></tr>
    <tr><td class="paramname">dy</td><td>added to fTop and subtracted from fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0e814d5ee07af540ff513579b4a71d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e814d5ee07af540ff513579b4a71d5a">&#9670;&nbsp;</a></span>intersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkRect::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if a intersects b, and sets <a class="el" href="struct_sk_rect.html">SkRect</a> to intersection. Returns false if a does not intersect b, and leaves <a class="el" href="struct_sk_rect.html">SkRect</a> unchanged.</p>
<p>Returns false if either a or b is empty, leaving <a class="el" href="struct_sk_rect.html">SkRect</a> unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to intersect </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to intersect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a and b have area in common </dd></dl>

</div>
</div>
<a id="a50a104c282e0ce09d01eaaf31d5d6aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a104c282e0ce09d01eaaf31d5d6aca">&#9670;&nbsp;</a></span>intersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkRect::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="struct_sk_rect.html">SkRect</a> intersects r, and sets <a class="el" href="struct_sk_rect.html">SkRect</a> to intersection. Returns false if <a class="el" href="struct_sk_rect.html">SkRect</a> does not intersect r, and leaves <a class="el" href="struct_sk_rect.html">SkRect</a> unchanged.</p>
<p>Returns false if either r or <a class="el" href="struct_sk_rect.html">SkRect</a> is empty, leaving <a class="el" href="struct_sk_rect.html">SkRect</a> unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>limit of result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if r and <a class="el" href="struct_sk_rect.html">SkRect</a> have area in common</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Rect_intersect">https://fiddle.skia.org/c/@Rect_intersect</a> </p>

</div>
</div>
<a id="a19a7df40f6cd57db2e6975242439b28f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a7df40f6cd57db2e6975242439b28f">&#9670;&nbsp;</a></span>Intersects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SkRect::Intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if a intersects b. Returns false if either a or b is empty, or do not intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to intersect </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to intersect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a and b have area in common </dd></dl>

</div>
</div>
<a id="a735d76d287864d0dbe5b8974658cd08b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735d76d287864d0dbe5b8974658cd08b">&#9670;&nbsp;</a></span>intersects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkRect::intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="struct_sk_rect.html">SkRect</a> intersects r. Returns false if either r or <a class="el" href="struct_sk_rect.html">SkRect</a> is empty, or do not intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to intersect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if r and <a class="el" href="struct_sk_rect.html">SkRect</a> have area in common </dd></dl>

</div>
</div>
<a id="ac3538672f858058318ddee7873b75802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3538672f858058318ddee7873b75802">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkRect::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if fLeft is equal to or greater than fRight, or if fTop is equal to or greater than fBottom. Call <a class="el" href="struct_sk_rect.html#acfcd3ead21de8e1f10ef1ae64b5facad">sort()</a> to reverse rectangles with negative <a class="el" href="struct_sk_rect.html#a310ae07c04770654b18e6af8679c647e">width()</a> or <a class="el" href="struct_sk_rect.html#a253a231ae7ceec0bf81187964b4d7fbd">height()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="struct_sk_rect.html#a310ae07c04770654b18e6af8679c647e">width()</a> or <a class="el" href="struct_sk_rect.html#a253a231ae7ceec0bf81187964b4d7fbd">height()</a> are zero or negative </dd></dl>

</div>
</div>
<a id="a423a349dd81b77e6b3d5e639b5802f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a423a349dd81b77e6b3d5e639b5802f87">&#9670;&nbsp;</a></span>isFinite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkRect::isFinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if all values in the rectangle are finite: SK_ScalarMin or larger, and SK_ScalarMax or smaller.</p>
<dl class="section return"><dt>Returns</dt><dd>true if no member is infinite or NaN </dd></dl>

</div>
</div>
<a id="aec7bf7c5d287b815e0021f3cd3ef95f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7bf7c5d287b815e0021f3cd3ef95f6">&#9670;&nbsp;</a></span>isSorted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkRect::isSorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if fLeft is equal to or less than fRight, or if fTop is equal to or less than fBottom. Call <a class="el" href="struct_sk_rect.html#acfcd3ead21de8e1f10ef1ae64b5facad">sort()</a> to reverse rectangles with negative <a class="el" href="struct_sk_rect.html#a310ae07c04770654b18e6af8679c647e">width()</a> or <a class="el" href="struct_sk_rect.html#a253a231ae7ceec0bf81187964b4d7fbd">height()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="struct_sk_rect.html#a310ae07c04770654b18e6af8679c647e">width()</a> or <a class="el" href="struct_sk_rect.html#a253a231ae7ceec0bf81187964b4d7fbd">height()</a> are zero or positive </dd></dl>

</div>
</div>
<a id="aca832d6819ffe5de53bfe959c5cdebb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca832d6819ffe5de53bfe959c5cdebb0">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_rect.html">SkRect</a> to the union of itself and r.</p>
<p>Has no effect if r is empty. Otherwise, if <a class="el" href="struct_sk_rect.html">SkRect</a> is empty, sets <a class="el" href="struct_sk_rect.html">SkRect</a> to r.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>expansion <a class="el" href="struct_sk_rect.html">SkRect</a></td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Rect_join_2">https://fiddle.skia.org/c/@Rect_join_2</a> </p>

</div>
</div>
<a id="a2971d629dca3fb2e3065ef5147ceea1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2971d629dca3fb2e3065ef5147ceea1d">&#9670;&nbsp;</a></span>joinNonEmptyArg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::joinNonEmptyArg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_rect.html">SkRect</a> to the union of itself and r.</p>
<p>Asserts if r is empty and SK_DEBUG is defined. If <a class="el" href="struct_sk_rect.html">SkRect</a> is empty, sets <a class="el" href="struct_sk_rect.html">SkRect</a> to r.</p>
<p>May produce incorrect results if r is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>expansion <a class="el" href="struct_sk_rect.html">SkRect</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4c792a9f8b3d18a7d3489de37128344e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c792a9f8b3d18a7d3489de37128344e">&#9670;&nbsp;</a></span>joinPossiblyEmptyRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::joinPossiblyEmptyRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_rect.html">SkRect</a> to the union of itself and the construction.</p>
<p>May produce incorrect results if <a class="el" href="struct_sk_rect.html">SkRect</a> or r is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>expansion <a class="el" href="struct_sk_rect.html">SkRect</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3276dbb9f87b1a64a1d09230bcf754b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3276dbb9f87b1a64a1d09230bcf754b7">&#9670;&nbsp;</a></span>left()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkRect::left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns left edge of <a class="el" href="struct_sk_rect.html">SkRect</a>, if sorted. Call <a class="el" href="struct_sk_rect.html#aec7bf7c5d287b815e0021f3cd3ef95f6">isSorted()</a> to see if <a class="el" href="struct_sk_rect.html">SkRect</a> is valid. Call <a class="el" href="struct_sk_rect.html#acfcd3ead21de8e1f10ef1ae64b5facad">sort()</a> to reverse fLeft and fRight if needed.</p>
<dl class="section return"><dt>Returns</dt><dd>fLeft </dd></dl>

</div>
</div>
<a id="adf327eb61b4732222a59e22e93a2840e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf327eb61b4732222a59e22e93a2840e">&#9670;&nbsp;</a></span>Make() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_sk_rect.html">SkRect</a> SK_WARN_UNUSED_RESULT SkRect::Make </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>irect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_sk_i_rect.html">SkIRect</a> set to irect, promoting integers to scalar. Does not validate input; fLeft may be greater than fRight, fTop may be greater than fBottom.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">irect</td><td>integer unsorted bounds </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>irect members converted to SkScalar </dd></dl>

</div>
</div>
<a id="a07aeab9a10302926fa7c4afe960b01bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07aeab9a10302926fa7c4afe960b01bb">&#9670;&nbsp;</a></span>Make() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_sk_rect.html">SkRect</a> SkRect::Make </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_size.html">SkISize</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_sk_i_rect.html">SkIRect</a> set to (0, 0, size.width(), size.height()). Does not validate input; size.width() or size.height() may be negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>integer values for <a class="el" href="struct_sk_rect.html">SkRect</a> width and height </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bounds (0, 0, size.width(), size.height()) </dd></dl>

</div>
</div>
<a id="a058722ba4a7ab6a2024bd67e88dadb5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058722ba4a7ab6a2024bd67e88dadb5b">&#9670;&nbsp;</a></span>MakeEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_sk_rect.html">SkRect</a> SK_WARN_UNUSED_RESULT SkRect::MakeEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_sk_rect.html">SkRect</a> set to (0, 0, 0, 0). Many other rectangles are empty; if left is equal to or greater than right, or if top is equal to or greater than bottom. Setting all members to zero is a convenience, but does not designate a special empty rectangle.</p>
<dl class="section return"><dt>Returns</dt><dd>bounds (0, 0, 0, 0) </dd></dl>

</div>
</div>
<a id="abc3fdf46ec3d9cea40867ed22975a97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc3fdf46ec3d9cea40867ed22975a97f">&#9670;&nbsp;</a></span>makeInset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_rect.html">SkRect</a> SkRect::makeInset </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_rect.html">SkRect</a>, inset by (dx, dy).</p>
<p>If dx is negative, <a class="el" href="struct_sk_rect.html">SkRect</a> returned is wider. If dx is positive, <a class="el" href="struct_sk_rect.html">SkRect</a> returned is narrower. If dy is negative, <a class="el" href="struct_sk_rect.html">SkRect</a> returned is taller. If dy is positive, <a class="el" href="struct_sk_rect.html">SkRect</a> returned is shorter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>added to fLeft and subtracted from fRight </td></tr>
    <tr><td class="paramname">dy</td><td>added to fTop and subtracted from fBottom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_sk_rect.html">SkRect</a> inset symmetrically left and right, top and bottom </dd></dl>

</div>
</div>
<a id="a2e47d3f2f60f07b7fdfbf0fb388cba0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e47d3f2f60f07b7fdfbf0fb388cba0c">&#9670;&nbsp;</a></span>MakeIWH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="struct_sk_rect.html">SkRect</a> SK_WARN_UNUSED_RESULT SkRect::MakeIWH </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_sk_rect.html">SkRect</a> set to integer values (0, 0, w, h). Does not validate input; w or h may be negative.</p>
<p>Use to avoid a compiler warning that input may lose precision when stored. Use <a class="el" href="struct_sk_i_rect.html">SkIRect</a> for an exact integer rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>integer width of constructed <a class="el" href="struct_sk_rect.html">SkRect</a> </td></tr>
    <tr><td class="paramname">h</td><td>integer height of constructed <a class="el" href="struct_sk_rect.html">SkRect</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bounds (0, 0, w, h) </dd></dl>

</div>
</div>
<a id="ac18108931cac5317e866dbbe12218b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac18108931cac5317e866dbbe12218b74">&#9670;&nbsp;</a></span>MakeLTRB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_sk_rect.html">SkRect</a> SK_WARN_UNUSED_RESULT SkRect::MakeLTRB </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_sk_rect.html">SkRect</a> set to (l, t, r, b). Does not sort input; <a class="el" href="struct_sk_rect.html">SkRect</a> may result in fLeft greater than fRight, or fTop greater than fBottom.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>SkScalar stored in fLeft </td></tr>
    <tr><td class="paramname">t</td><td>SkScalar stored in fTop </td></tr>
    <tr><td class="paramname">r</td><td>SkScalar stored in fRight </td></tr>
    <tr><td class="paramname">b</td><td>SkScalar stored in fBottom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bounds (l, t, r, b) </dd></dl>

</div>
</div>
<a id="a7f3259cc3f2d5495403b8556f10536de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f3259cc3f2d5495403b8556f10536de">&#9670;&nbsp;</a></span>makeOffset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_sk_rect.html">SkRect</a> SkRect::makeOffset </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_rect.html">SkRect</a> offset by (dx, dy).</p>
<p>If dx is negative, <a class="el" href="struct_sk_rect.html">SkRect</a> returned is moved to the left. If dx is positive, <a class="el" href="struct_sk_rect.html">SkRect</a> returned is moved to the right. If dy is negative, <a class="el" href="struct_sk_rect.html">SkRect</a> returned is moved upward. If dy is positive, <a class="el" href="struct_sk_rect.html">SkRect</a> returned is moved downward.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>added to fLeft and fRight </td></tr>
    <tr><td class="paramname">dy</td><td>added to fTop and fBottom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_sk_rect.html">SkRect</a> offset on axes, with original width and height </dd></dl>

</div>
</div>
<a id="a01a234f1130a519c5d9f98bb9deb2804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a234f1130a519c5d9f98bb9deb2804">&#9670;&nbsp;</a></span>makeOffset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_sk_rect.html">SkRect</a> SkRect::makeOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkVector</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_rect.html">SkRect</a> offset by v.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>added to rect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_sk_rect.html">SkRect</a> offset on axes, with original width and height </dd></dl>

</div>
</div>
<a id="aa59531061cfbe498266e68aa9c0416bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa59531061cfbe498266e68aa9c0416bf">&#9670;&nbsp;</a></span>makeOutset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_rect.html">SkRect</a> SkRect::makeOutset </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_rect.html">SkRect</a>, outset by (dx, dy).</p>
<p>If dx is negative, <a class="el" href="struct_sk_rect.html">SkRect</a> returned is narrower. If dx is positive, <a class="el" href="struct_sk_rect.html">SkRect</a> returned is wider. If dy is negative, <a class="el" href="struct_sk_rect.html">SkRect</a> returned is shorter. If dy is positive, <a class="el" href="struct_sk_rect.html">SkRect</a> returned is taller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>subtracted to fLeft and added from fRight </td></tr>
    <tr><td class="paramname">dy</td><td>subtracted to fTop and added from fBottom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_sk_rect.html">SkRect</a> outset symmetrically left and right, top and bottom </dd></dl>

</div>
</div>
<a id="a1b319932b7dcc45b5a8afe0db49bd326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b319932b7dcc45b5a8afe0db49bd326">&#9670;&nbsp;</a></span>MakeSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_sk_rect.html">SkRect</a> SK_WARN_UNUSED_RESULT SkRect::MakeSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_size.html">SkSize</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_sk_rect.html">SkRect</a> set to (0, 0, size.width(), size.height()). Does not validate input; size.width() or size.height() may be negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>SkScalar values for <a class="el" href="struct_sk_rect.html">SkRect</a> width and height </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bounds (0, 0, size.width(), size.height()) </dd></dl>

</div>
</div>
<a id="a06eccd7253b2c6d8b7629b3255fd4c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06eccd7253b2c6d8b7629b3255fd4c55">&#9670;&nbsp;</a></span>makeSorted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_rect.html">SkRect</a> SkRect::makeSorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_rect.html">SkRect</a> with fLeft and fRight swapped if fLeft is greater than fRight; and with fTop and fBottom swapped if fTop is greater than fBottom. Result may be empty; and <a class="el" href="struct_sk_rect.html#a310ae07c04770654b18e6af8679c647e">width()</a> and <a class="el" href="struct_sk_rect.html#a253a231ae7ceec0bf81187964b4d7fbd">height()</a> will be zero or positive.</p>
<dl class="section return"><dt>Returns</dt><dd>sorted <a class="el" href="struct_sk_rect.html">SkRect</a> </dd></dl>

</div>
</div>
<a id="a22456b8e053e6ed4b764207b9aae28a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22456b8e053e6ed4b764207b9aae28a6">&#9670;&nbsp;</a></span>MakeWH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_sk_rect.html">SkRect</a> SK_WARN_UNUSED_RESULT SkRect::MakeWH </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_sk_rect.html">SkRect</a> set to SkScalar values (0, 0, w, h). Does not validate input; w or h may be negative.</p>
<p>Passing integer values may generate a compiler warning since <a class="el" href="struct_sk_rect.html">SkRect</a> cannot represent 32-bit integers exactly. Use <a class="el" href="struct_sk_i_rect.html">SkIRect</a> for an exact integer rectangle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>SkScalar width of constructed <a class="el" href="struct_sk_rect.html">SkRect</a> </td></tr>
    <tr><td class="paramname">h</td><td>SkScalar height of constructed <a class="el" href="struct_sk_rect.html">SkRect</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bounds (0, 0, w, h) </dd></dl>

</div>
</div>
<a id="aef01ba00dd9ab4489fed11413fb2cdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef01ba00dd9ab4489fed11413fb2cdc7">&#9670;&nbsp;</a></span>MakeXYWH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_sk_rect.html">SkRect</a> SK_WARN_UNUSED_RESULT SkRect::MakeXYWH </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_sk_rect.html">SkRect</a> set to (x, y, x + w, y + h). Does not validate input; w or h may be negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>stored in fLeft </td></tr>
    <tr><td class="paramname">y</td><td>stored in fTop </td></tr>
    <tr><td class="paramname">w</td><td>added to x and stored in fRight </td></tr>
    <tr><td class="paramname">h</td><td>added to y and stored in fBottom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bounds at (x, y) with width w and height h </dd></dl>

</div>
</div>
<a id="a2c8f2bfd893aab26d02d78bf5cb40c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8f2bfd893aab26d02d78bf5cb40c71">&#9670;&nbsp;</a></span>offset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Offsets <a class="el" href="struct_sk_rect.html">SkRect</a> by adding delta.fX to fLeft, fRight; and by adding delta.fY to fTop, fBottom.</p>
<p>If delta.fX is negative, moves <a class="el" href="struct_sk_rect.html">SkRect</a> to the left. If delta.fX is positive, moves <a class="el" href="struct_sk_rect.html">SkRect</a> to the right. If delta.fY is negative, moves <a class="el" href="struct_sk_rect.html">SkRect</a> upward. If delta.fY is positive, moves <a class="el" href="struct_sk_rect.html">SkRect</a> downward.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>added to <a class="el" href="struct_sk_rect.html">SkRect</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a614001ece824a30589cf08864a75fcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614001ece824a30589cf08864a75fcc1">&#9670;&nbsp;</a></span>offset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::offset </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Offsets <a class="el" href="struct_sk_rect.html">SkRect</a> by adding dx to fLeft, fRight; and by adding dy to fTop, fBottom.</p>
<p>If dx is negative, moves <a class="el" href="struct_sk_rect.html">SkRect</a> to the left. If dx is positive, moves <a class="el" href="struct_sk_rect.html">SkRect</a> to the right. If dy is negative, moves <a class="el" href="struct_sk_rect.html">SkRect</a> upward. If dy is positive, moves <a class="el" href="struct_sk_rect.html">SkRect</a> downward.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>offset added to fLeft and fRight </td></tr>
    <tr><td class="paramname">dy</td><td>offset added to fTop and fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae11527364b7ff9ba8ba33f52581d8548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11527364b7ff9ba8ba33f52581d8548">&#9670;&nbsp;</a></span>offsetTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::offsetTo </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>newX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>newY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Offsets <a class="el" href="struct_sk_rect.html">SkRect</a> so that fLeft equals newX, and fTop equals newY. width and height are unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newX</td><td>stored in fLeft, preserving <a class="el" href="struct_sk_rect.html#a310ae07c04770654b18e6af8679c647e">width()</a> </td></tr>
    <tr><td class="paramname">newY</td><td>stored in fTop, preserving <a class="el" href="struct_sk_rect.html#a253a231ae7ceec0bf81187964b4d7fbd">height()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2af43f4e6782402b26920c7ab9b4e3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2af43f4e6782402b26920c7ab9b4e3f2">&#9670;&nbsp;</a></span>outset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::outset </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Outsets <a class="el" href="struct_sk_rect.html">SkRect</a> by (dx, dy).</p>
<p>If dx is positive, makes <a class="el" href="struct_sk_rect.html">SkRect</a> wider. If dx is negative, makes <a class="el" href="struct_sk_rect.html">SkRect</a> narrower. If dy is positive, makes <a class="el" href="struct_sk_rect.html">SkRect</a> taller. If dy is negative, makes <a class="el" href="struct_sk_rect.html">SkRect</a> shorter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>subtracted to fLeft and added from fRight </td></tr>
    <tr><td class="paramname">dy</td><td>subtracted to fTop and added from fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18c9fe4ed03a6499113e3c914d53add4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c9fe4ed03a6499113e3c914d53add4">&#9670;&nbsp;</a></span>right()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkRect::right </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns right edge of <a class="el" href="struct_sk_rect.html">SkRect</a>, if sorted. Call <a class="el" href="struct_sk_rect.html#aec7bf7c5d287b815e0021f3cd3ef95f6">isSorted()</a> to see if <a class="el" href="struct_sk_rect.html">SkRect</a> is valid. Call <a class="el" href="struct_sk_rect.html#acfcd3ead21de8e1f10ef1ae64b5facad">sort()</a> to reverse fLeft and fRight if needed.</p>
<dl class="section return"><dt>Returns</dt><dd>fRight </dd></dl>

</div>
</div>
<a id="aba14635425df0d4c700ff50ac26331c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba14635425df0d4c700ff50ac26331c7">&#9670;&nbsp;</a></span>round() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_i_rect.html">SkIRect</a> SkRect::round </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_i_rect.html">SkIRect</a> by adding 0.5 and discarding the fractional portion of <a class="el" href="struct_sk_rect.html">SkRect</a> members, using (SkScalarRoundToInt(fLeft), SkScalarRoundToInt(fTop), SkScalarRoundToInt(fRight), SkScalarRoundToInt(fBottom)).</p>
<dl class="section return"><dt>Returns</dt><dd>rounded <a class="el" href="struct_sk_i_rect.html">SkIRect</a> </dd></dl>

</div>
</div>
<a id="a9ce1e87f8c407e6ff884993f8032003a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce1e87f8c407e6ff884993f8032003a">&#9670;&nbsp;</a></span>round() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::round </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_i_rect.html">SkIRect</a> *&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> by adding 0.5 and discarding the fractional portion of <a class="el" href="struct_sk_rect.html">SkRect</a> members, using (SkScalarRoundToInt(fLeft), SkScalarRoundToInt(fTop), SkScalarRoundToInt(fRight), SkScalarRoundToInt(fBottom)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>storage for <a class="el" href="struct_sk_i_rect.html">SkIRect</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a8f75e18088804fdeebbb1fffc5a934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8f75e18088804fdeebbb1fffc5a934">&#9670;&nbsp;</a></span>roundIn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_i_rect.html">SkIRect</a> SkRect::roundIn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> by rounding up fLeft and fTop; and discarding the fractional portion of fRight and fBottom, using (SkScalarCeilToInt(fLeft), SkScalarCeilToInt(fTop), SkScalarFloorToInt(fRight), SkScalarFloorToInt(fBottom)).</p>
<dl class="section return"><dt>Returns</dt><dd>rounded <a class="el" href="struct_sk_i_rect.html">SkIRect</a> </dd></dl>

</div>
</div>
<a id="a4d961d8314ba194b4f04f9b713ab29ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d961d8314ba194b4f04f9b713ab29ff">&#9670;&nbsp;</a></span>roundIn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::roundIn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_i_rect.html">SkIRect</a> *&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_rect.html">SkRect</a> by rounding up fLeft and fTop; and discarding the fractional portion of fRight and fBottom, using (SkScalarCeilToInt(fLeft), SkScalarCeilToInt(fTop), SkScalarFloorToInt(fRight), SkScalarFloorToInt(fBottom)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>storage for <a class="el" href="struct_sk_i_rect.html">SkIRect</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81372adc2dd974149c5778e5aafcb020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81372adc2dd974149c5778e5aafcb020">&#9670;&nbsp;</a></span>roundOut() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_i_rect.html">SkIRect</a> SkRect::roundOut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> by discarding the fractional portion of fLeft and fTop; and rounding up fRight and fBottom, using (SkScalarFloorToInt(fLeft), SkScalarFloorToInt(fTop), SkScalarCeilToInt(fRight), SkScalarCeilToInt(fBottom)).</p>
<dl class="section return"><dt>Returns</dt><dd>rounded <a class="el" href="struct_sk_i_rect.html">SkIRect</a> </dd></dl>

</div>
</div>
<a id="a8a82140d34549c4add33cd988c7dded8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a82140d34549c4add33cd988c7dded8">&#9670;&nbsp;</a></span>roundOut() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::roundOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_i_rect.html">SkIRect</a> *&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> by discarding the fractional portion of fLeft and fTop; and rounding up fRight and fBottom, using (SkScalarFloorToInt(fLeft), SkScalarFloorToInt(fTop), SkScalarCeilToInt(fRight), SkScalarCeilToInt(fBottom)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>storage for <a class="el" href="struct_sk_i_rect.html">SkIRect</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5c49f7f74f9f67f623560b9794e0834c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c49f7f74f9f67f623560b9794e0834c">&#9670;&nbsp;</a></span>roundOut() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::roundOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_rect.html">SkRect</a> *&#160;</td>
          <td class="paramname"><em>dst</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_rect.html">SkRect</a> by discarding the fractional portion of fLeft and fTop; and rounding up fRight and fBottom, using (SkScalarFloorToInt(fLeft), SkScalarFloorToInt(fTop), SkScalarCeilToInt(fRight), SkScalarCeilToInt(fBottom)).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>storage for <a class="el" href="struct_sk_rect.html">SkRect</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af0274cc20b107b6deecb1959e1a0cd88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0274cc20b107b6deecb1959e1a0cd88">&#9670;&nbsp;</a></span>set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_rect.html">SkRect</a> to src, promoting src members from integer to scalar. Very large values in src may lose precision.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>integer <a class="el" href="struct_sk_rect.html">SkRect</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77b6c0846b2d171ca8e65b2db8ca3ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b6c0846b2d171ca8e65b2db8ca3ab7">&#9670;&nbsp;</a></span>set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets bounds to the smallest <a class="el" href="struct_sk_rect.html">SkRect</a> enclosing <a class="el" href="struct_sk_point.html">SkPoint</a> p0 and p1. The result is sorted and may be empty. Does not check to see if values are finite.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p0</td><td>corner to include </td></tr>
    <tr><td class="paramname">p1</td><td>corner to include </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbecc852bda53e4bf57f83c7644b887d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbecc852bda53e4bf57f83c7644b887d">&#9670;&nbsp;</a></span>setBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::setBounds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>pts</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets to bounds of <a class="el" href="struct_sk_point.html">SkPoint</a> array with count entries. If count is zero or smaller, or if <a class="el" href="struct_sk_point.html">SkPoint</a> array contains an infinity or NaN, sets to (0, 0, 0, 0).</p>
<p>Result is either empty or sorted: fLeft is less than or equal to fRight, and fTop is less than or equal to fBottom.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td><a class="el" href="struct_sk_point.html">SkPoint</a> array </td></tr>
    <tr><td class="paramname">count</td><td>entries in array </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab6471738693c63a027cdc6be7271337b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6471738693c63a027cdc6be7271337b">&#9670;&nbsp;</a></span>setBoundsCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkRect::setBoundsCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>pts</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets to bounds of <a class="el" href="struct_sk_point.html">SkPoint</a> array with count entries. Returns false if count is zero or smaller, or if <a class="el" href="struct_sk_point.html">SkPoint</a> array contains an infinity or NaN; in these cases sets <a class="el" href="struct_sk_rect.html">SkRect</a> to (0, 0, 0, 0).</p>
<p>Result is either empty or sorted: fLeft is less than or equal to fRight, and fTop is less than or equal to fBottom.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td><a class="el" href="struct_sk_point.html">SkPoint</a> array </td></tr>
    <tr><td class="paramname">count</td><td>entries in array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all <a class="el" href="struct_sk_point.html">SkPoint</a> values are finite</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Rect_setBoundsCheck">https://fiddle.skia.org/c/@Rect_setBoundsCheck</a> </p>

</div>
</div>
<a id="ada995b52374b12c1911942185058fb4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada995b52374b12c1911942185058fb4b">&#9670;&nbsp;</a></span>setBoundsNoCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::setBoundsNoCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>pts</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets to bounds of <a class="el" href="struct_sk_point.html">SkPoint</a> pts array with count entries. If any <a class="el" href="struct_sk_point.html">SkPoint</a> in pts contains infinity or NaN, all <a class="el" href="struct_sk_rect.html">SkRect</a> dimensions are set to NaN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td><a class="el" href="struct_sk_point.html">SkPoint</a> array </td></tr>
    <tr><td class="paramname">count</td><td>entries in array</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Rect_setBoundsNoCheck">https://fiddle.skia.org/c/@Rect_setBoundsNoCheck</a> </p>

</div>
</div>
<a id="af745695f16db12325af9b5770068ab93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af745695f16db12325af9b5770068ab93">&#9670;&nbsp;</a></span>setEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::setEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_rect.html">SkRect</a> to (0, 0, 0, 0).</p>
<p>Many other rectangles are empty; if left is equal to or greater than right, or if top is equal to or greater than bottom. Setting all members to zero is a convenience, but does not designate a special empty rectangle. </p>

</div>
</div>
<a id="a0a135fc03a19f7b41940ec6cc47550b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a135fc03a19f7b41940ec6cc47550b7">&#9670;&nbsp;</a></span>setLTRB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::setLTRB </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_rect.html">SkRect</a> to (left, top, right, bottom). left and right are not sorted; left is not necessarily less than right. top and bottom are not sorted; top is not necessarily less than bottom.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>stored in fLeft </td></tr>
    <tr><td class="paramname">top</td><td>stored in fTop </td></tr>
    <tr><td class="paramname">right</td><td>stored in fRight </td></tr>
    <tr><td class="paramname">bottom</td><td>stored in fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32b7147cc72564905ffe8311bba898d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b7147cc72564905ffe8311bba898d6">&#9670;&nbsp;</a></span>setWH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::setWH </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_rect.html">SkRect</a> to (0, 0, width, height). Does not validate input; width or height may be negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>stored in fRight </td></tr>
    <tr><td class="paramname">height</td><td>stored in fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e31e863d5e50de184246e1dd3078ef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e31e863d5e50de184246e1dd3078ef3">&#9670;&nbsp;</a></span>setXYWH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::setXYWH </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_rect.html">SkRect</a> to (x, y, x + width, y + height). Does not validate input; width or height may be negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>stored in fLeft </td></tr>
    <tr><td class="paramname">y</td><td>stored in fTop </td></tr>
    <tr><td class="paramname">width</td><td>added to x and stored in fRight </td></tr>
    <tr><td class="paramname">height</td><td>added to y and stored in fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfcd3ead21de8e1f10ef1ae64b5facad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcd3ead21de8e1f10ef1ae64b5facad">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps fLeft and fRight if fLeft is greater than fRight; and swaps fTop and fBottom if fTop is greater than fBottom. Result may be empty; and <a class="el" href="struct_sk_rect.html#a310ae07c04770654b18e6af8679c647e">width()</a> and <a class="el" href="struct_sk_rect.html#a253a231ae7ceec0bf81187964b4d7fbd">height()</a> will be zero or positive. </p>

</div>
</div>
<a id="aba881f31c06e070d8985ecb8b64dbc04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba881f31c06e070d8985ecb8b64dbc04">&#9670;&nbsp;</a></span>top()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkRect::top </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns top edge of <a class="el" href="struct_sk_rect.html">SkRect</a>, if sorted. Call <a class="el" href="struct_sk_rect.html#ac3538672f858058318ddee7873b75802">isEmpty()</a> to see if <a class="el" href="struct_sk_rect.html">SkRect</a> may be invalid, and <a class="el" href="struct_sk_rect.html#acfcd3ead21de8e1f10ef1ae64b5facad">sort()</a> to reverse fTop and fBottom if needed.</p>
<dl class="section return"><dt>Returns</dt><dd>fTop </dd></dl>

</div>
</div>
<a id="a1c64f14d3855d1947aa48e7cc7c9ba1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c64f14d3855d1947aa48e7cc7c9ba1f">&#9670;&nbsp;</a></span>toQuad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkRect::toQuad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>quad</em>[4]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns four points in quad that enclose <a class="el" href="struct_sk_rect.html">SkRect</a> ordered as: top-left, top-right, bottom-right, bottom-left.</p>
<p>TODO: Consider adding parameter to control whether quad is clockwise or counterclockwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">quad</td><td>storage for corners of <a class="el" href="struct_sk_rect.html">SkRect</a></td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Rect_toQuad">https://fiddle.skia.org/c/@Rect_toQuad</a> </p>

</div>
</div>
<a id="a310ae07c04770654b18e6af8679c647e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a310ae07c04770654b18e6af8679c647e">&#9670;&nbsp;</a></span>width()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkRect::width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns span on the x-axis. This does not check if <a class="el" href="struct_sk_rect.html">SkRect</a> is sorted, or if result fits in 32-bit float; result may be negative or infinity.</p>
<dl class="section return"><dt>Returns</dt><dd>fRight minus fLeft </dd></dl>

</div>
</div>
<a id="a61cc480105e5f210eee33b2cc995e1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61cc480105e5f210eee33b2cc995e1d9">&#9670;&nbsp;</a></span>x()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkRect::x </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns left edge of <a class="el" href="struct_sk_rect.html">SkRect</a>, if sorted. Call <a class="el" href="struct_sk_rect.html#aec7bf7c5d287b815e0021f3cd3ef95f6">isSorted()</a> to see if <a class="el" href="struct_sk_rect.html">SkRect</a> is valid. Call <a class="el" href="struct_sk_rect.html#acfcd3ead21de8e1f10ef1ae64b5facad">sort()</a> to reverse fLeft and fRight if needed.</p>
<dl class="section return"><dt>Returns</dt><dd>fLeft </dd></dl>

</div>
</div>
<a id="a039292b287cf0ffc64ad04d45590ec12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039292b287cf0ffc64ad04d45590ec12">&#9670;&nbsp;</a></span>y()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkRect::y </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns top edge of <a class="el" href="struct_sk_rect.html">SkRect</a>, if sorted. Call <a class="el" href="struct_sk_rect.html#ac3538672f858058318ddee7873b75802">isEmpty()</a> to see if <a class="el" href="struct_sk_rect.html">SkRect</a> may be invalid, and <a class="el" href="struct_sk_rect.html#acfcd3ead21de8e1f10ef1ae64b5facad">sort()</a> to reverse fTop and fBottom if needed.</p>
<dl class="section return"><dt>Returns</dt><dd>fTop </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="adf0ac4ff19909f104a1178292cadcf83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf0ac4ff19909f104a1178292cadcf83">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if any in a: fLeft, fTop, fRight, and fBottom; does not equal the corresponding members in b.</p>
<p>a and b are not equal if either contain NaN. a and b are equal if members contain zeroes with different signs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if members are not equal </dd></dl>

</div>
</div>
<a id="a3f00109392160f744487428ced663eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f00109392160f744487428ced663eb7">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if all members in a: fLeft, fTop, fRight, and fBottom; are equal to the corresponding members in b.</p>
<p>a and b are not equal if either contain NaN. a and b are equal if members contain zeroes with different signs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if members are equal </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/include/core/<a class="el" href="_sk_rect_8h_source.html">SkRect.h</a></li>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/src/core/SkRect.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
