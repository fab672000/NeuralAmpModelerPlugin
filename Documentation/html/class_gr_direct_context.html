<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: GrDirectContext Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_gr_direct_context-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">GrDirectContext Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for GrDirectContext:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_gr_direct_context.png" usemap="#GrDirectContext_map" alt=""/>
  <map id="GrDirectContext_map" name="GrDirectContext_map">
<area href="class_gr_recording_context.html" alt="GrRecordingContext" shape="rect" coords="0,224,126,248"/>
<area href="class_gr_image_context.html" alt="GrImageContext" shape="rect" coords="0,168,126,192"/>
<area href="class_gr_context___base.html" alt="GrContext_Base" shape="rect" coords="0,112,126,136"/>
<area href="class_sk_ref_cnt.html" alt="SkRefCnt" shape="rect" coords="0,56,126,80"/>
<area href="class_sk_ref_cnt_base.html" alt="SkRefCntBase" shape="rect" coords="0,0,126,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context_1_1_direct_context_i_d.html">DirectContextID</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a53c3539a51361c0483476a9efd247055"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a53c3539a51361c0483476a9efd247055">resetContext</a> (uint32_t <a class="el" href="structstate.html">state</a>=kAll_GrBackendState)</td></tr>
<tr class="separator:a53c3539a51361c0483476a9efd247055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f54c0e0566c134841ea94bf5f1e29d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#ac1f54c0e0566c134841ea94bf5f1e29d">resetGLTextureBindings</a> ()</td></tr>
<tr class="separator:ac1f54c0e0566c134841ea94bf5f1e29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb90c9ad9c8f849f8c09ce965f570a3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#aeb90c9ad9c8f849f8c09ce965f570a3d">abandonContext</a> () override</td></tr>
<tr class="separator:aeb90c9ad9c8f849f8c09ce965f570a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1c5c644a82f21ce2af991b4f451348"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a5c1c5c644a82f21ce2af991b4f451348">abandoned</a> () override</td></tr>
<tr class="separator:a5c1c5c644a82f21ce2af991b4f451348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95901720daa8d94387f990b12c7058b9"><td class="memItemLeft" align="right" valign="top"><a id="a95901720daa8d94387f990b12c7058b9"></a>
<a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_gr_context_thread_safe_proxy.html">GrContextThreadSafeProxy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>threadSafeProxy</b> ()</td></tr>
<tr class="separator:a95901720daa8d94387f990b12c7058b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46cacd2825836fd0305ee183e6fd276e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a46cacd2825836fd0305ee183e6fd276e">oomed</a> ()</td></tr>
<tr class="separator:a46cacd2825836fd0305ee183e6fd276e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585c7eebabd86ec88090d8cdee2d8f59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a585c7eebabd86ec88090d8cdee2d8f59">releaseResourcesAndAbandonContext</a> ()</td></tr>
<tr class="separator:a585c7eebabd86ec88090d8cdee2d8f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20d13cd13b25b1aacf12454da4a0af2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#ac20d13cd13b25b1aacf12454da4a0af2">getResourceCacheLimits</a> (int *maxResources, size_t *maxResourceBytes) const</td></tr>
<tr class="separator:ac20d13cd13b25b1aacf12454da4a0af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b00959f2ef26e2c1ac2a7b56e666dc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a41b00959f2ef26e2c1ac2a7b56e666dc">getResourceCacheLimit</a> () const</td></tr>
<tr class="separator:a41b00959f2ef26e2c1ac2a7b56e666dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2553f48d12afb0595f6f7920894446"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#abc2553f48d12afb0595f6f7920894446">getResourceCacheUsage</a> (int *resourceCount, size_t *resourceBytes) const</td></tr>
<tr class="separator:abc2553f48d12afb0595f6f7920894446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c49050b805e1d24c1cb2fb0266bf982"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a1c49050b805e1d24c1cb2fb0266bf982">getResourceCachePurgeableBytes</a> () const</td></tr>
<tr class="separator:a1c49050b805e1d24c1cb2fb0266bf982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e1728f5c16225c2a6e1a2eb65fa695"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a05e1728f5c16225c2a6e1a2eb65fa695">setResourceCacheLimits</a> (int maxResources, size_t maxResourceBytes)</td></tr>
<tr class="separator:a05e1728f5c16225c2a6e1a2eb65fa695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af972a5f50215ee314c48e5749d6259b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#af972a5f50215ee314c48e5749d6259b9">setResourceCacheLimit</a> (size_t maxResourceBytes)</td></tr>
<tr class="separator:af972a5f50215ee314c48e5749d6259b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef10709e240b76201c4ca5a26932890"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a3ef10709e240b76201c4ca5a26932890">freeGpuResources</a> ()</td></tr>
<tr class="separator:a3ef10709e240b76201c4ca5a26932890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae098633b71c877cf97965f0414f17ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#aae098633b71c877cf97965f0414f17ed">performDeferredCleanup</a> (std::chrono::milliseconds msNotUsed, bool scratchResourcesOnly=false)</td></tr>
<tr class="separator:aae098633b71c877cf97965f0414f17ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1024a75ca9e359dc79c6aac1f91dd8f3"><td class="memItemLeft" align="right" valign="top"><a id="a1024a75ca9e359dc79c6aac1f91dd8f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>purgeResourcesNotUsedInMs</b> (std::chrono::milliseconds msNotUsed)</td></tr>
<tr class="separator:a1024a75ca9e359dc79c6aac1f91dd8f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9f27a269e2c41f6530cdb4ad0b4da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#ada9f27a269e2c41f6530cdb4ad0b4da3">purgeUnlockedResources</a> (size_t bytesToPurge, bool preferScratchResources)</td></tr>
<tr class="separator:ada9f27a269e2c41f6530cdb4ad0b4da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464e8f2af9609a2937d05422eaaab5f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a464e8f2af9609a2937d05422eaaab5f7">purgeUnlockedResources</a> (bool scratchResourcesOnly)</td></tr>
<tr class="separator:a464e8f2af9609a2937d05422eaaab5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84b361801b9493a3d19d8fd761d87fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#ab84b361801b9493a3d19d8fd761d87fe">wait</a> (int numSemaphores, const <a class="el" href="class_gr_backend_semaphore.html">GrBackendSemaphore</a> *waitSemaphores, bool deleteSemaphoresAfterWait=true)</td></tr>
<tr class="separator:ab84b361801b9493a3d19d8fd761d87fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e068da6db37707ee353abedc584ef6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a5e068da6db37707ee353abedc584ef6f">flushAndSubmit</a> (bool syncCpu=false)</td></tr>
<tr class="separator:a5e068da6db37707ee353abedc584ef6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953f6ace921cd53e1333624c7770db54"><td class="memItemLeft" align="right" valign="top">GrSemaphoresSubmitted&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a953f6ace921cd53e1333624c7770db54">flush</a> (const <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a> &amp;info)</td></tr>
<tr class="separator:a953f6ace921cd53e1333624c7770db54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1b90f3a35d987e95e148c517b8cfd7"><td class="memItemLeft" align="right" valign="top"><a id="abd1b90f3a35d987e95e148c517b8cfd7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>flush</b> ()</td></tr>
<tr class="separator:abd1b90f3a35d987e95e148c517b8cfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e6391e15ee021f864a9d4fbef930732"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a2e6391e15ee021f864a9d4fbef930732">submit</a> (bool syncCpu=false)</td></tr>
<tr class="separator:a2e6391e15ee021f864a9d4fbef930732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a347baddc1feca01526524c6cabdd3c84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a347baddc1feca01526524c6cabdd3c84">checkAsyncWorkCompletion</a> ()</td></tr>
<tr class="separator:a347baddc1feca01526524c6cabdd3c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03201b03a0d733d1a0af6a2775cdb00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#ac03201b03a0d733d1a0af6a2775cdb00">dumpMemoryStatistics</a> (<a class="el" href="class_sk_trace_memory_dump.html">SkTraceMemoryDump</a> *traceMemoryDump) const</td></tr>
<tr class="separator:ac03201b03a0d733d1a0af6a2775cdb00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e77cbb4adc6d85f5087eefeb8f8195"><td class="memItemLeft" align="right" valign="top"><a id="ae4e77cbb4adc6d85f5087eefeb8f8195"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>supportsDistanceFieldText</b> () const</td></tr>
<tr class="separator:ae4e77cbb4adc6d85f5087eefeb8f8195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab098f7299e5b1a9e447be624c9636c51"><td class="memItemLeft" align="right" valign="top"><a id="ab098f7299e5b1a9e447be624c9636c51"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>storeVkPipelineCacheData</b> ()</td></tr>
<tr class="separator:ab098f7299e5b1a9e447be624c9636c51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87af0af0e7ed940e4940e132b980aae3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a87af0af0e7ed940e4940e132b980aae3">createBackendTexture</a> (int width, int height, const <a class="el" href="class_gr_backend_format.html">GrBackendFormat</a> &amp;, GrMipmapped, GrRenderable, GrProtected=GrProtected::kNo)</td></tr>
<tr class="separator:a87af0af0e7ed940e4940e132b980aae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a334dcc3239840aeec75f3322ae1987d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a334dcc3239840aeec75f3322ae1987d7">createBackendTexture</a> (int width, int height, SkColorType, GrMipmapped, GrRenderable, GrProtected=GrProtected::kNo)</td></tr>
<tr class="separator:a334dcc3239840aeec75f3322ae1987d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60567ade1eab2d44db3a79a76d27b79b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a60567ade1eab2d44db3a79a76d27b79b">createBackendTexture</a> (int width, int height, const <a class="el" href="class_gr_backend_format.html">GrBackendFormat</a> &amp;, const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;color, GrMipmapped, GrRenderable, GrProtected=GrProtected::kNo, GrGpuFinishedProc finishedProc=nullptr, GrGpuFinishedContext finishedContext=nullptr)</td></tr>
<tr class="separator:a60567ade1eab2d44db3a79a76d27b79b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f84fdee1cb5b34426002134f6e17c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a62f84fdee1cb5b34426002134f6e17c9">createBackendTexture</a> (int width, int height, SkColorType, const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;color, GrMipmapped, GrRenderable, GrProtected=GrProtected::kNo, GrGpuFinishedProc finishedProc=nullptr, GrGpuFinishedContext finishedContext=nullptr)</td></tr>
<tr class="separator:a62f84fdee1cb5b34426002134f6e17c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af151abc92b45bdc74b99471a33e2dd24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#af151abc92b45bdc74b99471a33e2dd24">createBackendTexture</a> (const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> srcData[], int numLevels, GrSurfaceOrigin, GrRenderable, GrProtected, GrGpuFinishedProc finishedProc=nullptr, GrGpuFinishedContext finishedContext=nullptr)</td></tr>
<tr class="separator:af151abc92b45bdc74b99471a33e2dd24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e96b31af4b591cd147ebba07920ed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#af3e96b31af4b591cd147ebba07920ed3">createBackendTexture</a> (const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> &amp;srcData, GrSurfaceOrigin textureOrigin, GrRenderable renderable, GrProtected isProtected, GrGpuFinishedProc finishedProc=nullptr, GrGpuFinishedContext finishedContext=nullptr)</td></tr>
<tr class="separator:af3e96b31af4b591cd147ebba07920ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6426a89b2441270f7a20034b8f370b1"><td class="memItemLeft" align="right" valign="top"><a id="aa6426a89b2441270f7a20034b8f370b1"></a>
<a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><b>createBackendTexture</b> (const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> srcData[], int numLevels, GrRenderable renderable, GrProtected isProtected, GrGpuFinishedProc finishedProc=nullptr, GrGpuFinishedContext finishedContext=nullptr)</td></tr>
<tr class="separator:aa6426a89b2441270f7a20034b8f370b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67d796b9269ed97823c705dc362ee96"><td class="memItemLeft" align="right" valign="top"><a id="ae67d796b9269ed97823c705dc362ee96"></a>
<a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><b>createBackendTexture</b> (const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> &amp;srcData, GrRenderable renderable, GrProtected isProtected, GrGpuFinishedProc finishedProc=nullptr, GrGpuFinishedContext finishedContext=nullptr)</td></tr>
<tr class="separator:ae67d796b9269ed97823c705dc362ee96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96e5681a6a452f4fe74920abe1594e55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a96e5681a6a452f4fe74920abe1594e55">updateBackendTexture</a> (const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;, const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;color, GrGpuFinishedProc finishedProc, GrGpuFinishedContext finishedContext)</td></tr>
<tr class="separator:a96e5681a6a452f4fe74920abe1594e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73536ee3f0f47e459f671f5b410b540c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a73536ee3f0f47e459f671f5b410b540c">updateBackendTexture</a> (const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;, SkColorType skColorType, const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;color, GrGpuFinishedProc finishedProc, GrGpuFinishedContext finishedContext)</td></tr>
<tr class="separator:a73536ee3f0f47e459f671f5b410b540c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa88d9f58d0aab0f689115c5ce9a358a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#afa88d9f58d0aab0f689115c5ce9a358a">updateBackendTexture</a> (const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;, const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> srcData[], int numLevels, GrSurfaceOrigin=kTopLeft_GrSurfaceOrigin, GrGpuFinishedProc finishedProc=nullptr, GrGpuFinishedContext finishedContext=nullptr)</td></tr>
<tr class="separator:afa88d9f58d0aab0f689115c5ce9a358a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a49762726cb726ec868970d75953a3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a9a49762726cb726ec868970d75953a3b">updateBackendTexture</a> (const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;texture, const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> &amp;srcData, GrSurfaceOrigin textureOrigin=kTopLeft_GrSurfaceOrigin, GrGpuFinishedProc finishedProc=nullptr, GrGpuFinishedContext finishedContext=nullptr)</td></tr>
<tr class="separator:a9a49762726cb726ec868970d75953a3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4c2fbe8b51d6ccdfe6c3812c0e63ec"><td class="memItemLeft" align="right" valign="top"><a id="ada4c2fbe8b51d6ccdfe6c3812c0e63ec"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>updateBackendTexture</b> (const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;texture, const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> srcData[], int numLevels, GrGpuFinishedProc finishedProc, GrGpuFinishedContext finishedContext)</td></tr>
<tr class="separator:ada4c2fbe8b51d6ccdfe6c3812c0e63ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12afd59a71e0c36d85259cf800a0f819"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a12afd59a71e0c36d85259cf800a0f819">createCompressedBackendTexture</a> (int width, int height, const <a class="el" href="class_gr_backend_format.html">GrBackendFormat</a> &amp;, const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;color, GrMipmapped, GrProtected=GrProtected::kNo, GrGpuFinishedProc finishedProc=nullptr, GrGpuFinishedContext finishedContext=nullptr)</td></tr>
<tr class="separator:a12afd59a71e0c36d85259cf800a0f819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c5464f00a84bbfa329beb0fda739aa"><td class="memItemLeft" align="right" valign="top"><a id="a95c5464f00a84bbfa329beb0fda739aa"></a>
<a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><b>createCompressedBackendTexture</b> (int width, int height, SkImage::CompressionType, const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;color, GrMipmapped, GrProtected=GrProtected::kNo, GrGpuFinishedProc finishedProc=nullptr, GrGpuFinishedContext finishedContext=nullptr)</td></tr>
<tr class="separator:a95c5464f00a84bbfa329beb0fda739aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa195f3bbf2c0baf8222cb1bdd40e9cd3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#aa195f3bbf2c0baf8222cb1bdd40e9cd3">createCompressedBackendTexture</a> (int width, int height, const <a class="el" href="class_gr_backend_format.html">GrBackendFormat</a> &amp;, const void *data, size_t dataSize, GrMipmapped, GrProtected=GrProtected::kNo, GrGpuFinishedProc finishedProc=nullptr, GrGpuFinishedContext finishedContext=nullptr)</td></tr>
<tr class="separator:aa195f3bbf2c0baf8222cb1bdd40e9cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd147b48e47fc84f0b82993109fcce2"><td class="memItemLeft" align="right" valign="top"><a id="a9dd147b48e47fc84f0b82993109fcce2"></a>
<a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><b>createCompressedBackendTexture</b> (int width, int height, SkImage::CompressionType, const void *data, size_t dataSize, GrMipmapped, GrProtected=GrProtected::kNo, GrGpuFinishedProc finishedProc=nullptr, GrGpuFinishedContext finishedContext=nullptr)</td></tr>
<tr class="separator:a9dd147b48e47fc84f0b82993109fcce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079adf61ab054bec6a1c8d9a2ec397f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a079adf61ab054bec6a1c8d9a2ec397f7">updateCompressedBackendTexture</a> (const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;, const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;color, GrGpuFinishedProc finishedProc, GrGpuFinishedContext finishedContext)</td></tr>
<tr class="separator:a079adf61ab054bec6a1c8d9a2ec397f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeedaf24edf8574a524dbf6f95fbe46d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#aeedaf24edf8574a524dbf6f95fbe46d3">updateCompressedBackendTexture</a> (const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;, const void *data, size_t dataSize, GrGpuFinishedProc finishedProc, GrGpuFinishedContext finishedContext)</td></tr>
<tr class="separator:aeedaf24edf8574a524dbf6f95fbe46d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bbafa0153d1b0e5e2204693b633612"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a16bbafa0153d1b0e5e2204693b633612">setBackendTextureState</a> (const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;, const <a class="el" href="class_gr_backend_surface_mutable_state.html">GrBackendSurfaceMutableState</a> &amp;, <a class="el" href="class_gr_backend_surface_mutable_state.html">GrBackendSurfaceMutableState</a> *previousState=nullptr, GrGpuFinishedProc finishedProc=nullptr, GrGpuFinishedContext finishedContext=nullptr)</td></tr>
<tr class="separator:a16bbafa0153d1b0e5e2204693b633612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40dff2268a0278ac66368743488dc9c"><td class="memItemLeft" align="right" valign="top"><a id="ad40dff2268a0278ac66368743488dc9c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>setBackendRenderTargetState</b> (const <a class="el" href="class_gr_backend_render_target.html">GrBackendRenderTarget</a> &amp;, const <a class="el" href="class_gr_backend_surface_mutable_state.html">GrBackendSurfaceMutableState</a> &amp;, <a class="el" href="class_gr_backend_surface_mutable_state.html">GrBackendSurfaceMutableState</a> *previousState=nullptr, GrGpuFinishedProc finishedProc=nullptr, GrGpuFinishedContext finishedContext=nullptr)</td></tr>
<tr class="separator:ad40dff2268a0278ac66368743488dc9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb38898fe336b7a7492b3fc557e1fce0"><td class="memItemLeft" align="right" valign="top"><a id="abb38898fe336b7a7492b3fc557e1fce0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>deleteBackendTexture</b> (<a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>)</td></tr>
<tr class="separator:abb38898fe336b7a7492b3fc557e1fce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4937ceb605a1a5eb68ba5b46774ab1f3"><td class="memItemLeft" align="right" valign="top"><a id="a4937ceb605a1a5eb68ba5b46774ab1f3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>precompileShader</b> (const <a class="el" href="class_sk_data.html">SkData</a> &amp;key, const <a class="el" href="class_sk_data.html">SkData</a> &amp;data)</td></tr>
<tr class="separator:a4937ceb605a1a5eb68ba5b46774ab1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d83c6a1ebf87e7cb663316618c7b2a"><td class="memItemLeft" align="right" valign="top"><a id="ac5d83c6a1ebf87e7cb663316618c7b2a"></a>
<a class="el" href="class_gr_direct_context_1_1_direct_context_i_d.html">DirectContextID</a>&#160;</td><td class="memItemRight" valign="bottom"><b>directContextID</b> () const</td></tr>
<tr class="separator:ac5d83c6a1ebf87e7cb663316618c7b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada720016bb09790a74ef80c0e5c7971a"><td class="memItemLeft" align="right" valign="top"><a id="ada720016bb09790a74ef80c0e5c7971a"></a>
GrDirectContextPriv&#160;</td><td class="memItemRight" valign="bottom"><b>priv</b> ()</td></tr>
<tr class="separator:ada720016bb09790a74ef80c0e5c7971a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2df6cb2d6a771e5f55a502260033575"><td class="memItemLeft" align="right" valign="top"><a id="ad2df6cb2d6a771e5f55a502260033575"></a>
const GrDirectContextPriv&#160;</td><td class="memItemRight" valign="bottom"><b>priv</b> () const</td></tr>
<tr class="separator:ad2df6cb2d6a771e5f55a502260033575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af480871a350a61af8fbc0fb413f0edec"><td class="memItemLeft" align="right" valign="top">SK_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#af480871a350a61af8fbc0fb413f0edec">maxTextureSize</a> () const</td></tr>
<tr class="separator:af480871a350a61af8fbc0fb413f0edec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa146ee57d29949b62820d89e7f32ab05"><td class="memItemLeft" align="right" valign="top">SK_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#aa146ee57d29949b62820d89e7f32ab05">maxRenderTargetSize</a> () const</td></tr>
<tr class="separator:aa146ee57d29949b62820d89e7f32ab05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5137fe6551394acee186d6be5631d1"><td class="memItemLeft" align="right" valign="top">SK_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#afe5137fe6551394acee186d6be5631d1">colorTypeSupportedAsImage</a> (SkColorType) const</td></tr>
<tr class="separator:afe5137fe6551394acee186d6be5631d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d321e29a1ba933f0e6e538e8095e553"><td class="memItemLeft" align="right" valign="top">SK_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a2d321e29a1ba933f0e6e538e8095e553">colorTypeSupportedAsSurface</a> (SkColorType colorType) const</td></tr>
<tr class="separator:a2d321e29a1ba933f0e6e538e8095e553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8421a291fdc2d1d5072d182eee34661f"><td class="memItemLeft" align="right" valign="top">SK_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a8421a291fdc2d1d5072d182eee34661f">maxSurfaceSampleCountForColorType</a> (SkColorType) const</td></tr>
<tr class="separator:a8421a291fdc2d1d5072d182eee34661f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511bc7524a6d21ac973b2b17ed6cc429"><td class="memItemLeft" align="right" valign="top">SK_API <a class="el" href="class_gr_backend_format.html">GrBackendFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_direct_context.html#a511bc7524a6d21ac973b2b17ed6cc429">defaultBackendFormat</a> (SkColorType ct, GrRenderable renderable) const</td></tr>
<tr class="separator:a511bc7524a6d21ac973b2b17ed6cc429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_gr_recording_context"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_gr_recording_context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_gr_recording_context.html">GrRecordingContext</a></td></tr>
<tr class="memitem:a511bc7524a6d21ac973b2b17ed6cc429 inherit pub_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="a511bc7524a6d21ac973b2b17ed6cc429"></a>
SK_API <a class="el" href="class_gr_backend_format.html">GrBackendFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>defaultBackendFormat</b> (SkColorType ct, GrRenderable renderable) const</td></tr>
<tr class="separator:a511bc7524a6d21ac973b2b17ed6cc429 inherit pub_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a278bd4668fd6874f58384abd1fee0fd0 inherit pub_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_recording_context.html#a278bd4668fd6874f58384abd1fee0fd0">abandoned</a> () override</td></tr>
<tr class="separator:a278bd4668fd6874f58384abd1fee0fd0 inherit pub_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d321e29a1ba933f0e6e538e8095e553 inherit pub_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="a2d321e29a1ba933f0e6e538e8095e553"></a>
SK_API bool&#160;</td><td class="memItemRight" valign="bottom"><b>colorTypeSupportedAsSurface</b> (SkColorType colorType) const</td></tr>
<tr class="separator:a2d321e29a1ba933f0e6e538e8095e553 inherit pub_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af480871a350a61af8fbc0fb413f0edec inherit pub_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top">SK_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_recording_context.html#af480871a350a61af8fbc0fb413f0edec">maxTextureSize</a> () const</td></tr>
<tr class="separator:af480871a350a61af8fbc0fb413f0edec inherit pub_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa146ee57d29949b62820d89e7f32ab05 inherit pub_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top">SK_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_recording_context.html#aa146ee57d29949b62820d89e7f32ab05">maxRenderTargetSize</a> () const</td></tr>
<tr class="separator:aa146ee57d29949b62820d89e7f32ab05 inherit pub_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5137fe6551394acee186d6be5631d1 inherit pub_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top">SK_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_recording_context.html#afe5137fe6551394acee186d6be5631d1">colorTypeSupportedAsImage</a> (SkColorType) const</td></tr>
<tr class="separator:afe5137fe6551394acee186d6be5631d1 inherit pub_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8421a291fdc2d1d5072d182eee34661f inherit pub_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top">SK_API int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_recording_context.html#a8421a291fdc2d1d5072d182eee34661f">maxSurfaceSampleCountForColorType</a> (SkColorType) const</td></tr>
<tr class="separator:a8421a291fdc2d1d5072d182eee34661f inherit pub_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c355b33d2f37e6c8218043b54f643fd inherit pub_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="a1c355b33d2f37e6c8218043b54f643fd"></a>
GrRecordingContextPriv&#160;</td><td class="memItemRight" valign="bottom"><b>priv</b> ()</td></tr>
<tr class="separator:a1c355b33d2f37e6c8218043b54f643fd inherit pub_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9ac453016accbf79897e181eebb8424 inherit pub_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="ae9ac453016accbf79897e181eebb8424"></a>
const GrRecordingContextPriv&#160;</td><td class="memItemRight" valign="bottom"><b>priv</b> () const</td></tr>
<tr class="separator:ae9ac453016accbf79897e181eebb8424 inherit pub_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_gr_image_context"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_gr_image_context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_gr_image_context.html">GrImageContext</a></td></tr>
<tr class="memitem:a57407565a119a89a4b3d9ade25eca26d inherit pub_methods_class_gr_image_context"><td class="memItemLeft" align="right" valign="top"><a id="a57407565a119a89a4b3d9ade25eca26d"></a>
GrImageContextPriv&#160;</td><td class="memItemRight" valign="bottom"><b>priv</b> ()</td></tr>
<tr class="separator:a57407565a119a89a4b3d9ade25eca26d inherit pub_methods_class_gr_image_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60f2c95291cd705d5e149f253a9624de inherit pub_methods_class_gr_image_context"><td class="memItemLeft" align="right" valign="top"><a id="a60f2c95291cd705d5e149f253a9624de"></a>
const GrImageContextPriv&#160;</td><td class="memItemRight" valign="bottom"><b>priv</b> () const</td></tr>
<tr class="separator:a60f2c95291cd705d5e149f253a9624de inherit pub_methods_class_gr_image_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_gr_context___base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_gr_context___base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_gr_context___base.html">GrContext_Base</a></td></tr>
<tr class="memitem:ad562305ea671d3aa06070a205f6aae47 inherit pub_methods_class_gr_context___base"><td class="memItemLeft" align="right" valign="top"><a id="ad562305ea671d3aa06070a205f6aae47"></a>
SK_API GrBackendApi&#160;</td><td class="memItemRight" valign="bottom"><b>backend</b> () const</td></tr>
<tr class="separator:ad562305ea671d3aa06070a205f6aae47 inherit pub_methods_class_gr_context___base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1583b2e7c9c6af297d2fe30ec10fe6f inherit pub_methods_class_gr_context___base"><td class="memItemLeft" align="right" valign="top"><a id="ab1583b2e7c9c6af297d2fe30ec10fe6f"></a>
SK_API <a class="el" href="class_gr_backend_format.html">GrBackendFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>defaultBackendFormat</b> (SkColorType, GrRenderable) const</td></tr>
<tr class="separator:ab1583b2e7c9c6af297d2fe30ec10fe6f inherit pub_methods_class_gr_context___base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a543f4c6297aafc33773d1bb103f21d61 inherit pub_methods_class_gr_context___base"><td class="memItemLeft" align="right" valign="top"><a id="a543f4c6297aafc33773d1bb103f21d61"></a>
SK_API <a class="el" href="class_gr_backend_format.html">GrBackendFormat</a>&#160;</td><td class="memItemRight" valign="bottom"><b>compressedBackendFormat</b> (SkImage::CompressionType) const</td></tr>
<tr class="separator:a543f4c6297aafc33773d1bb103f21d61 inherit pub_methods_class_gr_context___base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a4a5ae78466a9b697b8090d0d9b8d9 inherit pub_methods_class_gr_context___base"><td class="memItemLeft" align="right" valign="top"><a id="a92a4a5ae78466a9b697b8090d0d9b8d9"></a>
<a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_gr_context_thread_safe_proxy.html">GrContextThreadSafeProxy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>threadSafeProxy</b> ()</td></tr>
<tr class="separator:a92a4a5ae78466a9b697b8090d0d9b8d9 inherit pub_methods_class_gr_context___base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335ca582d2ec90fbf4b15b2fa2df92de inherit pub_methods_class_gr_context___base"><td class="memItemLeft" align="right" valign="top"><a id="a335ca582d2ec90fbf4b15b2fa2df92de"></a>
GrBaseContextPriv&#160;</td><td class="memItemRight" valign="bottom"><b>priv</b> ()</td></tr>
<tr class="separator:a335ca582d2ec90fbf4b15b2fa2df92de inherit pub_methods_class_gr_context___base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c062c6edd33d09da10e0d12947b93e inherit pub_methods_class_gr_context___base"><td class="memItemLeft" align="right" valign="top"><a id="ad0c062c6edd33d09da10e0d12947b93e"></a>
const GrBaseContextPriv&#160;</td><td class="memItemRight" valign="bottom"><b>priv</b> () const</td></tr>
<tr class="separator:ad0c062c6edd33d09da10e0d12947b93e inherit pub_methods_class_gr_context___base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_sk_ref_cnt_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_sk_ref_cnt_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_sk_ref_cnt_base.html">SkRefCntBase</a></td></tr>
<tr class="memitem:a5a774880256081e9e5cf33c8cf7ea9bc inherit pub_methods_class_sk_ref_cnt_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_ref_cnt_base.html#a5a774880256081e9e5cf33c8cf7ea9bc">SkRefCntBase</a> ()</td></tr>
<tr class="separator:a5a774880256081e9e5cf33c8cf7ea9bc inherit pub_methods_class_sk_ref_cnt_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0afdb3774d0e065874ecb0d0a288b83 inherit pub_methods_class_sk_ref_cnt_base"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_ref_cnt_base.html#ad0afdb3774d0e065874ecb0d0a288b83">~SkRefCntBase</a> ()</td></tr>
<tr class="separator:ad0afdb3774d0e065874ecb0d0a288b83 inherit pub_methods_class_sk_ref_cnt_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae058eee2ac4793db6bd663e59a235ce7 inherit pub_methods_class_sk_ref_cnt_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_ref_cnt_base.html#ae058eee2ac4793db6bd663e59a235ce7">unique</a> () const</td></tr>
<tr class="separator:ae058eee2ac4793db6bd663e59a235ce7 inherit pub_methods_class_sk_ref_cnt_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbd318b36c9e232c70488254e1f5e67 inherit pub_methods_class_sk_ref_cnt_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_ref_cnt_base.html#abbbd318b36c9e232c70488254e1f5e67">ref</a> () const</td></tr>
<tr class="separator:abbbd318b36c9e232c70488254e1f5e67 inherit pub_methods_class_sk_ref_cnt_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed65f99f91ef48a7892fafe4829d2f1 inherit pub_methods_class_sk_ref_cnt_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_ref_cnt_base.html#afed65f99f91ef48a7892fafe4829d2f1">unref</a> () const</td></tr>
<tr class="separator:afed65f99f91ef48a7892fafe4829d2f1 inherit pub_methods_class_sk_ref_cnt_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a85db11cd8ef1990bd556519f7141b578"><td class="memItemLeft" align="right" valign="top"><a id="a85db11cd8ef1990bd556519f7141b578"></a>
static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_gr_direct_context.html">GrDirectContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MakeMock</b> (const <a class="el" href="struct_gr_mock_options.html">GrMockOptions</a> *, const <a class="el" href="struct_gr_context_options.html">GrContextOptions</a> &amp;)</td></tr>
<tr class="separator:a85db11cd8ef1990bd556519f7141b578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec3fc35ff3ade9c9b204b2854f78459"><td class="memItemLeft" align="right" valign="top"><a id="aaec3fc35ff3ade9c9b204b2854f78459"></a>
static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_gr_direct_context.html">GrDirectContext</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MakeMock</b> (const <a class="el" href="struct_gr_mock_options.html">GrMockOptions</a> *)</td></tr>
<tr class="separator:aaec3fc35ff3ade9c9b204b2854f78459"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5b129026cae0551b3e3ed8271de82cc7"><td class="memItemLeft" align="right" valign="top"><a id="a5b129026cae0551b3e3ed8271de82cc7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GrDirectContext</b> (GrBackendApi backend, const <a class="el" href="struct_gr_context_options.html">GrContextOptions</a> &amp;options)</td></tr>
<tr class="separator:a5b129026cae0551b3e3ed8271de82cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f9af3c32aecfe7313a94e25eff6596"><td class="memItemLeft" align="right" valign="top"><a id="ac4f9af3c32aecfe7313a94e25eff6596"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> () override</td></tr>
<tr class="separator:ac4f9af3c32aecfe7313a94e25eff6596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c14ea4ebf560dc68b961cc4ccacd5b3"><td class="memItemLeft" align="right" valign="top"><a id="a2c14ea4ebf560dc68b961cc4ccacd5b3"></a>
GrAtlasManager *&#160;</td><td class="memItemRight" valign="bottom"><b>onGetAtlasManager</b> ()</td></tr>
<tr class="separator:a2c14ea4ebf560dc68b961cc4ccacd5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4217add97746bc67a43af937a4154f5"><td class="memItemLeft" align="right" valign="top"><a id="ab4217add97746bc67a43af937a4154f5"></a>
skgpu::v1::SmallPathAtlasMgr *&#160;</td><td class="memItemRight" valign="bottom"><b>onGetSmallPathAtlasMgr</b> ()</td></tr>
<tr class="separator:ab4217add97746bc67a43af937a4154f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f4f5d9acefdd3b2efffd62d5c56d89b"><td class="memItemLeft" align="right" valign="top"><a id="a0f4f5d9acefdd3b2efffd62d5c56d89b"></a>
<a class="el" href="class_gr_direct_context.html">GrDirectContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>asDirectContext</b> () override</td></tr>
<tr class="separator:a0f4f5d9acefdd3b2efffd62d5c56d89b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_gr_recording_context"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_gr_recording_context')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_gr_recording_context.html">GrRecordingContext</a></td></tr>
<tr class="memitem:a61df88ab0c0f9420e6e412cb46b5b50f inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="a61df88ab0c0f9420e6e412cb46b5b50f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GrRecordingContext</b> (<a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_gr_context_thread_safe_proxy.html">GrContextThreadSafeProxy</a> &gt;, bool ddlRecording)</td></tr>
<tr class="separator:a61df88ab0c0f9420e6e412cb46b5b50f inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f11e04176c850b3d81dcbea4526e32 inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="a67f11e04176c850b3d81dcbea4526e32"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> () override</td></tr>
<tr class="separator:a67f11e04176c850b3d81dcbea4526e32 inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57b6e54ad54ac57203427244048234e inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="af57b6e54ad54ac57203427244048234e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>abandonContext</b> () override</td></tr>
<tr class="separator:af57b6e54ad54ac57203427244048234e inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b2b8b6e59c311549f3fb01311b6185 inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="ac1b2b8b6e59c311549f3fb01311b6185"></a>
GrDrawingManager *&#160;</td><td class="memItemRight" valign="bottom"><b>drawingManager</b> ()</td></tr>
<tr class="separator:ac1b2b8b6e59c311549f3fb01311b6185 inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09211ed868bf579abeef02e60a8e5d2 inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="ad09211ed868bf579abeef02e60a8e5d2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>destroyDrawingManager</b> ()</td></tr>
<tr class="separator:ad09211ed868bf579abeef02e60a8e5d2 inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06aae97ff41f673fe49b256f4676835a inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="a06aae97ff41f673fe49b256f4676835a"></a>
<a class="el" href="class_gr_recording_context_1_1_arenas.html">Arenas</a>&#160;</td><td class="memItemRight" valign="bottom"><b>arenas</b> ()</td></tr>
<tr class="separator:a06aae97ff41f673fe49b256f4676835a inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc3d185e37918b0c43640b095d13dad inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="a4bc3d185e37918b0c43640b095d13dad"></a>
<a class="el" href="class_gr_recording_context_1_1_owned_arenas.html">OwnedArenas</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><b>detachArenas</b> ()</td></tr>
<tr class="separator:a4bc3d185e37918b0c43640b095d13dad inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ece0ae6dfc46dee06a0c47d8164031 inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="a82ece0ae6dfc46dee06a0c47d8164031"></a>
GrProxyProvider *&#160;</td><td class="memItemRight" valign="bottom"><b>proxyProvider</b> ()</td></tr>
<tr class="separator:a82ece0ae6dfc46dee06a0c47d8164031 inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbca07b39859c379210b5113871a3a5 inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="aedbca07b39859c379210b5113871a3a5"></a>
const GrProxyProvider *&#160;</td><td class="memItemRight" valign="bottom"><b>proxyProvider</b> () const</td></tr>
<tr class="separator:aedbca07b39859c379210b5113871a3a5 inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78646cad9c8f93800850a98757925bb7 inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="a78646cad9c8f93800850a98757925bb7"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>recordProgramInfo</b> (const GrProgramInfo *)</td></tr>
<tr class="separator:a78646cad9c8f93800850a98757925bb7 inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c060840f6cc9b443fc7d95eb022377 inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="ac1c060840f6cc9b443fc7d95eb022377"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>detachProgramData</b> (<a class="el" href="class_sk_t_array.html">SkTArray</a>&lt; <a class="el" href="struct_gr_recording_context_1_1_program_data.html">ProgramData</a> &gt; *)</td></tr>
<tr class="separator:ac1c060840f6cc9b443fc7d95eb022377 inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187a3053fe16662561e3801a37f92433 inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="a187a3053fe16662561e3801a37f92433"></a>
GrTextBlobCache *&#160;</td><td class="memItemRight" valign="bottom"><b>getTextBlobCache</b> ()</td></tr>
<tr class="separator:a187a3053fe16662561e3801a37f92433 inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe72301cb0cab1ed9139b626231d7df inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="a9fe72301cb0cab1ed9139b626231d7df"></a>
const GrTextBlobCache *&#160;</td><td class="memItemRight" valign="bottom"><b>getTextBlobCache</b> () const</td></tr>
<tr class="separator:a9fe72301cb0cab1ed9139b626231d7df inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdca0c2eeb7d86369d4f7dc7d58d7569 inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="afdca0c2eeb7d86369d4f7dc7d58d7569"></a>
GrThreadSafeCache *&#160;</td><td class="memItemRight" valign="bottom"><b>threadSafeCache</b> ()</td></tr>
<tr class="separator:afdca0c2eeb7d86369d4f7dc7d58d7569 inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6248ba0ae5aea884b66d5b6bfc44789f inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="a6248ba0ae5aea884b66d5b6bfc44789f"></a>
const GrThreadSafeCache *&#160;</td><td class="memItemRight" valign="bottom"><b>threadSafeCache</b> () const</td></tr>
<tr class="separator:a6248ba0ae5aea884b66d5b6bfc44789f inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62613ce00190ff605a9a2bbc57775650 inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_recording_context.html#a62613ce00190ff605a9a2bbc57775650">addOnFlushCallbackObject</a> (GrOnFlushCallbackObject *)</td></tr>
<tr class="separator:a62613ce00190ff605a9a2bbc57775650 inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4671d6fb38b52515c3bd837aa035bdf inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="ae4671d6fb38b52515c3bd837aa035bdf"></a>
<a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>asRecordingContext</b> () override</td></tr>
<tr class="separator:ae4671d6fb38b52515c3bd837aa035bdf inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ef147d2844ff1be29ac4b783d725c19 inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="a6ef147d2844ff1be29ac4b783d725c19"></a>
<a class="el" href="class_gr_recording_context_1_1_stats.html">Stats</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>stats</b> ()</td></tr>
<tr class="separator:a6ef147d2844ff1be29ac4b783d725c19 inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bea517ec0dd9062d1d7ef902daa82f inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="ab9bea517ec0dd9062d1d7ef902daa82f"></a>
const <a class="el" href="class_gr_recording_context_1_1_stats.html">Stats</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>stats</b> () const</td></tr>
<tr class="separator:ab9bea517ec0dd9062d1d7ef902daa82f inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a163441ecca29f9156d0df856a85cd38b inherit pro_methods_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="a163441ecca29f9156d0df856a85cd38b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpJSON</b> (<a class="el" href="class_sk_j_s_o_n_writer.html">SkJSONWriter</a> *) const</td></tr>
<tr class="separator:a163441ecca29f9156d0df856a85cd38b inherit pro_methods_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_gr_image_context"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_gr_image_context')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_gr_image_context.html">GrImageContext</a></td></tr>
<tr class="memitem:a87329cfa16717e398f28e7551b935050 inherit pro_methods_class_gr_image_context"><td class="memItemLeft" align="right" valign="top"><a id="a87329cfa16717e398f28e7551b935050"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GrImageContext</b> (<a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_gr_context_thread_safe_proxy.html">GrContextThreadSafeProxy</a> &gt;)</td></tr>
<tr class="separator:a87329cfa16717e398f28e7551b935050 inherit pro_methods_class_gr_image_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69ef3502b382772752695d9503c1f7a inherit pro_methods_class_gr_image_context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_gr_single_owner.html">GrSingleOwner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_image_context.html#ae69ef3502b382772752695d9503c1f7a">singleOwner</a> () const</td></tr>
<tr class="separator:ae69ef3502b382772752695d9503c1f7a inherit pro_methods_class_gr_image_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86cf20ab726ec4d4090736045b0c9fa inherit pro_methods_class_gr_image_context"><td class="memItemLeft" align="right" valign="top"><a id="ac86cf20ab726ec4d4090736045b0c9fa"></a>
<a class="el" href="class_gr_image_context.html">GrImageContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>asImageContext</b> () override</td></tr>
<tr class="separator:ac86cf20ab726ec4d4090736045b0c9fa inherit pro_methods_class_gr_image_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_gr_context___base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_gr_context___base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_gr_context___base.html">GrContext_Base</a></td></tr>
<tr class="memitem:a58a3e27b53b9c705d72c263a96a3b01c inherit pro_methods_class_gr_context___base"><td class="memItemLeft" align="right" valign="top"><a id="a58a3e27b53b9c705d72c263a96a3b01c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>GrContext_Base</b> (<a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_gr_context_thread_safe_proxy.html">GrContextThreadSafeProxy</a> &gt;)</td></tr>
<tr class="separator:a58a3e27b53b9c705d72c263a96a3b01c inherit pro_methods_class_gr_context___base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f8bbca0b061a92f17c88922d513148 inherit pro_methods_class_gr_context___base"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_gr_context___base.html#a21f8bbca0b061a92f17c88922d513148">contextID</a> () const</td></tr>
<tr class="separator:a21f8bbca0b061a92f17c88922d513148 inherit pro_methods_class_gr_context___base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7683085984449cfd849bb5d30d2c97f0 inherit pro_methods_class_gr_context___base"><td class="memItemLeft" align="right" valign="top"><a id="a7683085984449cfd849bb5d30d2c97f0"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>matches</b> (<a class="el" href="class_gr_context___base.html">GrContext_Base</a> *candidate) const</td></tr>
<tr class="separator:a7683085984449cfd849bb5d30d2c97f0 inherit pro_methods_class_gr_context___base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68132279ca2b5c803667d4b561d52f0 inherit pro_methods_class_gr_context___base"><td class="memItemLeft" align="right" valign="top"><a id="ab68132279ca2b5c803667d4b561d52f0"></a>
const <a class="el" href="struct_gr_context_options.html">GrContextOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>options</b> () const</td></tr>
<tr class="separator:ab68132279ca2b5c803667d4b561d52f0 inherit pro_methods_class_gr_context___base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465d9ec21a478fe613f285198ea9d5f5 inherit pro_methods_class_gr_context___base"><td class="memItemLeft" align="right" valign="top"><a id="a465d9ec21a478fe613f285198ea9d5f5"></a>
const GrCaps *&#160;</td><td class="memItemRight" valign="bottom"><b>caps</b> () const</td></tr>
<tr class="separator:a465d9ec21a478fe613f285198ea9d5f5 inherit pro_methods_class_gr_context___base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcae3799049d99e91f19e32a5eced50 inherit pro_methods_class_gr_context___base"><td class="memItemLeft" align="right" valign="top"><a id="a2bcae3799049d99e91f19e32a5eced50"></a>
<a class="el" href="classsk__sp.html">sk_sp</a>&lt; const GrCaps &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>refCaps</b> () const</td></tr>
<tr class="separator:a2bcae3799049d99e91f19e32a5eced50 inherit pro_methods_class_gr_context___base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a016f4a23a99255494f8d2a1a578fc687"><td class="memItemLeft" align="right" valign="top"><a id="a016f4a23a99255494f8d2a1a578fc687"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>GrDirectContextPriv</b></td></tr>
<tr class="separator:a016f4a23a99255494f8d2a1a578fc687"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_class_gr_recording_context"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_gr_recording_context')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_gr_recording_context.html">GrRecordingContext</a></td></tr>
<tr class="memitem:a524ffdfecf579c7aac78a2852c097689 inherit pro_attribs_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="a524ffdfecf579c7aac78a2852c097689"></a>
class <a class="el" href="class_gr_recording_context_1_1_stats.html">GrRecordingContext::Stats</a>&#160;</td><td class="memItemRight" valign="bottom"><b>fStats</b></td></tr>
<tr class="separator:a524ffdfecf579c7aac78a2852c097689 inherit pro_attribs_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ad47a611d33a1961022d185412ab6e inherit pro_attribs_class_gr_recording_context"><td class="memItemLeft" align="right" valign="top"><a id="af0ad47a611d33a1961022d185412ab6e"></a>
std::unique_ptr&lt; GrAuditTrail &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>fAuditTrail</b></td></tr>
<tr class="separator:af0ad47a611d33a1961022d185412ab6e inherit pro_attribs_class_gr_recording_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_gr_context___base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_gr_context___base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_gr_context___base.html">GrContext_Base</a></td></tr>
<tr class="memitem:aab2e23da87122f92dd85af3a74c9d6fa inherit pro_attribs_class_gr_context___base"><td class="memItemLeft" align="right" valign="top"><a id="aab2e23da87122f92dd85af3a74c9d6fa"></a>
<a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_gr_context_thread_safe_proxy.html">GrContextThreadSafeProxy</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>fThreadSafeProxy</b></td></tr>
<tr class="separator:aab2e23da87122f92dd85af3a74c9d6fa inherit pro_attribs_class_gr_context___base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aeb90c9ad9c8f849f8c09ce965f570a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb90c9ad9c8f849f8c09ce965f570a3d">&#9670;&nbsp;</a></span>abandonContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GrDirectContext::abandonContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Abandons all GPU resources and assumes the underlying backend 3D API context is no longer usable. Call this if you have lost the associated GPU context, and thus internal texture, buffer, etc. references/IDs are now invalid. Calling this ensures that the destructors of the context and any of its created resource objects will not make backend 3D API calls. Content rendered but not previously flushed may be lost. After this function is called all subsequent calls on the context will fail or be no-ops.</p>
<p>The typical use case for this function is that the underlying 3D context was lost and further API calls may crash.</p>
<p>For Vulkan, even if the device becomes lost, the VkQueue, VkDevice, or VkInstance used to create the context must be kept alive even after abandoning the context. Those objects must live for the lifetime of the context object itself. The reason for this is so that we can continue to delete any outstanding GrBackendTextures/RenderTargets which must be cleaned up even in a device lost state. </p>

<p>Reimplemented from <a class="el" href="class_gr_image_context.html">GrImageContext</a>.</p>

</div>
</div>
<a id="a5c1c5c644a82f21ce2af991b4f451348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1c5c644a82f21ce2af991b4f451348">&#9670;&nbsp;</a></span>abandoned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GrDirectContext::abandoned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the context was abandoned or if the if the backend specific context has gotten into an unrecoverarble, lost state (e.g. in Vulkan backend if we've gotten a VK_ERROR_DEVICE_LOST). If the backend context is lost, this call will also abandon this context. </p>

<p>Reimplemented from <a class="el" href="class_gr_image_context.html">GrImageContext</a>.</p>

</div>
</div>
<a id="a347baddc1feca01526524c6cabdd3c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a347baddc1feca01526524c6cabdd3c84">&#9670;&nbsp;</a></span>checkAsyncWorkCompletion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GrDirectContext::checkAsyncWorkCompletion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks whether any asynchronous work is complete and if so calls related callbacks. </p>

</div>
</div>
<a id="afe5137fe6551394acee186d6be5631d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe5137fe6551394acee186d6be5631d1">&#9670;&nbsp;</a></span>colorTypeSupportedAsImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SK_API bool GrRecordingContext::colorTypeSupportedAsImage</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Can a <a class="el" href="class_sk_image.html">SkImage</a> be created with the given color type. </p>

</div>
</div>
<a id="a2d321e29a1ba933f0e6e538e8095e553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d321e29a1ba933f0e6e538e8095e553">&#9670;&nbsp;</a></span>colorTypeSupportedAsSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SK_API bool GrRecordingContext::colorTypeSupportedAsSurface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Can a <a class="el" href="class_sk_surface.html">SkSurface</a> be created with the given color type. To check whether MSAA is supported use <a class="el" href="class_gr_recording_context.html#a8421a291fdc2d1d5072d182eee34661f">maxSurfaceSampleCountForColorType()</a>. </p>

</div>
</div>
<a id="af3e96b31af4b591cd147ebba07920ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e96b31af4b591cd147ebba07920ed3">&#9670;&nbsp;</a></span>createBackendTexture() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> GrDirectContext::createBackendTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> &amp;&#160;</td>
          <td class="paramname"><em>srcData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrSurfaceOrigin&#160;</td>
          <td class="paramname"><em>textureOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrRenderable&#160;</td>
          <td class="paramname"><em>renderable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrProtected&#160;</td>
          <td class="paramname"><em>isProtected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedProc&#160;</td>
          <td class="paramname"><em>finishedProc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedContext&#160;</td>
          <td class="paramname"><em>finishedContext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience version <a class="el" href="class_gr_direct_context.html#a87af0af0e7ed940e4940e132b980aae3">createBackendTexture()</a> that takes just a base level pixmap. </p>

</div>
</div>
<a id="af151abc92b45bdc74b99471a33e2dd24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af151abc92b45bdc74b99471a33e2dd24">&#9670;&nbsp;</a></span>createBackendTexture() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> GrDirectContext::createBackendTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_pixmap.html">SkPixmap</a>&#160;</td>
          <td class="paramname"><em>srcData</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrSurfaceOrigin&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrRenderable&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrProtected&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedProc&#160;</td>
          <td class="paramname"><em>finishedProc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedContext&#160;</td>
          <td class="paramname"><em>finishedContext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If possible, create a backend texture initialized with the provided pixmap data. The client should ensure that the returned backend texture is valid. The client can pass in a finishedProc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call <code>submit</code> to send the upload work to the gpu. The finishedProc will always get called even if we failed to create the <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>. If successful, the created backend texture will be compatible with the provided pixmap(s). Compatible, in this case, means that the backend format will be the result of calling defaultBackendFormat on the base pixmap's colortype. The src data can be deleted when this call returns. If numLevels is 1 a non-mipMapped texture will result. If a mipMapped texture is desired the data for all the mipmap levels must be provided. In the mipmapped case all the colortypes of the provided pixmaps must be the same. Additionally, all the miplevels must be sized correctly (please see SkMipmap::ComputeLevelSize and ComputeLevelCount). The GrSurfaceOrigin controls whether the pixmap data is vertically flipped in the texture. Note: the pixmap's alphatypes and colorspaces are ignored. For the Vulkan backend the layout of the created VkImage will be: VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL </p>

</div>
</div>
<a id="a60567ade1eab2d44db3a79a76d27b79b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60567ade1eab2d44db3a79a76d27b79b">&#9670;&nbsp;</a></span>createBackendTexture() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> GrDirectContext::createBackendTexture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_format.html">GrBackendFormat</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrMipmapped&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrRenderable&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrProtected&#160;</td>
          <td class="paramname"> = <code>GrProtected::kNo</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedProc&#160;</td>
          <td class="paramname"><em>finishedProc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedContext&#160;</td>
          <td class="paramname"><em>finishedContext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If possible, create a backend texture initialized to a particular color. The client should ensure that the returned backend texture is valid. The client can pass in a finishedProc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call <code>submit</code> to send the upload work to the gpu. The finishedProc will always get called even if we failed to create the <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>. For the Vulkan backend the layout of the created VkImage will be: VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL </p>

</div>
</div>
<a id="a87af0af0e7ed940e4940e132b980aae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87af0af0e7ed940e4940e132b980aae3">&#9670;&nbsp;</a></span>createBackendTexture() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> GrDirectContext::createBackendTexture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_format.html">GrBackendFormat</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrMipmapped&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrRenderable&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrProtected&#160;</td>
          <td class="paramname"> = <code>GrProtected::kNo</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The explicitly allocated backend texture API allows clients to use Skia to create backend objects outside of Skia proper (i.e., Skia's caching system will not know about them.)</p>
<p>It is the client's responsibility to delete all these objects (using deleteBackendTexture) before deleting the context used to create them. If the backend is Vulkan, the textures must be deleted before abandoning the context as well. Additionally, clients should only delete these objects on the thread for which that context is active.</p>
<p>The client is responsible for ensuring synchronization between different uses of the backend object (i.e., wrapping it in a surface, rendering to it, deleting the surface, rewrapping it in a image and drawing the image will require explicit synchronization on the client's part). If possible, create an uninitialized backend texture. The client should ensure that the returned backend texture is valid. For the Vulkan backend the layout of the created VkImage will be: VK_IMAGE_LAYOUT_UNDEFINED. </p>

</div>
</div>
<a id="a62f84fdee1cb5b34426002134f6e17c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f84fdee1cb5b34426002134f6e17c9">&#9670;&nbsp;</a></span>createBackendTexture() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> GrDirectContext::createBackendTexture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkColorType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrMipmapped&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrRenderable&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrProtected&#160;</td>
          <td class="paramname"> = <code>GrProtected::kNo</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedProc&#160;</td>
          <td class="paramname"><em>finishedProc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedContext&#160;</td>
          <td class="paramname"><em>finishedContext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If possible, create a backend texture initialized to a particular color. The client should ensure that the returned backend texture is valid. The client can pass in a finishedProc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call <code>submit</code> to send the upload work to the gpu. The finishedProc will always get called even if we failed to create the <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>. If successful, the created backend texture will be compatible with the provided SkColorType. For the Vulkan backend the layout of the created VkImage will be: VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL </p>

</div>
</div>
<a id="a334dcc3239840aeec75f3322ae1987d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a334dcc3239840aeec75f3322ae1987d7">&#9670;&nbsp;</a></span>createBackendTexture() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> GrDirectContext::createBackendTexture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkColorType&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrMipmapped&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrRenderable&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrProtected&#160;</td>
          <td class="paramname"> = <code>GrProtected::kNo</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If possible, create an uninitialized backend texture. The client should ensure that the returned backend texture is valid. If successful, the created backend texture will be compatible with the provided SkColorType. For the Vulkan backend the layout of the created VkImage will be: VK_IMAGE_LAYOUT_UNDEFINED. </p>

</div>
</div>
<a id="a12afd59a71e0c36d85259cf800a0f819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12afd59a71e0c36d85259cf800a0f819">&#9670;&nbsp;</a></span>createCompressedBackendTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> GrDirectContext::createCompressedBackendTexture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_format.html">GrBackendFormat</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrMipmapped&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrProtected&#160;</td>
          <td class="paramname"> = <code>GrProtected::kNo</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedProc&#160;</td>
          <td class="paramname"><em>finishedProc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedContext&#160;</td>
          <td class="paramname"><em>finishedContext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If possible, create a compressed backend texture initialized to a particular color. The client should ensure that the returned backend texture is valid. The client can pass in a finishedProc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call <code>submit</code> to send the upload work to the gpu. The finishedProc will always get called even if we failed to create the <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>. For the Vulkan backend the layout of the created VkImage will be: VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL </p>

</div>
</div>
<a id="aa195f3bbf2c0baf8222cb1bdd40e9cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa195f3bbf2c0baf8222cb1bdd40e9cd3">&#9670;&nbsp;</a></span>createCompressedBackendTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> GrDirectContext::createCompressedBackendTexture </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_format.html">GrBackendFormat</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrMipmapped&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrProtected&#160;</td>
          <td class="paramname"> = <code>GrProtected::kNo</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedProc&#160;</td>
          <td class="paramname"><em>finishedProc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedContext&#160;</td>
          <td class="paramname"><em>finishedContext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If possible, create a backend texture initialized with the provided raw data. The client should ensure that the returned backend texture is valid. The client can pass in a finishedProc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call <code>submit</code> to send the upload work to the gpu. The finishedProc will always get called even if we failed to create the <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> If numLevels is 1 a non-mipMapped texture will result. If a mipMapped texture is desired the data for all the mipmap levels must be provided. Additionally, all the miplevels must be sized correctly (please see SkMipmap::ComputeLevelSize and ComputeLevelCount). For the Vulkan backend the layout of the created VkImage will be: VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL </p>

</div>
</div>
<a id="a511bc7524a6d21ac973b2b17ed6cc429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511bc7524a6d21ac973b2b17ed6cc429">&#9670;&nbsp;</a></span>defaultBackendFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SK_API <a class="el" href="class_gr_backend_format.html">GrBackendFormat</a> GrRecordingContext::defaultBackendFormat</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieve the default <a class="el" href="class_gr_backend_format.html">GrBackendFormat</a> for a given SkColorType and renderability. It is guaranteed that this backend format will be the one used by the following SkColorType and SkSurfaceCharacterization-based createBackendTexture methods.</p>
<p>The caller should check that the returned format is valid. </p>

</div>
</div>
<a id="ac03201b03a0d733d1a0af6a2775cdb00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03201b03a0d733d1a0af6a2775cdb00">&#9670;&nbsp;</a></span>dumpMemoryStatistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GrDirectContext::dumpMemoryStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_trace_memory_dump.html">SkTraceMemoryDump</a> *&#160;</td>
          <td class="paramname"><em>traceMemoryDump</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumerates all cached GPU resources and dumps their memory to traceMemoryDump. </p>

</div>
</div>
<a id="a953f6ace921cd53e1333624c7770db54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953f6ace921cd53e1333624c7770db54">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GrSemaphoresSubmitted GrDirectContext::flush </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call to ensure all drawing to the context has been flushed to underlying 3D API specific objects. A call to <code>submit</code> is always required to ensure work is actually sent to the gpu. Some specific API details: GL: Commands are actually sent to the driver, but glFlush is never called. Thus some sync objects from the flush will not be valid until a submission occurs.</p>
<p>Vulkan/Metal/D3D/Dawn: Commands are recorded to the backend APIs corresponding command buffer or encoder objects. However, these objects are not sent to the gpu until a submission occurs.</p>
<p>If the return is GrSemaphoresSubmitted::kYes, only initialized GrBackendSemaphores will be submitted to the gpu during the next submit call (it is possible Skia failed to create a subset of the semaphores). The client should not wait on these semaphores until after submit has been called, and must keep them alive until then. If this call returns GrSemaphoresSubmitted::kNo, the GPU backend will not submit any semaphores to be signaled on the GPU. Thus the client should not have the GPU wait on any of the semaphores passed in with the <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a>. Regardless of whether semaphores were submitted to the GPU or not, the client is still responsible for deleting any initialized semaphores. Regardleess of semaphore submission the context will still be flushed. It should be emphasized that a return value of GrSemaphoresSubmitted::kNo does not mean the flush did not happen. It simply means there were no semaphores submitted to the GPU. A caller should only take this as a failure if they passed in semaphores to be submitted. </p>

</div>
</div>
<a id="a5e068da6db37707ee353abedc584ef6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e068da6db37707ee353abedc584ef6f">&#9670;&nbsp;</a></span>flushAndSubmit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void GrDirectContext::flushAndSubmit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>syncCpu</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call to ensure all drawing to the context has been flushed and submitted to the underlying 3D API. This is equivalent to calling GrContext::flush with a default <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a> followed by GrContext::submit(syncCpu). </p>

</div>
</div>
<a id="a3ef10709e240b76201c4ca5a26932890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef10709e240b76201c4ca5a26932890">&#9670;&nbsp;</a></span>freeGpuResources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GrDirectContext::freeGpuResources </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees GPU created by the context. Can be called to reduce GPU memory pressure. </p>

</div>
</div>
<a id="a41b00959f2ef26e2c1ac2a7b56e666dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b00959f2ef26e2c1ac2a7b56e666dc">&#9670;&nbsp;</a></span>getResourceCacheLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GrDirectContext::getResourceCacheLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the current GPU resource cache limit in bytes. </p>

</div>
</div>
<a id="ac20d13cd13b25b1aacf12454da4a0af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20d13cd13b25b1aacf12454da4a0af2">&#9670;&nbsp;</a></span>getResourceCacheLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GrDirectContext::getResourceCacheLimits </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>maxResources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>maxResourceBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DEPRECATED Return the current GPU resource cache limits.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxResources</td><td>If non-null, will be set to -1. </td></tr>
    <tr><td class="paramname">maxResourceBytes</td><td>If non-null, returns maximum number of bytes of video memory that can be held in the cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c49050b805e1d24c1cb2fb0266bf982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c49050b805e1d24c1cb2fb0266bf982">&#9670;&nbsp;</a></span>getResourceCachePurgeableBytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t GrDirectContext::getResourceCachePurgeableBytes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the number of bytes in the cache consumed by purgeable (e.g. unlocked) resources. </p>

</div>
</div>
<a id="abc2553f48d12afb0595f6f7920894446"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2553f48d12afb0595f6f7920894446">&#9670;&nbsp;</a></span>getResourceCacheUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GrDirectContext::getResourceCacheUsage </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>resourceCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>resourceBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current GPU resource cache usage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resourceCount</td><td>If non-null, returns the number of resources that are held in the cache. </td></tr>
    <tr><td class="paramname">maxResourceBytes</td><td>If non-null, returns the total number of bytes of video memory held in the cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa146ee57d29949b62820d89e7f32ab05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa146ee57d29949b62820d89e7f32ab05">&#9670;&nbsp;</a></span>maxRenderTargetSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SK_API int GrRecordingContext::maxRenderTargetSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the maximum supported render target size. </p>

</div>
</div>
<a id="a8421a291fdc2d1d5072d182eee34661f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8421a291fdc2d1d5072d182eee34661f">&#9670;&nbsp;</a></span>maxSurfaceSampleCountForColorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SK_API int GrRecordingContext::maxSurfaceSampleCountForColorType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the maximum supported sample count for a color type. 1 is returned if only non-MSAA rendering is supported for the color type. 0 is returned if rendering to this color type is not supported at all. </p>

</div>
</div>
<a id="af480871a350a61af8fbc0fb413f0edec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af480871a350a61af8fbc0fb413f0edec">&#9670;&nbsp;</a></span>maxTextureSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SK_API int GrRecordingContext::maxTextureSize</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the maximum supported texture size. </p>

</div>
</div>
<a id="a46cacd2825836fd0305ee183e6fd276e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46cacd2825836fd0305ee183e6fd276e">&#9670;&nbsp;</a></span>oomed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GrDirectContext::oomed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the underlying 3D API reported an out-of-memory error. If this returns true it is reset and will return false until another out-of-memory error is reported by the 3D API. If the context is abandoned then this will report false.</p>
<p>Currently this is implemented for:</p>
<p>OpenGL [ES] - Note that client calls to glGetError() may swallow GL_OUT_OF_MEMORY errors and therefore hide the error from Skia. Also, it is not advised to use this in combination with enabling GrContextOptions::fSkipGLErrorChecks. That option may prevent the context from ever checking the GL context for OOM.</p>
<p>Vulkan - Reports true if VK_ERROR_OUT_OF_HOST_MEMORY or VK_ERROR_OUT_OF_DEVICE_MEMORY has occurred. </p>

</div>
</div>
<a id="aae098633b71c877cf97965f0414f17ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae098633b71c877cf97965f0414f17ed">&#9670;&nbsp;</a></span>performDeferredCleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GrDirectContext::performDeferredCleanup </td>
          <td>(</td>
          <td class="paramtype">std::chrono::milliseconds&#160;</td>
          <td class="paramname"><em>msNotUsed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scratchResourcesOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Purge GPU resources that haven't been used in the past 'msNotUsed' milliseconds or are otherwise marked for deletion, regardless of whether the context is under budget.</p>
<p>If 'scratchResourcesOnly' is true all unlocked scratch resources older than 'msNotUsed' will be purged but the unlocked resources with persistent data will remain. If 'scratchResourcesOnly' is false then all unlocked resources older than 'msNotUsed' will be purged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msNotUsed</td><td>Only unlocked resources not used in these last milliseconds will be cleaned up. </td></tr>
    <tr><td class="paramname">scratchResourcesOnly</td><td>If true only unlocked scratch resources will be purged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a464e8f2af9609a2937d05422eaaab5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464e8f2af9609a2937d05422eaaab5f7">&#9670;&nbsp;</a></span>purgeUnlockedResources() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GrDirectContext::purgeUnlockedResources </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>scratchResourcesOnly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This entry point is intended for instances where an app has been backgrounded or suspended. If 'scratchResourcesOnly' is true all unlocked scratch resources will be purged but the unlocked resources with persistent data will remain. If 'scratchResourcesOnly' is false then all unlocked resources will be purged. In either case, after the unlocked resources are purged a separate pass will be made to ensure that resource usage is under budget (i.e., even if 'scratchResourcesOnly' is true some resources with persistent data may be purged to be under budget).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scratchResourcesOnly</td><td>If true only unlocked scratch resources will be purged prior enforcing the budget requirements. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ada9f27a269e2c41f6530cdb4ad0b4da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9f27a269e2c41f6530cdb4ad0b4da3">&#9670;&nbsp;</a></span>purgeUnlockedResources() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GrDirectContext::purgeUnlockedResources </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytesToPurge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preferScratchResources</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Purge unlocked resources from the cache until the the provided byte count has been reached or we have purged all unlocked resources. The default policy is to purge in LRU order, but can be overridden to prefer purging scratch resources (in LRU order) prior to purging other resource types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxBytesToPurge</td><td>the desired number of bytes to be purged. </td></tr>
    <tr><td class="paramname">preferScratchResources</td><td>If true scratch resources will be purged prior to other resource types. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a585c7eebabd86ec88090d8cdee2d8f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585c7eebabd86ec88090d8cdee2d8f59">&#9670;&nbsp;</a></span>releaseResourcesAndAbandonContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GrDirectContext::releaseResourcesAndAbandonContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is similar to <a class="el" href="class_gr_direct_context.html#aeb90c9ad9c8f849f8c09ce965f570a3d">abandonContext()</a> however the underlying 3D context is not yet lost and the context will cleanup all allocated resources before returning. After returning it will assume that the underlying context may no longer be valid.</p>
<p>The typical use case for this function is that the client is going to destroy the 3D context but can't guarantee that context will be destroyed first (perhaps because it may be ref'ed elsewhere by either the client or Skia objects).</p>
<p>For Vulkan, even if the device becomes lost, the VkQueue, VkDevice, or VkInstance used to create the context must be alive before calling releaseResourcesAndAbandonContext. </p>

</div>
</div>
<a id="a53c3539a51361c0483476a9efd247055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53c3539a51361c0483476a9efd247055">&#9670;&nbsp;</a></span>resetContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GrDirectContext::resetContext </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>state</em> = <code>kAll_GrBackendState</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The context normally assumes that no outsider is setting state within the underlying 3D API's context/device/whatever. This call informs the context that the state was modified and it should resend. Shouldn't be called frequently for good performance. The flag bits, state, is dependent on which backend is used by the context, either GL or D3D (possible in future). </p>

</div>
</div>
<a id="ac1f54c0e0566c134841ea94bf5f1e29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f54c0e0566c134841ea94bf5f1e29d">&#9670;&nbsp;</a></span>resetGLTextureBindings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GrDirectContext::resetGLTextureBindings </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the backend is GrBackendApi::kOpenGL, then all texture unit/target combinations for which the context has modified the bound texture will have texture id 0 bound. This does not flush the context. Calling <a class="el" href="class_gr_direct_context.html#a53c3539a51361c0483476a9efd247055">resetContext()</a> does not change the set that will be bound to texture id 0 on the next call to <a class="el" href="class_gr_direct_context.html#ac1f54c0e0566c134841ea94bf5f1e29d">resetGLTextureBindings()</a>. After this is called all unit/target combinations are considered to have unmodified bindings until the context subsequently modifies them (meaning if this is called twice in a row with no intervening context usage then the second call is a no-op.) </p>

</div>
</div>
<a id="a16bbafa0153d1b0e5e2204693b633612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bbafa0153d1b0e5e2204693b633612">&#9670;&nbsp;</a></span>setBackendTextureState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GrDirectContext::setBackendTextureState </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_surface_mutable_state.html">GrBackendSurfaceMutableState</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_gr_backend_surface_mutable_state.html">GrBackendSurfaceMutableState</a> *&#160;</td>
          <td class="paramname"><em>previousState</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedProc&#160;</td>
          <td class="paramname"><em>finishedProc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedContext&#160;</td>
          <td class="paramname"><em>finishedContext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the state of the GrBackendTexture/RenderTarget to have the passed in <a class="el" href="class_gr_backend_surface_mutable_state.html">GrBackendSurfaceMutableState</a>. All objects that wrap the backend surface (i.e. SkSurfaces and SkImages) will also be aware of this state change. This call does not submit the state change to the gpu, but requires the client to call <code>submit</code> to send it to the GPU. The work for this call is ordered linearly with all other calls that require GrContext::submit to be called (e.g updateBackendTexture and flush). If finishedProc is not null then it will be called with finishedContext after the state transition is known to have occurred on the GPU.</p>
<p>See <a class="el" href="class_gr_backend_surface_mutable_state.html">GrBackendSurfaceMutableState</a> to see what state can be set via this call.</p>
<p>If the backend API is Vulkan, the caller can set the <a class="el" href="class_gr_backend_surface_mutable_state.html">GrBackendSurfaceMutableState</a>'s VkImageLayout to VK_IMAGE_LAYOUT_UNDEFINED or queueFamilyIndex to VK_QUEUE_FAMILY_IGNORED to tell Skia to not change those respective states.</p>
<p>If previousState is not null and this returns true, then Skia will have filled in previousState to have the values of the state before this call. </p>

</div>
</div>
<a id="af972a5f50215ee314c48e5749d6259b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af972a5f50215ee314c48e5749d6259b9">&#9670;&nbsp;</a></span>setResourceCacheLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GrDirectContext::setResourceCacheLimit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxResourceBytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specify the GPU resource cache limit. If the cache currently exceeds this limit, it will be purged (LRU) to keep the cache within the limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxResourceBytes</td><td>The maximum number of bytes of video memory that can be held in the cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05e1728f5c16225c2a6e1a2eb65fa695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05e1728f5c16225c2a6e1a2eb65fa695">&#9670;&nbsp;</a></span>setResourceCacheLimits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void GrDirectContext::setResourceCacheLimits </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxResources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxResourceBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DEPRECATED Specify the GPU resource cache limits. If the current cache exceeds the maxResourceBytes limit, it will be purged (LRU) to keep the cache within the limit.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxResources</td><td>Unused. </td></tr>
    <tr><td class="paramname">maxResourceBytes</td><td>The maximum number of bytes of video memory that can be held in the cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e6391e15ee021f864a9d4fbef930732"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e6391e15ee021f864a9d4fbef930732">&#9670;&nbsp;</a></span>submit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GrDirectContext::submit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>syncCpu</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Submit outstanding work to the gpu from all previously un-submitted flushes. The return value of the submit will indicate whether or not the submission to the GPU was successful.</p>
<p>If the call returns true, all previously passed in semaphores in flush calls will have been submitted to the GPU and they can safely be waited on. The caller should wait on those semaphores or perform some other global synchronization before deleting the semaphores.</p>
<p>If it returns false, then those same semaphores will not have been submitted and we will not try to submit them again. The caller is free to delete the semaphores at any time.</p>
<p>If the syncCpu flag is true this function will return once the gpu has finished with all submitted work. </p>

</div>
</div>
<a id="a96e5681a6a452f4fe74920abe1594e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96e5681a6a452f4fe74920abe1594e55">&#9670;&nbsp;</a></span>updateBackendTexture() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GrDirectContext::updateBackendTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedProc&#160;</td>
          <td class="paramname"><em>finishedProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedContext&#160;</td>
          <td class="paramname"><em>finishedContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If possible, updates a backend texture to be filled to a particular color. The client should check the return value to see if the update was successful. The client can pass in a finishedProc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call <code>submit</code> to send the upload work to the gpu. The finishedProc will always get called even if we failed to update the <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>. For the Vulkan backend after a successful update the layout of the created VkImage will be: VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL </p>

</div>
</div>
<a id="afa88d9f58d0aab0f689115c5ce9a358a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa88d9f58d0aab0f689115c5ce9a358a">&#9670;&nbsp;</a></span>updateBackendTexture() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GrDirectContext::updateBackendTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_pixmap.html">SkPixmap</a>&#160;</td>
          <td class="paramname"><em>srcData</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numLevels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrSurfaceOrigin&#160;</td>
          <td class="paramname"> = <code>kTopLeft_GrSurfaceOrigin</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedProc&#160;</td>
          <td class="paramname"><em>finishedProc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedContext&#160;</td>
          <td class="paramname"><em>finishedContext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If possible, updates a backend texture filled with the provided pixmap data. The client should check the return value to see if the update was successful. The client can pass in a finishedProc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call <code>submit</code> to send the upload work to the gpu. The finishedProc will always get called even if we failed to create the <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>. The backend texture must be compatible with the provided pixmap(s). Compatible, in this case, means that the backend format is compatible with the base pixmap's colortype. The src data can be deleted when this call returns. If the backend texture is mip mapped, the data for all the mipmap levels must be provided. In the mipmapped case all the colortypes of the provided pixmaps must be the same. Additionally, all the miplevels must be sized correctly (please see SkMipmap::ComputeLevelSize and ComputeLevelCount). The GrSurfaceOrigin controls whether the pixmap data is vertically flipped in the texture. Note: the pixmap's alphatypes and colorspaces are ignored. For the Vulkan backend after a successful update the layout of the created VkImage will be: VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL </p>

</div>
</div>
<a id="a73536ee3f0f47e459f671f5b410b540c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73536ee3f0f47e459f671f5b410b540c">&#9670;&nbsp;</a></span>updateBackendTexture() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GrDirectContext::updateBackendTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkColorType&#160;</td>
          <td class="paramname"><em>skColorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedProc&#160;</td>
          <td class="paramname"><em>finishedProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedContext&#160;</td>
          <td class="paramname"><em>finishedContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If possible, updates a backend texture to be filled to a particular color. The data in <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> and passed in color is interpreted with respect to the passed in SkColorType. The client should check the return value to see if the update was successful. The client can pass in a finishedProc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call <code>submit</code> to send the upload work to the gpu. The finishedProc will always get called even if we failed to update the <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>. For the Vulkan backend after a successful update the layout of the created VkImage will be: VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL </p>

</div>
</div>
<a id="a9a49762726cb726ec868970d75953a3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a49762726cb726ec868970d75953a3b">&#9670;&nbsp;</a></span>updateBackendTexture() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool GrDirectContext::updateBackendTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> &amp;&#160;</td>
          <td class="paramname"><em>srcData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrSurfaceOrigin&#160;</td>
          <td class="paramname"><em>textureOrigin</em> = <code>kTopLeft_GrSurfaceOrigin</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedProc&#160;</td>
          <td class="paramname"><em>finishedProc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedContext&#160;</td>
          <td class="paramname"><em>finishedContext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience version of updateBackendTexture that takes just a base level pixmap. </p>

</div>
</div>
<a id="a079adf61ab054bec6a1c8d9a2ec397f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079adf61ab054bec6a1c8d9a2ec397f7">&#9670;&nbsp;</a></span>updateCompressedBackendTexture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GrDirectContext::updateCompressedBackendTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedProc&#160;</td>
          <td class="paramname"><em>finishedProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedContext&#160;</td>
          <td class="paramname"><em>finishedContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If possible, updates a backend texture filled with the provided color. If the texture is mipmapped, all levels of the mip chain will be updated to have the supplied color. The client should check the return value to see if the update was successful. The client can pass in a finishedProc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call <code>submit</code> to send the upload work to the gpu. The finishedProc will always get called even if we failed to create the <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>. For the Vulkan backend after a successful update the layout of the created VkImage will be: VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL </p>

</div>
</div>
<a id="aeedaf24edf8574a524dbf6f95fbe46d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeedaf24edf8574a524dbf6f95fbe46d3">&#9670;&nbsp;</a></span>updateCompressedBackendTexture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GrDirectContext::updateCompressedBackendTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedProc&#160;</td>
          <td class="paramname"><em>finishedProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrGpuFinishedContext&#160;</td>
          <td class="paramname"><em>finishedContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If possible, updates a backend texture filled with the provided raw data. The client should check the return value to see if the update was successful. The client can pass in a finishedProc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call <code>submit</code> to send the upload work to the gpu. The finishedProc will always get called even if we failed to create the <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>. If a mipMapped texture is passed in, the data for all the mipmap levels must be provided. Additionally, all the miplevels must be sized correctly (please see SkMipMap::ComputeLevelSize and ComputeLevelCount). For the Vulkan backend after a successful update the layout of the created VkImage will be: VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL </p>

</div>
</div>
<a id="ab84b361801b9493a3d19d8fd761d87fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84b361801b9493a3d19d8fd761d87fe">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool GrDirectContext::wait </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSemaphores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_semaphore.html">GrBackendSemaphore</a> *&#160;</td>
          <td class="paramname"><em>waitSemaphores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteSemaphoresAfterWait</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a list of GPU semaphores that the current GPU-backed API must wait on before executing any more commands on the GPU. If this call returns false, then the GPU back-end will not wait on any passed in semaphores, and the client will still own the semaphores, regardless of the value of deleteSemaphoresAfterWait.</p>
<p>If deleteSemaphoresAfterWait is false then Skia will not delete the semaphores. In this case it is the client's responsibility to not destroy or attempt to reuse the semaphores until it knows that Skia has finished waiting on them. This can be done by using finishedProcs on flush calls. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/include/gpu/<a class="el" href="_gr_direct_context_8h_source.html">GrDirectContext.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
