<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: SkMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_sk_matrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SkMatrix Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_sk_matrix_8h_source.html">SkMatrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SkMatrix:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_sk_matrix.png" usemap="#SkMatrix_map" alt=""/>
  <map id="SkMatrix_map" name="SkMatrix_map">
<area href="struct_sk_records_1_1_typed_matrix.html" alt="SkRecords::TypedMatrix" shape="rect" coords="0,56,149,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4540975cfa4b120d8c162b8ffa37afb5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a4540975cfa4b120d8c162b8ffa37afb5">ScaleToFit</a> { <a class="el" href="class_sk_matrix.html#a4540975cfa4b120d8c162b8ffa37afb5ac59b2679907dc2cbab030485d62aa264">kFill_ScaleToFit</a>, 
<a class="el" href="class_sk_matrix.html#a4540975cfa4b120d8c162b8ffa37afb5a18ac16f50a67ff8cb1dca0f3b2e84e59">kStart_ScaleToFit</a>, 
<a class="el" href="class_sk_matrix.html#a4540975cfa4b120d8c162b8ffa37afb5a745d481c22564f922dba446d61af718e">kCenter_ScaleToFit</a>, 
<a class="el" href="class_sk_matrix.html#a4540975cfa4b120d8c162b8ffa37afb5a62c2c8ded2e57c938b90557fbcc51dbd">kEnd_ScaleToFit</a>
 }</td></tr>
<tr class="separator:a4540975cfa4b120d8c162b8ffa37afb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af331aeddf3393681b4c506b0e597cccf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#af331aeddf3393681b4c506b0e597cccf">TypeMask</a> { <br />
&#160;&#160;<a class="el" href="class_sk_matrix.html#af331aeddf3393681b4c506b0e597cccfa5e91a98a1699bad635a86085c28230c4">kIdentity_Mask</a> = 0, 
<a class="el" href="class_sk_matrix.html#af331aeddf3393681b4c506b0e597cccfa38d182568a7ff43c5d5afb8f2d8a7e97">kTranslate_Mask</a> = 0x01, 
<a class="el" href="class_sk_matrix.html#af331aeddf3393681b4c506b0e597cccfa4f2398de1e039f04453824417c73e10f">kScale_Mask</a> = 0x02, 
<a class="el" href="class_sk_matrix.html#af331aeddf3393681b4c506b0e597cccfaa6ccabaa495e3b51f13d763b4d7d881a">kAffine_Mask</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="class_sk_matrix.html#af331aeddf3393681b4c506b0e597cccfa13db1f43d9b068b2b889cd20228988c7">kPerspective_Mask</a> = 0x08
<br />
 }</td></tr>
<tr class="separator:af331aeddf3393681b4c506b0e597cccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a46993a76460a4d2c8d20c5fe1900e9cb"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a46993a76460a4d2c8d20c5fe1900e9cb">SkMatrix</a> ()</td></tr>
<tr class="separator:a46993a76460a4d2c8d20c5fe1900e9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d962619c7bde5e6f7666a36be043ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html#af331aeddf3393681b4c506b0e597cccf">TypeMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#af4d962619c7bde5e6f7666a36be043ce">getType</a> () const</td></tr>
<tr class="separator:af4d962619c7bde5e6f7666a36be043ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af514e197c25c12087ba1b925e2d462cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#af514e197c25c12087ba1b925e2d462cc">isIdentity</a> () const</td></tr>
<tr class="separator:af514e197c25c12087ba1b925e2d462cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35426ca05523f92c9822328a01f2d8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ab35426ca05523f92c9822328a01f2d8f">isScaleTranslate</a> () const</td></tr>
<tr class="separator:ab35426ca05523f92c9822328a01f2d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5aabf2ddd38d3fc7a67e9404fb9355"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a7d5aabf2ddd38d3fc7a67e9404fb9355">isTranslate</a> () const</td></tr>
<tr class="separator:a7d5aabf2ddd38d3fc7a67e9404fb9355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853195ec94617eb8532a73bc705453e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a853195ec94617eb8532a73bc705453e7">rectStaysRect</a> () const</td></tr>
<tr class="separator:a853195ec94617eb8532a73bc705453e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad925199387a404a2dd643a1164307e7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ad925199387a404a2dd643a1164307e7b">preservesAxisAlignment</a> () const</td></tr>
<tr class="separator:ad925199387a404a2dd643a1164307e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac05bd201138194595572bbae7b87d549"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ac05bd201138194595572bbae7b87d549">hasPerspective</a> () const</td></tr>
<tr class="separator:ac05bd201138194595572bbae7b87d549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcd20c0f3c46cddc767ee5182c998200"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#adcd20c0f3c46cddc767ee5182c998200">isSimilarity</a> (SkScalar tol=SK_ScalarNearlyZero) const</td></tr>
<tr class="separator:adcd20c0f3c46cddc767ee5182c998200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae8c9c8ec2db54a087d21682134fc49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a4ae8c9c8ec2db54a087d21682134fc49">preservesRightAngles</a> (SkScalar tol=SK_ScalarNearlyZero) const</td></tr>
<tr class="separator:a4ae8c9c8ec2db54a087d21682134fc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3948022555f7667ef7bde1d358634d7"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ab3948022555f7667ef7bde1d358634d7">operator[]</a> (int index) const</td></tr>
<tr class="separator:ab3948022555f7667ef7bde1d358634d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace415bd9001d1b67899035c194aef005"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ace415bd9001d1b67899035c194aef005">get</a> (int index) const</td></tr>
<tr class="separator:ace415bd9001d1b67899035c194aef005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48183eb669dcb04202887f1a8cb18ef4"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a48183eb669dcb04202887f1a8cb18ef4">rc</a> (int r, int c) const</td></tr>
<tr class="separator:a48183eb669dcb04202887f1a8cb18ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e38c42742d41b4156214d9d49021aa7"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a8e38c42742d41b4156214d9d49021aa7">getScaleX</a> () const</td></tr>
<tr class="separator:a8e38c42742d41b4156214d9d49021aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d755c19debdb45bd6e0afcfdd21ed5"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#aa8d755c19debdb45bd6e0afcfdd21ed5">getScaleY</a> () const</td></tr>
<tr class="separator:aa8d755c19debdb45bd6e0afcfdd21ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2574de876e11bf146bba3e70946c850d"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a2574de876e11bf146bba3e70946c850d">getSkewY</a> () const</td></tr>
<tr class="separator:a2574de876e11bf146bba3e70946c850d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a721a2bc007080858e8965c5a02ee6d07"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a721a2bc007080858e8965c5a02ee6d07">getSkewX</a> () const</td></tr>
<tr class="separator:a721a2bc007080858e8965c5a02ee6d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2213f816896922952d978a05985ed37"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#af2213f816896922952d978a05985ed37">getTranslateX</a> () const</td></tr>
<tr class="separator:af2213f816896922952d978a05985ed37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b52e86c750b841cab7609389f963bf"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a44b52e86c750b841cab7609389f963bf">getTranslateY</a> () const</td></tr>
<tr class="separator:a44b52e86c750b841cab7609389f963bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcec4c0b7a12faa1fdb4ab9f180b111"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#adbcec4c0b7a12faa1fdb4ab9f180b111">getPerspX</a> () const</td></tr>
<tr class="separator:adbcec4c0b7a12faa1fdb4ab9f180b111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3557955c9f6b64bf1505f34259c63e"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a0d3557955c9f6b64bf1505f34259c63e">getPerspY</a> () const</td></tr>
<tr class="separator:a0d3557955c9f6b64bf1505f34259c63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8883b1b8a65df05103fc84b92c940c66"><td class="memItemLeft" align="right" valign="top">SkScalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a8883b1b8a65df05103fc84b92c940c66">operator[]</a> (int index)</td></tr>
<tr class="separator:a8883b1b8a65df05103fc84b92c940c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a029f43d83d7aaa4ce42e6eb679c3b4df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a029f43d83d7aaa4ce42e6eb679c3b4df">set</a> (int index, SkScalar value)</td></tr>
<tr class="separator:a029f43d83d7aaa4ce42e6eb679c3b4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa02218687e3936ebb1f2f7b6d91ff008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#aa02218687e3936ebb1f2f7b6d91ff008">setScaleX</a> (SkScalar v)</td></tr>
<tr class="separator:aa02218687e3936ebb1f2f7b6d91ff008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab935926217da50fc38d5d8b481b0d578"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ab935926217da50fc38d5d8b481b0d578">setScaleY</a> (SkScalar v)</td></tr>
<tr class="separator:ab935926217da50fc38d5d8b481b0d578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a8a44b2e3dc2bc02bb3184ef72a8f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a05a8a44b2e3dc2bc02bb3184ef72a8f0">setSkewY</a> (SkScalar v)</td></tr>
<tr class="separator:a05a8a44b2e3dc2bc02bb3184ef72a8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37ce4987ab1b220c63a15149ee731172"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a37ce4987ab1b220c63a15149ee731172">setSkewX</a> (SkScalar v)</td></tr>
<tr class="separator:a37ce4987ab1b220c63a15149ee731172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ae4fb690aa217f7108d6c6d3b1ebfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ae3ae4fb690aa217f7108d6c6d3b1ebfe">setTranslateX</a> (SkScalar v)</td></tr>
<tr class="separator:ae3ae4fb690aa217f7108d6c6d3b1ebfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a777d5779d7b2cee284498444ea590663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a777d5779d7b2cee284498444ea590663">setTranslateY</a> (SkScalar v)</td></tr>
<tr class="separator:a777d5779d7b2cee284498444ea590663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef0d22bbf1954bc498a97af455a9095"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a9ef0d22bbf1954bc498a97af455a9095">setPerspX</a> (SkScalar v)</td></tr>
<tr class="separator:a9ef0d22bbf1954bc498a97af455a9095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c4b9ef39f27ddb88c824319aa3e7a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a29c4b9ef39f27ddb88c824319aa3e7a4">setPerspY</a> (SkScalar v)</td></tr>
<tr class="separator:a29c4b9ef39f27ddb88c824319aa3e7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7f0cf9924529fbe153cd1e451dad68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a1c7f0cf9924529fbe153cd1e451dad68">setAll</a> (SkScalar scaleX, SkScalar skewX, SkScalar transX, SkScalar skewY, SkScalar scaleY, SkScalar transY, SkScalar persp0, SkScalar persp1, SkScalar persp2)</td></tr>
<tr class="separator:a1c7f0cf9924529fbe153cd1e451dad68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49a9684efff87a979f8e26607bd2932"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#aa49a9684efff87a979f8e26607bd2932">get9</a> (SkScalar <a class="el" href="structbuffer.html">buffer</a>[9]) const</td></tr>
<tr class="separator:aa49a9684efff87a979f8e26607bd2932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9609f2e7815c572c7012a2bf01931445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a9609f2e7815c572c7012a2bf01931445">set9</a> (const SkScalar <a class="el" href="structbuffer.html">buffer</a>[9])</td></tr>
<tr class="separator:a9609f2e7815c572c7012a2bf01931445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2221ac28297780a070c8fc516b9bb50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ae2221ac28297780a070c8fc516b9bb50">reset</a> ()</td></tr>
<tr class="separator:ae2221ac28297780a070c8fc516b9bb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a40483f395bad9a0ddf912b8788780a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a6a40483f395bad9a0ddf912b8788780a">setIdentity</a> ()</td></tr>
<tr class="separator:a6a40483f395bad9a0ddf912b8788780a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ecd592abc53828e16e1822f156e3e84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a5ecd592abc53828e16e1822f156e3e84">setTranslate</a> (SkScalar dx, SkScalar dy)</td></tr>
<tr class="separator:a5ecd592abc53828e16e1822f156e3e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3b75a2f6700cd7cc86609d027354fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a6c3b75a2f6700cd7cc86609d027354fa">setTranslate</a> (const <a class="el" href="struct_sk_point.html">SkVector</a> &amp;v)</td></tr>
<tr class="separator:a6c3b75a2f6700cd7cc86609d027354fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7037a86ecdfb3103f43fb2661f2d6463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a7037a86ecdfb3103f43fb2661f2d6463">setScale</a> (SkScalar sx, SkScalar sy, SkScalar px, SkScalar py)</td></tr>
<tr class="separator:a7037a86ecdfb3103f43fb2661f2d6463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee997ca4e728bb0cdc8cb90ecfed6edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#aee997ca4e728bb0cdc8cb90ecfed6edc">setScale</a> (SkScalar sx, SkScalar sy)</td></tr>
<tr class="separator:aee997ca4e728bb0cdc8cb90ecfed6edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2319c87e535a9c1f183e2b56927225"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a8c2319c87e535a9c1f183e2b56927225">setRotate</a> (SkScalar degrees, SkScalar px, SkScalar py)</td></tr>
<tr class="separator:a8c2319c87e535a9c1f183e2b56927225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39280d8756afece1a6d84093bb90e005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a39280d8756afece1a6d84093bb90e005">setRotate</a> (SkScalar degrees)</td></tr>
<tr class="separator:a39280d8756afece1a6d84093bb90e005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a33e5a90728cb3710bc30473590703"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a74a33e5a90728cb3710bc30473590703">setSinCos</a> (SkScalar sinValue, SkScalar cosValue, SkScalar px, SkScalar py)</td></tr>
<tr class="separator:a74a33e5a90728cb3710bc30473590703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad19b8a4a5bc152774ba119466d791145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ad19b8a4a5bc152774ba119466d791145">setSinCos</a> (SkScalar sinValue, SkScalar cosValue)</td></tr>
<tr class="separator:ad19b8a4a5bc152774ba119466d791145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6cbb8e012f9e7af48addfc2d9e3fab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a8e6cbb8e012f9e7af48addfc2d9e3fab">setRSXform</a> (const <a class="el" href="struct_sk_r_s_xform.html">SkRSXform</a> &amp;rsxForm)</td></tr>
<tr class="separator:a8e6cbb8e012f9e7af48addfc2d9e3fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f7d3a809ec23ab0d4b0e771807824a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ab2f7d3a809ec23ab0d4b0e771807824a">setSkew</a> (SkScalar kx, SkScalar ky, SkScalar px, SkScalar py)</td></tr>
<tr class="separator:ab2f7d3a809ec23ab0d4b0e771807824a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a7e60ba9f02c2df9e83ab7127cd9ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a11a7e60ba9f02c2df9e83ab7127cd9ba">setSkew</a> (SkScalar kx, SkScalar ky)</td></tr>
<tr class="separator:a11a7e60ba9f02c2df9e83ab7127cd9ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af825f7f6a030f1c8f5fdf659087f30c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#af825f7f6a030f1c8f5fdf659087f30c0">setConcat</a> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;a, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;b)</td></tr>
<tr class="separator:af825f7f6a030f1c8f5fdf659087f30c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1fe1ee2d65c04c8056818dcf8fa652f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#aa1fe1ee2d65c04c8056818dcf8fa652f">preTranslate</a> (SkScalar dx, SkScalar dy)</td></tr>
<tr class="separator:aa1fe1ee2d65c04c8056818dcf8fa652f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec598f5a0eedab6a62e1288269cdc29c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#aec598f5a0eedab6a62e1288269cdc29c">preScale</a> (SkScalar sx, SkScalar sy, SkScalar px, SkScalar py)</td></tr>
<tr class="separator:aec598f5a0eedab6a62e1288269cdc29c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c6e4498b849844549649242af7062e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a43c6e4498b849844549649242af7062e">preScale</a> (SkScalar sx, SkScalar sy)</td></tr>
<tr class="separator:a43c6e4498b849844549649242af7062e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39a85e39a75426fef10bc9470f7f267"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#aa39a85e39a75426fef10bc9470f7f267">preRotate</a> (SkScalar degrees, SkScalar px, SkScalar py)</td></tr>
<tr class="separator:aa39a85e39a75426fef10bc9470f7f267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c89a9aac5c02ac8b04ce90073a0a10f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a8c89a9aac5c02ac8b04ce90073a0a10f">preRotate</a> (SkScalar degrees)</td></tr>
<tr class="separator:a8c89a9aac5c02ac8b04ce90073a0a10f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b28b01ec3d91c2b3a282f9821ced6de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a1b28b01ec3d91c2b3a282f9821ced6de">preSkew</a> (SkScalar kx, SkScalar ky, SkScalar px, SkScalar py)</td></tr>
<tr class="separator:a1b28b01ec3d91c2b3a282f9821ced6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad77baa4e4ec8ff007b70c3b32c22f910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ad77baa4e4ec8ff007b70c3b32c22f910">preSkew</a> (SkScalar kx, SkScalar ky)</td></tr>
<tr class="separator:ad77baa4e4ec8ff007b70c3b32c22f910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29719999db0a4ddbd94c8de6bd71644"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#aa29719999db0a4ddbd94c8de6bd71644">preConcat</a> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;other)</td></tr>
<tr class="separator:aa29719999db0a4ddbd94c8de6bd71644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088ad7ee4bf42b4814492dcdff6f581d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a088ad7ee4bf42b4814492dcdff6f581d">postTranslate</a> (SkScalar dx, SkScalar dy)</td></tr>
<tr class="separator:a088ad7ee4bf42b4814492dcdff6f581d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e79f940534e51a82b4ef645727a4bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a25e79f940534e51a82b4ef645727a4bc">postScale</a> (SkScalar sx, SkScalar sy, SkScalar px, SkScalar py)</td></tr>
<tr class="separator:a25e79f940534e51a82b4ef645727a4bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86db02fa2ab934545bb503b1eba0f699"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a86db02fa2ab934545bb503b1eba0f699">postScale</a> (SkScalar sx, SkScalar sy)</td></tr>
<tr class="separator:a86db02fa2ab934545bb503b1eba0f699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180a6af42790bd7a6efdcc91fe7f161a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a180a6af42790bd7a6efdcc91fe7f161a">postRotate</a> (SkScalar degrees, SkScalar px, SkScalar py)</td></tr>
<tr class="separator:a180a6af42790bd7a6efdcc91fe7f161a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad38d3441ea7fb4551c8180ac15d5a61b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ad38d3441ea7fb4551c8180ac15d5a61b">postRotate</a> (SkScalar degrees)</td></tr>
<tr class="separator:ad38d3441ea7fb4551c8180ac15d5a61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75501df3ca3389c367b84eea0220b65d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a75501df3ca3389c367b84eea0220b65d">postSkew</a> (SkScalar kx, SkScalar ky, SkScalar px, SkScalar py)</td></tr>
<tr class="separator:a75501df3ca3389c367b84eea0220b65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10f8911a9c1fd58dd9ec15563acd188"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ae10f8911a9c1fd58dd9ec15563acd188">postSkew</a> (SkScalar kx, SkScalar ky)</td></tr>
<tr class="separator:ae10f8911a9c1fd58dd9ec15563acd188"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e784a41f2a257221ea87727de17c80b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a1e784a41f2a257221ea87727de17c80b">postConcat</a> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;other)</td></tr>
<tr class="separator:a1e784a41f2a257221ea87727de17c80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a47790b0eea536de853321b0fc5a32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ad1a47790b0eea536de853321b0fc5a32">setRectToRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;src, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;dst, <a class="el" href="class_sk_matrix.html#a4540975cfa4b120d8c162b8ffa37afb5">ScaleToFit</a> stf)</td></tr>
<tr class="separator:ad1a47790b0eea536de853321b0fc5a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a758cf57cf7a65c01a408125145c55531"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a758cf57cf7a65c01a408125145c55531">setPolyToPoly</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> src[], const <a class="el" href="struct_sk_point.html">SkPoint</a> dst[], int count)</td></tr>
<tr class="separator:a758cf57cf7a65c01a408125145c55531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d40915cf59dcce0f7270a4988aaf47"><td class="memItemLeft" align="right" valign="top">bool SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a85d40915cf59dcce0f7270a4988aaf47">invert</a> (<a class="el" href="class_sk_matrix.html">SkMatrix</a> *inverse) const</td></tr>
<tr class="separator:a85d40915cf59dcce0f7270a4988aaf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f54b3685f7a08fb607ef9f09ab9f44f"><td class="memItemLeft" align="right" valign="top">bool SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a4f54b3685f7a08fb607ef9f09ab9f44f">asAffine</a> (SkScalar affine[6]) const</td></tr>
<tr class="separator:a4f54b3685f7a08fb607ef9f09ab9f44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a2bf7c2d36328f3d39ae6f97905ffc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a06a2bf7c2d36328f3d39ae6f97905ffc">setAffine</a> (const SkScalar affine[6])</td></tr>
<tr class="separator:a06a2bf7c2d36328f3d39ae6f97905ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab922b7b843c9ccedb9ae825ebbeecd60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ab922b7b843c9ccedb9ae825ebbeecd60">normalizePerspective</a> ()</td></tr>
<tr class="separator:ab922b7b843c9ccedb9ae825ebbeecd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce443b90376b5d8fdedbc265ad81ab2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a5ce443b90376b5d8fdedbc265ad81ab2">mapPoints</a> (<a class="el" href="struct_sk_point.html">SkPoint</a> dst[], const <a class="el" href="struct_sk_point.html">SkPoint</a> src[], int count) const</td></tr>
<tr class="separator:a5ce443b90376b5d8fdedbc265ad81ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b0538565f49f84700f5a4ae0781eb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a65b0538565f49f84700f5a4ae0781eb3">mapPoints</a> (<a class="el" href="struct_sk_point.html">SkPoint</a> pts[], int count) const</td></tr>
<tr class="separator:a65b0538565f49f84700f5a4ae0781eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28b3fda37688ae6dec9a47bd2efa7d0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a28b3fda37688ae6dec9a47bd2efa7d0f">mapHomogeneousPoints</a> (<a class="el" href="struct_sk_point3.html">SkPoint3</a> dst[], const <a class="el" href="struct_sk_point3.html">SkPoint3</a> src[], int count) const</td></tr>
<tr class="separator:a28b3fda37688ae6dec9a47bd2efa7d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242262710c2dbf8b604fefa97461024f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a242262710c2dbf8b604fefa97461024f">mapHomogeneousPoints</a> (<a class="el" href="struct_sk_point3.html">SkPoint3</a> dst[], const <a class="el" href="struct_sk_point.html">SkPoint</a> src[], int count) const</td></tr>
<tr class="separator:a242262710c2dbf8b604fefa97461024f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545fc5d678f0c07c40636bc4cb699017"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a545fc5d678f0c07c40636bc4cb699017">mapPoint</a> (<a class="el" href="struct_sk_point.html">SkPoint</a> pt) const</td></tr>
<tr class="separator:a545fc5d678f0c07c40636bc4cb699017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f948aea7bae490af1cbecec31ec2b0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a7f948aea7bae490af1cbecec31ec2b0a">mapXY</a> (SkScalar x, SkScalar y, <a class="el" href="struct_sk_point.html">SkPoint</a> *result) const</td></tr>
<tr class="separator:a7f948aea7bae490af1cbecec31ec2b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4b9fbc2fae0a2483650f9bb29cc7907"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ac4b9fbc2fae0a2483650f9bb29cc7907">mapXY</a> (SkScalar x, SkScalar y) const</td></tr>
<tr class="separator:ac4b9fbc2fae0a2483650f9bb29cc7907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02531fdec93b91da05b4f48efb03c5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ab02531fdec93b91da05b4f48efb03c5e">mapOrigin</a> () const</td></tr>
<tr class="separator:ab02531fdec93b91da05b4f48efb03c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366bb77f6466a1579aa620a8bfc38856"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a366bb77f6466a1579aa620a8bfc38856">mapVectors</a> (<a class="el" href="struct_sk_point.html">SkVector</a> dst[], const <a class="el" href="struct_sk_point.html">SkVector</a> src[], int count) const</td></tr>
<tr class="separator:a366bb77f6466a1579aa620a8bfc38856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3973dff4c35cb72632171cd73ffe2bef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a3973dff4c35cb72632171cd73ffe2bef">mapVectors</a> (<a class="el" href="struct_sk_point.html">SkVector</a> vecs[], int count) const</td></tr>
<tr class="separator:a3973dff4c35cb72632171cd73ffe2bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af347d0de7ea1f178c1522e7ffdec38c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#af347d0de7ea1f178c1522e7ffdec38c3">mapVector</a> (SkScalar dx, SkScalar dy, <a class="el" href="struct_sk_point.html">SkVector</a> *result) const</td></tr>
<tr class="separator:af347d0de7ea1f178c1522e7ffdec38c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abafffbeeb2e2a17c2adb87170dc1ffeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_point.html">SkVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#abafffbeeb2e2a17c2adb87170dc1ffeb">mapVector</a> (SkScalar dx, SkScalar dy) const</td></tr>
<tr class="separator:abafffbeeb2e2a17c2adb87170dc1ffeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecc2a105c953e74f071c0fe7c5aadb7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#aecc2a105c953e74f071c0fe7c5aadb7b">mapRect</a> (<a class="el" href="struct_sk_rect.html">SkRect</a> *dst, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;src, SkApplyPerspectiveClip pc=SkApplyPerspectiveClip::kYes) const</td></tr>
<tr class="separator:aecc2a105c953e74f071c0fe7c5aadb7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89fa963f9e67471847853bcad689c1ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a89fa963f9e67471847853bcad689c1ec">mapRect</a> (<a class="el" href="struct_sk_rect.html">SkRect</a> *rect, SkApplyPerspectiveClip pc=SkApplyPerspectiveClip::kYes) const</td></tr>
<tr class="separator:a89fa963f9e67471847853bcad689c1ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fb36ba9d07ef5fe8f192116c95ae43"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_rect.html">SkRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#aa5fb36ba9d07ef5fe8f192116c95ae43">mapRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;src, SkApplyPerspectiveClip pc=SkApplyPerspectiveClip::kYes) const</td></tr>
<tr class="separator:aa5fb36ba9d07ef5fe8f192116c95ae43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce8e1c05bbc40ee69a376aa713542b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#afce8e1c05bbc40ee69a376aa713542b5">mapRectToQuad</a> (<a class="el" href="struct_sk_point.html">SkPoint</a> dst[4], const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect) const</td></tr>
<tr class="separator:afce8e1c05bbc40ee69a376aa713542b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa81aa5cfaa7640889a4a782bb5323c0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#aa81aa5cfaa7640889a4a782bb5323c0e">mapRectScaleTranslate</a> (<a class="el" href="struct_sk_rect.html">SkRect</a> *dst, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;src) const</td></tr>
<tr class="separator:aa81aa5cfaa7640889a4a782bb5323c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0371b96d06a6cd5129fe01ea30dd3e32"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a0371b96d06a6cd5129fe01ea30dd3e32">mapRadius</a> (SkScalar radius) const</td></tr>
<tr class="separator:a0371b96d06a6cd5129fe01ea30dd3e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bb30bef96ca2fddeb8218dcd082d22b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a4bb30bef96ca2fddeb8218dcd082d22b">dump</a> () const</td></tr>
<tr class="separator:a4bb30bef96ca2fddeb8218dcd082d22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e38de15e3b2853a21aed9faa2b80a7"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a92e38de15e3b2853a21aed9faa2b80a7">getMinScale</a> () const</td></tr>
<tr class="separator:a92e38de15e3b2853a21aed9faa2b80a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7b113497891919c5733278b1f7cf7b"><td class="memItemLeft" align="right" valign="top">SkScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#aba7b113497891919c5733278b1f7cf7b">getMaxScale</a> () const</td></tr>
<tr class="separator:aba7b113497891919c5733278b1f7cf7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22545b914379e71c85111b3864359b59"><td class="memItemLeft" align="right" valign="top">bool SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a22545b914379e71c85111b3864359b59">getMinMaxScales</a> (SkScalar scaleFactors[2]) const</td></tr>
<tr class="separator:a22545b914379e71c85111b3864359b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22e10b72b688963edb48b826775a974"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#aa22e10b72b688963edb48b826775a974">decomposeScale</a> (<a class="el" href="struct_sk_size.html">SkSize</a> *scale, <a class="el" href="class_sk_matrix.html">SkMatrix</a> *remaining=nullptr) const</td></tr>
<tr class="separator:aa22e10b72b688963edb48b826775a974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb926d0000d753339425bde36e9b73d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#afb926d0000d753339425bde36e9b73d6">dirtyMatrixTypeCache</a> ()</td></tr>
<tr class="separator:afb926d0000d753339425bde36e9b73d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48845691e564d36b175183b6f7793398"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a48845691e564d36b175183b6f7793398">setScaleTranslate</a> (SkScalar sx, SkScalar sy, SkScalar tx, SkScalar ty)</td></tr>
<tr class="separator:a48845691e564d36b175183b6f7793398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e7082b7f1d6362ff16ea2baf456dfe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ac9e7082b7f1d6362ff16ea2baf456dfe">isFinite</a> () const</td></tr>
<tr class="separator:ac9e7082b7f1d6362ff16ea2baf456dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9f5da1a67fb5c98649ba2ff4af5572fa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a9f5da1a67fb5c98649ba2ff4af5572fa">Scale</a> (SkScalar sx, SkScalar sy)</td></tr>
<tr class="separator:a9f5da1a67fb5c98649ba2ff4af5572fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67b155b025d42a116e1ee23f1a0e8eb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#af67b155b025d42a116e1ee23f1a0e8eb">Translate</a> (SkScalar dx, SkScalar dy)</td></tr>
<tr class="separator:af67b155b025d42a116e1ee23f1a0e8eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546ef56faf7cef7483de4eceeaeca418"><td class="memItemLeft" align="right" valign="top"><a id="a546ef56faf7cef7483de4eceeaeca418"></a>
static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>Translate</b> (<a class="el" href="struct_sk_point.html">SkVector</a> t)</td></tr>
<tr class="separator:a546ef56faf7cef7483de4eceeaeca418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a58c14525bde6ec0aae6a33aab3255"><td class="memItemLeft" align="right" valign="top"><a id="a32a58c14525bde6ec0aae6a33aab3255"></a>
static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>Translate</b> (<a class="el" href="struct_sk_i_point.html">SkIVector</a> t)</td></tr>
<tr class="separator:a32a58c14525bde6ec0aae6a33aab3255"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad1ef73ce5d66f779ec7d43a8cb880e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#adad1ef73ce5d66f779ec7d43a8cb880e">RotateDeg</a> (SkScalar deg)</td></tr>
<tr class="separator:adad1ef73ce5d66f779ec7d43a8cb880e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac652a6174e81986e4883863ae224e1"><td class="memItemLeft" align="right" valign="top"><a id="a7ac652a6174e81986e4883863ae224e1"></a>
static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>RotateDeg</b> (SkScalar deg, <a class="el" href="struct_sk_point.html">SkPoint</a> pt)</td></tr>
<tr class="separator:a7ac652a6174e81986e4883863ae224e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a2ae660f29268f334371cf4a6257159"><td class="memItemLeft" align="right" valign="top"><a id="a0a2ae660f29268f334371cf4a6257159"></a>
static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><b>RotateRad</b> (SkScalar rad)</td></tr>
<tr class="separator:a0a2ae660f29268f334371cf4a6257159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9af45e5c110f6da777e5eebb5b55e8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a8c9af45e5c110f6da777e5eebb5b55e8">Skew</a> (SkScalar kx, SkScalar ky)</td></tr>
<tr class="separator:a8c9af45e5c110f6da777e5eebb5b55e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5194eea4174d97931f2eafd62abcd7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a6c5194eea4174d97931f2eafd62abcd7">RectToRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;src, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;dst, <a class="el" href="class_sk_matrix.html#a4540975cfa4b120d8c162b8ffa37afb5">ScaleToFit</a> mode=<a class="el" href="class_sk_matrix.html#a4540975cfa4b120d8c162b8ffa37afb5ac59b2679907dc2cbab030485d62aa264">kFill_ScaleToFit</a>)</td></tr>
<tr class="separator:a6c5194eea4174d97931f2eafd62abcd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f682f2882d2f8fd7224994ded26e7b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ad3f682f2882d2f8fd7224994ded26e7b">MakeAll</a> (SkScalar scaleX, SkScalar skewX, SkScalar transX, SkScalar skewY, SkScalar scaleY, SkScalar transY, SkScalar pers0, SkScalar pers1, SkScalar pers2)</td></tr>
<tr class="separator:ad3f682f2882d2f8fd7224994ded26e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d9c70cc312ef92202aca2b80161166"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_sk_matrix.html">SkMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ab0d9c70cc312ef92202aca2b80161166">MakeRectToRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;src, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;dst, <a class="el" href="class_sk_matrix.html#a4540975cfa4b120d8c162b8ffa37afb5">ScaleToFit</a> stf)</td></tr>
<tr class="separator:ab0d9c70cc312ef92202aca2b80161166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8020ffbb697ca43309dc30b2e13ea2ab"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a8020ffbb697ca43309dc30b2e13ea2ab">SetAffineIdentity</a> (SkScalar affine[6])</td></tr>
<tr class="separator:a8020ffbb697ca43309dc30b2e13ea2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa097a3a1e9b15f1a083a6a807185600a"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#aa097a3a1e9b15f1a083a6a807185600a">I</a> ()</td></tr>
<tr class="separator:aa097a3a1e9b15f1a083a6a807185600a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97ff786fa9adbf09cee7e0190a8328a"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#af97ff786fa9adbf09cee7e0190a8328a">InvalidMatrix</a> ()</td></tr>
<tr class="separator:af97ff786fa9adbf09cee7e0190a8328a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6cec1ad170c54722e2912ff2023b8c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_sk_matrix.html">SkMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a6c6cec1ad170c54722e2912ff2023b8c">Concat</a> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;a, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;b)</td></tr>
<tr class="separator:a6c6cec1ad170c54722e2912ff2023b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1d8855a83368b37e2968c206a2312a2d"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a1d8855a83368b37e2968c206a2312a2d">kMScaleX</a> = 0</td></tr>
<tr class="memdesc:a1d8855a83368b37e2968c206a2312a2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">horizontal scale factor  <a href="class_sk_matrix.html#a1d8855a83368b37e2968c206a2312a2d">More...</a><br /></td></tr>
<tr class="separator:a1d8855a83368b37e2968c206a2312a2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1fd6db858b27ce37d09b1d1807bdab9"><td class="memItemLeft" align="right" valign="top"><a id="ae1fd6db858b27ce37d09b1d1807bdab9"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ae1fd6db858b27ce37d09b1d1807bdab9">kMSkewX</a> = 1</td></tr>
<tr class="memdesc:ae1fd6db858b27ce37d09b1d1807bdab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">horizontal skew factor <br /></td></tr>
<tr class="separator:ae1fd6db858b27ce37d09b1d1807bdab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac040a7d0f0451e71ffb6c5d721ff5038"><td class="memItemLeft" align="right" valign="top"><a id="ac040a7d0f0451e71ffb6c5d721ff5038"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ac040a7d0f0451e71ffb6c5d721ff5038">kMTransX</a> = 2</td></tr>
<tr class="memdesc:ac040a7d0f0451e71ffb6c5d721ff5038"><td class="mdescLeft">&#160;</td><td class="mdescRight">horizontal translation <br /></td></tr>
<tr class="separator:ac040a7d0f0451e71ffb6c5d721ff5038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac789af4ad8c477ded6513bfef1fcfeb0"><td class="memItemLeft" align="right" valign="top"><a id="ac789af4ad8c477ded6513bfef1fcfeb0"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ac789af4ad8c477ded6513bfef1fcfeb0">kMSkewY</a> = 3</td></tr>
<tr class="memdesc:ac789af4ad8c477ded6513bfef1fcfeb0"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertical skew factor <br /></td></tr>
<tr class="separator:ac789af4ad8c477ded6513bfef1fcfeb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18678bd1129b4a92b8fdb4453e7f7e1"><td class="memItemLeft" align="right" valign="top"><a id="ad18678bd1129b4a92b8fdb4453e7f7e1"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#ad18678bd1129b4a92b8fdb4453e7f7e1">kMScaleY</a> = 4</td></tr>
<tr class="memdesc:ad18678bd1129b4a92b8fdb4453e7f7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertical scale factor <br /></td></tr>
<tr class="separator:ad18678bd1129b4a92b8fdb4453e7f7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d97f70cf9c8d4c9d43c0f298b819ea7"><td class="memItemLeft" align="right" valign="top"><a id="a1d97f70cf9c8d4c9d43c0f298b819ea7"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a1d97f70cf9c8d4c9d43c0f298b819ea7">kMTransY</a> = 5</td></tr>
<tr class="memdesc:a1d97f70cf9c8d4c9d43c0f298b819ea7"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertical translation <br /></td></tr>
<tr class="separator:a1d97f70cf9c8d4c9d43c0f298b819ea7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ae8d8bd847764687d44222a2272fee"><td class="memItemLeft" align="right" valign="top"><a id="aa2ae8d8bd847764687d44222a2272fee"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#aa2ae8d8bd847764687d44222a2272fee">kMPersp0</a> = 6</td></tr>
<tr class="memdesc:aa2ae8d8bd847764687d44222a2272fee"><td class="mdescLeft">&#160;</td><td class="mdescRight">input x perspective factor <br /></td></tr>
<tr class="separator:aa2ae8d8bd847764687d44222a2272fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bfb8f276f5364ea07af32a5203fd0c"><td class="memItemLeft" align="right" valign="top"><a id="a30bfb8f276f5364ea07af32a5203fd0c"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a30bfb8f276f5364ea07af32a5203fd0c">kMPersp1</a> = 7</td></tr>
<tr class="memdesc:a30bfb8f276f5364ea07af32a5203fd0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">input y perspective factor <br /></td></tr>
<tr class="separator:a30bfb8f276f5364ea07af32a5203fd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc664193cb40ac47d840ba7188e1d88"><td class="memItemLeft" align="right" valign="top"><a id="abdc664193cb40ac47d840ba7188e1d88"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#abdc664193cb40ac47d840ba7188e1d88">kMPersp2</a> = 8</td></tr>
<tr class="memdesc:abdc664193cb40ac47d840ba7188e1d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">perspective bias <br /></td></tr>
<tr class="separator:abdc664193cb40ac47d840ba7188e1d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed7f43ec97f0063983c60c7513f7e7d"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a7ed7f43ec97f0063983c60c7513f7e7d">kAScaleX</a> = 0</td></tr>
<tr class="memdesc:a7ed7f43ec97f0063983c60c7513f7e7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">horizontal scale factor  <a href="class_sk_matrix.html#a7ed7f43ec97f0063983c60c7513f7e7d">More...</a><br /></td></tr>
<tr class="separator:a7ed7f43ec97f0063983c60c7513f7e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851c56049e76bc4ff623df06f0941319"><td class="memItemLeft" align="right" valign="top"><a id="a851c56049e76bc4ff623df06f0941319"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a851c56049e76bc4ff623df06f0941319">kASkewY</a> = 1</td></tr>
<tr class="memdesc:a851c56049e76bc4ff623df06f0941319"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertical skew factor <br /></td></tr>
<tr class="separator:a851c56049e76bc4ff623df06f0941319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266878e9c54ab20d938a2aa74785d8b3"><td class="memItemLeft" align="right" valign="top"><a id="a266878e9c54ab20d938a2aa74785d8b3"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a266878e9c54ab20d938a2aa74785d8b3">kASkewX</a> = 2</td></tr>
<tr class="memdesc:a266878e9c54ab20d938a2aa74785d8b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">horizontal skew factor <br /></td></tr>
<tr class="separator:a266878e9c54ab20d938a2aa74785d8b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f64c41c3ea33fa958e8ed653ff64afa"><td class="memItemLeft" align="right" valign="top"><a id="a1f64c41c3ea33fa958e8ed653ff64afa"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a1f64c41c3ea33fa958e8ed653ff64afa">kAScaleY</a> = 3</td></tr>
<tr class="memdesc:a1f64c41c3ea33fa958e8ed653ff64afa"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertical scale factor <br /></td></tr>
<tr class="separator:a1f64c41c3ea33fa958e8ed653ff64afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5ce591ad632c1a2e655c3378fa9756"><td class="memItemLeft" align="right" valign="top"><a id="a3a5ce591ad632c1a2e655c3378fa9756"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a3a5ce591ad632c1a2e655c3378fa9756">kATransX</a> = 4</td></tr>
<tr class="memdesc:a3a5ce591ad632c1a2e655c3378fa9756"><td class="mdescLeft">&#160;</td><td class="mdescRight">horizontal translation <br /></td></tr>
<tr class="separator:a3a5ce591ad632c1a2e655c3378fa9756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f2e2351005aee3f83b1783a27992d4"><td class="memItemLeft" align="right" valign="top"><a id="a18f2e2351005aee3f83b1783a27992d4"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a18f2e2351005aee3f83b1783a27992d4">kATransY</a> = 5</td></tr>
<tr class="memdesc:a18f2e2351005aee3f83b1783a27992d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">vertical translation <br /></td></tr>
<tr class="separator:a18f2e2351005aee3f83b1783a27992d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae61bf0dc568d9ff21a34994ed6529033"><td class="memItemLeft" align="right" valign="top"><a id="ae61bf0dc568d9ff21a34994ed6529033"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkPerspIter</b></td></tr>
<tr class="separator:ae61bf0dc568d9ff21a34994ed6529033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f5f79af0715cf6ac6d158596467e2b"><td class="memItemLeft" align="right" valign="top"><a id="aa6f5f79af0715cf6ac6d158596467e2b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkMatrixPriv</b></td></tr>
<tr class="separator:aa6f5f79af0715cf6ac6d158596467e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ded938ff6bfb82061e49f20546351b6"><td class="memItemLeft" align="right" valign="top"><a id="a3ded938ff6bfb82061e49f20546351b6"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SerializationTest</b></td></tr>
<tr class="separator:a3ded938ff6bfb82061e49f20546351b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f9c5b6475c169bd76e02da9e280eab"><td class="memItemLeft" align="right" valign="top">SK_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a75f9c5b6475c169bd76e02da9e280eab">operator==</a> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;a, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;b)</td></tr>
<tr class="separator:a75f9c5b6475c169bd76e02da9e280eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dec58ac26e24e8be89fa2ddd325aaa2"><td class="memItemLeft" align="right" valign="top">SK_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_matrix.html#a6dec58ac26e24e8be89fa2ddd325aaa2">operator!=</a> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;a, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;b)</td></tr>
<tr class="separator:a6dec58ac26e24e8be89fa2ddd325aaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9508426a926558afb465342ee3b496"><td class="memItemLeft" align="right" valign="top"><a id="aca9508426a926558afb465342ee3b496"></a>
<a class="el" href="class_sk_matrix.html">SkMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><b>operator*</b> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;a, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;b)</td></tr>
<tr class="separator:aca9508426a926558afb465342ee3b496"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_sk_matrix.html">SkMatrix</a> holds a 3x3 matrix for transforming coordinates. This allows mapping <a class="el" href="struct_sk_point.html">SkPoint</a> and vectors with translation, scaling, skewing, rotation, and perspective.</p>
<p><a class="el" href="class_sk_matrix.html">SkMatrix</a> elements are in row major order. <a class="el" href="class_sk_matrix.html">SkMatrix</a> constexpr default constructs to identity.</p>
<p><a class="el" href="class_sk_matrix.html">SkMatrix</a> includes a hidden variable that classifies the type of matrix to improve performance. <a class="el" href="class_sk_matrix.html">SkMatrix</a> is not thread safe unless <a class="el" href="class_sk_matrix.html#af4d962619c7bde5e6f7666a36be043ce">getType()</a> is called first.</p>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_063">https://fiddle.skia.org/c/@Matrix_063</a> </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a4540975cfa4b120d8c162b8ffa37afb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4540975cfa4b120d8c162b8ffa37afb5">&#9670;&nbsp;</a></span>ScaleToFit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_matrix.html#a4540975cfa4b120d8c162b8ffa37afb5">SkMatrix::ScaleToFit</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4540975cfa4b120d8c162b8ffa37afb5ac59b2679907dc2cbab030485d62aa264"></a>kFill_ScaleToFit&#160;</td><td class="fielddoc"><p>scales in x and y to fill destination <a class="el" href="struct_sk_rect.html">SkRect</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="a4540975cfa4b120d8c162b8ffa37afb5a18ac16f50a67ff8cb1dca0f3b2e84e59"></a>kStart_ScaleToFit&#160;</td><td class="fielddoc"><p>scales and aligns to left and top </p>
</td></tr>
<tr><td class="fieldname"><a id="a4540975cfa4b120d8c162b8ffa37afb5a745d481c22564f922dba446d61af718e"></a>kCenter_ScaleToFit&#160;</td><td class="fielddoc"><p>scales and aligns to center </p>
</td></tr>
<tr><td class="fieldname"><a id="a4540975cfa4b120d8c162b8ffa37afb5a62c2c8ded2e57c938b90557fbcc51dbd"></a>kEnd_ScaleToFit&#160;</td><td class="fielddoc"><p>scales and aligns to right and bottom </p>
</td></tr>
</table>

</div>
</div>
<a id="af331aeddf3393681b4c506b0e597cccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af331aeddf3393681b4c506b0e597cccf">&#9670;&nbsp;</a></span>TypeMask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_matrix.html#af331aeddf3393681b4c506b0e597cccf">SkMatrix::TypeMask</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af331aeddf3393681b4c506b0e597cccfa5e91a98a1699bad635a86085c28230c4"></a>kIdentity_Mask&#160;</td><td class="fielddoc"><p>identity <a class="el" href="class_sk_matrix.html">SkMatrix</a>; all bits clear </p>
</td></tr>
<tr><td class="fieldname"><a id="af331aeddf3393681b4c506b0e597cccfa38d182568a7ff43c5d5afb8f2d8a7e97"></a>kTranslate_Mask&#160;</td><td class="fielddoc"><p>translation <a class="el" href="class_sk_matrix.html">SkMatrix</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="af331aeddf3393681b4c506b0e597cccfa4f2398de1e039f04453824417c73e10f"></a>kScale_Mask&#160;</td><td class="fielddoc"><p>scale <a class="el" href="class_sk_matrix.html">SkMatrix</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="af331aeddf3393681b4c506b0e597cccfaa6ccabaa495e3b51f13d763b4d7d881a"></a>kAffine_Mask&#160;</td><td class="fielddoc"><p>skew or rotate <a class="el" href="class_sk_matrix.html">SkMatrix</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="af331aeddf3393681b4c506b0e597cccfa13db1f43d9b068b2b889cd20228988c7"></a>kPerspective_Mask&#160;</td><td class="fielddoc"><p>perspective <a class="el" href="class_sk_matrix.html">SkMatrix</a> </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a46993a76460a4d2c8d20c5fe1900e9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46993a76460a4d2c8d20c5fe1900e9cb">&#9670;&nbsp;</a></span>SkMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr SkMatrix::SkMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates an identity <a class="el" href="class_sk_matrix.html">SkMatrix</a>: </p><pre class="fragment">| 1 0 0 |
| 0 1 0 |
| 0 0 1 |
</pre> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4f54b3685f7a08fb607ef9f09ab9f44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f54b3685f7a08fb607ef9f09ab9f44f">&#9670;&nbsp;</a></span>asAffine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::asAffine </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>affine</em>[6]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills affine in column major order. Sets affine to: </p><pre class="fragment">| scale-x  skew-x translate-x |
| skew-y  scale-y translate-y |
</pre><p>If <a class="el" href="class_sk_matrix.html">SkMatrix</a> contains perspective, returns false and leaves affine unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">affine</td><td>storage for 3 by 2 affine matrix; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> does not contain perspective </dd></dl>

</div>
</div>
<a id="a6c6cec1ad170c54722e2912ff2023b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6cec1ad170c54722e2912ff2023b8c">&#9670;&nbsp;</a></span>Concat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SkMatrix::Concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="class_sk_matrix.html">SkMatrix</a> a multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a> b.</p>
<p>Given: </p><pre class="fragment">    | A B C |      | J K L |
a = | D E F |, b = | M N O |
    | G H I |      | P Q R |
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">        | A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |
a * b = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |
        | G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_sk_matrix.html">SkMatrix</a> on left side of multiply expression </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_sk_matrix.html">SkMatrix</a> on right side of multiply expression </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_matrix.html">SkMatrix</a> computed from a times b </dd></dl>

</div>
</div>
<a id="aa22e10b72b688963edb48b826775a974"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22e10b72b688963edb48b826775a974">&#9670;&nbsp;</a></span>decomposeScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::decomposeScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_size.html">SkSize</a> *&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_matrix.html">SkMatrix</a> *&#160;</td>
          <td class="paramname"><em>remaining</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decomposes <a class="el" href="class_sk_matrix.html">SkMatrix</a> into scale components and whatever remains. Returns false if <a class="el" href="class_sk_matrix.html">SkMatrix</a> could not be decomposed.</p>
<p>Sets scale to portion of <a class="el" href="class_sk_matrix.html">SkMatrix</a> that scale axes. Sets remaining to <a class="el" href="class_sk_matrix.html">SkMatrix</a> with scaling factored out. remaining may be passed as nullptr to determine if <a class="el" href="class_sk_matrix.html">SkMatrix</a> can be decomposed without computing remainder.</p>
<p>Returns true if scale components are found. scale and remaining are unchanged if <a class="el" href="class_sk_matrix.html">SkMatrix</a> contains perspective; scale factors are not finite, or are nearly zero.</p>
<p>On success: Matrix = Remaining * scale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>axes scaling factors; may be nullptr </td></tr>
    <tr><td class="paramname">remaining</td><td><a class="el" href="class_sk_matrix.html">SkMatrix</a> without scaling; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if scale can be computed</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_decomposeScale">https://fiddle.skia.org/c/@Matrix_decomposeScale</a> </p>

</div>
</div>
<a id="afb926d0000d753339425bde36e9b73d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb926d0000d753339425bde36e9b73d6">&#9670;&nbsp;</a></span>dirtyMatrixTypeCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::dirtyMatrixTypeCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets internal cache to unknown state. Use to force update after repeated modifications to <a class="el" href="class_sk_matrix.html">SkMatrix</a> element reference returned by <a class="el" href="class_sk_matrix.html#a8883b1b8a65df05103fc84b92c940c66">operator[](int index)</a>. </p>

</div>
</div>
<a id="a4bb30bef96ca2fddeb8218dcd082d22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bb30bef96ca2fddeb8218dcd082d22b">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::dump </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes text representation of <a class="el" href="class_sk_matrix.html">SkMatrix</a> to standard output. Floating point values are written with limited precision; it may not be possible to reconstruct original <a class="el" href="class_sk_matrix.html">SkMatrix</a> from output.</p>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_dump">https://fiddle.skia.org/c/@Matrix_dump</a> </p>

</div>
</div>
<a id="ace415bd9001d1b67899035c194aef005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace415bd9001d1b67899035c194aef005">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkMatrix::get </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns one matrix value. Asserts if index is out of range and SK_DEBUG is defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>one of: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value corresponding to index </dd></dl>

</div>
</div>
<a id="aa49a9684efff87a979f8e26607bd2932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49a9684efff87a979f8e26607bd2932">&#9670;&nbsp;</a></span>get9()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::get9 </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>buffer</em>[9]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies nine scalar values contained by <a class="el" href="class_sk_matrix.html">SkMatrix</a> into buffer, in member value ascending order: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>storage for nine scalar values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aba7b113497891919c5733278b1f7cf7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7b113497891919c5733278b1f7cf7b">&#9670;&nbsp;</a></span>getMaxScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkMatrix::getMaxScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximum scaling factor of <a class="el" href="class_sk_matrix.html">SkMatrix</a> by decomposing the scaling and skewing elements. Returns -1 if scale factor overflows or <a class="el" href="class_sk_matrix.html">SkMatrix</a> contains perspective.</p>
<dl class="section return"><dt>Returns</dt><dd>maximum scale factor</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_getMaxScale">https://fiddle.skia.org/c/@Matrix_getMaxScale</a> </p>

</div>
</div>
<a id="a22545b914379e71c85111b3864359b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22545b914379e71c85111b3864359b59">&#9670;&nbsp;</a></span>getMinMaxScales()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::getMinMaxScales </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>scaleFactors</em>[2]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets scaleFactors[0] to the minimum scaling factor, and scaleFactors[1] to the maximum scaling factor. Scaling factors are computed by decomposing the <a class="el" href="class_sk_matrix.html">SkMatrix</a> scaling and skewing elements.</p>
<p>Returns true if scaleFactors are found; otherwise, returns false and sets scaleFactors to undefined values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleFactors</td><td>storage for minimum and maximum scale factors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if scale factors were computed correctly </dd></dl>

</div>
</div>
<a id="a92e38de15e3b2853a21aed9faa2b80a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e38de15e3b2853a21aed9faa2b80a7">&#9670;&nbsp;</a></span>getMinScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkMatrix::getMinScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the minimum scaling factor of <a class="el" href="class_sk_matrix.html">SkMatrix</a> by decomposing the scaling and skewing elements. Returns -1 if scale factor overflows or <a class="el" href="class_sk_matrix.html">SkMatrix</a> contains perspective.</p>
<dl class="section return"><dt>Returns</dt><dd>minimum scale factor</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_getMinScale">https://fiddle.skia.org/c/@Matrix_getMinScale</a> </p>

</div>
</div>
<a id="adbcec4c0b7a12faa1fdb4ab9f180b111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcec4c0b7a12faa1fdb4ab9f180b111">&#9670;&nbsp;</a></span>getPerspX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkMatrix::getPerspX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns factor scaling input x-axis relative to input y-axis.</p>
<dl class="section return"><dt>Returns</dt><dd>input x-axis perspective factor </dd></dl>

</div>
</div>
<a id="a0d3557955c9f6b64bf1505f34259c63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3557955c9f6b64bf1505f34259c63e">&#9670;&nbsp;</a></span>getPerspY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkMatrix::getPerspY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns factor scaling input y-axis relative to input x-axis.</p>
<dl class="section return"><dt>Returns</dt><dd>input y-axis perspective factor </dd></dl>

</div>
</div>
<a id="a8e38c42742d41b4156214d9d49021aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e38c42742d41b4156214d9d49021aa7">&#9670;&nbsp;</a></span>getScaleX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkMatrix::getScaleX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns scale factor multiplied by x-axis input, contributing to x-axis output. With <a class="el" href="class_sk_matrix.html#a5ce443b90376b5d8fdedbc265ad81ab2">mapPoints()</a>, scales <a class="el" href="struct_sk_point.html">SkPoint</a> along the x-axis.</p>
<dl class="section return"><dt>Returns</dt><dd>horizontal scale factor </dd></dl>

</div>
</div>
<a id="aa8d755c19debdb45bd6e0afcfdd21ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d755c19debdb45bd6e0afcfdd21ed5">&#9670;&nbsp;</a></span>getScaleY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkMatrix::getScaleY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns scale factor multiplied by y-axis input, contributing to y-axis output. With <a class="el" href="class_sk_matrix.html#a5ce443b90376b5d8fdedbc265ad81ab2">mapPoints()</a>, scales <a class="el" href="struct_sk_point.html">SkPoint</a> along the y-axis.</p>
<dl class="section return"><dt>Returns</dt><dd>vertical scale factor </dd></dl>

</div>
</div>
<a id="a721a2bc007080858e8965c5a02ee6d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a721a2bc007080858e8965c5a02ee6d07">&#9670;&nbsp;</a></span>getSkewX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkMatrix::getSkewX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns scale factor multiplied by y-axis input, contributing to x-axis output. With <a class="el" href="class_sk_matrix.html#a5ce443b90376b5d8fdedbc265ad81ab2">mapPoints()</a>, skews <a class="el" href="struct_sk_point.html">SkPoint</a> along the x-axis. Skewing both axes can rotate <a class="el" href="struct_sk_point.html">SkPoint</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>horizontal scale factor </dd></dl>

</div>
</div>
<a id="a2574de876e11bf146bba3e70946c850d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2574de876e11bf146bba3e70946c850d">&#9670;&nbsp;</a></span>getSkewY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkMatrix::getSkewY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns scale factor multiplied by x-axis input, contributing to y-axis output. With <a class="el" href="class_sk_matrix.html#a5ce443b90376b5d8fdedbc265ad81ab2">mapPoints()</a>, skews <a class="el" href="struct_sk_point.html">SkPoint</a> along the y-axis. Skewing both axes can rotate <a class="el" href="struct_sk_point.html">SkPoint</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>vertical skew factor </dd></dl>

</div>
</div>
<a id="af2213f816896922952d978a05985ed37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2213f816896922952d978a05985ed37">&#9670;&nbsp;</a></span>getTranslateX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkMatrix::getTranslateX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns translation contributing to x-axis output. With <a class="el" href="class_sk_matrix.html#a5ce443b90376b5d8fdedbc265ad81ab2">mapPoints()</a>, moves <a class="el" href="struct_sk_point.html">SkPoint</a> along the x-axis.</p>
<dl class="section return"><dt>Returns</dt><dd>horizontal translation factor </dd></dl>

</div>
</div>
<a id="a44b52e86c750b841cab7609389f963bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b52e86c750b841cab7609389f963bf">&#9670;&nbsp;</a></span>getTranslateY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkMatrix::getTranslateY </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns translation contributing to y-axis output. With <a class="el" href="class_sk_matrix.html#a5ce443b90376b5d8fdedbc265ad81ab2">mapPoints()</a>, moves <a class="el" href="struct_sk_point.html">SkPoint</a> along the y-axis.</p>
<dl class="section return"><dt>Returns</dt><dd>vertical translation factor </dd></dl>

</div>
</div>
<a id="af4d962619c7bde5e6f7666a36be043ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d962619c7bde5e6f7666a36be043ce">&#9670;&nbsp;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html#af331aeddf3393681b4c506b0e597cccf">TypeMask</a> SkMatrix::getType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a bit field describing the transformations the matrix may perform. The bit field is computed conservatively, so it may include false positives. For example, when kPerspective_Mask is set, all other bits are set.</p>
<dl class="section return"><dt>Returns</dt><dd>kIdentity_Mask, or combinations of: kTranslate_Mask, kScale_Mask, kAffine_Mask, kPerspective_Mask </dd></dl>

</div>
</div>
<a id="ac05bd201138194595572bbae7b87d549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac05bd201138194595572bbae7b87d549">&#9670;&nbsp;</a></span>hasPerspective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::hasPerspective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the matrix contains perspective elements. <a class="el" href="class_sk_matrix.html">SkMatrix</a> form is: </p><pre class="fragment">|       --            --              --          |
|       --            --              --          |
| perspective-x  perspective-y  perspective-scale |
</pre><p>where perspective-x or perspective-y is non-zero, or perspective-scale is not one. All other elements may have any value.</p>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> is in most general form </dd></dl>

</div>
</div>
<a id="aa097a3a1e9b15f1a083a6a807185600a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa097a3a1e9b15f1a083a6a807185600a">&#9670;&nbsp;</a></span>I()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::I </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns reference to const identity <a class="el" href="class_sk_matrix.html">SkMatrix</a>. Returned <a class="el" href="class_sk_matrix.html">SkMatrix</a> is set to: </p><pre class="fragment">| 1 0 0 |
| 0 1 0 |
| 0 0 1 |
</pre><dl class="section return"><dt>Returns</dt><dd>const identity <a class="el" href="class_sk_matrix.html">SkMatrix</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_I">https://fiddle.skia.org/c/@Matrix_I</a> </p>

</div>
</div>
<a id="af97ff786fa9adbf09cee7e0190a8328a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97ff786fa9adbf09cee7e0190a8328a">&#9670;&nbsp;</a></span>InvalidMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::InvalidMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns reference to a const <a class="el" href="class_sk_matrix.html">SkMatrix</a> with invalid values. Returned <a class="el" href="class_sk_matrix.html">SkMatrix</a> is set to: </p><pre class="fragment">| SK_ScalarMax SK_ScalarMax SK_ScalarMax |
| SK_ScalarMax SK_ScalarMax SK_ScalarMax |
| SK_ScalarMax SK_ScalarMax SK_ScalarMax |
</pre><dl class="section return"><dt>Returns</dt><dd>const invalid <a class="el" href="class_sk_matrix.html">SkMatrix</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_InvalidMatrix">https://fiddle.skia.org/c/@Matrix_InvalidMatrix</a> </p>

</div>
</div>
<a id="a85d40915cf59dcce0f7270a4988aaf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d40915cf59dcce0f7270a4988aaf47">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SK_WARN_UNUSED_RESULT SkMatrix::invert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_matrix.html">SkMatrix</a> *&#160;</td>
          <td class="paramname"><em>inverse</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets inverse to reciprocal matrix, returning true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> can be inverted. Geometrically, if <a class="el" href="class_sk_matrix.html">SkMatrix</a> maps from source to destination, inverse <a class="el" href="class_sk_matrix.html">SkMatrix</a> maps from destination to source. If <a class="el" href="class_sk_matrix.html">SkMatrix</a> can not be inverted, inverse is unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inverse</td><td>storage for inverted <a class="el" href="class_sk_matrix.html">SkMatrix</a>; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> can be inverted </dd></dl>

</div>
</div>
<a id="ac9e7082b7f1d6362ff16ea2baf456dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9e7082b7f1d6362ff16ea2baf456dfe">&#9670;&nbsp;</a></span>isFinite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::isFinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if all elements of the matrix are finite. Returns false if any element is infinity, or NaN.</p>
<dl class="section return"><dt>Returns</dt><dd>true if matrix has only finite elements </dd></dl>

</div>
</div>
<a id="af514e197c25c12087ba1b925e2d462cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af514e197c25c12087ba1b925e2d462cc">&#9670;&nbsp;</a></span>isIdentity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::isIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> is identity. <a class="el" href="struct_identity.html">Identity</a> matrix is: </p><pre class="fragment">| 1 0 0 |
| 0 1 0 |
| 0 0 1 |
</pre><dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> has no effect </dd></dl>

</div>
</div>
<a id="ab35426ca05523f92c9822328a01f2d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35426ca05523f92c9822328a01f2d8f">&#9670;&nbsp;</a></span>isScaleTranslate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::isScaleTranslate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> at most scales and translates. <a class="el" href="class_sk_matrix.html">SkMatrix</a> may be identity, contain only scale elements, only translate elements, or both. <a class="el" href="class_sk_matrix.html">SkMatrix</a> form is: </p><pre class="fragment">| scale-x    0    translate-x |
|    0    scale-y translate-y |
|    0       0         1      |
</pre><dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> is identity; or scales, translates, or both </dd></dl>

</div>
</div>
<a id="adcd20c0f3c46cddc767ee5182c998200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcd20c0f3c46cddc767ee5182c998200">&#9670;&nbsp;</a></span>isSimilarity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::isSimilarity </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>tol</em> = <code>SK_ScalarNearlyZero</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> contains only translation, rotation, reflection, and uniform scale. Returns false if <a class="el" href="class_sk_matrix.html">SkMatrix</a> contains different scales, skewing, perspective, or degenerate forms that collapse to a line or point.</p>
<p>Describes that the <a class="el" href="class_sk_matrix.html">SkMatrix</a> makes rendering with and without the matrix are visually alike; a transformed circle remains a circle. Mathematically, this is referred to as similarity of a Euclidean space, or a similarity transformation.</p>
<p>Preserves right angles, keeping the arms of the angle equal lengths.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tol</td><td>to be deprecated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> only rotates, uniformly scales, translates</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_isSimilarity">https://fiddle.skia.org/c/@Matrix_isSimilarity</a> </p>

</div>
</div>
<a id="a7d5aabf2ddd38d3fc7a67e9404fb9355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5aabf2ddd38d3fc7a67e9404fb9355">&#9670;&nbsp;</a></span>isTranslate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::isTranslate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> is identity, or translates. <a class="el" href="class_sk_matrix.html">SkMatrix</a> form is: </p><pre class="fragment">| 1 0 translate-x |
| 0 1 translate-y |
| 0 0      1      |
</pre><dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> is identity, or translates </dd></dl>

</div>
</div>
<a id="ad3f682f2882d2f8fd7224994ded26e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f682f2882d2f8fd7224994ded26e7b">&#9670;&nbsp;</a></span>MakeAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT SkMatrix::MakeAll </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>scaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>skewX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>transX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>skewY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>transY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>pers0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>pers1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>pers2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">| scaleX  skewX transX |
|  skewY scaleY transY |
|  pers0  pers1  pers2 |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleX</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">skewX</td><td>horizontal skew factor </td></tr>
    <tr><td class="paramname">transX</td><td>horizontal translation </td></tr>
    <tr><td class="paramname">skewY</td><td>vertical skew factor </td></tr>
    <tr><td class="paramname">scaleY</td><td>vertical scale factor </td></tr>
    <tr><td class="paramname">transY</td><td>vertical translation </td></tr>
    <tr><td class="paramname">pers0</td><td>input x-axis perspective factor </td></tr>
    <tr><td class="paramname">pers1</td><td>input y-axis perspective factor </td></tr>
    <tr><td class="paramname">pers2</td><td>perspective scale factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_matrix.html">SkMatrix</a> constructed from parameters </dd></dl>

</div>
</div>
<a id="ab0d9c70cc312ef92202aca2b80161166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d9c70cc312ef92202aca2b80161166">&#9670;&nbsp;</a></span>MakeRectToRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SkMatrix::MakeRectToRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_matrix.html#a4540975cfa4b120d8c162b8ffa37afb5">ScaleToFit</a>&#160;</td>
          <td class="paramname"><em>stf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="class_sk_matrix.html">SkMatrix</a> set to scale and translate src <a class="el" href="struct_sk_rect.html">SkRect</a> to dst <a class="el" href="struct_sk_rect.html">SkRect</a>. stf selects whether mapping completely fills dst or preserves the aspect ratio, and how to align src within dst. Returns the identity <a class="el" href="class_sk_matrix.html">SkMatrix</a> if src is empty. If dst is empty, returns <a class="el" href="class_sk_matrix.html">SkMatrix</a> set to: </p><pre class="fragment">| 0 0 0 |
| 0 0 0 |
| 0 0 1 |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to map from </td></tr>
    <tr><td class="paramname">dst</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to map to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_matrix.html">SkMatrix</a> mapping src to dst </dd></dl>

</div>
</div>
<a id="a242262710c2dbf8b604fefa97461024f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242262710c2dbf8b604fefa97461024f">&#9670;&nbsp;</a></span>mapHomogeneousPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::mapHomogeneousPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point3.html">SkPoint3</a>&#160;</td>
          <td class="paramname"><em>dst</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>src</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns homogeneous points, starting with 2D src points (with implied w = 1). </p>

</div>
</div>
<a id="a28b3fda37688ae6dec9a47bd2efa7d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28b3fda37688ae6dec9a47bd2efa7d0f">&#9670;&nbsp;</a></span>mapHomogeneousPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::mapHomogeneousPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point3.html">SkPoint3</a>&#160;</td>
          <td class="paramname"><em>dst</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point3.html">SkPoint3</a>&#160;</td>
          <td class="paramname"><em>src</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps src <a class="el" href="struct_sk_point3.html">SkPoint3</a> array of length count to dst <a class="el" href="struct_sk_point3.html">SkPoint3</a> array, which must of length count or greater. <a class="el" href="struct_sk_point3.html">SkPoint3</a> array is mapped by multiplying each <a class="el" href="struct_sk_point3.html">SkPoint3</a> by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. Given: </p><pre class="fragment">         | A B C |         | x |
Matrix = | D E F |,  src = | y |
         | G H I |         | z |
</pre><p>each resulting dst <a class="el" href="struct_sk_point.html">SkPoint</a> is computed as: </p><pre class="fragment">               |A B C| |x|
Matrix * src = |D E F| |y| = |Ax+By+Cz Dx+Ey+Fz Gx+Hy+Iz|
               |G H I| |z|
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>storage for mapped <a class="el" href="struct_sk_point3.html">SkPoint3</a> array </td></tr>
    <tr><td class="paramname">src</td><td><a class="el" href="struct_sk_point3.html">SkPoint3</a> array to transform </td></tr>
    <tr><td class="paramname">count</td><td>items in <a class="el" href="struct_sk_point3.html">SkPoint3</a> array to transform</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_mapHomogeneousPoints">https://fiddle.skia.org/c/@Matrix_mapHomogeneousPoints</a> </p>

</div>
</div>
<a id="ab02531fdec93b91da05b4f48efb03c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02531fdec93b91da05b4f48efb03c5e">&#9670;&nbsp;</a></span>mapOrigin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_point.html">SkPoint</a> SkMatrix::mapOrigin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns (0, 0) multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. Given: </p><pre class="fragment">         | A B C |        | 0 |
Matrix = | D E F |,  pt = | 0 |
         | G H I |        | 1 |
</pre><p>result is computed as: </p><pre class="fragment">              |A B C| |0|             C    F
Matrix * pt = |D E F| |0| = |C F I| = -  , -
              |G H I| |1|             I    I
</pre><dl class="section return"><dt>Returns</dt><dd>mapped (0, 0) </dd></dl>

</div>
</div>
<a id="a545fc5d678f0c07c40636bc4cb699017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545fc5d678f0c07c40636bc4cb699017">&#9670;&nbsp;</a></span>mapPoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_point.html">SkPoint</a> SkMatrix::mapPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>pt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_point.html">SkPoint</a> pt multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. Given: </p><pre class="fragment">         | A B C |        | x |
Matrix = | D E F |,  pt = | y |
         | G H I |        | 1 |
</pre><p>result is computed as: </p><pre class="fragment">              |A B C| |x|                               Ax+By+C   Dx+Ey+F
Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------
              |G H I| |1|                               Gx+Hy+I   Gx+Hy+I
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td><a class="el" href="struct_sk_point.html">SkPoint</a> to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mapped <a class="el" href="struct_sk_point.html">SkPoint</a> </dd></dl>

</div>
</div>
<a id="a5ce443b90376b5d8fdedbc265ad81ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce443b90376b5d8fdedbc265ad81ab2">&#9670;&nbsp;</a></span>mapPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::mapPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>dst</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>src</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps src <a class="el" href="struct_sk_point.html">SkPoint</a> array of length count to dst <a class="el" href="struct_sk_point.html">SkPoint</a> array of equal or greater length. <a class="el" href="struct_sk_point.html">SkPoint</a> are mapped by multiplying each <a class="el" href="struct_sk_point.html">SkPoint</a> by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. Given: </p><pre class="fragment">         | A B C |        | x |
Matrix = | D E F |,  pt = | y |
         | G H I |        | 1 |
</pre><p>where </p><pre class="fragment">for (i = 0; i &lt; count; ++i) {
    x = src[i].fX
    y = src[i].fY
}
</pre><p>each dst <a class="el" href="struct_sk_point.html">SkPoint</a> is computed as: </p><pre class="fragment">              |A B C| |x|                               Ax+By+C   Dx+Ey+F
Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------
              |G H I| |1|                               Gx+Hy+I   Gx+Hy+I
</pre><p>src and dst may point to the same storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>storage for mapped <a class="el" href="struct_sk_point.html">SkPoint</a> </td></tr>
    <tr><td class="paramname">src</td><td><a class="el" href="struct_sk_point.html">SkPoint</a> to transform </td></tr>
    <tr><td class="paramname">count</td><td>number of <a class="el" href="struct_sk_point.html">SkPoint</a> to transform</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_mapPoints">https://fiddle.skia.org/c/@Matrix_mapPoints</a> </p>

</div>
</div>
<a id="a65b0538565f49f84700f5a4ae0781eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b0538565f49f84700f5a4ae0781eb3">&#9670;&nbsp;</a></span>mapPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::mapPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>pts</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps pts <a class="el" href="struct_sk_point.html">SkPoint</a> array of length count in place. <a class="el" href="struct_sk_point.html">SkPoint</a> are mapped by multiplying each <a class="el" href="struct_sk_point.html">SkPoint</a> by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. Given: </p><pre class="fragment">         | A B C |        | x |
Matrix = | D E F |,  pt = | y |
         | G H I |        | 1 |
</pre><p>where </p><pre class="fragment">for (i = 0; i &lt; count; ++i) {
    x = pts[i].fX
    y = pts[i].fY
}
</pre><p>each resulting pts <a class="el" href="struct_sk_point.html">SkPoint</a> is computed as: </p><pre class="fragment">              |A B C| |x|                               Ax+By+C   Dx+Ey+F
Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------
              |G H I| |1|                               Gx+Hy+I   Gx+Hy+I
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td>storage for mapped <a class="el" href="struct_sk_point.html">SkPoint</a> </td></tr>
    <tr><td class="paramname">count</td><td>number of <a class="el" href="struct_sk_point.html">SkPoint</a> to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0371b96d06a6cd5129fe01ea30dd3e32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0371b96d06a6cd5129fe01ea30dd3e32">&#9670;&nbsp;</a></span>mapRadius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkMatrix::mapRadius </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>radius</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns geometric mean radius of ellipse formed by constructing circle of size radius, and mapping constructed circle with <a class="el" href="class_sk_matrix.html">SkMatrix</a>. The result squared is equal to the major axis length times the minor axis length. Result is not meaningful if <a class="el" href="class_sk_matrix.html">SkMatrix</a> contains perspective elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">radius</td><td>circle size to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>average mapped radius</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_mapRadius">https://fiddle.skia.org/c/@Matrix_mapRadius</a> </p>

</div>
</div>
<a id="aa5fb36ba9d07ef5fe8f192116c95ae43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fb36ba9d07ef5fe8f192116c95ae43">&#9670;&nbsp;</a></span>mapRect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_rect.html">SkRect</a> SkMatrix::mapRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkApplyPerspectiveClip&#160;</td>
          <td class="paramname"><em>pc</em> = <code>SkApplyPerspectiveClip::kYes</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns bounds of src corners mapped by <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>rectangle to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mapped bounds </dd></dl>

</div>
</div>
<a id="aecc2a105c953e74f071c0fe7c5aadb7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecc2a105c953e74f071c0fe7c5aadb7b">&#9670;&nbsp;</a></span>mapRect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::mapRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_rect.html">SkRect</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkApplyPerspectiveClip&#160;</td>
          <td class="paramname"><em>pc</em> = <code>SkApplyPerspectiveClip::kYes</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets dst to bounds of src corners mapped by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. Returns true if mapped corners are dst corners.</p>
<p>Returned value is the same as calling <a class="el" href="class_sk_matrix.html#a853195ec94617eb8532a73bc705453e7">rectStaysRect()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>storage for bounds of mapped <a class="el" href="struct_sk_point.html">SkPoint</a> </td></tr>
    <tr><td class="paramname">src</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to map </td></tr>
    <tr><td class="paramname">pc</td><td>whether to apply perspective clipping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if dst is equivalent to mapped src</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_mapRect">https://fiddle.skia.org/c/@Matrix_mapRect</a> </p>

</div>
</div>
<a id="a89fa963f9e67471847853bcad689c1ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89fa963f9e67471847853bcad689c1ec">&#9670;&nbsp;</a></span>mapRect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::mapRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_rect.html">SkRect</a> *&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkApplyPerspectiveClip&#160;</td>
          <td class="paramname"><em>pc</em> = <code>SkApplyPerspectiveClip::kYes</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets rect to bounds of rect corners mapped by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. Returns true if mapped corners are computed rect corners.</p>
<p>Returned value is the same as calling <a class="el" href="class_sk_matrix.html#a853195ec94617eb8532a73bc705453e7">rectStaysRect()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>rectangle to map, and storage for bounds of mapped corners </td></tr>
    <tr><td class="paramname">pc</td><td>whether to apply perspective clipping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if result is equivalent to mapped rect </dd></dl>

</div>
</div>
<a id="aa81aa5cfaa7640889a4a782bb5323c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa81aa5cfaa7640889a4a782bb5323c0e">&#9670;&nbsp;</a></span>mapRectScaleTranslate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::mapRectScaleTranslate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_rect.html">SkRect</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets dst to bounds of src corners mapped by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. If matrix contains elements other than scale or translate: asserts if SK_DEBUG is defined; otherwise, results are undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>storage for bounds of mapped <a class="el" href="struct_sk_point.html">SkPoint</a> </td></tr>
    <tr><td class="paramname">src</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to map</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_mapRectScaleTranslate">https://fiddle.skia.org/c/@Matrix_mapRectScaleTranslate</a> </p>

</div>
</div>
<a id="afce8e1c05bbc40ee69a376aa713542b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce8e1c05bbc40ee69a376aa713542b5">&#9670;&nbsp;</a></span>mapRectToQuad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::mapRectToQuad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>dst</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps four corners of rect to dst. <a class="el" href="struct_sk_point.html">SkPoint</a> are mapped by multiplying each rect corner by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. rect corner is processed in this order: (rect.fLeft, rect.fTop), (rect.fRight, rect.fTop), (rect.fRight, rect.fBottom), (rect.fLeft, rect.fBottom).</p>
<p>rect may be empty: rect.fLeft may be greater than or equal to rect.fRight; rect.fTop may be greater than or equal to rect.fBottom.</p>
<p>Given: </p><pre class="fragment">         | A B C |        | x |
Matrix = | D E F |,  pt = | y |
         | G H I |        | 1 |
</pre><p>where pt is initialized from each of (rect.fLeft, rect.fTop), (rect.fRight, rect.fTop), (rect.fRight, rect.fBottom), (rect.fLeft, rect.fBottom), each dst <a class="el" href="struct_sk_point.html">SkPoint</a> is computed as: </p><pre class="fragment">              |A B C| |x|                               Ax+By+C   Dx+Ey+F
Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------
              |G H I| |1|                               Gx+Hy+I   Gx+Hy+I
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>storage for mapped corner <a class="el" href="struct_sk_point.html">SkPoint</a> </td></tr>
    <tr><td class="paramname">rect</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to map</td></tr>
  </table>
  </dd>
</dl>
<p>Note: this does not perform perspective clipping (as that might result in more than 4 points, so results are suspect if the matrix contains perspective. </p>

</div>
</div>
<a id="abafffbeeb2e2a17c2adb87170dc1ffeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abafffbeeb2e2a17c2adb87170dc1ffeb">&#9670;&nbsp;</a></span>mapVector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_point.html">SkVector</a> SkMatrix::mapVector </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns vector (dx, dy) multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a>, treating <a class="el" href="class_sk_matrix.html">SkMatrix</a> translation as zero. Given: </p><pre class="fragment">         | A B 0 |         | dx |
Matrix = | D E 0 |,  vec = | dy |
         | G H I |         |  1 |
</pre><p>each result vector is computed as: </p><pre class="fragment">           |A B 0| |dx|                                        A*dx+B*dy     D*dx+E*dy
</pre><p> Matrix * vec = |D E 0| |dy| = |A*dx+B*dy D*dx+E*dy G*dx+H*dy+I| = --------&mdash; , --------&mdash; |G <a class="el" href="struct_h.html">H</a> I| | 1| G*dx+H*dy+I G*dx+*dHy+I</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>x-axis value of vector to map </td></tr>
    <tr><td class="paramname">dy</td><td>y-axis value of vector to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mapped vector </dd></dl>

</div>
</div>
<a id="af347d0de7ea1f178c1522e7ffdec38c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af347d0de7ea1f178c1522e7ffdec38c3">&#9670;&nbsp;</a></span>mapVector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::mapVector </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkVector</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps vector (dx, dy) to result. Vector is mapped by multiplying by <a class="el" href="class_sk_matrix.html">SkMatrix</a>, treating <a class="el" href="class_sk_matrix.html">SkMatrix</a> translation as zero. Given: </p><pre class="fragment">         | A B 0 |         | dx |
Matrix = | D E 0 |,  vec = | dy |
         | G H I |         |  1 |
</pre><p>each result vector is computed as: </p><pre class="fragment">           |A B 0| |dx|                                        A*dx+B*dy     D*dx+E*dy
</pre><p> Matrix * vec = |D E 0| |dy| = |A*dx+B*dy D*dx+E*dy G*dx+H*dy+I| = --------&mdash; , --------&mdash; |G <a class="el" href="struct_h.html">H</a> I| | 1| G*dx+H*dy+I G*dx+*dHy+I</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>x-axis value of vector to map </td></tr>
    <tr><td class="paramname">dy</td><td>y-axis value of vector to map </td></tr>
    <tr><td class="paramname">result</td><td>storage for mapped vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a366bb77f6466a1579aa620a8bfc38856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366bb77f6466a1579aa620a8bfc38856">&#9670;&nbsp;</a></span>mapVectors() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::mapVectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkVector</a>&#160;</td>
          <td class="paramname"><em>dst</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkVector</a>&#160;</td>
          <td class="paramname"><em>src</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps src vector array of length count to vector <a class="el" href="struct_sk_point.html">SkPoint</a> array of equal or greater length. Vectors are mapped by multiplying each vector by <a class="el" href="class_sk_matrix.html">SkMatrix</a>, treating <a class="el" href="class_sk_matrix.html">SkMatrix</a> translation as zero. Given: </p><pre class="fragment">         | A B 0 |         | x |
Matrix = | D E 0 |,  src = | y |
         | G H I |         | 1 |
</pre><p>where </p><pre class="fragment">for (i = 0; i &lt; count; ++i) {
    x = src[i].fX
    y = src[i].fY
}
</pre><p>each dst vector is computed as: </p><pre class="fragment">               |A B 0| |x|                            Ax+By     Dx+Ey
Matrix * src = |D E 0| |y| = |Ax+By Dx+Ey Gx+Hy+I| = ------- , -------
               |G H I| |1|                           Gx+Hy+I   Gx+Hy+I
</pre><p>src and dst may point to the same storage.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>storage for mapped vectors </td></tr>
    <tr><td class="paramname">src</td><td>vectors to transform </td></tr>
    <tr><td class="paramname">count</td><td>number of vectors to transform</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_mapVectors">https://fiddle.skia.org/c/@Matrix_mapVectors</a> </p>

</div>
</div>
<a id="a3973dff4c35cb72632171cd73ffe2bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3973dff4c35cb72632171cd73ffe2bef">&#9670;&nbsp;</a></span>mapVectors() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::mapVectors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkVector</a>&#160;</td>
          <td class="paramname"><em>vecs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps vecs vector array of length count in place, multiplying each vector by <a class="el" href="class_sk_matrix.html">SkMatrix</a>, treating <a class="el" href="class_sk_matrix.html">SkMatrix</a> translation as zero. Given: </p><pre class="fragment">         | A B 0 |         | x |
Matrix = | D E 0 |,  vec = | y |
         | G H I |         | 1 |
</pre><p>where </p><pre class="fragment">for (i = 0; i &lt; count; ++i) {
    x = vecs[i].fX
    y = vecs[i].fY
}
</pre><p>each result vector is computed as: </p><pre class="fragment">               |A B 0| |x|                            Ax+By     Dx+Ey
Matrix * vec = |D E 0| |y| = |Ax+By Dx+Ey Gx+Hy+I| = ------- , -------
               |G H I| |1|                           Gx+Hy+I   Gx+Hy+I
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vecs</td><td>vectors to transform, and storage for mapped vectors </td></tr>
    <tr><td class="paramname">count</td><td>number of vectors to transform </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac4b9fbc2fae0a2483650f9bb29cc7907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4b9fbc2fae0a2483650f9bb29cc7907">&#9670;&nbsp;</a></span>mapXY() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_point.html">SkPoint</a> SkMatrix::mapXY </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_point.html">SkPoint</a> (x, y) multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. Given: </p><pre class="fragment">         | A B C |        | x |
Matrix = | D E F |,  pt = | y |
         | G H I |        | 1 |
</pre><p>result is computed as: </p><pre class="fragment">              |A B C| |x|                               Ax+By+C   Dx+Ey+F
Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------
              |G H I| |1|                               Gx+Hy+I   Gx+Hy+I
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x-axis value of <a class="el" href="struct_sk_point.html">SkPoint</a> to map </td></tr>
    <tr><td class="paramname">y</td><td>y-axis value of <a class="el" href="struct_sk_point.html">SkPoint</a> to map </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>mapped <a class="el" href="struct_sk_point.html">SkPoint</a> </dd></dl>

</div>
</div>
<a id="a7f948aea7bae490af1cbecec31ec2b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f948aea7bae490af1cbecec31ec2b0a">&#9670;&nbsp;</a></span>mapXY() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::mapXY </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps <a class="el" href="struct_sk_point.html">SkPoint</a> (x, y) to result. <a class="el" href="struct_sk_point.html">SkPoint</a> is mapped by multiplying by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. Given: </p><pre class="fragment">         | A B C |        | x |
Matrix = | D E F |,  pt = | y |
         | G H I |        | 1 |
</pre><p>result is computed as: </p><pre class="fragment">              |A B C| |x|                               Ax+By+C   Dx+Ey+F
Matrix * pt = |D E F| |y| = |Ax+By+C Dx+Ey+F Gx+Hy+I| = ------- , -------
              |G H I| |1|                               Gx+Hy+I   Gx+Hy+I
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x-axis value of <a class="el" href="struct_sk_point.html">SkPoint</a> to map </td></tr>
    <tr><td class="paramname">y</td><td>y-axis value of <a class="el" href="struct_sk_point.html">SkPoint</a> to map </td></tr>
    <tr><td class="paramname">result</td><td>storage for mapped <a class="el" href="struct_sk_point.html">SkPoint</a></td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_mapXY">https://fiddle.skia.org/c/@Matrix_mapXY</a> </p>

</div>
</div>
<a id="ab922b7b843c9ccedb9ae825ebbeecd60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab922b7b843c9ccedb9ae825ebbeecd60">&#9670;&nbsp;</a></span>normalizePerspective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::normalizePerspective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A matrix is categorized as 'perspective' if the bottom row is not [0, 0, 1]. However, for most uses (e.g. mapPoints) a bottom row of [0, 0, X] behaves like a non-perspective matrix, though it will be categorized as perspective. Calling <a class="el" href="class_sk_matrix.html#ab922b7b843c9ccedb9ae825ebbeecd60">normalizePerspective()</a> will change the matrix such that, if its bottom row was [0, 0, X], it will be changed to [0, 0, 1] by scaling the rest of the matrix by 1/X.</p>
<p>| A B C | | A/X B/X C/X | | D E <a class="el" href="struct_f.html">F</a> | -&gt; | D/X E/X F/X | for X != 0 | 0 0 X | | 0 0 1 | </p>

</div>
</div>
<a id="a8883b1b8a65df05103fc84b92c940c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8883b1b8a65df05103fc84b92c940c66">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar&amp; SkMatrix::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns writable <a class="el" href="class_sk_matrix.html">SkMatrix</a> value. Asserts if index is out of range and SK_DEBUG is defined. Clears internal cache anticipating that caller will change <a class="el" href="class_sk_matrix.html">SkMatrix</a> value.</p>
<p>Next call to read <a class="el" href="class_sk_matrix.html">SkMatrix</a> state may recompute cache; subsequent writes to <a class="el" href="class_sk_matrix.html">SkMatrix</a> value must be followed by <a class="el" href="class_sk_matrix.html#afb926d0000d753339425bde36e9b73d6">dirtyMatrixTypeCache()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>one of: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>writable value corresponding to index </dd></dl>

</div>
</div>
<a id="ab3948022555f7667ef7bde1d358634d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3948022555f7667ef7bde1d358634d7">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkMatrix::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns one matrix value. Asserts if index is out of range and SK_DEBUG is defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>one of: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value corresponding to index </dd></dl>

</div>
</div>
<a id="a1e784a41f2a257221ea87727de17c80b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e784a41f2a257221ea87727de17c80b">&#9670;&nbsp;</a></span>postConcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::postConcat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> other multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. This can be thought of mapping by other after applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Given: </p><pre class="fragment">         | J K L |           | A B C |
Matrix = | M N O |,  other = | D E F |
         | P Q R |           | G H I |
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                 | A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |
other * Matrix = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |
                 | G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="class_sk_matrix.html">SkMatrix</a> on left side of multiply expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad38d3441ea7fb4551c8180ac15d5a61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38d3441ea7fb4551c8180ac15d5a61b">&#9670;&nbsp;</a></span>postRotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::postRotate </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> constructed from rotating by degrees about pivot point (0, 0), multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. This can be thought of as rotating about the origin after applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Positive degrees rotates clockwise.</p>
<p>Given: </p><pre class="fragment">         | J K L |                        | c -s 0 |
Matrix = | M N O |,  R(degrees, px, py) = | s  c 0 |
         | P Q R |                        | 0  0 1 |
</pre><p>where </p><pre class="fragment">c  = cos(degrees)
s  = sin(degrees)
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                              | c -s dx | | J K L |   | cJ-sM cK-sN cL-sO |
R(degrees, px, py) * Matrix = | s  c dy | | M N O | = | sJ+cM sK+cN sL+cO |
                              | 0  0  1 | | P Q R |   |     P     Q     R |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>angle of axes relative to upright axes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a180a6af42790bd7a6efdcc91fe7f161a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180a6af42790bd7a6efdcc91fe7f161a">&#9670;&nbsp;</a></span>postRotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::postRotate </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> constructed from rotating by degrees about pivot point (px, py), multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. This can be thought of as rotating about a pivot point after applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Positive degrees rotates clockwise.</p>
<p>Given: </p><pre class="fragment">         | J K L |                        | c -s dx |
Matrix = | M N O |,  R(degrees, px, py) = | s  c dy |
         | P Q R |                        | 0  0  1 |
</pre><p>where </p><pre class="fragment">c  = cos(degrees)
s  = sin(degrees)
dx =  s * py + (1 - c) * px
dy = -s * px + (1 - c) * py
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                              |c -s dx| |J K L|   |cJ-sM+dx*P cK-sN+dx*Q cL-sO+dx+R|
R(degrees, px, py) * Matrix = |s  c dy| |M N O| = |sJ+cM+dy*P sK+cN+dy*Q sL+cO+dy*R|
                              |0  0  1| |P Q R|   |         P          Q          R|
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>angle of axes relative to upright axes </td></tr>
    <tr><td class="paramname">px</td><td>pivot on x-axis </td></tr>
    <tr><td class="paramname">py</td><td>pivot on y-axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86db02fa2ab934545bb503b1eba0f699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86db02fa2ab934545bb503b1eba0f699">&#9670;&nbsp;</a></span>postScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::postScale </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> constructed from scaling by (sx, sy) about pivot point (0, 0), multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. This can be thought of as scaling about the origin after applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Given: </p><pre class="fragment">         | J K L |               | sx  0  0 |
Matrix = | M N O |,  S(sx, sy) = |  0 sy  0 |
         | P Q R |               |  0  0  1 |
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                     | sx  0  0 | | J K L |   | sx*J sx*K sx*L |
S(sx, sy) * Matrix = |  0 sy  0 | | M N O | = | sy*M sy*N sy*O |
                     |  0  0  1 | | P Q R |   |    P    Q    R |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a25e79f940534e51a82b4ef645727a4bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e79f940534e51a82b4ef645727a4bc">&#9670;&nbsp;</a></span>postScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::postScale </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> constructed from scaling by (sx, sy) about pivot point (px, py), multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. This can be thought of as scaling about a pivot point after applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Given: </p><pre class="fragment">         | J K L |                       | sx  0 dx |
Matrix = | M N O |,  S(sx, sy, px, py) = |  0 sy dy |
         | P Q R |                       |  0  0  1 |
</pre><p>where </p><pre class="fragment">dx = px - sx * px
dy = py - sy * py
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                             | sx  0 dx | | J K L |   | sx*J+dx*P sx*K+dx*Q sx*L+dx+R |
S(sx, sy, px, py) * Matrix = |  0 sy dy | | M N O | = | sy*M+dy*P sy*N+dy*Q sy*O+dy*R |
                             |  0  0  1 | | P Q R |   |         P         Q         R |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor </td></tr>
    <tr><td class="paramname">px</td><td>pivot on x-axis </td></tr>
    <tr><td class="paramname">py</td><td>pivot on y-axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae10f8911a9c1fd58dd9ec15563acd188"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae10f8911a9c1fd58dd9ec15563acd188">&#9670;&nbsp;</a></span>postSkew() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::postSkew </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>ky</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> constructed from skewing by (kx, ky) about pivot point (0, 0), multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. This can be thought of as skewing about the origin after applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Given: </p><pre class="fragment">         | J K L |               |  1 kx 0 |
Matrix = | M N O |,  K(kx, ky) = | ky  1 0 |
         | P Q R |               |  0  0 1 |
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                     |  1 kx 0 | | J K L |   | J+kx*M K+kx*N L+kx*O |
K(kx, ky) * Matrix = | ky  1 0 | | M N O | = | ky*J+M ky*K+N ky*L+O |
                     |  0  0 1 | | P Q R |   |      P      Q      R |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kx</td><td>horizontal skew factor </td></tr>
    <tr><td class="paramname">ky</td><td>vertical skew factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a75501df3ca3389c367b84eea0220b65d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75501df3ca3389c367b84eea0220b65d">&#9670;&nbsp;</a></span>postSkew() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::postSkew </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>ky</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> constructed from skewing by (kx, ky) about pivot point (px, py), multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. This can be thought of as skewing about a pivot point after applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Given: </p><pre class="fragment">         | J K L |                       |  1 kx dx |
Matrix = | M N O |,  K(kx, ky, px, py) = | ky  1 dy |
         | P Q R |                       |  0  0  1 |
</pre><p>where </p><pre class="fragment">dx = -kx * py
dy = -ky * px
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                             | 1 kx dx| |J K L|   |J+kx*M+dx*P K+kx*N+dx*Q L+kx*O+dx+R|
K(kx, ky, px, py) * Matrix = |ky  1 dy| |M N O| = |ky*J+M+dy*P ky*K+N+dy*Q ky*L+O+dy*R|
                             | 0  0  1| |P Q R|   |          P           Q           R|
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kx</td><td>horizontal skew factor </td></tr>
    <tr><td class="paramname">ky</td><td>vertical skew factor </td></tr>
    <tr><td class="paramname">px</td><td>pivot on x-axis </td></tr>
    <tr><td class="paramname">py</td><td>pivot on y-axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a088ad7ee4bf42b4814492dcdff6f581d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088ad7ee4bf42b4814492dcdff6f581d">&#9670;&nbsp;</a></span>postTranslate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::postTranslate </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> constructed from translation (dx, dy) multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. This can be thought of as moving the point to be mapped after applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Given: </p><pre class="fragment">         | J K L |               | 1 0 dx |
Matrix = | M N O |,  T(dx, dy) = | 0 1 dy |
         | P Q R |               | 0 0  1 |
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                     | 1 0 dx | | J K L |   | J+dx*P K+dx*Q L+dx*R |
T(dx, dy) * Matrix = | 0 1 dy | | M N O | = | M+dy*P N+dy*Q O+dy*R |
                     | 0 0  1 | | P Q R |   |      P      Q      R |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>x-axis translation after applying <a class="el" href="class_sk_matrix.html">SkMatrix</a> </td></tr>
    <tr><td class="paramname">dy</td><td>y-axis translation after applying <a class="el" href="class_sk_matrix.html">SkMatrix</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa29719999db0a4ddbd94c8de6bd71644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29719999db0a4ddbd94c8de6bd71644">&#9670;&nbsp;</a></span>preConcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::preConcat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a> other. This can be thought of mapping by other before applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Given: </p><pre class="fragment">         | A B C |          | J K L |
Matrix = | D E F |, other = | M N O |
         | G H I |          | P Q R |
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                 | A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |
Matrix * other = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |
                 | G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="class_sk_matrix.html">SkMatrix</a> on right side of multiply expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c89a9aac5c02ac8b04ce90073a0a10f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c89a9aac5c02ac8b04ce90073a0a10f">&#9670;&nbsp;</a></span>preRotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::preRotate </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a> constructed from rotating by degrees about pivot point (0, 0). This can be thought of as rotating about the origin before applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Positive degrees rotates clockwise.</p>
<p>Given: </p><pre class="fragment">         | A B C |                        | c -s 0 |
Matrix = | D E F |,  R(degrees, px, py) = | s  c 0 |
         | G H I |                        | 0  0 1 |
</pre><p>where </p><pre class="fragment">c  = cos(degrees)
s  = sin(degrees)
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                              | A B C | | c -s 0 |   | Ac+Bs -As+Bc C |
Matrix * R(degrees, px, py) = | D E F | | s  c 0 | = | Dc+Es -Ds+Ec F |
                              | G H I | | 0  0 1 |   | Gc+Hs -Gs+Hc I |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>angle of axes relative to upright axes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa39a85e39a75426fef10bc9470f7f267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39a85e39a75426fef10bc9470f7f267">&#9670;&nbsp;</a></span>preRotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::preRotate </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a> constructed from rotating by degrees about pivot point (px, py). This can be thought of as rotating about a pivot point before applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Positive degrees rotates clockwise.</p>
<p>Given: </p><pre class="fragment">         | A B C |                        | c -s dx |
Matrix = | D E F |,  R(degrees, px, py) = | s  c dy |
         | G H I |                        | 0  0  1 |
</pre><p>where </p><pre class="fragment">c  = cos(degrees)
s  = sin(degrees)
dx =  s * py + (1 - c) * px
dy = -s * px + (1 - c) * py
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                              | A B C | | c -s dx |   | Ac+Bs -As+Bc A*dx+B*dy+C |
Matrix * R(degrees, px, py) = | D E F | | s  c dy | = | Dc+Es -Ds+Ec D*dx+E*dy+F |
                              | G H I | | 0  0  1 |   | Gc+Hs -Gs+Hc G*dx+H*dy+I |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>angle of axes relative to upright axes </td></tr>
    <tr><td class="paramname">px</td><td>pivot on x-axis </td></tr>
    <tr><td class="paramname">py</td><td>pivot on y-axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43c6e4498b849844549649242af7062e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c6e4498b849844549649242af7062e">&#9670;&nbsp;</a></span>preScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::preScale </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a> constructed from scaling by (sx, sy) about pivot point (0, 0). This can be thought of as scaling about the origin before applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Given: </p><pre class="fragment">         | A B C |               | sx  0  0 |
Matrix = | D E F |,  S(sx, sy) = |  0 sy  0 |
         | G H I |               |  0  0  1 |
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                     | A B C | | sx  0  0 |   | A*sx B*sy C |
Matrix * S(sx, sy) = | D E F | |  0 sy  0 | = | D*sx E*sy F |
                     | G H I | |  0  0  1 |   | G*sx H*sy I |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aec598f5a0eedab6a62e1288269cdc29c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec598f5a0eedab6a62e1288269cdc29c">&#9670;&nbsp;</a></span>preScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::preScale </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a> constructed from scaling by (sx, sy) about pivot point (px, py). This can be thought of as scaling about a pivot point before applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Given: </p><pre class="fragment">         | A B C |                       | sx  0 dx |
Matrix = | D E F |,  S(sx, sy, px, py) = |  0 sy dy |
         | G H I |                       |  0  0  1 |
</pre><p>where </p><pre class="fragment">dx = px - sx * px
dy = py - sy * py
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                             | A B C | | sx  0 dx |   | A*sx B*sy A*dx+B*dy+C |
Matrix * S(sx, sy, px, py) = | D E F | |  0 sy dy | = | D*sx E*sy D*dx+E*dy+F |
                             | G H I | |  0  0  1 |   | G*sx H*sy G*dx+H*dy+I |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor </td></tr>
    <tr><td class="paramname">px</td><td>pivot on x-axis </td></tr>
    <tr><td class="paramname">py</td><td>pivot on y-axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad925199387a404a2dd643a1164307e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad925199387a404a2dd643a1164307e7b">&#9670;&nbsp;</a></span>preservesAxisAlignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::preservesAxisAlignment </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true <a class="el" href="class_sk_matrix.html">SkMatrix</a> maps <a class="el" href="struct_sk_rect.html">SkRect</a> to another <a class="el" href="struct_sk_rect.html">SkRect</a>. If true, <a class="el" href="class_sk_matrix.html">SkMatrix</a> is identity, or scales, or rotates a multiple of 90 degrees, or mirrors on axes. In all cases, <a class="el" href="class_sk_matrix.html">SkMatrix</a> may also have translation. <a class="el" href="class_sk_matrix.html">SkMatrix</a> form is either: </p><pre class="fragment">| scale-x    0    translate-x |
|    0    scale-y translate-y |
|    0       0         1      |
</pre><p>or </p><pre class="fragment">|    0     rotate-x translate-x |
| rotate-y    0     translate-y |
|    0        0          1      |
</pre><p>for non-zero values of scale-x, scale-y, rotate-x, and rotate-y.</p>
<p>Also called <a class="el" href="class_sk_matrix.html#a853195ec94617eb8532a73bc705453e7">rectStaysRect()</a>; use the one that provides better inline documentation.</p>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> maps one <a class="el" href="struct_sk_rect.html">SkRect</a> into another </dd></dl>

</div>
</div>
<a id="a4ae8c9c8ec2db54a087d21682134fc49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae8c9c8ec2db54a087d21682134fc49">&#9670;&nbsp;</a></span>preservesRightAngles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::preservesRightAngles </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>tol</em> = <code>SK_ScalarNearlyZero</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> contains only translation, rotation, reflection, and scale. Scale may differ along rotated axes. Returns false if <a class="el" href="class_sk_matrix.html">SkMatrix</a> skewing, perspective, or degenerate forms that collapse to a line or point.</p>
<p>Preserves right angles, but not requiring that the arms of the angle retain equal lengths.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tol</td><td>to be deprecated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> only rotates, scales, translates</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_preservesRightAngles">https://fiddle.skia.org/c/@Matrix_preservesRightAngles</a> </p>

</div>
</div>
<a id="ad77baa4e4ec8ff007b70c3b32c22f910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad77baa4e4ec8ff007b70c3b32c22f910">&#9670;&nbsp;</a></span>preSkew() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::preSkew </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>ky</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a> constructed from skewing by (kx, ky) about pivot point (0, 0). This can be thought of as skewing about the origin before applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Given: </p><pre class="fragment">         | A B C |               |  1 kx 0 |
Matrix = | D E F |,  K(kx, ky) = | ky  1 0 |
         | G H I |               |  0  0 1 |
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                     | A B C | |  1 kx 0 |   | A+B*ky A*kx+B C |
Matrix * K(kx, ky) = | D E F | | ky  1 0 | = | D+E*ky D*kx+E F |
                     | G H I | |  0  0 1 |   | G+H*ky G*kx+H I |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kx</td><td>horizontal skew factor </td></tr>
    <tr><td class="paramname">ky</td><td>vertical skew factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1b28b01ec3d91c2b3a282f9821ced6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b28b01ec3d91c2b3a282f9821ced6de">&#9670;&nbsp;</a></span>preSkew() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::preSkew </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>ky</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a> constructed from skewing by (kx, ky) about pivot point (px, py). This can be thought of as skewing about a pivot point before applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Given: </p><pre class="fragment">         | A B C |                       |  1 kx dx |
Matrix = | D E F |,  K(kx, ky, px, py) = | ky  1 dy |
         | G H I |                       |  0  0  1 |
</pre><p>where </p><pre class="fragment">dx = -kx * py
dy = -ky * px
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                             | A B C | |  1 kx dx |   | A+B*ky A*kx+B A*dx+B*dy+C |
Matrix * K(kx, ky, px, py) = | D E F | | ky  1 dy | = | D+E*ky D*kx+E D*dx+E*dy+F |
                             | G H I | |  0  0  1 |   | G+H*ky G*kx+H G*dx+H*dy+I |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kx</td><td>horizontal skew factor </td></tr>
    <tr><td class="paramname">ky</td><td>vertical skew factor </td></tr>
    <tr><td class="paramname">px</td><td>pivot on x-axis </td></tr>
    <tr><td class="paramname">py</td><td>pivot on y-axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa1fe1ee2d65c04c8056818dcf8fa652f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1fe1ee2d65c04c8056818dcf8fa652f">&#9670;&nbsp;</a></span>preTranslate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::preTranslate </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a> constructed from translation (dx, dy). This can be thought of as moving the point to be mapped before applying <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Given: </p><pre class="fragment">         | A B C |               | 1 0 dx |
Matrix = | D E F |,  T(dx, dy) = | 0 1 dy |
         | G H I |               | 0 0  1 |
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">                     | A B C | | 1 0 dx |   | A B A*dx+B*dy+C |
Matrix * T(dx, dy) = | D E F | | 0 1 dy | = | D E D*dx+E*dy+F |
                     | G H I | | 0 0  1 |   | G H G*dx+H*dy+I |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>x-axis translation before applying <a class="el" href="class_sk_matrix.html">SkMatrix</a> </td></tr>
    <tr><td class="paramname">dy</td><td>y-axis translation before applying <a class="el" href="class_sk_matrix.html">SkMatrix</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48183eb669dcb04202887f1a8cb18ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48183eb669dcb04202887f1a8cb18ef4">&#9670;&nbsp;</a></span>rc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkScalar SkMatrix::rc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns one matrix value from a particular row/column. Asserts if index is out of range and SK_DEBUG is defined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>matrix row to fetch </td></tr>
    <tr><td class="paramname">c</td><td>matrix column to fetch </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>value at the given matrix position </dd></dl>

</div>
</div>
<a id="a853195ec94617eb8532a73bc705453e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853195ec94617eb8532a73bc705453e7">&#9670;&nbsp;</a></span>rectStaysRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::rectStaysRect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true <a class="el" href="class_sk_matrix.html">SkMatrix</a> maps <a class="el" href="struct_sk_rect.html">SkRect</a> to another <a class="el" href="struct_sk_rect.html">SkRect</a>. If true, <a class="el" href="class_sk_matrix.html">SkMatrix</a> is identity, or scales, or rotates a multiple of 90 degrees, or mirrors on axes. In all cases, <a class="el" href="class_sk_matrix.html">SkMatrix</a> may also have translation. <a class="el" href="class_sk_matrix.html">SkMatrix</a> form is either: </p><pre class="fragment">| scale-x    0    translate-x |
|    0    scale-y translate-y |
|    0       0         1      |
</pre><p>or </p><pre class="fragment">|    0     rotate-x translate-x |
| rotate-y    0     translate-y |
|    0        0          1      |
</pre><p>for non-zero values of scale-x, scale-y, rotate-x, and rotate-y.</p>
<p>Also called <a class="el" href="class_sk_matrix.html#ad925199387a404a2dd643a1164307e7b">preservesAxisAlignment()</a>; use the one that provides better inline documentation.</p>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> maps one <a class="el" href="struct_sk_rect.html">SkRect</a> into another </dd></dl>

</div>
</div>
<a id="a6c5194eea4174d97931f2eafd62abcd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5194eea4174d97931f2eafd62abcd7">&#9670;&nbsp;</a></span>RectToRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT SkMatrix::RectToRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_matrix.html#a4540975cfa4b120d8c162b8ffa37afb5">ScaleToFit</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="class_sk_matrix.html#a4540975cfa4b120d8c162b8ffa37afb5ac59b2679907dc2cbab030485d62aa264">kFill_ScaleToFit</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="class_sk_matrix.html">SkMatrix</a> set to scale and translate src to dst. ScaleToFit selects whether mapping completely fills dst or preserves the aspect ratio, and how to align src within dst. Returns the identity <a class="el" href="class_sk_matrix.html">SkMatrix</a> if src is empty. If dst is empty, returns <a class="el" href="class_sk_matrix.html">SkMatrix</a> set to: </p><pre class="fragment">| 0 0 0 |
| 0 0 0 |
| 0 0 1 |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to map from </td></tr>
    <tr><td class="paramname">dst</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to map to </td></tr>
    <tr><td class="paramname">mode</td><td>How to handle the mapping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_matrix.html">SkMatrix</a> mapping src to dst </dd></dl>

</div>
</div>
<a id="ae2221ac28297780a070c8fc516b9bb50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2221ac28297780a070c8fc516b9bb50">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to identity; which has no effect on mapped <a class="el" href="struct_sk_point.html">SkPoint</a>. Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">| 1 0 0 |
| 0 1 0 |
| 0 0 1 |
</pre><p>Also called <a class="el" href="class_sk_matrix.html#a6a40483f395bad9a0ddf912b8788780a">setIdentity()</a>; use the one that provides better inline documentation. </p>

</div>
</div>
<a id="adad1ef73ce5d66f779ec7d43a8cb880e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad1ef73ce5d66f779ec7d43a8cb880e">&#9670;&nbsp;</a></span>RotateDeg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT SkMatrix::RotateDeg </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>deg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to rotate by |deg| about a pivot point at (0, 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deg</td><td>rotation angle in degrees (positive rotates clockwise) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_matrix.html">SkMatrix</a> with rotation </dd></dl>

</div>
</div>
<a id="a9f5da1a67fb5c98649ba2ff4af5572fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5da1a67fb5c98649ba2ff4af5572fa">&#9670;&nbsp;</a></span>Scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT SkMatrix::Scale </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to scale by (sx, sy). Returned matrix is: </p><pre class="fragment">| sx  0  0 |
|  0 sy  0 |
|  0  0  1 |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_matrix.html">SkMatrix</a> with scale </dd></dl>

</div>
</div>
<a id="a029f43d83d7aaa4ce42e6eb679c3b4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a029f43d83d7aaa4ce42e6eb679c3b4df">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a>&amp; SkMatrix::set </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> value. Asserts if index is out of range and SK_DEBUG is defined. Safer than operator[]; internal cache is always maintained.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>one of: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2 </td></tr>
    <tr><td class="paramname">value</td><td>scalar to store in <a class="el" href="class_sk_matrix.html">SkMatrix</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9609f2e7815c572c7012a2bf01931445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9609f2e7815c572c7012a2bf01931445">&#9670;&nbsp;</a></span>set9()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::set9 </td>
          <td>(</td>
          <td class="paramtype">const SkScalar&#160;</td>
          <td class="paramname"><em>buffer</em>[9]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to nine scalar values in buffer, in member value ascending order: kMScaleX, kMSkewX, kMTransX, kMSkewY, kMScaleY, kMTransY, kMPersp0, kMPersp1, kMPersp2.</p>
<p>Sets matrix to: </p><pre class="fragment">| buffer[0] buffer[1] buffer[2] |
| buffer[3] buffer[4] buffer[5] |
| buffer[6] buffer[7] buffer[8] |
</pre><p>In the future, set9 followed by get9 may not return the same values. Since <a class="el" href="class_sk_matrix.html">SkMatrix</a> maps non-homogeneous coordinates, scaling all nine values produces an equivalent transformation, possibly improving precision.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>nine scalar values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06a2bf7c2d36328f3d39ae6f97905ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a2bf7c2d36328f3d39ae6f97905ffc">&#9670;&nbsp;</a></span>setAffine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::setAffine </td>
          <td>(</td>
          <td class="paramtype">const SkScalar&#160;</td>
          <td class="paramname"><em>affine</em>[6]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to affine values, passed in column major order. Given affine, column, then row, as: </p><pre class="fragment">| scale-x  skew-x translate-x |
|  skew-y scale-y translate-y |
</pre><p><a class="el" href="class_sk_matrix.html">SkMatrix</a> is set, row, then column, to: </p><pre class="fragment">| scale-x  skew-x translate-x |
|  skew-y scale-y translate-y |
|       0       0           1 |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">affine</td><td>3 by 2 affine matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8020ffbb697ca43309dc30b2e13ea2ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8020ffbb697ca43309dc30b2e13ea2ab">&#9670;&nbsp;</a></span>SetAffineIdentity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::SetAffineIdentity </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>affine</em>[6]</td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills affine with identity values in column major order. Sets affine to: </p><pre class="fragment">| 1 0 0 |
| 0 1 0 |
</pre><p>Affine 3 by 2 matrices in column major order are used by OpenGL and XPS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">affine</td><td>storage for 3 by 2 affine matrix</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_SetAffineIdentity">https://fiddle.skia.org/c/@Matrix_SetAffineIdentity</a> </p>

</div>
</div>
<a id="a1c7f0cf9924529fbe153cd1e451dad68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7f0cf9924529fbe153cd1e451dad68">&#9670;&nbsp;</a></span>setAll()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a>&amp; SkMatrix::setAll </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>scaleX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>skewX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>transX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>skewY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>scaleY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>transY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>persp0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>persp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>persp2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all values from parameters. Sets matrix to: </p><pre class="fragment">| scaleX  skewX transX |
|  skewY scaleY transY |
| persp0 persp1 persp2 |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleX</td><td>horizontal scale factor to store </td></tr>
    <tr><td class="paramname">skewX</td><td>horizontal skew factor to store </td></tr>
    <tr><td class="paramname">transX</td><td>horizontal translation to store </td></tr>
    <tr><td class="paramname">skewY</td><td>vertical skew factor to store </td></tr>
    <tr><td class="paramname">scaleY</td><td>vertical scale factor to store </td></tr>
    <tr><td class="paramname">transY</td><td>vertical translation to store </td></tr>
    <tr><td class="paramname">persp0</td><td>input x-axis values perspective factor to store </td></tr>
    <tr><td class="paramname">persp1</td><td>input y-axis values perspective factor to store </td></tr>
    <tr><td class="paramname">persp2</td><td>perspective scale factor to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af825f7f6a030f1c8f5fdf659087f30c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af825f7f6a030f1c8f5fdf659087f30c0">&#9670;&nbsp;</a></span>setConcat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::setConcat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to <a class="el" href="class_sk_matrix.html">SkMatrix</a> a multiplied by <a class="el" href="class_sk_matrix.html">SkMatrix</a> b. Either a or b may be this.</p>
<p>Given: </p><pre class="fragment">    | A B C |      | J K L |
a = | D E F |, b = | M N O |
    | G H I |      | P Q R |
</pre><p>sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">        | A B C |   | J K L |   | AJ+BM+CP AK+BN+CQ AL+BO+CR |
a * b = | D E F | * | M N O | = | DJ+EM+FP DK+EN+FQ DL+EO+FR |
        | G H I |   | P Q R |   | GJ+HM+IP GK+HN+IQ GL+HO+IR |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_sk_matrix.html">SkMatrix</a> on left side of multiply expression </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_sk_matrix.html">SkMatrix</a> on right side of multiply expression </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6a40483f395bad9a0ddf912b8788780a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a40483f395bad9a0ddf912b8788780a">&#9670;&nbsp;</a></span>setIdentity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a>&amp; SkMatrix::setIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to identity; which has no effect on mapped <a class="el" href="struct_sk_point.html">SkPoint</a>. Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">| 1 0 0 |
| 0 1 0 |
| 0 0 1 |
</pre><p>Also called <a class="el" href="class_sk_matrix.html#ae2221ac28297780a070c8fc516b9bb50">reset()</a>; use the one that provides better inline documentation. </p>

</div>
</div>
<a id="a9ef0d22bbf1954bc498a97af455a9095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef0d22bbf1954bc498a97af455a9095">&#9670;&nbsp;</a></span>setPerspX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a>&amp; SkMatrix::setPerspX </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets input x-axis perspective factor, which causes <a class="el" href="class_sk_matrix.html#a7f948aea7bae490af1cbecec31ec2b0a">mapXY()</a> to vary input x-axis values inversely proportional to input y-axis values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>perspective factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29c4b9ef39f27ddb88c824319aa3e7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c4b9ef39f27ddb88c824319aa3e7a4">&#9670;&nbsp;</a></span>setPerspY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a>&amp; SkMatrix::setPerspY </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets input y-axis perspective factor, which causes <a class="el" href="class_sk_matrix.html#a7f948aea7bae490af1cbecec31ec2b0a">mapXY()</a> to vary input y-axis values inversely proportional to input x-axis values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>perspective factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a758cf57cf7a65c01a408125145c55531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a758cf57cf7a65c01a408125145c55531">&#9670;&nbsp;</a></span>setPolyToPoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::setPolyToPoly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>src</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>dst</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to map src to dst. count must be zero or greater, and four or less.</p>
<p>If count is zero, sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to identity and returns true. If count is one, sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to translate and returns true. If count is two or more, sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to map <a class="el" href="struct_sk_point.html">SkPoint</a> if possible; returns false if <a class="el" href="class_sk_matrix.html">SkMatrix</a> cannot be constructed. If count is four, <a class="el" href="class_sk_matrix.html">SkMatrix</a> may include perspective.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="struct_sk_point.html">SkPoint</a> to map from </td></tr>
    <tr><td class="paramname">dst</td><td><a class="el" href="struct_sk_point.html">SkPoint</a> to map to </td></tr>
    <tr><td class="paramname">count</td><td>number of <a class="el" href="struct_sk_point.html">SkPoint</a> in src and dst </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> was constructed successfully</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_setPolyToPoly">https://fiddle.skia.org/c/@Matrix_setPolyToPoly</a> </p>

</div>
</div>
<a id="ad1a47790b0eea536de853321b0fc5a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a47790b0eea536de853321b0fc5a32">&#9670;&nbsp;</a></span>setRectToRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkMatrix::setRectToRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_matrix.html#a4540975cfa4b120d8c162b8ffa37afb5">ScaleToFit</a>&#160;</td>
          <td class="paramname"><em>stf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to scale and translate src <a class="el" href="struct_sk_rect.html">SkRect</a> to dst <a class="el" href="struct_sk_rect.html">SkRect</a>. stf selects whether mapping completely fills dst or preserves the aspect ratio, and how to align src within dst. Returns false if src is empty, and sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to identity. Returns true if dst is empty, and sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to: </p><pre class="fragment">| 0 0 0 |
| 0 0 0 |
| 0 0 1 |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to map from </td></tr>
    <tr><td class="paramname">dst</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to map to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> can represent <a class="el" href="struct_sk_rect.html">SkRect</a> mapping</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_setRectToRect">https://fiddle.skia.org/c/@Matrix_setRectToRect</a> </p>

</div>
</div>
<a id="a39280d8756afece1a6d84093bb90e005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39280d8756afece1a6d84093bb90e005">&#9670;&nbsp;</a></span>setRotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::setRotate </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to rotate by degrees about a pivot point at (0, 0). Positive degrees rotates clockwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>angle of axes relative to upright axes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c2319c87e535a9c1f183e2b56927225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2319c87e535a9c1f183e2b56927225">&#9670;&nbsp;</a></span>setRotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::setRotate </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to rotate by degrees about a pivot point at (px, py). The pivot point is unchanged when mapped with <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Positive degrees rotates clockwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>angle of axes relative to upright axes </td></tr>
    <tr><td class="paramname">px</td><td>pivot on x-axis </td></tr>
    <tr><td class="paramname">py</td><td>pivot on y-axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e6cbb8e012f9e7af48addfc2d9e3fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6cbb8e012f9e7af48addfc2d9e3fab">&#9670;&nbsp;</a></span>setRSXform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::setRSXform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_r_s_xform.html">SkRSXform</a> &amp;&#160;</td>
          <td class="paramname"><em>rsxForm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to rotate, scale, and translate using a compressed matrix form.</p>
<p>Vector (rsxForm.fSSin, rsxForm.fSCos) describes the angle of rotation relative to (0, 1). Vector length specifies scale. Mapped point is rotated and scaled by vector, then translated by (rsxForm.fTx, rsxForm.fTy).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rsxForm</td><td>compressed <a class="el" href="struct_sk_r_s_xform.html">SkRSXform</a> matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_matrix.html">SkMatrix</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Matrix_setRSXform">https://fiddle.skia.org/c/@Matrix_setRSXform</a> </p>

</div>
</div>
<a id="aee997ca4e728bb0cdc8cb90ecfed6edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee997ca4e728bb0cdc8cb90ecfed6edc">&#9670;&nbsp;</a></span>setScale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::setScale </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to scale by sx and sy about at pivot point at (0, 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7037a86ecdfb3103f43fb2661f2d6463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7037a86ecdfb3103f43fb2661f2d6463">&#9670;&nbsp;</a></span>setScale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::setScale </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to scale by sx and sy, about a pivot point at (px, py). The pivot point is unchanged when mapped with <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor </td></tr>
    <tr><td class="paramname">px</td><td>pivot on x-axis </td></tr>
    <tr><td class="paramname">py</td><td>pivot on y-axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48845691e564d36b175183b6f7793398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48845691e564d36b175183b6f7793398">&#9670;&nbsp;</a></span>setScaleTranslate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkMatrix::setScaleTranslate </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>tx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>ty</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes <a class="el" href="class_sk_matrix.html">SkMatrix</a> with scale and translate elements. </p><pre class="fragment">| sx  0 tx |
|  0 sy ty |
|  0  0  1 |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>horizontal scale factor to store </td></tr>
    <tr><td class="paramname">sy</td><td>vertical scale factor to store </td></tr>
    <tr><td class="paramname">tx</td><td>horizontal translation to store </td></tr>
    <tr><td class="paramname">ty</td><td>vertical translation to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa02218687e3936ebb1f2f7b6d91ff008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa02218687e3936ebb1f2f7b6d91ff008">&#9670;&nbsp;</a></span>setScaleX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a>&amp; SkMatrix::setScaleX </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets horizontal scale factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>horizontal scale factor to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab935926217da50fc38d5d8b481b0d578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab935926217da50fc38d5d8b481b0d578">&#9670;&nbsp;</a></span>setScaleY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a>&amp; SkMatrix::setScaleY </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets vertical scale factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vertical scale factor to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad19b8a4a5bc152774ba119466d791145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad19b8a4a5bc152774ba119466d791145">&#9670;&nbsp;</a></span>setSinCos() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::setSinCos </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sinValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>cosValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to rotate by sinValue and cosValue, about a pivot point at (0, 0).</p>
<p>Vector (sinValue, cosValue) describes the angle of rotation relative to (0, 1). Vector length specifies scale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sinValue</td><td>rotation vector x-axis component </td></tr>
    <tr><td class="paramname">cosValue</td><td>rotation vector y-axis component </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74a33e5a90728cb3710bc30473590703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a33e5a90728cb3710bc30473590703">&#9670;&nbsp;</a></span>setSinCos() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::setSinCos </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sinValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>cosValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to rotate by sinValue and cosValue, about a pivot point at (px, py). The pivot point is unchanged when mapped with <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>Vector (sinValue, cosValue) describes the angle of rotation relative to (0, 1). Vector length specifies scale.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sinValue</td><td>rotation vector x-axis component </td></tr>
    <tr><td class="paramname">cosValue</td><td>rotation vector y-axis component </td></tr>
    <tr><td class="paramname">px</td><td>pivot on x-axis </td></tr>
    <tr><td class="paramname">py</td><td>pivot on y-axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11a7e60ba9f02c2df9e83ab7127cd9ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a7e60ba9f02c2df9e83ab7127cd9ba">&#9670;&nbsp;</a></span>setSkew() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::setSkew </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>ky</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to skew by kx and ky, about a pivot point at (0, 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kx</td><td>horizontal skew factor </td></tr>
    <tr><td class="paramname">ky</td><td>vertical skew factor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2f7d3a809ec23ab0d4b0e771807824a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2f7d3a809ec23ab0d4b0e771807824a">&#9670;&nbsp;</a></span>setSkew() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::setSkew </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>ky</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to skew by kx and ky, about a pivot point at (px, py). The pivot point is unchanged when mapped with <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kx</td><td>horizontal skew factor </td></tr>
    <tr><td class="paramname">ky</td><td>vertical skew factor </td></tr>
    <tr><td class="paramname">px</td><td>pivot on x-axis </td></tr>
    <tr><td class="paramname">py</td><td>pivot on y-axis </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37ce4987ab1b220c63a15149ee731172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37ce4987ab1b220c63a15149ee731172">&#9670;&nbsp;</a></span>setSkewX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a>&amp; SkMatrix::setSkewX </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets horizontal skew factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>horizontal skew factor to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05a8a44b2e3dc2bc02bb3184ef72a8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a8a44b2e3dc2bc02bb3184ef72a8f0">&#9670;&nbsp;</a></span>setSkewY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a>&amp; SkMatrix::setSkewY </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets vertical skew factor.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vertical skew factor to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c3b75a2f6700cd7cc86609d027354fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3b75a2f6700cd7cc86609d027354fa">&#9670;&nbsp;</a></span>setTranslate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a>&amp; SkMatrix::setTranslate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to translate by (v.fX, v.fY).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vector containing horizontal and vertical translation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ecd592abc53828e16e1822f156e3e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ecd592abc53828e16e1822f156e3e84">&#9670;&nbsp;</a></span>setTranslate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp; SkMatrix::setTranslate </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to translate by (dx, dy).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>horizontal translation </td></tr>
    <tr><td class="paramname">dy</td><td>vertical translation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae3ae4fb690aa217f7108d6c6d3b1ebfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3ae4fb690aa217f7108d6c6d3b1ebfe">&#9670;&nbsp;</a></span>setTranslateX()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a>&amp; SkMatrix::setTranslateX </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets horizontal translation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>horizontal translation to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a777d5779d7b2cee284498444ea590663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a777d5779d7b2cee284498444ea590663">&#9670;&nbsp;</a></span>setTranslateY()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a>&amp; SkMatrix::setTranslateY </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets vertical translation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>vertical translation to store </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8c9af45e5c110f6da777e5eebb5b55e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c9af45e5c110f6da777e5eebb5b55e8">&#9670;&nbsp;</a></span>Skew()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT SkMatrix::Skew </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>kx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>ky</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to skew by (kx, ky) about pivot point (0, 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kx</td><td>horizontal skew factor </td></tr>
    <tr><td class="paramname">ky</td><td>vertical skew factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_matrix.html">SkMatrix</a> with skew </dd></dl>

</div>
</div>
<a id="af67b155b025d42a116e1ee23f1a0e8eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67b155b025d42a116e1ee23f1a0e8eb">&#9670;&nbsp;</a></span>Translate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_sk_matrix.html">SkMatrix</a> SK_WARN_UNUSED_RESULT SkMatrix::Translate </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to translate by (dx, dy). Returned matrix is: </p><pre class="fragment">| 1 0 dx |
| 0 1 dy |
| 0 0  1 |
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>horizontal translation </td></tr>
    <tr><td class="paramname">dy</td><td>vertical translation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_matrix.html">SkMatrix</a> with translation </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a6dec58ac26e24e8be89fa2ddd325aaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dec58ac26e24e8be89fa2ddd325aaa2">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SK_API bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares a and b; returns true if a and b are not numerically equal. Returns false even if sign of zero values are different. Returns true if either <a class="el" href="class_sk_matrix.html">SkMatrix</a> contains NaN, even if the other <a class="el" href="class_sk_matrix.html">SkMatrix</a> also contains NaN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_sk_matrix.html">SkMatrix</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_sk_matrix.html">SkMatrix</a> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> a and <a class="el" href="class_sk_matrix.html">SkMatrix</a> b are numerically not equal </dd></dl>

</div>
</div>
<a id="a75f9c5b6475c169bd76e02da9e280eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f9c5b6475c169bd76e02da9e280eab">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SK_API bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares a and b; returns true if a and b are numerically equal. Returns true even if sign of zero values are different. Returns false if either <a class="el" href="class_sk_matrix.html">SkMatrix</a> contains NaN, even if the other <a class="el" href="class_sk_matrix.html">SkMatrix</a> also contains NaN.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_sk_matrix.html">SkMatrix</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_sk_matrix.html">SkMatrix</a> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_matrix.html">SkMatrix</a> a and <a class="el" href="class_sk_matrix.html">SkMatrix</a> b are numerically equal </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7ed7f43ec97f0063983c60c7513f7e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed7f43ec97f0063983c60c7513f7e7d">&#9670;&nbsp;</a></span>kAScaleX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int SkMatrix::kAScaleX = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>horizontal scale factor </p>
<p>Affine arrays are in column-major order to match the matrix used by PDF and XPS. </p>

</div>
</div>
<a id="a1d8855a83368b37e2968c206a2312a2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d8855a83368b37e2968c206a2312a2d">&#9670;&nbsp;</a></span>kMScaleX</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int SkMatrix::kMScaleX = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>horizontal scale factor </p>
<p><a class="el" href="class_sk_matrix.html">SkMatrix</a> organizes its values in row-major order. These members correspond to each value in <a class="el" href="class_sk_matrix.html">SkMatrix</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/include/core/<a class="el" href="_sk_matrix_8h_source.html">SkMatrix.h</a></li>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/src/core/SkMatrix.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
