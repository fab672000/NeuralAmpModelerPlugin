<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Eigen::SparseMatrix&lt; Scalar_, Options_, StorageIndex_ &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_eigen.html">Eigen</a></li><li class="navelem"><a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_eigen_1_1_sparse_matrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Eigen::SparseMatrix&lt; Scalar_, Options_, StorageIndex_ &gt; Class Template Reference<div class="ingroups"><a class="el" href="group___sparse__chapter.html">Sparse linear algebra</a> &raquo; <a class="el" href="group___sparse___reference.html">Reference</a> &raquo; <a class="el" href="group___sparse_core___module.html">SparseCore_Module</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A versatible sparse matrix representation.  
 <a href="class_eigen_1_1_sparse_matrix.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source.html">SparseMatrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Eigen::SparseMatrix&lt; Scalar_, Options_, StorageIndex_ &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_eigen_1_1_sparse_matrix.png" usemap="#Eigen::SparseMatrix_3C_20Scalar_5F_2C_20Options_5F_2C_20StorageIndex_5F_20_3E_map" alt=""/>
  <map id="Eigen::SparseMatrix_3C_20Scalar_5F_2C_20Options_5F_2C_20StorageIndex_5F_20_3E_map" name="Eigen::SparseMatrix_3C_20Scalar_5F_2C_20Options_5F_2C_20StorageIndex_5F_20_3E_map">
<area href="class_eigen_1_1_sparse_compressed_base.html" alt="Eigen::SparseCompressedBase&lt; SparseMatrix&lt; Scalar_, Options_, StorageIndex_ &gt; &gt;" shape="rect" coords="0,0,504,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_sparse_matrix_1_1_index_pos_pair.html">IndexPosPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix_1_1_singleton_vector.html">SingletonVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a691345e9899a2d839fede70a999236e4"><td class="memItemLeft" align="right" valign="top"><a id="a691345e9899a2d839fede70a999236e4"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>Options</b> = Options_
 }</td></tr>
<tr class="separator:a691345e9899a2d839fede70a999236e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c9dc4fbb171fc6dcab594233d7708c"><td class="memItemLeft" align="right" valign="top"><a id="aa2c9dc4fbb171fc6dcab594233d7708c"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>Options</b> = Options_
 }</td></tr>
<tr class="separator:aa2c9dc4fbb171fc6dcab594233d7708c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82ddf82aca8feb988166bbb4df7648fe"><td class="memItemLeft" align="right" valign="top"><a id="a82ddf82aca8feb988166bbb4df7648fe"></a>
typedef <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar, Flags, StorageIndex &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b></td></tr>
<tr class="separator:a82ddf82aca8feb988166bbb4df7648fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe476855efa1004607b543f45d91df73"><td class="memItemLeft" align="right" valign="top"><a id="abe476855efa1004607b543f45d91df73"></a>
typedef <a class="el" href="class_eigen_1_1_diagonal.html">Diagonal</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DiagonalReturnType</b></td></tr>
<tr class="separator:abe476855efa1004607b543f45d91df73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61b240f39819875dec55b79762e44ba"><td class="memItemLeft" align="right" valign="top"><a id="ac61b240f39819875dec55b79762e44ba"></a>
typedef <a class="el" href="class_eigen_1_1_diagonal.html">Diagonal</a>&lt; const <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstDiagonalReturnType</b></td></tr>
<tr class="separator:ac61b240f39819875dec55b79762e44ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59e12794ec77242f9219a65a7b9224a"><td class="memItemLeft" align="right" valign="top"><a id="ac59e12794ec77242f9219a65a7b9224a"></a>
typedef <a class="el" href="class_eigen_1_1_sparse_compressed_base_1_1_inner_iterator.html">Base::InnerIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>InnerIterator</b></td></tr>
<tr class="separator:ac59e12794ec77242f9219a65a7b9224a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e53848677e57de281a41b0b2f7f2d5"><td class="memItemLeft" align="right" valign="top"><a id="af4e53848677e57de281a41b0b2f7f2d5"></a>
typedef <a class="el" href="class_eigen_1_1_sparse_compressed_base_1_1_reverse_inner_iterator.html">Base::ReverseInnerIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ReverseInnerIterator</b></td></tr>
<tr class="separator:af4e53848677e57de281a41b0b2f7f2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc458fc0ae6e7326ca18dd754bc3107"><td class="memItemLeft" align="right" valign="top"><a id="a8bc458fc0ae6e7326ca18dd754bc3107"></a>
typedef <a class="el" href="class_eigen_1_1internal_1_1_compressed_storage.html">internal::CompressedStorage</a>&lt; Scalar, StorageIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Storage</b></td></tr>
<tr class="separator:a8bc458fc0ae6e7326ca18dd754bc3107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0420953aaf5136c95288622f0234dc63"><td class="memItemLeft" align="right" valign="top"><a id="a0420953aaf5136c95288622f0234dc63"></a>
typedef <a class="el" href="class_eigen_1_1_matrix.html">Base::IndexVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IndexVector</b></td></tr>
<tr class="separator:a0420953aaf5136c95288622f0234dc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1cf96cdef4e594ed5fee32ef8c1ba0"><td class="memItemLeft" align="right" valign="top"><a id="aef1cf96cdef4e594ed5fee32ef8c1ba0"></a>
typedef Base::ScalarVector&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarVector</b></td></tr>
<tr class="separator:aef1cf96cdef4e594ed5fee32ef8c1ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad0a1c7013ff97b74142c5fbbb6d46e"><td class="memItemLeft" align="right" valign="top"><a id="afad0a1c7013ff97b74142c5fbbb6d46e"></a>
typedef <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar, Options_, StorageIndex &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Map</b></td></tr>
<tr class="separator:afad0a1c7013ff97b74142c5fbbb6d46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe476855efa1004607b543f45d91df73"><td class="memItemLeft" align="right" valign="top"><a id="abe476855efa1004607b543f45d91df73"></a>
typedef <a class="el" href="class_eigen_1_1_diagonal.html">Diagonal</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>DiagonalReturnType</b></td></tr>
<tr class="separator:abe476855efa1004607b543f45d91df73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61b240f39819875dec55b79762e44ba"><td class="memItemLeft" align="right" valign="top"><a id="ac61b240f39819875dec55b79762e44ba"></a>
typedef <a class="el" href="class_eigen_1_1_diagonal.html">Diagonal</a>&lt; const <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ConstDiagonalReturnType</b></td></tr>
<tr class="separator:ac61b240f39819875dec55b79762e44ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59e12794ec77242f9219a65a7b9224a"><td class="memItemLeft" align="right" valign="top"><a id="ac59e12794ec77242f9219a65a7b9224a"></a>
typedef <a class="el" href="class_eigen_1_1_sparse_compressed_base_1_1_inner_iterator.html">Base::InnerIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>InnerIterator</b></td></tr>
<tr class="separator:ac59e12794ec77242f9219a65a7b9224a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e53848677e57de281a41b0b2f7f2d5"><td class="memItemLeft" align="right" valign="top"><a id="af4e53848677e57de281a41b0b2f7f2d5"></a>
typedef <a class="el" href="class_eigen_1_1_sparse_compressed_base_1_1_reverse_inner_iterator.html">Base::ReverseInnerIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><b>ReverseInnerIterator</b></td></tr>
<tr class="separator:af4e53848677e57de281a41b0b2f7f2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc458fc0ae6e7326ca18dd754bc3107"><td class="memItemLeft" align="right" valign="top"><a id="a8bc458fc0ae6e7326ca18dd754bc3107"></a>
typedef <a class="el" href="class_eigen_1_1internal_1_1_compressed_storage.html">internal::CompressedStorage</a>&lt; Scalar, StorageIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Storage</b></td></tr>
<tr class="separator:a8bc458fc0ae6e7326ca18dd754bc3107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0420953aaf5136c95288622f0234dc63"><td class="memItemLeft" align="right" valign="top"><a id="a0420953aaf5136c95288622f0234dc63"></a>
typedef <a class="el" href="class_eigen_1_1_matrix.html">Base::IndexVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IndexVector</b></td></tr>
<tr class="separator:a0420953aaf5136c95288622f0234dc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1cf96cdef4e594ed5fee32ef8c1ba0"><td class="memItemLeft" align="right" valign="top"><a id="aef1cf96cdef4e594ed5fee32ef8c1ba0"></a>
typedef Base::ScalarVector&#160;</td><td class="memItemRight" valign="bottom"><b>ScalarVector</b></td></tr>
<tr class="separator:aef1cf96cdef4e594ed5fee32ef8c1ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_eigen_1_1_sparse_compressed_base"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_eigen_1_1_sparse_compressed_base')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_eigen_1_1_sparse_compressed_base.html">Eigen::SparseCompressedBase&lt; SparseMatrix&lt; Scalar_, Options_, StorageIndex_ &gt; &gt;</a></td></tr>
<tr class="memitem:ae6242e9335f1e02eafe10debf8bd6b05 inherit pub_types_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="ae6242e9335f1e02eafe10debf8bd6b05"></a>
typedef <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b></td></tr>
<tr class="separator:ae6242e9335f1e02eafe10debf8bd6b05 inherit pub_types_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6242e9335f1e02eafe10debf8bd6b05 inherit pub_types_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="ae6242e9335f1e02eafe10debf8bd6b05"></a>
typedef <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; Derived &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Base</b></td></tr>
<tr class="separator:ae6242e9335f1e02eafe10debf8bd6b05 inherit pub_types_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a853a76dd42349fa2f3654a4a61e0f574"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a853a76dd42349fa2f3654a4a61e0f574">rows</a> () const</td></tr>
<tr class="separator:a853a76dd42349fa2f3654a4a61e0f574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b8cc95234b4e2de38a199b6b2af9fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a36b8cc95234b4e2de38a199b6b2af9fc">cols</a> () const</td></tr>
<tr class="separator:a36b8cc95234b4e2de38a199b6b2af9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6411a0a909423d2d843a2e7d8b8e4e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#aa6411a0a909423d2d843a2e7d8b8e4e7">innerSize</a> () const</td></tr>
<tr class="separator:aa6411a0a909423d2d843a2e7d8b8e4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c7cdf3c713ea69d08387aaf78e0c53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a47c7cdf3c713ea69d08387aaf78e0c53">outerSize</a> () const</td></tr>
<tr class="separator:a47c7cdf3c713ea69d08387aaf78e0c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed99bab9d4f142c629f69a93a2d1efb"><td class="memItemLeft" align="right" valign="top">const Scalar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a6ed99bab9d4f142c629f69a93a2d1efb">valuePtr</a> () const</td></tr>
<tr class="separator:a6ed99bab9d4f142c629f69a93a2d1efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9513f7d7336a698a47ff3135d6d555"><td class="memItemLeft" align="right" valign="top">Scalar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a5e9513f7d7336a698a47ff3135d6d555">valuePtr</a> ()</td></tr>
<tr class="separator:a5e9513f7d7336a698a47ff3135d6d555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3e26297390865d80a09d1ce06cc916"><td class="memItemLeft" align="right" valign="top">const StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ade3e26297390865d80a09d1ce06cc916">innerIndexPtr</a> () const</td></tr>
<tr class="separator:ade3e26297390865d80a09d1ce06cc916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f927d1e7251a78585b12bf451423d4e"><td class="memItemLeft" align="right" valign="top">StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a0f927d1e7251a78585b12bf451423d4e">innerIndexPtr</a> ()</td></tr>
<tr class="separator:a0f927d1e7251a78585b12bf451423d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d1a4d9033c2bc0917ea09cdc5c700c"><td class="memItemLeft" align="right" valign="top">const StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ad2d1a4d9033c2bc0917ea09cdc5c700c">outerIndexPtr</a> () const</td></tr>
<tr class="separator:ad2d1a4d9033c2bc0917ea09cdc5c700c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de5655e0e36dfefd9812d65f48092f9"><td class="memItemLeft" align="right" valign="top">StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a6de5655e0e36dfefd9812d65f48092f9">outerIndexPtr</a> ()</td></tr>
<tr class="separator:a6de5655e0e36dfefd9812d65f48092f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ba20726a10c2c9d095aed024297a2a"><td class="memItemLeft" align="right" valign="top">const StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a62ba20726a10c2c9d095aed024297a2a">innerNonZeroPtr</a> () const</td></tr>
<tr class="separator:a62ba20726a10c2c9d095aed024297a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa5da473fe96a8ae7fae6f3ca2d5b62"><td class="memItemLeft" align="right" valign="top">StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a0fa5da473fe96a8ae7fae6f3ca2d5b62">innerNonZeroPtr</a> ()</td></tr>
<tr class="separator:a0fa5da473fe96a8ae7fae6f3ca2d5b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae6da207cad2055c8e6a5f467b997ea"><td class="memItemLeft" align="right" valign="top"><a id="a8ae6da207cad2055c8e6a5f467b997ea"></a>
<a class="el" href="class_eigen_1_1internal_1_1_compressed_storage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> ()</td></tr>
<tr class="separator:a8ae6da207cad2055c8e6a5f467b997ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c695b6b9b4987ba9e616c03c337e6b"><td class="memItemLeft" align="right" valign="top"><a id="a10c695b6b9b4987ba9e616c03c337e6b"></a>
const <a class="el" href="class_eigen_1_1internal_1_1_compressed_storage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const</td></tr>
<tr class="separator:a10c695b6b9b4987ba9e616c03c337e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c9adc323553ed53726acae06fc4c18"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a05c9adc323553ed53726acae06fc4c18">coeff</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col) const</td></tr>
<tr class="separator:a05c9adc323553ed53726acae06fc4c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4f970149f1cbab1eecc2a04c291fb1"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a6e4f970149f1cbab1eecc2a04c291fb1">coeffRef</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col)</td></tr>
<tr class="separator:a6e4f970149f1cbab1eecc2a04c291fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d8f72ff86a300b76f9edd67df8d8fd"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ae2d8f72ff86a300b76f9edd67df8d8fd">insert</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col)</td></tr>
<tr class="separator:ae2d8f72ff86a300b76f9edd67df8d8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2feb71dd2ed222057a77ff92b736badc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a2feb71dd2ed222057a77ff92b736badc">setZero</a> ()</td></tr>
<tr class="separator:a2feb71dd2ed222057a77ff92b736badc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e36e669468663012b77bf1bff8cc4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ad9e36e669468663012b77bf1bff8cc4f">reserve</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> reserveSize)</td></tr>
<tr class="separator:ad9e36e669468663012b77bf1bff8cc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac881079cb90522f0e8392d47aa7adb7a"><td class="memTemplParams" colspan="2"><a id="ac881079cb90522f0e8392d47aa7adb7a"></a>
template&lt;class SizesType &gt; </td></tr>
<tr class="memitem:ac881079cb90522f0e8392d47aa7adb7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reserve</b> (const SizesType &amp;reserveSizes, const typename SizesType::value_type &amp;enableif=typename SizesType::value_type())</td></tr>
<tr class="separator:ac881079cb90522f0e8392d47aa7adb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46211f9f38f0cb99f7e2262fe634cd6"><td class="memItemLeft" align="right" valign="top"><a id="ad46211f9f38f0cb99f7e2262fe634cd6"></a>
Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertBack</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col)</td></tr>
<tr class="separator:ad46211f9f38f0cb99f7e2262fe634cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cac4cc4fe57ac796c344d3f68ff75fe"><td class="memItemLeft" align="right" valign="top"><a id="a4cac4cc4fe57ac796c344d3f68ff75fe"></a>
Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertBackByOuterInner</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> outer, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> inner)</td></tr>
<tr class="separator:a4cac4cc4fe57ac796c344d3f68ff75fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea808bafd08024942e2d96a1f5904031"><td class="memItemLeft" align="right" valign="top"><a id="aea808bafd08024942e2d96a1f5904031"></a>
Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertBackByOuterInnerUnordered</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> outer, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> inner)</td></tr>
<tr class="separator:aea808bafd08024942e2d96a1f5904031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bc66a0851cf65b23b70b1d602fee26"><td class="memItemLeft" align="right" valign="top"><a id="a42bc66a0851cf65b23b70b1d602fee26"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>startVec</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> outer)</td></tr>
<tr class="separator:a42bc66a0851cf65b23b70b1d602fee26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6046c670175cdb44e3c7909db56c5172"><td class="memItemLeft" align="right" valign="top"><a id="a6046c670175cdb44e3c7909db56c5172"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>finalize</b> ()</td></tr>
<tr class="separator:a6046c670175cdb44e3c7909db56c5172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f09e3597f37aa8861599260af6a53e0"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators &gt; </td></tr>
<tr class="memitem:a8f09e3597f37aa8861599260af6a53e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a8f09e3597f37aa8861599260af6a53e0">setFromTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end)</td></tr>
<tr class="separator:a8f09e3597f37aa8861599260af6a53e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8c96b7dd72d03f14b5cf40f5005d55"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators , typename DupFunctor &gt; </td></tr>
<tr class="memitem:a3e8c96b7dd72d03f14b5cf40f5005d55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a3e8c96b7dd72d03f14b5cf40f5005d55">setFromTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end, DupFunctor dup_func)</td></tr>
<tr class="separator:a3e8c96b7dd72d03f14b5cf40f5005d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6222c9a5338c413ec4edae119d454724"><td class="memItemLeft" align="right" valign="top"><a id="a6222c9a5338c413ec4edae119d454724"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sumupDuplicates</b> ()</td></tr>
<tr class="separator:a6222c9a5338c413ec4edae119d454724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef7fd1b03805b10906f3e6596de525c"><td class="memTemplParams" colspan="2"><a id="a3ef7fd1b03805b10906f3e6596de525c"></a>
template&lt;typename DupFunctor &gt; </td></tr>
<tr class="memitem:a3ef7fd1b03805b10906f3e6596de525c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>collapseDuplicates</b> (DupFunctor dup_func=DupFunctor())</td></tr>
<tr class="separator:a3ef7fd1b03805b10906f3e6596de525c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cacf861d0a03b22aec1c3c4b4f8b657"><td class="memItemLeft" align="right" valign="top"><a id="a6cacf861d0a03b22aec1c3c4b4f8b657"></a>
Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertByOuterInner</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> j, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> i)</td></tr>
<tr class="separator:a6cacf861d0a03b22aec1c3c4b4f8b657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6400e6e733a7131f9b776d6386d2ed89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a6400e6e733a7131f9b776d6386d2ed89">makeCompressed</a> ()</td></tr>
<tr class="separator:a6400e6e733a7131f9b776d6386d2ed89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542c2a877dcffbd48248b43d3eaf670f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a542c2a877dcffbd48248b43d3eaf670f">uncompress</a> ()</td></tr>
<tr class="separator:a542c2a877dcffbd48248b43d3eaf670f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b7ffe0c08f653f5c34b02b9b12e6bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ab4b7ffe0c08f653f5c34b02b9b12e6bf">prune</a> (const Scalar &amp;reference, const RealScalar &amp;epsilon=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; RealScalar &gt;::dummy_precision())</td></tr>
<tr class="separator:ab4b7ffe0c08f653f5c34b02b9b12e6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3916ec112e13c513380b47fad7954b"><td class="memTemplParams" colspan="2">template&lt;typename KeepFunc &gt; </td></tr>
<tr class="memitem:aca3916ec112e13c513380b47fad7954b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#aca3916ec112e13c513380b47fad7954b">prune</a> (const KeepFunc &amp;keep=KeepFunc())</td></tr>
<tr class="separator:aca3916ec112e13c513380b47fad7954b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e43ac03eb34e451e0f16e97ea2afda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ab0e43ac03eb34e451e0f16e97ea2afda">conservativeResize</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html#a853a76dd42349fa2f3654a4a61e0f574">rows</a>, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html#a36b8cc95234b4e2de38a199b6b2af9fc">cols</a>)</td></tr>
<tr class="separator:ab0e43ac03eb34e451e0f16e97ea2afda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835ae5b304ddbb187eac25d5850b2ced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a835ae5b304ddbb187eac25d5850b2ced">resize</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html#a853a76dd42349fa2f3654a4a61e0f574">rows</a>, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html#a36b8cc95234b4e2de38a199b6b2af9fc">cols</a>)</td></tr>
<tr class="separator:a835ae5b304ddbb187eac25d5850b2ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab903403b32107a7e91c53e8f1a1ff0eb"><td class="memItemLeft" align="right" valign="top"><a id="ab903403b32107a7e91c53e8f1a1ff0eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resizeNonZeros</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> size)</td></tr>
<tr class="separator:ab903403b32107a7e91c53e8f1a1ff0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20301b7b657f0948d6a6da68509fb4da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_diagonal.html">ConstDiagonalReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a20301b7b657f0948d6a6da68509fb4da">diagonal</a> () const</td></tr>
<tr class="separator:a20301b7b657f0948d6a6da68509fb4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f4db56c76e4d374eb8507fbef5bdb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_diagonal.html">DiagonalReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ae6f4db56c76e4d374eb8507fbef5bdb5">diagonal</a> ()</td></tr>
<tr class="separator:ae6f4db56c76e4d374eb8507fbef5bdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f28e83ea504f0d8ee76c4b8701939d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a4f28e83ea504f0d8ee76c4b8701939d6">SparseMatrix</a> ()</td></tr>
<tr class="separator:a4f28e83ea504f0d8ee76c4b8701939d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa647b5f0462b9986e3c907e9ca7c5984"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#aa647b5f0462b9986e3c907e9ca7c5984">SparseMatrix</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html#a853a76dd42349fa2f3654a4a61e0f574">rows</a>, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html#a36b8cc95234b4e2de38a199b6b2af9fc">cols</a>)</td></tr>
<tr class="separator:aa647b5f0462b9986e3c907e9ca7c5984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a6307cd6ba6b4ee7124d590d3120bf"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ac4a6307cd6ba6b4ee7124d590d3120bf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ac4a6307cd6ba6b4ee7124d590d3120bf">SparseMatrix</a> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:ac4a6307cd6ba6b4ee7124d590d3120bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794f49fa972d5d39fc81c0925aae1513"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived , unsigned int UpLo&gt; </td></tr>
<tr class="memitem:a794f49fa972d5d39fc81c0925aae1513"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a794f49fa972d5d39fc81c0925aae1513">SparseMatrix</a> (const <a class="el" href="class_eigen_1_1_sparse_self_adjoint_view.html">SparseSelfAdjointView</a>&lt; OtherDerived, UpLo &gt; &amp;other)</td></tr>
<tr class="separator:a794f49fa972d5d39fc81c0925aae1513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ce452dd42db3db4e262e955f7820aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a85ce452dd42db3db4e262e955f7820aa">SparseMatrix</a> (const <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;other)</td></tr>
<tr class="separator:a85ce452dd42db3db4e262e955f7820aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394987faa818eb6a0a5c9f92c3740f1a"><td class="memTemplParams" colspan="2"><a id="a394987faa818eb6a0a5c9f92c3740f1a"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a394987faa818eb6a0a5c9f92c3740f1a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a394987faa818eb6a0a5c9f92c3740f1a">SparseMatrix</a> (const <a class="el" href="class_eigen_1_1_return_by_value.html">ReturnByValue</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:a394987faa818eb6a0a5c9f92c3740f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with in-place evaluation. <br /></td></tr>
<tr class="separator:a394987faa818eb6a0a5c9f92c3740f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8a247192285453d402becafdd106c4"><td class="memTemplParams" colspan="2"><a id="a9c8a247192285453d402becafdd106c4"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a9c8a247192285453d402becafdd106c4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a9c8a247192285453d402becafdd106c4">SparseMatrix</a> (const <a class="el" href="class_eigen_1_1_diagonal_base.html">DiagonalBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:a9c8a247192285453d402becafdd106c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with in-place evaluation. <br /></td></tr>
<tr class="separator:a9c8a247192285453d402becafdd106c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20eec45a940a4dd7edcacfa21468b328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a20eec45a940a4dd7edcacfa21468b328">swap</a> (<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;other)</td></tr>
<tr class="separator:a20eec45a940a4dd7edcacfa21468b328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4064cc1e3a4038cf09ff03af5a3ffb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#aa4064cc1e3a4038cf09ff03af5a3ffb5">setIdentity</a> ()</td></tr>
<tr class="separator:aa4064cc1e3a4038cf09ff03af5a3ffb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1e29fbee762d9fc890e279c2969fa9"><td class="memItemLeft" align="right" valign="top"><a id="ace1e29fbee762d9fc890e279c2969fa9"></a>
<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;other)</td></tr>
<tr class="separator:ace1e29fbee762d9fc890e279c2969fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4723a57e84b89bb8a64eb6c44a860955"><td class="memTemplParams" colspan="2"><a id="a4723a57e84b89bb8a64eb6c44a860955"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a4723a57e84b89bb8a64eb6c44a860955"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a4723a57e84b89bb8a64eb6c44a860955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf46ae2a000529efeef7493bf44f241e"><td class="memTemplParams" colspan="2"><a id="abf46ae2a000529efeef7493bf44f241e"></a>
template&lt;typename Lhs , typename Rhs &gt; </td></tr>
<tr class="memitem:abf46ae2a000529efeef7493bf44f241e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; Lhs, Rhs, AliasFreeProduct &gt; &amp;other)</td></tr>
<tr class="separator:abf46ae2a000529efeef7493bf44f241e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7d2d6e4ae19526c6260eac3707123c"><td class="memTemplParams" colspan="2"><a id="a1d7d2d6e4ae19526c6260eac3707123c"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a1d7d2d6e4ae19526c6260eac3707123c"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DONT_INLINE <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a1d7d2d6e4ae19526c6260eac3707123c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac837d39f0ae378ecb132f5ef2d7fa74b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ac837d39f0ae378ecb132f5ef2d7fa74b">~SparseMatrix</a> ()</td></tr>
<tr class="separator:ac837d39f0ae378ecb132f5ef2d7fa74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b635a54bf2fe66facd1cb1872aae9f"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ad2b635a54bf2fe66facd1cb1872aae9f">sum</a> () const</td></tr>
<tr class="separator:ad2b635a54bf2fe66facd1cb1872aae9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432a162ad5f4e177c094f7585407129b"><td class="memItemLeft" align="right" valign="top"><a id="a432a162ad5f4e177c094f7585407129b"></a>
EIGEN_STRONG_INLINE Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertBackUncompressed</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col)</td></tr>
<tr class="separator:a432a162ad5f4e177c094f7585407129b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853a76dd42349fa2f3654a4a61e0f574"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a853a76dd42349fa2f3654a4a61e0f574">rows</a> () const</td></tr>
<tr class="separator:a853a76dd42349fa2f3654a4a61e0f574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b8cc95234b4e2de38a199b6b2af9fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a36b8cc95234b4e2de38a199b6b2af9fc">cols</a> () const</td></tr>
<tr class="separator:a36b8cc95234b4e2de38a199b6b2af9fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6411a0a909423d2d843a2e7d8b8e4e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#aa6411a0a909423d2d843a2e7d8b8e4e7">innerSize</a> () const</td></tr>
<tr class="separator:aa6411a0a909423d2d843a2e7d8b8e4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c7cdf3c713ea69d08387aaf78e0c53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a47c7cdf3c713ea69d08387aaf78e0c53">outerSize</a> () const</td></tr>
<tr class="separator:a47c7cdf3c713ea69d08387aaf78e0c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed99bab9d4f142c629f69a93a2d1efb"><td class="memItemLeft" align="right" valign="top">const Scalar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a6ed99bab9d4f142c629f69a93a2d1efb">valuePtr</a> () const</td></tr>
<tr class="separator:a6ed99bab9d4f142c629f69a93a2d1efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9513f7d7336a698a47ff3135d6d555"><td class="memItemLeft" align="right" valign="top">Scalar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a5e9513f7d7336a698a47ff3135d6d555">valuePtr</a> ()</td></tr>
<tr class="separator:a5e9513f7d7336a698a47ff3135d6d555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3e26297390865d80a09d1ce06cc916"><td class="memItemLeft" align="right" valign="top">const StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ade3e26297390865d80a09d1ce06cc916">innerIndexPtr</a> () const</td></tr>
<tr class="separator:ade3e26297390865d80a09d1ce06cc916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f927d1e7251a78585b12bf451423d4e"><td class="memItemLeft" align="right" valign="top">StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a0f927d1e7251a78585b12bf451423d4e">innerIndexPtr</a> ()</td></tr>
<tr class="separator:a0f927d1e7251a78585b12bf451423d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d1a4d9033c2bc0917ea09cdc5c700c"><td class="memItemLeft" align="right" valign="top">const StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ad2d1a4d9033c2bc0917ea09cdc5c700c">outerIndexPtr</a> () const</td></tr>
<tr class="separator:ad2d1a4d9033c2bc0917ea09cdc5c700c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de5655e0e36dfefd9812d65f48092f9"><td class="memItemLeft" align="right" valign="top">StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a6de5655e0e36dfefd9812d65f48092f9">outerIndexPtr</a> ()</td></tr>
<tr class="separator:a6de5655e0e36dfefd9812d65f48092f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ba20726a10c2c9d095aed024297a2a"><td class="memItemLeft" align="right" valign="top">const StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a62ba20726a10c2c9d095aed024297a2a">innerNonZeroPtr</a> () const</td></tr>
<tr class="separator:a62ba20726a10c2c9d095aed024297a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa5da473fe96a8ae7fae6f3ca2d5b62"><td class="memItemLeft" align="right" valign="top">StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a0fa5da473fe96a8ae7fae6f3ca2d5b62">innerNonZeroPtr</a> ()</td></tr>
<tr class="separator:a0fa5da473fe96a8ae7fae6f3ca2d5b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae6da207cad2055c8e6a5f467b997ea"><td class="memItemLeft" align="right" valign="top"><a id="a8ae6da207cad2055c8e6a5f467b997ea"></a>
<a class="el" href="class_eigen_1_1internal_1_1_compressed_storage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> ()</td></tr>
<tr class="separator:a8ae6da207cad2055c8e6a5f467b997ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c695b6b9b4987ba9e616c03c337e6b"><td class="memItemLeft" align="right" valign="top"><a id="a10c695b6b9b4987ba9e616c03c337e6b"></a>
const <a class="el" href="class_eigen_1_1internal_1_1_compressed_storage.html">Storage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>data</b> () const</td></tr>
<tr class="separator:a10c695b6b9b4987ba9e616c03c337e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c9adc323553ed53726acae06fc4c18"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a05c9adc323553ed53726acae06fc4c18">coeff</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col) const</td></tr>
<tr class="separator:a05c9adc323553ed53726acae06fc4c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4f970149f1cbab1eecc2a04c291fb1"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a6e4f970149f1cbab1eecc2a04c291fb1">coeffRef</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col)</td></tr>
<tr class="separator:a6e4f970149f1cbab1eecc2a04c291fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3911a1444c1c8afc25c8c205ab7a05c"><td class="memItemLeft" align="right" valign="top">Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ab3911a1444c1c8afc25c8c205ab7a05c">insert</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col)</td></tr>
<tr class="separator:ab3911a1444c1c8afc25c8c205ab7a05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2feb71dd2ed222057a77ff92b736badc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a2feb71dd2ed222057a77ff92b736badc">setZero</a> ()</td></tr>
<tr class="separator:a2feb71dd2ed222057a77ff92b736badc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e36e669468663012b77bf1bff8cc4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ad9e36e669468663012b77bf1bff8cc4f">reserve</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> reserveSize)</td></tr>
<tr class="separator:ad9e36e669468663012b77bf1bff8cc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac881079cb90522f0e8392d47aa7adb7a"><td class="memTemplParams" colspan="2"><a id="ac881079cb90522f0e8392d47aa7adb7a"></a>
template&lt;class SizesType &gt; </td></tr>
<tr class="memitem:ac881079cb90522f0e8392d47aa7adb7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reserve</b> (const SizesType &amp;reserveSizes, const typename SizesType::value_type &amp;enableif=typename SizesType::value_type())</td></tr>
<tr class="separator:ac881079cb90522f0e8392d47aa7adb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad46211f9f38f0cb99f7e2262fe634cd6"><td class="memItemLeft" align="right" valign="top"><a id="ad46211f9f38f0cb99f7e2262fe634cd6"></a>
Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertBack</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col)</td></tr>
<tr class="separator:ad46211f9f38f0cb99f7e2262fe634cd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cac4cc4fe57ac796c344d3f68ff75fe"><td class="memItemLeft" align="right" valign="top"><a id="a4cac4cc4fe57ac796c344d3f68ff75fe"></a>
Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertBackByOuterInner</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> outer, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> inner)</td></tr>
<tr class="separator:a4cac4cc4fe57ac796c344d3f68ff75fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea808bafd08024942e2d96a1f5904031"><td class="memItemLeft" align="right" valign="top"><a id="aea808bafd08024942e2d96a1f5904031"></a>
Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertBackByOuterInnerUnordered</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> outer, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> inner)</td></tr>
<tr class="separator:aea808bafd08024942e2d96a1f5904031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bc66a0851cf65b23b70b1d602fee26"><td class="memItemLeft" align="right" valign="top"><a id="a42bc66a0851cf65b23b70b1d602fee26"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>startVec</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> outer)</td></tr>
<tr class="separator:a42bc66a0851cf65b23b70b1d602fee26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6046c670175cdb44e3c7909db56c5172"><td class="memItemLeft" align="right" valign="top"><a id="a6046c670175cdb44e3c7909db56c5172"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>finalize</b> ()</td></tr>
<tr class="separator:a6046c670175cdb44e3c7909db56c5172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a549d8e75547dd49d0242a5e73fb4df27"><td class="memTemplParams" colspan="2"><a id="a549d8e75547dd49d0242a5e73fb4df27"></a>
template&lt;typename InputIterators &gt; </td></tr>
<tr class="memitem:a549d8e75547dd49d0242a5e73fb4df27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setFromTriplets</b> (const InputIterators &amp;begin, const InputIterators &amp;end)</td></tr>
<tr class="separator:a549d8e75547dd49d0242a5e73fb4df27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9db60b2c58dabb1e817a335d74a7bdf6"><td class="memTemplParams" colspan="2"><a id="a9db60b2c58dabb1e817a335d74a7bdf6"></a>
template&lt;typename InputIterators , typename DupFunctor &gt; </td></tr>
<tr class="memitem:a9db60b2c58dabb1e817a335d74a7bdf6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>setFromTriplets</b> (const InputIterators &amp;begin, const InputIterators &amp;end, DupFunctor dup_func)</td></tr>
<tr class="separator:a9db60b2c58dabb1e817a335d74a7bdf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14090a04f0018389fc6d1cf7d40667dd"><td class="memTemplParams" colspan="2"><a id="a14090a04f0018389fc6d1cf7d40667dd"></a>
template&lt;typename Derived , typename DupFunctor &gt; </td></tr>
<tr class="memitem:a14090a04f0018389fc6d1cf7d40667dd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>collapseDuplicates</b> (<a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a>&lt; Derived &gt; &amp;wi, DupFunctor dup_func=DupFunctor())</td></tr>
<tr class="separator:a14090a04f0018389fc6d1cf7d40667dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c6b1ee045d58ced163b140b9c6bf36"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators &gt; </td></tr>
<tr class="memitem:a39c6b1ee045d58ced163b140b9c6bf36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a39c6b1ee045d58ced163b140b9c6bf36">setFromSortedTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end)</td></tr>
<tr class="separator:a39c6b1ee045d58ced163b140b9c6bf36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73841eccfc1066680c7bed8bf98ec3e1"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators , typename DupFunctor &gt; </td></tr>
<tr class="memitem:a73841eccfc1066680c7bed8bf98ec3e1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a73841eccfc1066680c7bed8bf98ec3e1">setFromSortedTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end, DupFunctor dup_func)</td></tr>
<tr class="separator:a73841eccfc1066680c7bed8bf98ec3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5bf43559efce09f5415d6b66aa31d53"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators &gt; </td></tr>
<tr class="memitem:af5bf43559efce09f5415d6b66aa31d53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#af5bf43559efce09f5415d6b66aa31d53">insertFromTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end)</td></tr>
<tr class="separator:af5bf43559efce09f5415d6b66aa31d53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab452919fafc44dc6f8407fe4e5ffeddd"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators , typename DupFunctor &gt; </td></tr>
<tr class="memitem:ab452919fafc44dc6f8407fe4e5ffeddd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ab452919fafc44dc6f8407fe4e5ffeddd">insertFromTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end, DupFunctor dup_func)</td></tr>
<tr class="separator:ab452919fafc44dc6f8407fe4e5ffeddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5983337b43e23cf688a00a23e30cfffb"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators &gt; </td></tr>
<tr class="memitem:a5983337b43e23cf688a00a23e30cfffb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a5983337b43e23cf688a00a23e30cfffb">insertFromSortedTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end)</td></tr>
<tr class="separator:a5983337b43e23cf688a00a23e30cfffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f17d24f224a1fb73ab903e2a42aba4"><td class="memTemplParams" colspan="2">template&lt;typename InputIterators , typename DupFunctor &gt; </td></tr>
<tr class="memitem:a29f17d24f224a1fb73ab903e2a42aba4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a29f17d24f224a1fb73ab903e2a42aba4">insertFromSortedTriplets</a> (const InputIterators &amp;begin, const InputIterators &amp;end, DupFunctor dup_func)</td></tr>
<tr class="separator:a29f17d24f224a1fb73ab903e2a42aba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cacf861d0a03b22aec1c3c4b4f8b657"><td class="memItemLeft" align="right" valign="top"><a id="a6cacf861d0a03b22aec1c3c4b4f8b657"></a>
Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertByOuterInner</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> j, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> i)</td></tr>
<tr class="separator:a6cacf861d0a03b22aec1c3c4b4f8b657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6400e6e733a7131f9b776d6386d2ed89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a6400e6e733a7131f9b776d6386d2ed89">makeCompressed</a> ()</td></tr>
<tr class="separator:a6400e6e733a7131f9b776d6386d2ed89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a542c2a877dcffbd48248b43d3eaf670f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a542c2a877dcffbd48248b43d3eaf670f">uncompress</a> ()</td></tr>
<tr class="separator:a542c2a877dcffbd48248b43d3eaf670f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b7ffe0c08f653f5c34b02b9b12e6bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ab4b7ffe0c08f653f5c34b02b9b12e6bf">prune</a> (const Scalar &amp;reference, const RealScalar &amp;epsilon=<a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; RealScalar &gt;::dummy_precision())</td></tr>
<tr class="separator:ab4b7ffe0c08f653f5c34b02b9b12e6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3916ec112e13c513380b47fad7954b"><td class="memTemplParams" colspan="2">template&lt;typename KeepFunc &gt; </td></tr>
<tr class="memitem:aca3916ec112e13c513380b47fad7954b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#aca3916ec112e13c513380b47fad7954b">prune</a> (const KeepFunc &amp;keep=KeepFunc())</td></tr>
<tr class="separator:aca3916ec112e13c513380b47fad7954b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e43ac03eb34e451e0f16e97ea2afda"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ab0e43ac03eb34e451e0f16e97ea2afda">conservativeResize</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html#a853a76dd42349fa2f3654a4a61e0f574">rows</a>, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html#a36b8cc95234b4e2de38a199b6b2af9fc">cols</a>)</td></tr>
<tr class="separator:ab0e43ac03eb34e451e0f16e97ea2afda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a835ae5b304ddbb187eac25d5850b2ced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a835ae5b304ddbb187eac25d5850b2ced">resize</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html#a853a76dd42349fa2f3654a4a61e0f574">rows</a>, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html#a36b8cc95234b4e2de38a199b6b2af9fc">cols</a>)</td></tr>
<tr class="separator:a835ae5b304ddbb187eac25d5850b2ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab903403b32107a7e91c53e8f1a1ff0eb"><td class="memItemLeft" align="right" valign="top"><a id="ab903403b32107a7e91c53e8f1a1ff0eb"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>resizeNonZeros</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> size)</td></tr>
<tr class="separator:ab903403b32107a7e91c53e8f1a1ff0eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20301b7b657f0948d6a6da68509fb4da"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_diagonal.html">ConstDiagonalReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a20301b7b657f0948d6a6da68509fb4da">diagonal</a> () const</td></tr>
<tr class="separator:a20301b7b657f0948d6a6da68509fb4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6f4db56c76e4d374eb8507fbef5bdb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_diagonal.html">DiagonalReturnType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ae6f4db56c76e4d374eb8507fbef5bdb5">diagonal</a> ()</td></tr>
<tr class="separator:ae6f4db56c76e4d374eb8507fbef5bdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f28e83ea504f0d8ee76c4b8701939d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a4f28e83ea504f0d8ee76c4b8701939d6">SparseMatrix</a> ()</td></tr>
<tr class="separator:a4f28e83ea504f0d8ee76c4b8701939d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa647b5f0462b9986e3c907e9ca7c5984"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#aa647b5f0462b9986e3c907e9ca7c5984">SparseMatrix</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html#a853a76dd42349fa2f3654a4a61e0f574">rows</a>, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html#a36b8cc95234b4e2de38a199b6b2af9fc">cols</a>)</td></tr>
<tr class="separator:aa647b5f0462b9986e3c907e9ca7c5984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a6307cd6ba6b4ee7124d590d3120bf"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:ac4a6307cd6ba6b4ee7124d590d3120bf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ac4a6307cd6ba6b4ee7124d590d3120bf">SparseMatrix</a> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:ac4a6307cd6ba6b4ee7124d590d3120bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794f49fa972d5d39fc81c0925aae1513"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived , unsigned int UpLo&gt; </td></tr>
<tr class="memitem:a794f49fa972d5d39fc81c0925aae1513"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a794f49fa972d5d39fc81c0925aae1513">SparseMatrix</a> (const <a class="el" href="class_eigen_1_1_sparse_self_adjoint_view.html">SparseSelfAdjointView</a>&lt; OtherDerived, UpLo &gt; &amp;other)</td></tr>
<tr class="separator:a794f49fa972d5d39fc81c0925aae1513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacbbae87083903bc8a0032810e68d4d"><td class="memItemLeft" align="right" valign="top"><a id="afacbbae87083903bc8a0032810e68d4d"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SparseMatrix</b> (<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;&amp;other)</td></tr>
<tr class="separator:afacbbae87083903bc8a0032810e68d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ce452dd42db3db4e262e955f7820aa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a85ce452dd42db3db4e262e955f7820aa">SparseMatrix</a> (const <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;other)</td></tr>
<tr class="separator:a85ce452dd42db3db4e262e955f7820aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a394987faa818eb6a0a5c9f92c3740f1a"><td class="memTemplParams" colspan="2"><a id="a394987faa818eb6a0a5c9f92c3740f1a"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a394987faa818eb6a0a5c9f92c3740f1a"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a394987faa818eb6a0a5c9f92c3740f1a">SparseMatrix</a> (const <a class="el" href="class_eigen_1_1_return_by_value.html">ReturnByValue</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:a394987faa818eb6a0a5c9f92c3740f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with in-place evaluation. <br /></td></tr>
<tr class="separator:a394987faa818eb6a0a5c9f92c3740f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8a247192285453d402becafdd106c4"><td class="memTemplParams" colspan="2"><a id="a9c8a247192285453d402becafdd106c4"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a9c8a247192285453d402becafdd106c4"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a9c8a247192285453d402becafdd106c4">SparseMatrix</a> (const <a class="el" href="class_eigen_1_1_diagonal_base.html">DiagonalBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:a9c8a247192285453d402becafdd106c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor with in-place evaluation. <br /></td></tr>
<tr class="separator:a9c8a247192285453d402becafdd106c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20eec45a940a4dd7edcacfa21468b328"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a20eec45a940a4dd7edcacfa21468b328">swap</a> (<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;other)</td></tr>
<tr class="separator:a20eec45a940a4dd7edcacfa21468b328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4064cc1e3a4038cf09ff03af5a3ffb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#aa4064cc1e3a4038cf09ff03af5a3ffb5">setIdentity</a> ()</td></tr>
<tr class="separator:aa4064cc1e3a4038cf09ff03af5a3ffb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1e29fbee762d9fc890e279c2969fa9"><td class="memItemLeft" align="right" valign="top"><a id="ace1e29fbee762d9fc890e279c2969fa9"></a>
<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;other)</td></tr>
<tr class="separator:ace1e29fbee762d9fc890e279c2969fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbe34a408979949ec8678c7cf8850da"><td class="memItemLeft" align="right" valign="top"><a id="a3cbe34a408979949ec8678c7cf8850da"></a>
<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;&amp;other)</td></tr>
<tr class="separator:a3cbe34a408979949ec8678c7cf8850da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4723a57e84b89bb8a64eb6c44a860955"><td class="memTemplParams" colspan="2"><a id="a4723a57e84b89bb8a64eb6c44a860955"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a4723a57e84b89bb8a64eb6c44a860955"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a4723a57e84b89bb8a64eb6c44a860955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf46ae2a000529efeef7493bf44f241e"><td class="memTemplParams" colspan="2"><a id="abf46ae2a000529efeef7493bf44f241e"></a>
template&lt;typename Lhs , typename Rhs &gt; </td></tr>
<tr class="memitem:abf46ae2a000529efeef7493bf44f241e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; Lhs, Rhs, AliasFreeProduct &gt; &amp;other)</td></tr>
<tr class="separator:abf46ae2a000529efeef7493bf44f241e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7d2d6e4ae19526c6260eac3707123c"><td class="memTemplParams" colspan="2"><a id="a1d7d2d6e4ae19526c6260eac3707123c"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a1d7d2d6e4ae19526c6260eac3707123c"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DONT_INLINE <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a1d7d2d6e4ae19526c6260eac3707123c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac837d39f0ae378ecb132f5ef2d7fa74b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ac837d39f0ae378ecb132f5ef2d7fa74b">~SparseMatrix</a> ()</td></tr>
<tr class="separator:ac837d39f0ae378ecb132f5ef2d7fa74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bfe2c81a8afbd1bf2aa991a673c486d"><td class="memItemLeft" align="right" valign="top">Scalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#a5bfe2c81a8afbd1bf2aa991a673c486d">sum</a> () const</td></tr>
<tr class="separator:a5bfe2c81a8afbd1bf2aa991a673c486d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a432a162ad5f4e177c094f7585407129b"><td class="memItemLeft" align="right" valign="top"><a id="a432a162ad5f4e177c094f7585407129b"></a>
EIGEN_STRONG_INLINE Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertBackUncompressed</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col)</td></tr>
<tr class="separator:a432a162ad5f4e177c094f7585407129b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ab64396b1a71e60c822c53c2229282"><td class="memTemplParams" colspan="2"><a id="a61ab64396b1a71e60c822c53c2229282"></a>
template&lt;typename OtherDerived &gt; </td></tr>
<tr class="memitem:a61ab64396b1a71e60c822c53c2229282"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DONT_INLINE <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a61ab64396b1a71e60c822c53c2229282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7857c321fa3f3c74e41a3d5c7d852b3a"><td class="memTemplParams" colspan="2"><a id="a7857c321fa3f3c74e41a3d5c7d852b3a"></a>
template&lt;typename Lhs , typename Rhs &gt; </td></tr>
<tr class="memitem:a7857c321fa3f3c74e41a3d5c7d852b3a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; Lhs, Rhs, AliasFreeProduct &gt; &amp;src)</td></tr>
<tr class="separator:a7857c321fa3f3c74e41a3d5c7d852b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae257333ca0e0b16cf5d3080bbefeaf47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ae257333ca0e0b16cf5d3080bbefeaf47">isCompressed</a> () const</td></tr>
<tr class="separator:ae257333ca0e0b16cf5d3080bbefeaf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae257333ca0e0b16cf5d3080bbefeaf47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ae257333ca0e0b16cf5d3080bbefeaf47">isCompressed</a> () const</td></tr>
<tr class="separator:ae257333ca0e0b16cf5d3080bbefeaf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53743108cd668b8da927ff149631fe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ae53743108cd668b8da927ff149631fe0">nonZeros</a> () const</td></tr>
<tr class="separator:ae53743108cd668b8da927ff149631fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53743108cd668b8da927ff149631fe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ae53743108cd668b8da927ff149631fe0">nonZeros</a> () const</td></tr>
<tr class="separator:ae53743108cd668b8da927ff149631fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae257333ca0e0b16cf5d3080bbefeaf47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ae257333ca0e0b16cf5d3080bbefeaf47">isCompressed</a> () const</td></tr>
<tr class="separator:ae257333ca0e0b16cf5d3080bbefeaf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae257333ca0e0b16cf5d3080bbefeaf47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ae257333ca0e0b16cf5d3080bbefeaf47">isCompressed</a> () const</td></tr>
<tr class="separator:ae257333ca0e0b16cf5d3080bbefeaf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53743108cd668b8da927ff149631fe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ae53743108cd668b8da927ff149631fe0">nonZeros</a> () const</td></tr>
<tr class="separator:ae53743108cd668b8da927ff149631fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53743108cd668b8da927ff149631fe0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html#ae53743108cd668b8da927ff149631fe0">nonZeros</a> () const</td></tr>
<tr class="separator:ae53743108cd668b8da927ff149631fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_eigen_1_1_sparse_compressed_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_eigen_1_1_sparse_compressed_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_eigen_1_1_sparse_compressed_base.html">Eigen::SparseCompressedBase&lt; SparseMatrix&lt; Scalar_, Options_, StorageIndex_ &gt; &gt;</a></td></tr>
<tr class="memitem:ae53743108cd668b8da927ff149631fe0 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#ae53743108cd668b8da927ff149631fe0">nonZeros</a> () const</td></tr>
<tr class="separator:ae53743108cd668b8da927ff149631fe0 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53743108cd668b8da927ff149631fe0 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#ae53743108cd668b8da927ff149631fe0">nonZeros</a> () const</td></tr>
<tr class="separator:ae53743108cd668b8da927ff149631fe0 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891c75ed270dde48054db2603a774b76 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">const Scalar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a891c75ed270dde48054db2603a774b76">valuePtr</a> () const</td></tr>
<tr class="separator:a891c75ed270dde48054db2603a774b76 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3990734332d9ef15b09efaa552a2fb19 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">Scalar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a3990734332d9ef15b09efaa552a2fb19">valuePtr</a> ()</td></tr>
<tr class="separator:a3990734332d9ef15b09efaa552a2fb19 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891c75ed270dde48054db2603a774b76 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">const Scalar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a891c75ed270dde48054db2603a774b76">valuePtr</a> () const</td></tr>
<tr class="separator:a891c75ed270dde48054db2603a774b76 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3990734332d9ef15b09efaa552a2fb19 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">Scalar *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a3990734332d9ef15b09efaa552a2fb19">valuePtr</a> ()</td></tr>
<tr class="separator:a3990734332d9ef15b09efaa552a2fb19 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c50033e593cfe2729012fa4f8cb79e inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">const StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#ac0c50033e593cfe2729012fa4f8cb79e">innerIndexPtr</a> () const</td></tr>
<tr class="separator:ac0c50033e593cfe2729012fa4f8cb79e inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3fd9bf7f186dbfd4297d0dd003cabf inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a1d3fd9bf7f186dbfd4297d0dd003cabf">innerIndexPtr</a> ()</td></tr>
<tr class="separator:a1d3fd9bf7f186dbfd4297d0dd003cabf inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c50033e593cfe2729012fa4f8cb79e inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">const StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#ac0c50033e593cfe2729012fa4f8cb79e">innerIndexPtr</a> () const</td></tr>
<tr class="separator:ac0c50033e593cfe2729012fa4f8cb79e inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3fd9bf7f186dbfd4297d0dd003cabf inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a1d3fd9bf7f186dbfd4297d0dd003cabf">innerIndexPtr</a> ()</td></tr>
<tr class="separator:a1d3fd9bf7f186dbfd4297d0dd003cabf inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f41e3360fd9f0c749686c6ffb829a90 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">const StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a1f41e3360fd9f0c749686c6ffb829a90">outerIndexPtr</a> () const</td></tr>
<tr class="separator:a1f41e3360fd9f0c749686c6ffb829a90 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2602a8c30f924857be54ff6de5f47e inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a1d2602a8c30f924857be54ff6de5f47e">outerIndexPtr</a> ()</td></tr>
<tr class="separator:a1d2602a8c30f924857be54ff6de5f47e inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f41e3360fd9f0c749686c6ffb829a90 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">const StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a1f41e3360fd9f0c749686c6ffb829a90">outerIndexPtr</a> () const</td></tr>
<tr class="separator:a1f41e3360fd9f0c749686c6ffb829a90 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2602a8c30f924857be54ff6de5f47e inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a1d2602a8c30f924857be54ff6de5f47e">outerIndexPtr</a> ()</td></tr>
<tr class="separator:a1d2602a8c30f924857be54ff6de5f47e inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7780293a4b936231f7d0b687bc50347c inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">const StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a7780293a4b936231f7d0b687bc50347c">innerNonZeroPtr</a> () const</td></tr>
<tr class="separator:a7780293a4b936231f7d0b687bc50347c inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dad03980598adb585dbc1cee32d977 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#ac8dad03980598adb585dbc1cee32d977">innerNonZeroPtr</a> ()</td></tr>
<tr class="separator:ac8dad03980598adb585dbc1cee32d977 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7780293a4b936231f7d0b687bc50347c inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">const StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a7780293a4b936231f7d0b687bc50347c">innerNonZeroPtr</a> () const</td></tr>
<tr class="separator:a7780293a4b936231f7d0b687bc50347c inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8dad03980598adb585dbc1cee32d977 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#ac8dad03980598adb585dbc1cee32d977">innerNonZeroPtr</a> ()</td></tr>
<tr class="separator:ac8dad03980598adb585dbc1cee32d977 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae257333ca0e0b16cf5d3080bbefeaf47 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#ae257333ca0e0b16cf5d3080bbefeaf47">isCompressed</a> () const</td></tr>
<tr class="separator:ae257333ca0e0b16cf5d3080bbefeaf47 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae257333ca0e0b16cf5d3080bbefeaf47 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#ae257333ca0e0b16cf5d3080bbefeaf47">isCompressed</a> () const</td></tr>
<tr class="separator:ae257333ca0e0b16cf5d3080bbefeaf47 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb41e40b43f7dbe6fd8b3e9e3755172 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_map.html">Map</a>&lt; const <a class="el" href="class_eigen_1_1_array.html">Array</a>&lt; Scalar, Dynamic, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a9cb41e40b43f7dbe6fd8b3e9e3755172">coeffs</a> () const</td></tr>
<tr class="separator:a9cb41e40b43f7dbe6fd8b3e9e3755172 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff03e28a4bb93cd473d12452906065c2 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_map.html">Map</a>&lt; <a class="el" href="class_eigen_1_1_array.html">Array</a>&lt; Scalar, Dynamic, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#aff03e28a4bb93cd473d12452906065c2">coeffs</a> ()</td></tr>
<tr class="separator:aff03e28a4bb93cd473d12452906065c2 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb41e40b43f7dbe6fd8b3e9e3755172 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_map.html">Map</a>&lt; const <a class="el" href="class_eigen_1_1_array.html">Array</a>&lt; Scalar, Dynamic, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a9cb41e40b43f7dbe6fd8b3e9e3755172">coeffs</a> () const</td></tr>
<tr class="separator:a9cb41e40b43f7dbe6fd8b3e9e3755172 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff03e28a4bb93cd473d12452906065c2 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_map.html">Map</a>&lt; <a class="el" href="class_eigen_1_1_array.html">Array</a>&lt; Scalar, Dynamic, 1 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#aff03e28a4bb93cd473d12452906065c2">coeffs</a> ()</td></tr>
<tr class="separator:aff03e28a4bb93cd473d12452906065c2 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9ee05f51a5c63cd5c4bda5cc3280b5 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a8c9ee05f51a5c63cd5c4bda5cc3280b5">sortInnerIndices</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> begin, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> end)</td></tr>
<tr class="separator:a8c9ee05f51a5c63cd5c4bda5cc3280b5 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add78b04f3e35f6809422ee824ac60e53 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#add78b04f3e35f6809422ee824ac60e53">sortInnerIndices</a> ()</td></tr>
<tr class="separator:add78b04f3e35f6809422ee824ac60e53 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856967aafbe24158a9e511e1b4767721 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a856967aafbe24158a9e511e1b4767721">innerIndicesAreSorted</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> begin, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> end) const</td></tr>
<tr class="separator:a856967aafbe24158a9e511e1b4767721 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a102ae7b1c3a146f86d5011e4ac870c9f inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a102ae7b1c3a146f86d5011e4ac870c9f">innerIndicesAreSorted</a> () const</td></tr>
<tr class="separator:a102ae7b1c3a146f86d5011e4ac870c9f inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd8edc09b41d8fd24bb384c155f127b inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a8dd8edc09b41d8fd24bb384c155f127b"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a8dd8edc09b41d8fd24bb384c155f127b inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b9cf2473aa33aa22164334c307c342 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a85b9cf2473aa33aa22164334c307c342"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_return_by_value.html">ReturnByValue</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a85b9cf2473aa33aa22164334c307c342 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9a0c22d7e0acf07f1d4ac857860d7b inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a0e9a0c22d7e0acf07f1d4ac857860d7b"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a0e9a0c22d7e0acf07f1d4ac857860d7b inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74cadfeede22a20d026710f6e0249b5 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="aa74cadfeede22a20d026710f6e0249b5"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const Derived &amp;other)</td></tr>
<tr class="separator:aa74cadfeede22a20d026710f6e0249b5 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8523de7f7d0a32821dfe641af46ad188 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a8523de7f7d0a32821dfe641af46ad188"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a8523de7f7d0a32821dfe641af46ad188 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8033a3a3428212c0887b59da8a8eb11d inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a8033a3a3428212c0887b59da8a8eb11d"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_return_by_value.html">ReturnByValue</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a8033a3a3428212c0887b59da8a8eb11d inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32666b993a0d65a845c2b3af0644f35 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="ab32666b993a0d65a845c2b3af0644f35"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:ab32666b993a0d65a845c2b3af0644f35 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74cadfeede22a20d026710f6e0249b5 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="aa74cadfeede22a20d026710f6e0249b5"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const Derived &amp;other)</td></tr>
<tr class="separator:aa74cadfeede22a20d026710f6e0249b5 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2db4585386b6d4a043af6371c1a2ef inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a6d2db4585386b6d4a043af6371c1a2ef"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const Derived &amp;other)</td></tr>
<tr class="separator:a6d2db4585386b6d4a043af6371c1a2ef inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd8edc09b41d8fd24bb384c155f127b inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a8dd8edc09b41d8fd24bb384c155f127b"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a8dd8edc09b41d8fd24bb384c155f127b inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b9cf2473aa33aa22164334c307c342 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a85b9cf2473aa33aa22164334c307c342"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_return_by_value.html">ReturnByValue</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a85b9cf2473aa33aa22164334c307c342 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9a0c22d7e0acf07f1d4ac857860d7b inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a0e9a0c22d7e0acf07f1d4ac857860d7b"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a0e9a0c22d7e0acf07f1d4ac857860d7b inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74cadfeede22a20d026710f6e0249b5 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="aa74cadfeede22a20d026710f6e0249b5"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const Derived &amp;other)</td></tr>
<tr class="separator:aa74cadfeede22a20d026710f6e0249b5 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8523de7f7d0a32821dfe641af46ad188 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a8523de7f7d0a32821dfe641af46ad188"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a8523de7f7d0a32821dfe641af46ad188 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8033a3a3428212c0887b59da8a8eb11d inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a8033a3a3428212c0887b59da8a8eb11d"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_return_by_value.html">ReturnByValue</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:a8033a3a3428212c0887b59da8a8eb11d inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32666b993a0d65a845c2b3af0644f35 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="ab32666b993a0d65a845c2b3af0644f35"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="separator:ab32666b993a0d65a845c2b3af0644f35 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74cadfeede22a20d026710f6e0249b5 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="aa74cadfeede22a20d026710f6e0249b5"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const Derived &amp;other)</td></tr>
<tr class="separator:aa74cadfeede22a20d026710f6e0249b5 inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2db4585386b6d4a043af6371c1a2ef inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a6d2db4585386b6d4a043af6371c1a2ef"></a>
Derived &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const Derived &amp;other)</td></tr>
<tr class="separator:a6d2db4585386b6d4a043af6371c1a2ef inherit pub_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:aa69a39f979185401dacefbd7a8f63b45"><td class="memItemLeft" align="right" valign="top"><a id="aa69a39f979185401dacefbd7a8f63b45"></a>
typedef <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar,(Flags &amp;~<a class="el" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a>)|(IsRowMajor?RowMajorBit:0), StorageIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TransposedSparseMatrix</b></td></tr>
<tr class="separator:aa69a39f979185401dacefbd7a8f63b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b4ae929a173403f05ed043a823287b"><td class="memItemLeft" align="right" valign="top"><a id="a62b4ae929a173403f05ed043a823287b"></a>
typedef <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar, IsRowMajor ? <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a">ColMajor</a> :<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3">RowMajor</a>, StorageIndex &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>TransposedSparseMatrix</b></td></tr>
<tr class="separator:a62b4ae929a173403f05ed043a823287b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_types_class_eigen_1_1_sparse_compressed_base"><td colspan="2" onclick="javascript:toggleInherit('pro_types_class_eigen_1_1_sparse_compressed_base')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="class_eigen_1_1_sparse_compressed_base.html">Eigen::SparseCompressedBase&lt; SparseMatrix&lt; Scalar_, Options_, StorageIndex_ &gt; &gt;</a></td></tr>
<tr class="memitem:a7711e74128319af99b2dbc9e70df7aad inherit pro_types_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a7711e74128319af99b2dbc9e70df7aad"></a>
typedef <a class="el" href="class_eigen_1_1_matrix.html">Base::IndexVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IndexVector</b></td></tr>
<tr class="separator:a7711e74128319af99b2dbc9e70df7aad inherit pro_types_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7711e74128319af99b2dbc9e70df7aad inherit pro_types_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a7711e74128319af99b2dbc9e70df7aad"></a>
typedef <a class="el" href="class_eigen_1_1_matrix.html">Base::IndexVector</a>&#160;</td><td class="memItemRight" valign="bottom"><b>IndexVector</b></td></tr>
<tr class="separator:a7711e74128319af99b2dbc9e70df7aad inherit pro_types_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6279d14bb06354f2b149185903d2886c"><td class="memTemplParams" colspan="2"><a id="a6279d14bb06354f2b149185903d2886c"></a>
template&lt;class SizesType &gt; </td></tr>
<tr class="memitem:a6279d14bb06354f2b149185903d2886c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reserveInnerVectors</b> (const SizesType &amp;reserveSizes)</td></tr>
<tr class="separator:a6279d14bb06354f2b149185903d2886c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efecfb5d8d51eac0ad988f09e726b8d"><td class="memTemplParams" colspan="2"><a id="a6efecfb5d8d51eac0ad988f09e726b8d"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a6efecfb5d8d51eac0ad988f09e726b8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>initAssignment</b> (const Other &amp;other)</td></tr>
<tr class="separator:a6efecfb5d8d51eac0ad988f09e726b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016b1a91367a894e6d77e84a539e3df8"><td class="memItemLeft" align="right" valign="top"><a id="a016b1a91367a894e6d77e84a539e3df8"></a>
EIGEN_DONT_INLINE Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertCompressed</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col)</td></tr>
<tr class="separator:a016b1a91367a894e6d77e84a539e3df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a5db16bd5830276dc4f452c5d097a5"><td class="memItemLeft" align="right" valign="top"><a id="a18a5db16bd5830276dc4f452c5d097a5"></a>
EIGEN_DONT_INLINE Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertUncompressed</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col)</td></tr>
<tr class="separator:a18a5db16bd5830276dc4f452c5d097a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d82c0cbc0c3996b5d1b8b89a5f60b71"><td class="memTemplParams" colspan="2"><a id="a2d82c0cbc0c3996b5d1b8b89a5f60b71"></a>
template&lt;typename DiagXpr , typename Func &gt; </td></tr>
<tr class="memitem:a2d82c0cbc0c3996b5d1b8b89a5f60b71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assignDiagonal</b> (const DiagXpr diagXpr, const Func &amp;assignFunc)</td></tr>
<tr class="separator:a2d82c0cbc0c3996b5d1b8b89a5f60b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6279d14bb06354f2b149185903d2886c"><td class="memTemplParams" colspan="2"><a id="a6279d14bb06354f2b149185903d2886c"></a>
template&lt;class SizesType &gt; </td></tr>
<tr class="memitem:a6279d14bb06354f2b149185903d2886c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reserveInnerVectors</b> (const SizesType &amp;reserveSizes)</td></tr>
<tr class="separator:a6279d14bb06354f2b149185903d2886c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6efecfb5d8d51eac0ad988f09e726b8d"><td class="memTemplParams" colspan="2"><a id="a6efecfb5d8d51eac0ad988f09e726b8d"></a>
template&lt;typename Other &gt; </td></tr>
<tr class="memitem:a6efecfb5d8d51eac0ad988f09e726b8d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>initAssignment</b> (const Other &amp;other)</td></tr>
<tr class="separator:a6efecfb5d8d51eac0ad988f09e726b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870b028fce0f75cda9c7f524e5de57cb"><td class="memItemLeft" align="right" valign="top"><a id="a870b028fce0f75cda9c7f524e5de57cb"></a>
EIGEN_DEPRECATED EIGEN_DONT_INLINE Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertCompressed</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col)</td></tr>
<tr class="separator:a870b028fce0f75cda9c7f524e5de57cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4f80d46d047a3001be911a3a696002"><td class="memItemLeft" align="right" valign="top"><a id="a5c4f80d46d047a3001be911a3a696002"></a>
EIGEN_DEPRECATED EIGEN_DONT_INLINE Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertUncompressed</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col)</td></tr>
<tr class="separator:a5c4f80d46d047a3001be911a3a696002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d82c0cbc0c3996b5d1b8b89a5f60b71"><td class="memTemplParams" colspan="2"><a id="a2d82c0cbc0c3996b5d1b8b89a5f60b71"></a>
template&lt;typename DiagXpr , typename Func &gt; </td></tr>
<tr class="memitem:a2d82c0cbc0c3996b5d1b8b89a5f60b71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>assignDiagonal</b> (const DiagXpr diagXpr, const Func &amp;assignFunc)</td></tr>
<tr class="separator:a2d82c0cbc0c3996b5d1b8b89a5f60b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec3e1d303327378164371e16d9b49c3"><td class="memItemLeft" align="right" valign="top"><a id="afec3e1d303327378164371e16d9b49c3"></a>
EIGEN_STRONG_INLINE Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertAtByOuterInner</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> outer, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> inner, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> dst)</td></tr>
<tr class="separator:afec3e1d303327378164371e16d9b49c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067731d09fd181ce0a1f10f66c65de14"><td class="memItemLeft" align="right" valign="top"><a id="a067731d09fd181ce0a1f10f66c65de14"></a>
Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertCompressedAtByOuterInner</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> outer, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> inner, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> dst)</td></tr>
<tr class="separator:a067731d09fd181ce0a1f10f66c65de14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21caf616236a1f91620d09abd7582641"><td class="memItemLeft" align="right" valign="top"><a id="a21caf616236a1f91620d09abd7582641"></a>
Scalar &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>insertUncompressedAtByOuterInner</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> outer, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> inner, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> dst)</td></tr>
<tr class="separator:a21caf616236a1f91620d09abd7582641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_eigen_1_1_sparse_compressed_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_eigen_1_1_sparse_compressed_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_eigen_1_1_sparse_compressed_base.html">Eigen::SparseCompressedBase&lt; SparseMatrix&lt; Scalar_, Options_, StorageIndex_ &gt; &gt;</a></td></tr>
<tr class="memitem:a95494aab39b92fbe37084d68695bb2f5 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a95494aab39b92fbe37084d68695bb2f5"></a>
<a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>innerNonZeros</b> ()</td></tr>
<tr class="separator:a95494aab39b92fbe37084d68695bb2f5 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a87aaf84e11b46fd4b5ca0529488a1 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a08a87aaf84e11b46fd4b5ca0529488a1"></a>
const <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; const <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>innerNonZeros</b> () const</td></tr>
<tr class="separator:a08a87aaf84e11b46fd4b5ca0529488a1 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95494aab39b92fbe37084d68695bb2f5 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a95494aab39b92fbe37084d68695bb2f5"></a>
<a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>innerNonZeros</b> ()</td></tr>
<tr class="separator:a95494aab39b92fbe37084d68695bb2f5 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a87aaf84e11b46fd4b5ca0529488a1 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a08a87aaf84e11b46fd4b5ca0529488a1"></a>
const <a class="el" href="class_eigen_1_1_map.html">Eigen::Map</a>&lt; const <a class="el" href="class_eigen_1_1_matrix.html">IndexVector</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>innerNonZeros</b> () const</td></tr>
<tr class="separator:a08a87aaf84e11b46fd4b5ca0529488a1 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6bf2cb53121f653f4212e45922a830 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a4d6bf2cb53121f653f4212e45922a830">SparseCompressedBase</a> ()</td></tr>
<tr class="separator:a4d6bf2cb53121f653f4212e45922a830 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d6bf2cb53121f653f4212e45922a830 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html#a4d6bf2cb53121f653f4212e45922a830">SparseCompressedBase</a> ()</td></tr>
<tr class="separator:a4d6bf2cb53121f653f4212e45922a830 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3a990d051b448258502cc1097e2714 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a1a3a990d051b448258502cc1097e2714"></a>
<a class="el" href="struct_eigen_1_1internal_1_1_lower_bound_index.html">internal::LowerBoundIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lower_bound</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col) const</td></tr>
<tr class="separator:a1a3a990d051b448258502cc1097e2714 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3a990d051b448258502cc1097e2714 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memItemLeft" align="right" valign="top"><a id="a1a3a990d051b448258502cc1097e2714"></a>
<a class="el" href="struct_eigen_1_1internal_1_1_lower_bound_index.html">internal::LowerBoundIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><b>lower_bound</b> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> row, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> col) const</td></tr>
<tr class="separator:a1a3a990d051b448258502cc1097e2714 inherit pro_methods_class_eigen_1_1_sparse_compressed_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a6ae44163705c2ca028527caa60c8c148"><td class="memItemLeft" align="right" valign="top"><a id="a6ae44163705c2ca028527caa60c8c148"></a>
<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_outerSize</b></td></tr>
<tr class="separator:a6ae44163705c2ca028527caa60c8c148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c29e0b9abac0a43d228562a3551ddc"><td class="memItemLeft" align="right" valign="top"><a id="af0c29e0b9abac0a43d228562a3551ddc"></a>
<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_innerSize</b></td></tr>
<tr class="separator:af0c29e0b9abac0a43d228562a3551ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7969fc27848623744ad1b88c31317728"><td class="memItemLeft" align="right" valign="top"><a id="a7969fc27848623744ad1b88c31317728"></a>
StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><b>m_outerIndex</b></td></tr>
<tr class="separator:a7969fc27848623744ad1b88c31317728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01652a1dffe9d922a21427997b02cd23"><td class="memItemLeft" align="right" valign="top"><a id="a01652a1dffe9d922a21427997b02cd23"></a>
StorageIndex *&#160;</td><td class="memItemRight" valign="bottom"><b>m_innerNonZeros</b></td></tr>
<tr class="separator:a01652a1dffe9d922a21427997b02cd23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140a4a7d53b455ecc94fb858fc9daa9f"><td class="memItemLeft" align="right" valign="top"><a id="a140a4a7d53b455ecc94fb858fc9daa9f"></a>
<a class="el" href="class_eigen_1_1internal_1_1_compressed_storage.html">Storage</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_data</b></td></tr>
<tr class="separator:a140a4a7d53b455ecc94fb858fc9daa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5140946cd5ed916fc012c8f086cf48e3"><td class="memItemLeft" align="right" valign="top"><a id="a5140946cd5ed916fc012c8f086cf48e3"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SparseVector&lt; Scalar_, 0, StorageIndex_ &gt;</b></td></tr>
<tr class="separator:a5140946cd5ed916fc012c8f086cf48e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73cc30ad676def82be71665641e5256f"><td class="memTemplParams" colspan="2"><a id="a73cc30ad676def82be71665641e5256f"></a>
template&lt;typename , typename , typename , typename , typename &gt; </td></tr>
<tr class="memitem:a73cc30ad676def82be71665641e5256f"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>internal::Assignment</b></td></tr>
<tr class="separator:a73cc30ad676def82be71665641e5256f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cb03fccbdb1456601051ffa6522c46"><td class="memItemLeft" align="right" valign="top"><a id="ae7cb03fccbdb1456601051ffa6522c46"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;m)</td></tr>
<tr class="separator:ae7cb03fccbdb1456601051ffa6522c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cb03fccbdb1456601051ffa6522c46"><td class="memItemLeft" align="right" valign="top"><a id="ae7cb03fccbdb1456601051ffa6522c46"></a>
std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> &amp;m)</td></tr>
<tr class="separator:ae7cb03fccbdb1456601051ffa6522c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4a0dbeb79ee3734a3399020d7dfdfbf"><td class="memTemplParams" colspan="2"><a id="ae4a0dbeb79ee3734a3399020d7dfdfbf"></a>
template&lt;typename , typename , typename , typename , typename &gt; </td></tr>
<tr class="memitem:ae4a0dbeb79ee3734a3399020d7dfdfbf"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><b>internal::Assignment</b></td></tr>
<tr class="separator:ae4a0dbeb79ee3734a3399020d7dfdfbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Scalar_, int Options_, typename StorageIndex_&gt;<br />
class Eigen::SparseMatrix&lt; Scalar_, Options_, StorageIndex_ &gt;</h3>

<p>A versatible sparse matrix representation. </p>
<p>This class implements a more versatile variants of the common <em>compressed</em> row/column storage format. Each colmun's (resp. row) non zeros are stored as a pair of value with associated row (resp. colmiun) index. All the non zeros are stored in a single large buffer. Unlike the <em>compressed</em> format, there might be extra space in between the nonzeros of two successive colmuns (resp. rows) such that insertion of new non-zero can be done with limited memory reallocation and copies.</p>
<p>A call to the function <a class="el" href="class_eigen_1_1_sparse_matrix.html#a6400e6e733a7131f9b776d6386d2ed89">makeCompressed()</a> turns the matrix into the standard <em>compressed</em> format compatible with many library.</p>
<p>More details on this storage sceheme are given in the <a class="el" href="group___tutorial_sparse.html">manual pages</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Scalar_</td><td>the scalar type, i.e. the type of the coefficients </td></tr>
    <tr><td class="paramname">Options_</td><td>Union of bit flags controlling the storage scheme. Currently the only possibility is ColMajor or RowMajor. The default is 0 which means column-major. </td></tr>
    <tr><td class="paramname">StorageIndex_</td><td>the type of the indices. It has to be a <b>signed</b> type (e.g., short, int, std::ptrdiff_t). Default is <code>int</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>In Eigen 3.2, the undocumented type <code>SparseMatrix::Index</code> was improperly defined as the storage index type (e.g., int), whereas it is now (starting from Eigen 3.3) deprecated and always defined as <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde" title="The Index type as used for the API.">Eigen::Index</a>. Codes making use of <code>SparseMatrix::Index</code>, might thus likely have to be changed to use <code>SparseMatrix::StorageIndex</code> instead.</dd></dl>
<p>This class can be extended with the help of the plugin mechanism described on the page <a class="el" href="_topic_customizing__plugins.html">Extending MatrixBase (and other classes)</a> by defining the preprocessor symbol <code>EIGEN_SPARSEMATRIX_PLUGIN</code>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4f28e83ea504f0d8ee76c4b8701939d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f28e83ea504f0d8ee76c4b8701939d6">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor yielding an empty <code>0</code> <code>x</code> <code>0</code> matrix </p>

</div>
</div>
<a id="aa647b5f0462b9986e3c907e9ca7c5984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa647b5f0462b9986e3c907e9ca7c5984">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a <em>rows</em> <code>x</code> <em>cols</em> empty matrix </p>

</div>
</div>
<a id="ac4a6307cd6ba6b4ee7124d590d3120bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a6307cd6ba6b4ee7124d590d3120bf">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a sparse matrix from the sparse expression <em>other</em> </p>

</div>
</div>
<a id="a794f49fa972d5d39fc81c0925aae1513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794f49fa972d5d39fc81c0925aae1513">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived , unsigned int UpLo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_self_adjoint_view.html">SparseSelfAdjointView</a>&lt; OtherDerived, UpLo &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a sparse matrix from the sparse selfadjoint view <em>other</em> </p>

</div>
</div>
<a id="a85ce452dd42db3db4e262e955f7820aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ce452dd42db3db4e262e955f7820aa">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor (it performs a deep copy) </p>

</div>
</div>
<a id="ac837d39f0ae378ecb132f5ef2d7fa74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac837d39f0ae378ecb132f5ef2d7fa74b">&#9670;&nbsp;</a></span>~SparseMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::~<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<a id="a4f28e83ea504f0d8ee76c4b8701939d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f28e83ea504f0d8ee76c4b8701939d6">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor yielding an empty <code>0</code> <code>x</code> <code>0</code> matrix </p>

</div>
</div>
<a id="aa647b5f0462b9986e3c907e9ca7c5984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa647b5f0462b9986e3c907e9ca7c5984">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a <em>rows</em> <code>x</code> <em>cols</em> empty matrix </p>

</div>
</div>
<a id="ac4a6307cd6ba6b4ee7124d590d3120bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a6307cd6ba6b4ee7124d590d3120bf">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a sparse matrix from the sparse expression <em>other</em> </p>

</div>
</div>
<a id="a794f49fa972d5d39fc81c0925aae1513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794f49fa972d5d39fc81c0925aae1513">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename OtherDerived , unsigned int UpLo&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_self_adjoint_view.html">SparseSelfAdjointView</a>&lt; OtherDerived, UpLo &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a sparse matrix from the sparse selfadjoint view <em>other</em> </p>

</div>
</div>
<a id="a85ce452dd42db3db4e262e955f7820aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ce452dd42db3db4e262e955f7820aa">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor (it performs a deep copy) </p>

</div>
</div>
<a id="ac837d39f0ae378ecb132f5ef2d7fa74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac837d39f0ae378ecb132f5ef2d7fa74b">&#9670;&nbsp;</a></span>~SparseMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::~<a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a05c9adc323553ed53726acae06fc4c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c9adc323553ed53726acae06fc4c18">&#9670;&nbsp;</a></span>coeff() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::coeff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the value of the matrix at position <em>i</em>, <em>j</em> This function returns Scalar(0) if the element is an explicit <em>zero</em> </dd></dl>

</div>
</div>
<a id="a05c9adc323553ed53726acae06fc4c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05c9adc323553ed53726acae06fc4c18">&#9670;&nbsp;</a></span>coeff() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::coeff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the value of the matrix at position <em>i</em>, <em>j</em> This function returns Scalar(0) if the element is an explicit <em>zero</em> </dd></dl>

</div>
</div>
<a id="a6e4f970149f1cbab1eecc2a04c291fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4f970149f1cbab1eecc2a04c291fb1">&#9670;&nbsp;</a></span>coeffRef() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar&amp; <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::coeffRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const reference to the value of the matrix at position <em>i</em>, <em>j</em> </dd></dl>
<p>If the element does not exist then it is inserted via the <a class="el" href="class_eigen_1_1_sparse_matrix.html#ae2d8f72ff86a300b76f9edd67df8d8fd">insert(Index,Index)</a> function which itself turns the matrix into a non compressed form if that was not the case.</p>
<p>This is a O(log(nnz_j)) operation (binary search) plus the cost of <a class="el" href="class_eigen_1_1_sparse_matrix.html#ae2d8f72ff86a300b76f9edd67df8d8fd">insert(Index,Index)</a> function if the element does not already exist. </p>

</div>
</div>
<a id="a6e4f970149f1cbab1eecc2a04c291fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4f970149f1cbab1eecc2a04c291fb1">&#9670;&nbsp;</a></span>coeffRef() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar&amp; <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::coeffRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const reference to the value of the matrix at position <em>i</em>, <em>j</em> </dd></dl>
<p>If the element does not exist then it is inserted via the <a class="el" href="class_eigen_1_1_sparse_matrix.html#ae2d8f72ff86a300b76f9edd67df8d8fd">insert(Index,Index)</a> function which itself turns the matrix into a non compressed form if that was not the case.</p>
<p>This is a O(log(nnz_j)) operation (binary search) plus the cost of <a class="el" href="class_eigen_1_1_sparse_matrix.html#ae2d8f72ff86a300b76f9edd67df8d8fd">insert(Index,Index)</a> function if the element does not already exist. </p>

</div>
</div>
<a id="a36b8cc95234b4e2de38a199b6b2af9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b8cc95234b4e2de38a199b6b2af9fc">&#9670;&nbsp;</a></span>cols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of columns of the matrix </dd></dl>

</div>
</div>
<a id="a36b8cc95234b4e2de38a199b6b2af9fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b8cc95234b4e2de38a199b6b2af9fc">&#9670;&nbsp;</a></span>cols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of columns of the matrix </dd></dl>

</div>
</div>
<a id="ab0e43ac03eb34e451e0f16e97ea2afda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e43ac03eb34e451e0f16e97ea2afda">&#9670;&nbsp;</a></span>conservativeResize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::conservativeResize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the matrix to a <em>rows</em> x <em>cols</em> matrix leaving old values untouched.</p>
<p>If the sizes of the matrix are decreased, then the matrix is turned to <b>uncompressed-mode</b> and the storage of the out of bounds coefficients is kept and reserved. Call <a class="el" href="class_eigen_1_1_sparse_matrix.html#a6400e6e733a7131f9b776d6386d2ed89">makeCompressed()</a> to pack the entries and squeeze extra memory.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#ad9e36e669468663012b77bf1bff8cc4f">reserve()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a2feb71dd2ed222057a77ff92b736badc">setZero()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a6400e6e733a7131f9b776d6386d2ed89">makeCompressed()</a> </dd></dl>

</div>
</div>
<a id="ab0e43ac03eb34e451e0f16e97ea2afda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0e43ac03eb34e451e0f16e97ea2afda">&#9670;&nbsp;</a></span>conservativeResize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::conservativeResize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the matrix to a <em>rows</em> x <em>cols</em> matrix leaving old values untouched.</p>
<p>If the sizes of the matrix are decreased, then the matrix is turned to <b>uncompressed-mode</b> and the storage of the out of bounds coefficients is kept and reserved. Call <a class="el" href="class_eigen_1_1_sparse_matrix.html#a6400e6e733a7131f9b776d6386d2ed89">makeCompressed()</a> to pack the entries and squeeze extra memory.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#ad9e36e669468663012b77bf1bff8cc4f">reserve()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a2feb71dd2ed222057a77ff92b736badc">setZero()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a6400e6e733a7131f9b776d6386d2ed89">makeCompressed()</a> </dd></dl>

</div>
</div>
<a id="ae6f4db56c76e4d374eb8507fbef5bdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f4db56c76e4d374eb8507fbef5bdb5">&#9670;&nbsp;</a></span>diagonal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_diagonal.html">DiagonalReturnType</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::diagonal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a read-write expression of the diagonal coefficients. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the diagonal entries are written, then all diagonal entries <b>must</b> already exist, otherwise an assertion will be raised. </dd></dl>

</div>
</div>
<a id="ae6f4db56c76e4d374eb8507fbef5bdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6f4db56c76e4d374eb8507fbef5bdb5">&#9670;&nbsp;</a></span>diagonal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_diagonal.html">DiagonalReturnType</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::diagonal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a read-write expression of the diagonal coefficients. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>If the diagonal entries are written, then all diagonal entries <b>must</b> already exist, otherwise an assertion will be raised. </dd></dl>

</div>
</div>
<a id="a20301b7b657f0948d6a6da68509fb4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20301b7b657f0948d6a6da68509fb4da">&#9670;&nbsp;</a></span>diagonal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_diagonal.html">ConstDiagonalReturnType</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::diagonal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const expression of the diagonal coefficients. </dd></dl>

</div>
</div>
<a id="a20301b7b657f0948d6a6da68509fb4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20301b7b657f0948d6a6da68509fb4da">&#9670;&nbsp;</a></span>diagonal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_diagonal.html">ConstDiagonalReturnType</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::diagonal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const expression of the diagonal coefficients. </dd></dl>

</div>
</div>
<a id="a0f927d1e7251a78585b12bf451423d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f927d1e7251a78585b12bf451423d4e">&#9670;&nbsp;</a></span>innerIndexPtr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StorageIndex* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::innerIndexPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const pointer to the array of inner indices. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#a5e9513f7d7336a698a47ff3135d6d555">valuePtr()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a6de5655e0e36dfefd9812d65f48092f9">outerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="a0f927d1e7251a78585b12bf451423d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f927d1e7251a78585b12bf451423d4e">&#9670;&nbsp;</a></span>innerIndexPtr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StorageIndex* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::innerIndexPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const pointer to the array of inner indices. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#a5e9513f7d7336a698a47ff3135d6d555">valuePtr()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a6de5655e0e36dfefd9812d65f48092f9">outerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="ade3e26297390865d80a09d1ce06cc916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3e26297390865d80a09d1ce06cc916">&#9670;&nbsp;</a></span>innerIndexPtr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const StorageIndex* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::innerIndexPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the array of inner indices. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#a5e9513f7d7336a698a47ff3135d6d555">valuePtr()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a6de5655e0e36dfefd9812d65f48092f9">outerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="ade3e26297390865d80a09d1ce06cc916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3e26297390865d80a09d1ce06cc916">&#9670;&nbsp;</a></span>innerIndexPtr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const StorageIndex* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::innerIndexPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the array of inner indices. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#a5e9513f7d7336a698a47ff3135d6d555">valuePtr()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a6de5655e0e36dfefd9812d65f48092f9">outerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="a0fa5da473fe96a8ae7fae6f3ca2d5b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa5da473fe96a8ae7fae6f3ca2d5b62">&#9670;&nbsp;</a></span>innerNonZeroPtr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StorageIndex* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::innerNonZeroPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const pointer to the array of the number of non zeros of the inner vectors. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>it returns the null pointer 0 in compressed mode </dd></dl>

</div>
</div>
<a id="a0fa5da473fe96a8ae7fae6f3ca2d5b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa5da473fe96a8ae7fae6f3ca2d5b62">&#9670;&nbsp;</a></span>innerNonZeroPtr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StorageIndex* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::innerNonZeroPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const pointer to the array of the number of non zeros of the inner vectors. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>it returns the null pointer 0 in compressed mode </dd></dl>

</div>
</div>
<a id="a62ba20726a10c2c9d095aed024297a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ba20726a10c2c9d095aed024297a2a">&#9670;&nbsp;</a></span>innerNonZeroPtr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const StorageIndex* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::innerNonZeroPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the array of the number of non zeros of the inner vectors. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>it returns the null pointer 0 in compressed mode </dd></dl>

</div>
</div>
<a id="a62ba20726a10c2c9d095aed024297a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ba20726a10c2c9d095aed024297a2a">&#9670;&nbsp;</a></span>innerNonZeroPtr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const StorageIndex* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::innerNonZeroPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the array of the number of non zeros of the inner vectors. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>it returns the null pointer 0 in compressed mode </dd></dl>

</div>
</div>
<a id="aa6411a0a909423d2d843a2e7d8b8e4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6411a0a909423d2d843a2e7d8b8e4e7">&#9670;&nbsp;</a></span>innerSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::innerSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of rows (resp. columns) of the matrix if the storage order column major (resp. row major) </dd></dl>

</div>
</div>
<a id="aa6411a0a909423d2d843a2e7d8b8e4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6411a0a909423d2d843a2e7d8b8e4e7">&#9670;&nbsp;</a></span>innerSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::innerSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of rows (resp. columns) of the matrix if the storage order column major (resp. row major) </dd></dl>

</div>
</div>
<a id="ae2d8f72ff86a300b76f9edd67df8d8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d8f72ff86a300b76f9edd67df8d8fd">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::Scalar &amp; <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a reference to a novel non zero coefficient with coordinates <em>row</em> x <em>col</em>. The non zero coefficient must <b>not</b> already exist.</dd></dl>
<p>If the matrix <code>*this</code> is in compressed mode, then <code>*this</code> is turned into uncompressed mode while reserving room for 2 x this-&gt;<a class="el" href="class_eigen_1_1_sparse_matrix.html#aa6411a0a909423d2d843a2e7d8b8e4e7">innerSize()</a> non zeros if <a class="el" href="class_eigen_1_1_sparse_matrix.html#ad9e36e669468663012b77bf1bff8cc4f">reserve(Index)</a> has not been called earlier. In this case, the insertion procedure is optimized for a <em>sequential</em> insertion mode where elements are assumed to be inserted by increasing outer-indices.</p>
<p>If that's not the case, then it is strongly recommended to either use a triplet-list to assemble the matrix, or to first call reserve(const SizesType &amp;) to reserve the appropriate number of non-zero elements per inner vector.</p>
<p>Assuming memory has been appropriately reserved, this function performs a sorted insertion in O(1) if the elements of each inner vector are inserted in increasing inner index order, and in O(nnz_j) for a random insertion. </p>

</div>
</div>
<a id="ab3911a1444c1c8afc25c8c205ab7a05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3911a1444c1c8afc25c8c205ab7a05c">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar&amp; <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a reference to a novel non zero coefficient with coordinates <em>row</em> x <em>col</em>. The non zero coefficient must <b>not</b> already exist.</dd></dl>
<p>If the matrix <code>*this</code> is in compressed mode, then <code>*this</code> is turned into uncompressed mode while reserving room for 2 x this-&gt;<a class="el" href="class_eigen_1_1_sparse_matrix.html#aa6411a0a909423d2d843a2e7d8b8e4e7">innerSize()</a> non zeros if <a class="el" href="class_eigen_1_1_sparse_matrix.html#ad9e36e669468663012b77bf1bff8cc4f">reserve(Index)</a> has not been called earlier. In this case, the insertion procedure is optimized for a <em>sequential</em> insertion mode where elements are assumed to be inserted by increasing outer-indices.</p>
<p>If that's not the case, then it is strongly recommended to either use a triplet-list to assemble the matrix, or to first call reserve(const SizesType &amp;) to reserve the appropriate number of non-zero elements per inner vector.</p>
<p>Assuming memory has been appropriately reserved, this function performs a sorted insertion in O(1) if the elements of each inner vector are inserted in increasing inner index order, and in O(nnz_j) for a random insertion. </p>

</div>
</div>
<a id="a5983337b43e23cf688a00a23e30cfffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5983337b43e23cf688a00a23e30cfffb">&#9670;&nbsp;</a></span>insertFromSortedTriplets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::insertFromSortedTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as insertFromTriplets but triplets are assumed to be pre-sorted. This is faster and requires less temporary storage. Two triplets <code>a</code> and <code>b</code> are appropriately ordered if: </p><div class="fragment"><div class="line"><a class="code" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a">ColMajor</a>: ((a.col() != b.col()) ? (a.col() &lt; b.col()) : (a.row() &lt; b.row())</div>
<div class="line"><a class="code" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3">RowMajor</a>: ((a.row() != b.row()) ? (a.row() &lt; b.row()) : (a.col() &lt; b.col())</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a29f17d24f224a1fb73ab903e2a42aba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f17d24f224a1fb73ab903e2a42aba4">&#9670;&nbsp;</a></span>insertFromSortedTriplets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators , typename DupFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::insertFromSortedTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DupFunctor&#160;</td>
          <td class="paramname"><em>dup_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as insertFromSortedTriplets but when duplicates are met the functor <em>dup_func</em> is applied: </p><div class="fragment"><div class="line">value = dup_func(OldValue, NewValue)</div>
</div><!-- fragment --><p> Here is a C++11 example keeping the latest entry only: </p><div class="fragment"><div class="line">mat.insertFromSortedTriplets(triplets.begin(), triplets.end(), [] (<span class="keyword">const</span> Scalar&amp;,<span class="keyword">const</span> Scalar &amp;b) { return b; });</div>
</div><!-- fragment --> 
</div>
</div>
<a id="af5bf43559efce09f5415d6b66aa31d53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bf43559efce09f5415d6b66aa31d53">&#9670;&nbsp;</a></span>insertFromTriplets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::insertFromTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a batch of elements into the matrix <code>*this</code> with the list of <em>triplets</em> defined in the half-open range from <em>begin</em> to <em>end</em>.</p>
<p>A <em>triplet</em> is a tuple (i,j,value) defining a non-zero element. The input list of triplets does not have to be sorted, and may contain duplicated elements. In any case, the result is a <b>sorted</b> and <b>compressed</b> sparse matrix where the duplicates have been summed up. This is a <em>O(n)</em> operation, with <em>n</em> the number of triplet elements. The initial contents of <code>*this</code> are preserved (except for the summation of duplicate elements). The matrix <code>*this</code> must be properly sized beforehand. The sizes are not extracted from the triplet list.</p>
<p>The <em>InputIterators</em> value_type must provide the following interface: </p><div class="fragment"><div class="line">Scalar value() <span class="keyword">const</span>; <span class="comment">// the value</span></div>
<div class="line">IndexType <a class="code" href="group__gtc__matrix__access.html#ga259e5ebd0f31ec3f83440f8cae7f5dba">row</a>() <span class="keyword">const</span>;   <span class="comment">// the row index i</span></div>
<div class="line">IndexType col() <span class="keyword">const</span>;   <span class="comment">// the column index j</span></div>
</div><!-- fragment --><p> See for instance the <a class="el" href="class_eigen_1_1_triplet.html" title="A small structure to hold a non zero as a triplet (i,j,value).">Eigen::Triplet</a> template class.</p>
<p>Here is a typical usage example: </p><div class="fragment"><div class="line">SparseMatrixType m(<a class="code" href="class_eigen_1_1_sparse_matrix.html#a853a76dd42349fa2f3654a4a61e0f574">rows</a>,<a class="code" href="class_eigen_1_1_sparse_matrix.html#a36b8cc95234b4e2de38a199b6b2af9fc">cols</a>); <span class="comment">// m contains nonzero entries</span></div>
<div class="line"><span class="keyword">typedef</span> Triplet&lt;double&gt; <a class="code" href="class_eigen_1_1_triplet.html">T</a>;</div>
<div class="line">std::vector&lt;T&gt; tripletList;</div>
<div class="line">tripletList.reserve(estimation_of_entries);</div>
<div class="line"><span class="keywordflow">for</span>(...)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  tripletList.push_back(<a class="code" href="class_eigen_1_1_triplet.html">T</a>(i,j,v_ij));</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">m.insertFromTriplets(tripletList.begin(), tripletList.end());</div>
<div class="line"><span class="comment">// m is ready to go!</span></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The list of triplets is read multiple times (at least twice). Therefore, it is not recommended to define an abstract iterator over a complex data-structure that would be expensive to evaluate. The triplets should rather be explicitly stored into a std::vector for instance. </dd></dl>

</div>
</div>
<a id="ab452919fafc44dc6f8407fe4e5ffeddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab452919fafc44dc6f8407fe4e5ffeddd">&#9670;&nbsp;</a></span>insertFromTriplets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators , typename DupFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::insertFromTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DupFunctor&#160;</td>
          <td class="paramname"><em>dup_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as insertFromTriplets but when duplicates are met the functor <em>dup_func</em> is applied: </p><div class="fragment"><div class="line">value = dup_func(OldValue, NewValue)</div>
</div><!-- fragment --><p> Here is a C++11 example keeping the latest entry only: </p><div class="fragment"><div class="line">mat.insertFromTriplets(triplets.begin(), triplets.end(), [] (<span class="keyword">const</span> Scalar&amp;,<span class="keyword">const</span> Scalar &amp;b) { return b; });</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ae257333ca0e0b16cf5d3080bbefeaf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae257333ca0e0b16cf5d3080bbefeaf47">&#9670;&nbsp;</a></span>isCompressed() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Eigen::SparseCompressedBase::isCompressed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether <code>*this</code> is in compressed form. </dd></dl>

</div>
</div>
<a id="ae257333ca0e0b16cf5d3080bbefeaf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae257333ca0e0b16cf5d3080bbefeaf47">&#9670;&nbsp;</a></span>isCompressed() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Eigen::SparseCompressedBase::isCompressed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether <code>*this</code> is in compressed form. </dd></dl>

</div>
</div>
<a id="ae257333ca0e0b16cf5d3080bbefeaf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae257333ca0e0b16cf5d3080bbefeaf47">&#9670;&nbsp;</a></span>isCompressed() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Eigen::SparseCompressedBase::isCompressed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether <code>*this</code> is in compressed form. </dd></dl>

</div>
</div>
<a id="ae257333ca0e0b16cf5d3080bbefeaf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae257333ca0e0b16cf5d3080bbefeaf47">&#9670;&nbsp;</a></span>isCompressed() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Eigen::SparseCompressedBase::isCompressed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>whether <code>*this</code> is in compressed form. </dd></dl>

</div>
</div>
<a id="a6400e6e733a7131f9b776d6386d2ed89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6400e6e733a7131f9b776d6386d2ed89">&#9670;&nbsp;</a></span>makeCompressed() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::makeCompressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Turns the matrix into the <em>compressed</em> format. </p>

</div>
</div>
<a id="a6400e6e733a7131f9b776d6386d2ed89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6400e6e733a7131f9b776d6386d2ed89">&#9670;&nbsp;</a></span>makeCompressed() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::makeCompressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Turns the matrix into the <em>compressed</em> format. </p>

</div>
</div>
<a id="ae53743108cd668b8da927ff149631fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53743108cd668b8da927ff149631fe0">&#9670;&nbsp;</a></span>nonZeros() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> Eigen::SparseCompressedBase::nonZeros</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of non zero coefficients </dd></dl>

</div>
</div>
<a id="ae53743108cd668b8da927ff149631fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53743108cd668b8da927ff149631fe0">&#9670;&nbsp;</a></span>nonZeros() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> Eigen::SparseCompressedBase::nonZeros</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of non zero coefficients </dd></dl>

</div>
</div>
<a id="ae53743108cd668b8da927ff149631fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53743108cd668b8da927ff149631fe0">&#9670;&nbsp;</a></span>nonZeros() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> Eigen::SparseCompressedBase::nonZeros</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of non zero coefficients </dd></dl>

</div>
</div>
<a id="ae53743108cd668b8da927ff149631fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53743108cd668b8da927ff149631fe0">&#9670;&nbsp;</a></span>nonZeros() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> Eigen::SparseCompressedBase::nonZeros</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of non zero coefficients </dd></dl>

</div>
</div>
<a id="a6de5655e0e36dfefd9812d65f48092f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de5655e0e36dfefd9812d65f48092f9">&#9670;&nbsp;</a></span>outerIndexPtr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StorageIndex* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::outerIndexPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const pointer to the array of the starting positions of the inner vectors. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#a5e9513f7d7336a698a47ff3135d6d555">valuePtr()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a0f927d1e7251a78585b12bf451423d4e">innerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="a6de5655e0e36dfefd9812d65f48092f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de5655e0e36dfefd9812d65f48092f9">&#9670;&nbsp;</a></span>outerIndexPtr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StorageIndex* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::outerIndexPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const pointer to the array of the starting positions of the inner vectors. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#a5e9513f7d7336a698a47ff3135d6d555">valuePtr()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a0f927d1e7251a78585b12bf451423d4e">innerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="ad2d1a4d9033c2bc0917ea09cdc5c700c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d1a4d9033c2bc0917ea09cdc5c700c">&#9670;&nbsp;</a></span>outerIndexPtr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const StorageIndex* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::outerIndexPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the array of the starting positions of the inner vectors. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#a5e9513f7d7336a698a47ff3135d6d555">valuePtr()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a0f927d1e7251a78585b12bf451423d4e">innerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="ad2d1a4d9033c2bc0917ea09cdc5c700c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d1a4d9033c2bc0917ea09cdc5c700c">&#9670;&nbsp;</a></span>outerIndexPtr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const StorageIndex* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::outerIndexPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the array of the starting positions of the inner vectors. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#a5e9513f7d7336a698a47ff3135d6d555">valuePtr()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a0f927d1e7251a78585b12bf451423d4e">innerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="a47c7cdf3c713ea69d08387aaf78e0c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c7cdf3c713ea69d08387aaf78e0c53">&#9670;&nbsp;</a></span>outerSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::outerSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of columns (resp. rows) of the matrix if the storage order column major (resp. row major) </dd></dl>

</div>
</div>
<a id="a47c7cdf3c713ea69d08387aaf78e0c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c7cdf3c713ea69d08387aaf78e0c53">&#9670;&nbsp;</a></span>outerSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::outerSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of columns (resp. rows) of the matrix if the storage order column major (resp. row major) </dd></dl>

</div>
</div>
<a id="aca3916ec112e13c513380b47fad7954b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3916ec112e13c513380b47fad7954b">&#9670;&nbsp;</a></span>prune() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename KeepFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::prune </td>
          <td>(</td>
          <td class="paramtype">const KeepFunc &amp;&#160;</td>
          <td class="paramname"><em>keep</em> = <code>KeepFunc()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Turns the matrix into compressed format, and suppresses all nonzeros which do not satisfy the predicate <em>keep</em>. The functor type <em>KeepFunc</em> must implement the following function: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> <a class="code" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&amp; <a class="code" href="group__gtc__matrix__access.html#ga259e5ebd0f31ec3f83440f8cae7f5dba">row</a>, <span class="keyword">const</span> <a class="code" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&amp; col, <span class="keyword">const</span> Scalar&amp; value) <span class="keyword">const</span>;</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>prune(Scalar,RealScalar) </dd></dl>

</div>
</div>
<a id="aca3916ec112e13c513380b47fad7954b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3916ec112e13c513380b47fad7954b">&#9670;&nbsp;</a></span>prune() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename KeepFunc &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::prune </td>
          <td>(</td>
          <td class="paramtype">const KeepFunc &amp;&#160;</td>
          <td class="paramname"><em>keep</em> = <code>KeepFunc()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Turns the matrix into compressed format, and suppresses all nonzeros which do not satisfy the predicate <em>keep</em>. The functor type <em>KeepFunc</em> must implement the following function: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> <a class="code" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&amp; <a class="code" href="group__gtc__matrix__access.html#ga259e5ebd0f31ec3f83440f8cae7f5dba">row</a>, <span class="keyword">const</span> <a class="code" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&amp; col, <span class="keyword">const</span> Scalar&amp; value) <span class="keyword">const</span>;</div>
</div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd>prune(Scalar,RealScalar) </dd></dl>

</div>
</div>
<a id="ab4b7ffe0c08f653f5c34b02b9b12e6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b7ffe0c08f653f5c34b02b9b12e6bf">&#9670;&nbsp;</a></span>prune() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::prune </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt;RealScalar&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Suppresses all nonzeros which are <b>much</b> <b>smaller</b> <b>than</b> <em>reference</em> under the tolerance <em>epsilon</em> </p>

</div>
</div>
<a id="ab4b7ffe0c08f653f5c34b02b9b12e6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b7ffe0c08f653f5c34b02b9b12e6bf">&#9670;&nbsp;</a></span>prune() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::prune </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt;RealScalar&gt;::dummy_precision()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Suppresses all nonzeros which are <b>much</b> <b>smaller</b> <b>than</b> <em>reference</em> under the tolerance <em>epsilon</em> </p>

</div>
</div>
<a id="ad9e36e669468663012b77bf1bff8cc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e36e669468663012b77bf1bff8cc4f">&#9670;&nbsp;</a></span>reserve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>reserveSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Preallocates <em>reserveSize</em> non zeros.</p>
<p>Precondition: the matrix must be in compressed mode. </p>

</div>
</div>
<a id="ad9e36e669468663012b77bf1bff8cc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e36e669468663012b77bf1bff8cc4f">&#9670;&nbsp;</a></span>reserve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>reserveSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Preallocates <em>reserveSize</em> non zeros.</p>
<p>Precondition: the matrix must be in compressed mode. </p>

</div>
</div>
<a id="a835ae5b304ddbb187eac25d5850b2ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835ae5b304ddbb187eac25d5850b2ced">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the matrix to a <em>rows</em> x <em>cols</em> matrix and initializes it to zero.</p>
<p>This function does not free the currently allocated memory. To release as much as memory as possible, call</p><div class="fragment"><div class="line">mat.data().squeeze(); </div>
</div><!-- fragment --><p> after resizing it.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#ad9e36e669468663012b77bf1bff8cc4f">reserve()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a2feb71dd2ed222057a77ff92b736badc">setZero()</a> </dd></dl>

</div>
</div>
<a id="a835ae5b304ddbb187eac25d5850b2ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a835ae5b304ddbb187eac25d5850b2ced">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes the matrix to a <em>rows</em> x <em>cols</em> matrix and initializes it to zero.</p>
<p>This function does not free the currently allocated memory. To release as much as memory as possible, call</p><div class="fragment"><div class="line">mat.data().squeeze(); </div>
</div><!-- fragment --><p> after resizing it.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#ad9e36e669468663012b77bf1bff8cc4f">reserve()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a2feb71dd2ed222057a77ff92b736badc">setZero()</a> </dd></dl>

</div>
</div>
<a id="a853a76dd42349fa2f3654a4a61e0f574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853a76dd42349fa2f3654a4a61e0f574">&#9670;&nbsp;</a></span>rows() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of rows of the matrix </dd></dl>

</div>
</div>
<a id="a853a76dd42349fa2f3654a4a61e0f574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853a76dd42349fa2f3654a4a61e0f574">&#9670;&nbsp;</a></span>rows() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the number of rows of the matrix </dd></dl>

</div>
</div>
<a id="a39c6b1ee045d58ced163b140b9c6bf36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c6b1ee045d58ced163b140b9c6bf36">&#9670;&nbsp;</a></span>setFromSortedTriplets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::setFromSortedTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as setFromTriplets but triplets are assumed to be pre-sorted. This is faster and requires less temporary storage. Two triplets <code>a</code> and <code>b</code> are appropriately ordered if: </p><div class="fragment"><div class="line"><a class="code" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a">ColMajor</a>: ((a.col() != b.col()) ? (a.col() &lt; b.col()) : (a.row() &lt; b.row())</div>
<div class="line"><a class="code" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3">RowMajor</a>: ((a.row() != b.row()) ? (a.row() &lt; b.row()) : (a.col() &lt; b.col())</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a73841eccfc1066680c7bed8bf98ec3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73841eccfc1066680c7bed8bf98ec3e1">&#9670;&nbsp;</a></span>setFromSortedTriplets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators , typename DupFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::setFromSortedTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DupFunctor&#160;</td>
          <td class="paramname"><em>dup_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as setFromSortedTriplets but when duplicates are met the functor <em>dup_func</em> is applied: </p><div class="fragment"><div class="line">value = dup_func(OldValue, NewValue)</div>
</div><!-- fragment --><p> Here is a C++11 example keeping the latest entry only: </p><div class="fragment"><div class="line">mat.setFromSortedTriplets(triplets.begin(), triplets.end(), [] (<span class="keyword">const</span> Scalar&amp;,<span class="keyword">const</span> Scalar &amp;b) { return b; });</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a8f09e3597f37aa8861599260af6a53e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f09e3597f37aa8861599260af6a53e0">&#9670;&nbsp;</a></span>setFromTriplets() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::setFromTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill the matrix <code>*this</code> with the list of <em>triplets</em> defined by the iterator range <em>begin</em> - <em>end</em>.</p>
<p>A <em>triplet</em> is a tuple (i,j,value) defining a non-zero element. The input list of triplets does not have to be sorted, and can contains duplicated elements. In any case, the result is a <b>sorted</b> and <b>compressed</b> sparse matrix where the duplicates have been summed up. This is a <em>O(n)</em> operation, with <em>n</em> the number of triplet elements. The initial contents of <code>*this</code> is destroyed. The matrix <code>*this</code> must be properly resized beforehand using the <a class="el" href="class_eigen_1_1_sparse_matrix.html#aa647b5f0462b9986e3c907e9ca7c5984">SparseMatrix(Index,Index)</a> constructor, or the <a class="el" href="class_eigen_1_1_sparse_matrix.html#a835ae5b304ddbb187eac25d5850b2ced">resize(Index,Index)</a> method. The sizes are not extracted from the triplet list.</p>
<p>The <em>InputIterators</em> value_type must provide the following interface: </p><div class="fragment"><div class="line">Scalar value() <span class="keyword">const</span>; <span class="comment">// the value</span></div>
<div class="line">Scalar <a class="code" href="group__gtc__matrix__access.html#ga259e5ebd0f31ec3f83440f8cae7f5dba">row</a>() <span class="keyword">const</span>;   <span class="comment">// the row index i</span></div>
<div class="line">Scalar col() <span class="keyword">const</span>;   <span class="comment">// the column index j</span></div>
</div><!-- fragment --><p> See for instance the <a class="el" href="class_eigen_1_1_triplet.html" title="A small structure to hold a non zero as a triplet (i,j,value).">Eigen::Triplet</a> template class.</p>
<p>Here is a typical usage example: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> Triplet&lt;double&gt; <a class="code" href="class_eigen_1_1_triplet.html">T</a>;</div>
<div class="line">std::vector&lt;T&gt; tripletList;</div>
<div class="line">tripletList.reserve(estimation_of_entries);</div>
<div class="line"><span class="keywordflow">for</span>(...)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  tripletList.push_back(<a class="code" href="class_eigen_1_1_triplet.html">T</a>(i,j,v_ij));</div>
<div class="line">}</div>
<div class="line">SparseMatrixType m(<a class="code" href="class_eigen_1_1_sparse_matrix.html#a853a76dd42349fa2f3654a4a61e0f574">rows</a>,<a class="code" href="class_eigen_1_1_sparse_matrix.html#a36b8cc95234b4e2de38a199b6b2af9fc">cols</a>);</div>
<div class="line">m.setFromTriplets(tripletList.begin(), tripletList.end());</div>
<div class="line"><span class="comment">// m is ready to go!</span></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The list of triplets is read multiple times (at least twice). Therefore, it is not recommended to define an abstract iterator over a complex data-structure that would be expensive to evaluate. The triplets should rather be explicitly stored into a std::vector for instance.</dd></dl>
<p>Fill the matrix <code>*this</code> with the list of <em>triplets</em> defined in the half-open range from <em>begin</em> to <em>end</em>.</p>
<p>A <em>triplet</em> is a tuple (i,j,value) defining a non-zero element. The input list of triplets does not have to be sorted, and may contain duplicated elements. In any case, the result is a <b>sorted</b> and <b>compressed</b> sparse matrix where the duplicates have been summed up. This is a <em>O(n)</em> operation, with <em>n</em> the number of triplet elements. The initial contents of <code>*this</code> are destroyed. The matrix <code>*this</code> must be properly resized beforehand using the <a class="el" href="class_eigen_1_1_sparse_matrix.html#aa647b5f0462b9986e3c907e9ca7c5984">SparseMatrix(Index,Index)</a> constructor, or the <a class="el" href="class_eigen_1_1_sparse_matrix.html#a835ae5b304ddbb187eac25d5850b2ced">resize(Index,Index)</a> method. The sizes are not extracted from the triplet list.</p>
<p>The <em>InputIterators</em> value_type must provide the following interface: </p><div class="fragment"><div class="line">Scalar value() <span class="keyword">const</span>; <span class="comment">// the value</span></div>
<div class="line">IndexType <a class="code" href="group__gtc__matrix__access.html#ga259e5ebd0f31ec3f83440f8cae7f5dba">row</a>() <span class="keyword">const</span>;   <span class="comment">// the row index i</span></div>
<div class="line">IndexType col() <span class="keyword">const</span>;   <span class="comment">// the column index j</span></div>
</div><!-- fragment --><p> See for instance the <a class="el" href="class_eigen_1_1_triplet.html" title="A small structure to hold a non zero as a triplet (i,j,value).">Eigen::Triplet</a> template class.</p>
<p>Here is a typical usage example: </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> Triplet&lt;double&gt; <a class="code" href="class_eigen_1_1_triplet.html">T</a>;</div>
<div class="line">std::vector&lt;T&gt; tripletList;</div>
<div class="line">tripletList.reserve(estimation_of_entries);</div>
<div class="line"><span class="keywordflow">for</span>(...)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  tripletList.push_back(<a class="code" href="class_eigen_1_1_triplet.html">T</a>(i,j,v_ij));</div>
<div class="line">}</div>
<div class="line">SparseMatrixType m(<a class="code" href="class_eigen_1_1_sparse_matrix.html#a853a76dd42349fa2f3654a4a61e0f574">rows</a>,<a class="code" href="class_eigen_1_1_sparse_matrix.html#a36b8cc95234b4e2de38a199b6b2af9fc">cols</a>);</div>
<div class="line">m.setFromTriplets(tripletList.begin(), tripletList.end());</div>
<div class="line"><span class="comment">// m is ready to go!</span></div>
</div><!-- fragment --><dl class="section warning"><dt>Warning</dt><dd>The list of triplets is read multiple times (at least twice). Therefore, it is not recommended to define an abstract iterator over a complex data-structure that would be expensive to evaluate. The triplets should rather be explicitly stored into a std::vector for instance. </dd></dl>

</div>
</div>
<a id="a3e8c96b7dd72d03f14b5cf40f5005d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8c96b7dd72d03f14b5cf40f5005d55">&#9670;&nbsp;</a></span>setFromTriplets() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Options_, typename StorageIndex_ &gt; </div>
<div class="memtemplate">
template&lt;typename InputIterators , typename DupFunctor &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar, Options_, StorageIndex_ &gt;::setFromTriplets </td>
          <td>(</td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterators &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DupFunctor&#160;</td>
          <td class="paramname"><em>dup_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as setFromTriplets but when duplicates are met the functor <em>dup_func</em> is applied: </p><div class="fragment"><div class="line">value = dup_func(OldValue, NewValue)</div>
</div><!-- fragment --><p> Here is a C++11 example keeping the latest entry only: </p><div class="fragment"><div class="line">mat.setFromTriplets(triplets.begin(), triplets.end(), [] (<span class="keyword">const</span> Scalar&amp;,<span class="keyword">const</span> Scalar &amp;b) { return b; });</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa4064cc1e3a4038cf09ff03af5a3ffb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4064cc1e3a4038cf09ff03af5a3ffb5">&#9670;&nbsp;</a></span>setIdentity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::setIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets *this to the identity matrix. This function also turns the matrix into compressed mode, and drop any reserved memory. </p>

</div>
</div>
<a id="aa4064cc1e3a4038cf09ff03af5a3ffb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4064cc1e3a4038cf09ff03af5a3ffb5">&#9670;&nbsp;</a></span>setIdentity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::setIdentity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets *this to the identity matrix. This function also turns the matrix into compressed mode, and drop any reserved memory. </p>

</div>
</div>
<a id="a2feb71dd2ed222057a77ff92b736badc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2feb71dd2ed222057a77ff92b736badc">&#9670;&nbsp;</a></span>setZero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::setZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all non zeros but keep allocated memory</p>
<p>This function does not free the currently allocated memory. To release as much as memory as possible, call</p><div class="fragment"><div class="line">mat.data().squeeze(); </div>
</div><!-- fragment --><p> after resizing it.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#a835ae5b304ddbb187eac25d5850b2ced">resize(Index,Index)</a>, data() </dd></dl>

</div>
</div>
<a id="a2feb71dd2ed222057a77ff92b736badc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2feb71dd2ed222057a77ff92b736badc">&#9670;&nbsp;</a></span>setZero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::setZero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes all non zeros but keep allocated memory</p>
<p>This function does not free the currently allocated memory. To release as much as memory as possible, call</p><div class="fragment"><div class="line">mat.data().squeeze(); </div>
</div><!-- fragment --><p> after resizing it.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#a835ae5b304ddbb187eac25d5850b2ced">resize(Index,Index)</a>, data() </dd></dl>

</div>
</div>
<a id="ad2b635a54bf2fe66facd1cb1872aae9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b635a54bf2fe66facd1cb1872aae9f">&#9670;&nbsp;</a></span>sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_eigen_1_1internal_1_1traits.html">internal::traits</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar_, Options_, Index_ &gt; &gt;::Scalar <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, Index_ &gt;::sum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloaded for performance </p>

</div>
</div>
<a id="a5bfe2c81a8afbd1bf2aa991a673c486d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bfe2c81a8afbd1bf2aa991a673c486d">&#9670;&nbsp;</a></span>sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Scalar <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overloaded for performance </p>

</div>
</div>
<a id="a20eec45a940a4dd7edcacfa21468b328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20eec45a940a4dd7edcacfa21468b328">&#9670;&nbsp;</a></span>swap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps the content of two sparse matrices of the same type. This is a fast operation that simply swaps the underlying pointers and parameters. </p>

</div>
</div>
<a id="a20eec45a940a4dd7edcacfa21468b328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20eec45a940a4dd7edcacfa21468b328">&#9670;&nbsp;</a></span>swap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps the content of two sparse matrices of the same type. This is a fast operation that simply swaps the underlying pointers and parameters. </p>

</div>
</div>
<a id="a542c2a877dcffbd48248b43d3eaf670f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542c2a877dcffbd48248b43d3eaf670f">&#9670;&nbsp;</a></span>uncompress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::uncompress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Turns the matrix into the uncompressed mode </p>

</div>
</div>
<a id="a542c2a877dcffbd48248b43d3eaf670f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a542c2a877dcffbd48248b43d3eaf670f">&#9670;&nbsp;</a></span>uncompress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::uncompress </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Turns the matrix into the uncompressed mode </p>

</div>
</div>
<a id="a5e9513f7d7336a698a47ff3135d6d555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9513f7d7336a698a47ff3135d6d555">&#9670;&nbsp;</a></span>valuePtr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::valuePtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const pointer to the array of values. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#a0f927d1e7251a78585b12bf451423d4e">innerIndexPtr()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a6de5655e0e36dfefd9812d65f48092f9">outerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="a5e9513f7d7336a698a47ff3135d6d555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9513f7d7336a698a47ff3135d6d555">&#9670;&nbsp;</a></span>valuePtr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scalar* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::valuePtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a non-const pointer to the array of values. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#a0f927d1e7251a78585b12bf451423d4e">innerIndexPtr()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a6de5655e0e36dfefd9812d65f48092f9">outerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="a6ed99bab9d4f142c629f69a93a2d1efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed99bab9d4f142c629f69a93a2d1efb">&#9670;&nbsp;</a></span>valuePtr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Scalar* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::valuePtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the array of values. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#a0f927d1e7251a78585b12bf451423d4e">innerIndexPtr()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a6de5655e0e36dfefd9812d65f48092f9">outerIndexPtr()</a> </dd></dl>

</div>
</div>
<a id="a6ed99bab9d4f142c629f69a93a2d1efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed99bab9d4f142c629f69a93a2d1efb">&#9670;&nbsp;</a></span>valuePtr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Scalar* <a class="el" href="class_eigen_1_1_sparse_matrix.html">Eigen::SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt;::valuePtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a const pointer to the array of values. This function is aimed at interoperability with other libraries. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_eigen_1_1_sparse_matrix.html#a0f927d1e7251a78585b12bf451423d4e">innerIndexPtr()</a>, <a class="el" href="class_eigen_1_1_sparse_matrix.html#a6de5655e0e36dfefd9812d65f48092f9">outerIndexPtr()</a> </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/eigen/Eigen/src/SparseCore/<a class="el" href="eigen_2_eigen_2src_2_sparse_core_2_sparse_matrix_8h_source.html">SparseMatrix.h</a></li>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/eigen/Eigen/src/SparseCore/<a class="el" href="eigen_2_eigen_2src_2_sparse_core_2_sparse_product_8h_source.html">SparseProduct.h</a></li>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/eigen/Eigen/src/SparseCore/<a class="el" href="eigen_2_eigen_2src_2_sparse_core_2_sparse_redux_8h_source.html">SparseRedux.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="agroup__gtc__matrix__access_html_ga259e5ebd0f31ec3f83440f8cae7f5dba"><div class="ttname"><a href="group__gtc__matrix__access.html#ga259e5ebd0f31ec3f83440f8cae7f5dba">glm::row</a></div><div class="ttdeci">GLM_FUNC_DECL genType::row_type row(genType const &amp;m, length_t index)</div><div class="ttdef"><b>Definition:</b> matrix_access.inl:24</div></div>
<div class="ttc" id="agroup__enums_html_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3"><div class="ttname"><a href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3">Eigen::RowMajor</a></div><div class="ttdeci">@ RowMajor</div><div class="ttdef"><b>Definition:</b> Constants.h:323</div></div>
<div class="ttc" id="anamespace_eigen_html_a62e77e0933482dafde8fe197d9a2cfde"><div class="ttname"><a href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a></div><div class="ttdeci">EIGEN_DEFAULT_DENSE_INDEX_TYPE Index</div><div class="ttdoc">The Index type as used for the API.</div><div class="ttdef"><b>Definition:</b> Meta.h:59</div></div>
<div class="ttc" id="aclass_eigen_1_1_sparse_matrix_html_a853a76dd42349fa2f3654a4a61e0f574"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#a853a76dd42349fa2f3654a4a61e0f574">Eigen::SparseMatrix::rows</a></div><div class="ttdeci">Index rows() const</div><div class="ttdef"><b>Definition:</b> SparseMatrix.h:140</div></div>
<div class="ttc" id="aclass_eigen_1_1_triplet_html"><div class="ttname"><a href="class_eigen_1_1_triplet.html">Eigen::Triplet</a></div><div class="ttdoc">A small structure to hold a non zero as a triplet (i,j,value).</div><div class="ttdef"><b>Definition:</b> SparseUtil.h:162</div></div>
<div class="ttc" id="aclass_eigen_1_1_sparse_matrix_html_a36b8cc95234b4e2de38a199b6b2af9fc"><div class="ttname"><a href="class_eigen_1_1_sparse_matrix.html#a36b8cc95234b4e2de38a199b6b2af9fc">Eigen::SparseMatrix::cols</a></div><div class="ttdeci">Index cols() const</div><div class="ttdef"><b>Definition:</b> SparseMatrix.h:142</div></div>
<div class="ttc" id="agroup__enums_html_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a"><div class="ttname"><a href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a">Eigen::ColMajor</a></div><div class="ttdeci">@ ColMajor</div><div class="ttdef"><b>Definition:</b> Constants.h:321</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
