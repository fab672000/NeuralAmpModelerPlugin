<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/third_party/externals/icu/source/common/unicode/ucnv.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_165293a501ba4c2e6154d2349f7bda2f.html">iPlug2</a></li><li class="navelem"><a class="el" href="dir_641d916385cbd9a9905ec9187e5a8cbf.html">Dependencies</a></li><li class="navelem"><a class="el" href="dir_31040ea15c7786249445d58d4501206c.html">Build</a></li><li class="navelem"><a class="el" href="dir_e8f3db59aac1d5c97f13eb5dbbaa3a7d.html">src</a></li><li class="navelem"><a class="el" href="dir_7a9255f9d333bb98ab788446a5533da8.html">skia</a></li><li class="navelem"><a class="el" href="dir_212a600375b83c6af05be875f6a23535.html">third_party</a></li><li class="navelem"><a class="el" href="dir_937bea7cc4f3b9e8c1234fe3c579a587.html">externals</a></li><li class="navelem"><a class="el" href="dir_542afbf6d0c69a274871e3d957b678ee.html">icu</a></li><li class="navelem"><a class="el" href="dir_31622dccf8db85caffa8f85ad4320bbe.html">source</a></li><li class="navelem"><a class="el" href="dir_6c5ab2b8add3ebc22db5bfe0d8229e32.html">common</a></li><li class="navelem"><a class="el" href="dir_937cffebded29b02632a2dbb4062d4a1.html">unicode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ucnv.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>C API: Character conversion.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="ucnv__err_8h_source.html">unicode/ucnv_err.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="uenum_8h_source.html">unicode/uenum.h</a>&quot;</code><br />
</div>
<p><a href="ucnv_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a653d3a72747d7629e58979fdcc84bff3"><td class="memItemLeft" align="right" valign="top"><a id="a653d3a72747d7629e58979fdcc84bff3"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>USET_DEFINED</b></td></tr>
<tr class="separator:a653d3a72747d7629e58979fdcc84bff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab00bb423db8533da12c35848e4c281"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a3ab00bb423db8533da12c35848e4c281">UCNV_MAX_CONVERTER_NAME_LENGTH</a>&#160;&#160;&#160;60</td></tr>
<tr class="separator:a3ab00bb423db8533da12c35848e4c281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a579f67d05b09f731df5a68eb80b851"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a1a579f67d05b09f731df5a68eb80b851">UCNV_MAX_FULL_FILE_NAME_LENGTH</a>&#160;&#160;&#160;(600+<a class="el" href="ucnv_8h.html#a3ab00bb423db8533da12c35848e4c281">UCNV_MAX_CONVERTER_NAME_LENGTH</a>)</td></tr>
<tr class="separator:a1a579f67d05b09f731df5a68eb80b851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082aba7f50746ff6135a4ca2a00f6d6c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a082aba7f50746ff6135a4ca2a00f6d6c">UCNV_SI</a>&#160;&#160;&#160;0x0F</td></tr>
<tr class="separator:a082aba7f50746ff6135a4ca2a00f6d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3918524388c8100107273806bd58c65"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ad3918524388c8100107273806bd58c65">UCNV_SO</a>&#160;&#160;&#160;0x0E</td></tr>
<tr class="separator:ad3918524388c8100107273806bd58c65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420028eb5f83222307bf16632857b148"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a420028eb5f83222307bf16632857b148">UCNV_OPTION_SEP_CHAR</a>&#160;&#160;&#160;','</td></tr>
<tr class="separator:a420028eb5f83222307bf16632857b148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f221dc37208cc5c5e9b1d72a7103435"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a8f221dc37208cc5c5e9b1d72a7103435">UCNV_OPTION_SEP_STRING</a>&#160;&#160;&#160;&quot;,&quot;</td></tr>
<tr class="separator:a8f221dc37208cc5c5e9b1d72a7103435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92803b44385721ec771befc01b5e8e3b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a92803b44385721ec771befc01b5e8e3b">UCNV_VALUE_SEP_CHAR</a>&#160;&#160;&#160;'='</td></tr>
<tr class="separator:a92803b44385721ec771befc01b5e8e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cd53c804d95e14388398843e6edc82"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a33cd53c804d95e14388398843e6edc82">UCNV_VALUE_SEP_STRING</a>&#160;&#160;&#160;&quot;=&quot;</td></tr>
<tr class="separator:a33cd53c804d95e14388398843e6edc82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867b3f44513565bca406eebe2f87ee99"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a867b3f44513565bca406eebe2f87ee99">UCNV_LOCALE_OPTION_STRING</a>&#160;&#160;&#160;&quot;,locale=&quot;</td></tr>
<tr class="separator:a867b3f44513565bca406eebe2f87ee99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b80fb72078403f8bdba322b63a5a93"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ac7b80fb72078403f8bdba322b63a5a93">UCNV_VERSION_OPTION_STRING</a>&#160;&#160;&#160;&quot;,version=&quot;</td></tr>
<tr class="separator:ac7b80fb72078403f8bdba322b63a5a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0588f7014923ad969821941f9dd51040"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a0588f7014923ad969821941f9dd51040">UCNV_SWAP_LFNL_OPTION_STRING</a>&#160;&#160;&#160;&quot;,swaplfnl&quot;</td></tr>
<tr class="separator:a0588f7014923ad969821941f9dd51040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ef5c3c7c83982313e415e697a26089"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ab6ef5c3c7c83982313e415e697a26089">U_CNV_SAFECLONE_BUFFERSIZE</a>&#160;&#160;&#160;1024</td></tr>
<tr class="separator:ab6ef5c3c7c83982313e415e697a26089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d7e4ae84f8a95b9735ed3491cdb77e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#aa3d7e4ae84f8a95b9735ed3491cdb77e">UCNV_GET_MAX_BYTES_FOR_STRING</a>(length,  maxCharSize)&#160;&#160;&#160;(((int32_t)(length)+10)*(int32_t)(maxCharSize))</td></tr>
<tr class="separator:aa3d7e4ae84f8a95b9735ed3491cdb77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:adce3fef7c15d7c78196bf977ac96ec9c"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="uchar_8h.html#adce3fef7c15d7c78196bf977ac96ec9c">USet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#adce3fef7c15d7c78196bf977ac96ec9c">USet</a></td></tr>
<tr class="separator:adce3fef7c15d7c78196bf977ac96ec9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae077d9f2a37d3aa640c3c2032a2baa2c"><td class="memItemLeft" align="right" valign="top">typedef void(U_EXPORT2 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ae077d9f2a37d3aa640c3c2032a2baa2c">UConverterToUCallback</a>) (const void *context, <a class="el" href="struct_u_converter_to_unicode_args.html">UConverterToUnicodeArgs</a> *args, const char *codeUnits, int32_t length, <a class="el" href="ucnv__err_8h.html#a19e1a4d55a7679634e84b241b00de01a">UConverterCallbackReason</a> reason, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:ae077d9f2a37d3aa640c3c2032a2baa2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7002374690e3deef6b3ad9fb9ec8b1e5"><td class="memItemLeft" align="right" valign="top">typedef void(U_EXPORT2 *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a7002374690e3deef6b3ad9fb9ec8b1e5">UConverterFromUCallback</a>) (const void *context, <a class="el" href="struct_u_converter_from_unicode_args.html">UConverterFromUnicodeArgs</a> *args, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *codeUnits, int32_t length, <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> codePoint, <a class="el" href="ucnv__err_8h.html#a19e1a4d55a7679634e84b241b00de01a">UConverterCallbackReason</a> reason, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:a7002374690e3deef6b3ad9fb9ec8b1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3160ba6268742546123c8fecdbfbabb2"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="ucnv_8h.html#a402221896b6d7153b14a5ff8dadde806">UConverterUnicodeSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a3160ba6268742546123c8fecdbfbabb2">UConverterUnicodeSet</a></td></tr>
<tr class="separator:a3160ba6268742546123c8fecdbfbabb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:adb0b44c6bd828c9d4cc2defcbba0f902"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a> { <br />
&#160;&#160;<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a8ba1940e34a58186b231679da1272904">UCNV_UNSUPPORTED_CONVERTER</a> = -1, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a81e595b85ba86dd7fde25f2a1c59bfc3">UCNV_SBCS</a> = 0, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902af7ed8ed108be1286bd0e01818dae0dbd">UCNV_DBCS</a> = 1, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902ac0f17aec1772eeca6c86d13191b6c852">UCNV_MBCS</a> = 2, 
<br />
&#160;&#160;<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a1211937ef4e044d96014a77c04915554">UCNV_LATIN_1</a> = 3, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a6a63fa949b29c7a55cc7cf5eecc3c89e">UCNV_UTF8</a> = 4, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902aac97a8806bad1e28965f045cdbd8e305">UCNV_UTF16_BigEndian</a> = 5, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a824cb728f9beb71051820f49f74fa4dd">UCNV_UTF16_LittleEndian</a> = 6, 
<br />
&#160;&#160;<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a1c8fa4af063d027b5bc2baa03bc29da8">UCNV_UTF32_BigEndian</a> = 7, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902aa776a4cccf14778c20230da58aa1c38d">UCNV_UTF32_LittleEndian</a> = 8, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902ab5b73d6ee548bda138fc56829800111b">UCNV_EBCDIC_STATEFUL</a> = 9, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a11368f51e102406facd6da0a3ee7d606">UCNV_ISO_2022</a> = 10, 
<br />
&#160;&#160;<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902af2c460935eca00105ad7dc2622d74100">UCNV_LMBCS_1</a> = 11, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902aaafb05c0fda0e6530807fedabf82c261">UCNV_LMBCS_2</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a6020a8e2cc71c9f8d8a64d729db9adb2">UCNV_LMBCS_3</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902ac71afd7dc6b8a304638e52f8a8bed20b">UCNV_LMBCS_4</a>, 
<br />
&#160;&#160;<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902ab126f5ee7a9c722ed0425973cea76df3">UCNV_LMBCS_5</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a443a68687c6c38b7d683fa4070a953bd">UCNV_LMBCS_6</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902aa8001a5fc7d37fa386c3d147106a6a5e">UCNV_LMBCS_8</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a0be612a93cffc67fc042b1bc168ed205">UCNV_LMBCS_11</a>, 
<br />
&#160;&#160;<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a98bc32e41e4d6e7bd75275c7f9738113">UCNV_LMBCS_16</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a41ffccf0b679631558a2547d2e445cea">UCNV_LMBCS_17</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902ad7a7305473e98bb7a9b4bf1f23406599">UCNV_LMBCS_18</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a16ff6cda2e1211eceadda889dbb359ba">UCNV_LMBCS_19</a>, 
<br />
&#160;&#160;<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902aee49b0c0e4b4fc4eb16627fce1620938">UCNV_LMBCS_LAST</a> = UCNV_LMBCS_19, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a086920821721b34d9260723ec86d5a71">UCNV_HZ</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902ace8cd9e435b4a5579286931a57c0bd88">UCNV_SCSU</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a59030fe051a4961ab474d0d91017ad47">UCNV_ISCII</a>, 
<br />
&#160;&#160;<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902aaadc5fba9e00621313dd6c9a5be3a84d">UCNV_US_ASCII</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902ad4a8edc0956f24d724441118a8f2226c">UCNV_UTF7</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902add63c4e0987f7622db1f2c2052dd7da8">UCNV_BOCU1</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902aab2340e8dc51c36dd8f0b48b07ac82c1">UCNV_UTF16</a>, 
<br />
&#160;&#160;<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a4eed53e3582d767aa03cd3ba3828515f">UCNV_UTF32</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902afceba4bdab9c135cccabc255e580980b">UCNV_CESU8</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a690c232e8a75021df389c39f03869d26">UCNV_IMAP_MAILBOX</a>, 
<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902a15555ec1e53dfa419dc6231f326ef79d">UCNV_COMPOUND_TEXT</a>, 
<br />
&#160;&#160;<b>UCNV_NUMBER_OF_SUPPORTED_CONVERTER_TYPES</b>
<br />
 }</td></tr>
<tr class="separator:adb0b44c6bd828c9d4cc2defcbba0f902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5ba7fbc2f113618ba57f4d9825ff85"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#aba5ba7fbc2f113618ba57f4d9825ff85">UConverterPlatform</a> { <b>UCNV_UNKNOWN</b> = -1, 
<b>UCNV_IBM</b> = 0
 }</td></tr>
<tr class="separator:aba5ba7fbc2f113618ba57f4d9825ff85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a402221896b6d7153b14a5ff8dadde806"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a402221896b6d7153b14a5ff8dadde806">UConverterUnicodeSet</a> { <a class="el" href="ucnv_8h.html#a402221896b6d7153b14a5ff8dadde806ab08c09dd129a92d08725b5260b49cbf9">UCNV_ROUNDTRIP_SET</a>, 
<a class="el" href="ucnv_8h.html#a402221896b6d7153b14a5ff8dadde806a38d95100b8b58d2c66c4c83b30d99499">UCNV_ROUNDTRIP_AND_FALLBACK_SET</a>, 
<a class="el" href="ucnv_8h.html#a402221896b6d7153b14a5ff8dadde806a33cced69d47e6de3cbfd79d17f88fcaf">UCNV_SET_COUNT</a>
 }</td></tr>
<tr class="separator:a402221896b6d7153b14a5ff8dadde806"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8d23f178a9474210cce08530fbfe6ab3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a8d23f178a9474210cce08530fbfe6ab3">ucnv_compareNames</a> (const char *name1, const char *name2)</td></tr>
<tr class="separator:a8d23f178a9474210cce08530fbfe6ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04af8743cca855974b87fd55a7970d6c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a> (const char *converterName, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:a04af8743cca855974b87fd55a7970d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f473f991769a94f21e195473470157"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ad3f473f991769a94f21e195473470157">ucnv_openU</a> (const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *name, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:ad3f473f991769a94f21e195473470157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f54f96fcedd8d89f433c4bd9437864d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a3f54f96fcedd8d89f433c4bd9437864d">ucnv_openCCSID</a> (int32_t codepage, <a class="el" href="ucnv_8h.html#aba5ba7fbc2f113618ba57f4d9825ff85">UConverterPlatform</a> platform, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:a3f54f96fcedd8d89f433c4bd9437864d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee49410890e472b8983b6865b4b964f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#afee49410890e472b8983b6865b4b964f">ucnv_openPackage</a> (const char *packageName, const char *converterName, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:afee49410890e472b8983b6865b4b964f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb51e41917fe9b0488cfdb5717ff826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#aebb51e41917fe9b0488cfdb5717ff826">ucnv_safeClone</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, void *stackBuffer, int32_t *pBufferSize, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="separator:aebb51e41917fe9b0488cfdb5717ff826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499316e130bdd073c394c92f55c315d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a499316e130bdd073c394c92f55c315d2">ucnv_close</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter)</td></tr>
<tr class="separator:a499316e130bdd073c394c92f55c315d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a670af025c7632628b450daa50e47df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a8a670af025c7632628b450daa50e47df">ucnv_getSubstChars</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, char *subChars, int8_t *len, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:a8a670af025c7632628b450daa50e47df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa840af123bebe51ecdb936641087f229"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#aa840af123bebe51ecdb936641087f229">ucnv_setSubstChars</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, const char *subChars, int8_t len, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:aa840af123bebe51ecdb936641087f229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e2e21ab52bd6fab1c4cb21d00fd23f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a38e2e21ab52bd6fab1c4cb21d00fd23f">ucnv_setSubstString</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *s, int32_t length, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:a38e2e21ab52bd6fab1c4cb21d00fd23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a000c5d12f9fde6e68289cc84694b5c3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a000c5d12f9fde6e68289cc84694b5c3b">ucnv_getInvalidChars</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, char *errBytes, int8_t *len, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:a000c5d12f9fde6e68289cc84694b5c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ea3b6034be2ed719622c81bdc0ff1e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a13ea3b6034be2ed719622c81bdc0ff1e">ucnv_getInvalidUChars</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *errUChars, int8_t *len, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:a13ea3b6034be2ed719622c81bdc0ff1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68fb6700ceb5168d4dd9ee93d1a6e47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ae68fb6700ceb5168d4dd9ee93d1a6e47">ucnv_reset</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter)</td></tr>
<tr class="separator:ae68fb6700ceb5168d4dd9ee93d1a6e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedbb912ce9067a392052bc91a7d9ee34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#aedbb912ce9067a392052bc91a7d9ee34">ucnv_resetToUnicode</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter)</td></tr>
<tr class="separator:aedbb912ce9067a392052bc91a7d9ee34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5938e9be0deb4a17575b073a98d37a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#aeb5938e9be0deb4a17575b073a98d37a">ucnv_resetFromUnicode</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter)</td></tr>
<tr class="separator:aeb5938e9be0deb4a17575b073a98d37a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab284cb660babcd328f4e03f6f0b0b802"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int8_t U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ab284cb660babcd328f4e03f6f0b0b802">ucnv_getMaxCharSize</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter)</td></tr>
<tr class="separator:ab284cb660babcd328f4e03f6f0b0b802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f30417f0f0b249f449eb8d4e1100ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int8_t U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a65f30417f0f0b249f449eb8d4e1100ce">ucnv_getMinCharSize</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter)</td></tr>
<tr class="separator:a65f30417f0f0b249f449eb8d4e1100ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7fc1500c99cf888e3b5e1714c17ccd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ab7fc1500c99cf888e3b5e1714c17ccd0">ucnv_getDisplayName</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, const char *displayLocale, <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *displayName, int32_t displayNameCapacity, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:ab7fc1500c99cf888e3b5e1714c17ccd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032612b9d1f370e8831181c50b352dcf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char *U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a032612b9d1f370e8831181c50b352dcf">ucnv_getName</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:a032612b9d1f370e8831181c50b352dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17df5c1434e7f5fd3c2871543428346"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ad17df5c1434e7f5fd3c2871543428346">ucnv_getCCSID</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:ad17df5c1434e7f5fd3c2871543428346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979fb8ddc407eccd2ac89d502d5245e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="ucnv_8h.html#aba5ba7fbc2f113618ba57f4d9825ff85">UConverterPlatform</a> U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a979fb8ddc407eccd2ac89d502d5245e5">ucnv_getPlatform</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:a979fb8ddc407eccd2ac89d502d5245e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c7d83c0179a90eadab5ebc8040fdb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a> U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a84c7d83c0179a90eadab5ebc8040fdb6">ucnv_getType</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter)</td></tr>
<tr class="separator:a84c7d83c0179a90eadab5ebc8040fdb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a115789580a4449f8b65891be3e04111a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a115789580a4449f8b65891be3e04111a">ucnv_getStarters</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> starters[256], <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:a115789580a4449f8b65891be3e04111a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94a776ddba4f503fe9ad08a88c66b8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ab94a776ddba4f503fe9ad08a88c66b8d">ucnv_getUnicodeSet</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, <a class="el" href="uchar_8h.html#adce3fef7c15d7c78196bf977ac96ec9c">USet</a> *setFillIn, <a class="el" href="ucnv_8h.html#a402221896b6d7153b14a5ff8dadde806">UConverterUnicodeSet</a> whichSet, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:ab94a776ddba4f503fe9ad08a88c66b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9981e203dd727f20ce391e9c1c12d88c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a9981e203dd727f20ce391e9c1c12d88c">ucnv_getToUCallBack</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, <a class="el" href="ucnv_8h.html#ae077d9f2a37d3aa640c3c2032a2baa2c">UConverterToUCallback</a> *action, const void **context)</td></tr>
<tr class="separator:a9981e203dd727f20ce391e9c1c12d88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621359c31651d5615bd063917f41a3eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a621359c31651d5615bd063917f41a3eb">ucnv_getFromUCallBack</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, <a class="el" href="ucnv_8h.html#a7002374690e3deef6b3ad9fb9ec8b1e5">UConverterFromUCallback</a> *action, const void **context)</td></tr>
<tr class="separator:a621359c31651d5615bd063917f41a3eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce4464cdb5b488460bf21c116cb1cf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#afce4464cdb5b488460bf21c116cb1cf2">ucnv_setToUCallBack</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, <a class="el" href="ucnv_8h.html#ae077d9f2a37d3aa640c3c2032a2baa2c">UConverterToUCallback</a> newAction, const void *newContext, <a class="el" href="ucnv_8h.html#ae077d9f2a37d3aa640c3c2032a2baa2c">UConverterToUCallback</a> *oldAction, const void **oldContext, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:afce4464cdb5b488460bf21c116cb1cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304bcaa1f4cbc789d10197d6f51c94f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a304bcaa1f4cbc789d10197d6f51c94f1">ucnv_setFromUCallBack</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, <a class="el" href="ucnv_8h.html#a7002374690e3deef6b3ad9fb9ec8b1e5">UConverterFromUCallback</a> newAction, const void *newContext, <a class="el" href="ucnv_8h.html#a7002374690e3deef6b3ad9fb9ec8b1e5">UConverterFromUCallback</a> *oldAction, const void **oldContext, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:a304bcaa1f4cbc789d10197d6f51c94f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63cf11835833041f2ce0ed3662edfcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#aa63cf11835833041f2ce0ed3662edfcd">ucnv_fromUnicode</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, char **target, const char *targetLimit, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> **source, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *sourceLimit, int32_t *offsets, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> flush, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:aa63cf11835833041f2ce0ed3662edfcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbbface3193728333668691daaf2fbfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> **target, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *targetLimit, const char **source, const char *sourceLimit, int32_t *offsets, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> flush, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:afbbface3193728333668691daaf2fbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc3d9d8fbab664493a9aa189d120571"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a2cc3d9d8fbab664493a9aa189d120571">ucnv_fromUChars</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, char *dest, int32_t destCapacity, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *src, int32_t srcLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:a2cc3d9d8fbab664493a9aa189d120571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd107e398535c523d900f030df8326df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#afd107e398535c523d900f030df8326df">ucnv_toUChars</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *dest, int32_t destCapacity, const char *src, int32_t srcLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:afd107e398535c523d900f030df8326df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c0fdce8c98e50dea85beb3f086fe8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a00c0fdce8c98e50dea85beb3f086fe8e">ucnv_getNextUChar</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *converter, const char **source, const char *sourceLimit, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *err)</td></tr>
<tr class="separator:a00c0fdce8c98e50dea85beb3f086fe8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab80dfe1f774537db9d5497a2ba8be7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *targetCnv, <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *sourceCnv, char **target, const char *targetLimit, const char **source, const char *sourceLimit, <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *pivotStart, <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> **pivotSource, <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> **pivotTarget, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *pivotLimit, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> reset, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> flush, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:a1ab80dfe1f774537db9d5497a2ba8be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a942e532c2f02bcaea39741d4b99764b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a942e532c2f02bcaea39741d4b99764b5">ucnv_convert</a> (const char *toConverterName, const char *fromConverterName, char *target, int32_t targetCapacity, const char *source, int32_t sourceLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:a942e532c2f02bcaea39741d4b99764b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872d74b772834c4c7924edfe1f933691"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a872d74b772834c4c7924edfe1f933691">ucnv_toAlgorithmic</a> (<a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a> algorithmicType, <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, char *target, int32_t targetCapacity, const char *source, int32_t sourceLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:a872d74b772834c4c7924edfe1f933691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939c6148e6ebcf39568ce1c6ea0a24f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a939c6148e6ebcf39568ce1c6ea0a24f0">ucnv_fromAlgorithmic</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, <a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a> algorithmicType, char *target, int32_t targetCapacity, const char *source, int32_t sourceLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:a939c6148e6ebcf39568ce1c6ea0a24f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae81557ec64ef4902a5bcb56a8cfac369"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ae81557ec64ef4902a5bcb56a8cfac369">ucnv_flushCache</a> (void)</td></tr>
<tr class="separator:ae81557ec64ef4902a5bcb56a8cfac369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d737c9927986829ca6add75af6e792"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a13d737c9927986829ca6add75af6e792">ucnv_countAvailable</a> (void)</td></tr>
<tr class="separator:a13d737c9927986829ca6add75af6e792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b954cb4102add0e0400a149b37b3a9f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char *U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a5b954cb4102add0e0400a149b37b3a9f">ucnv_getAvailableName</a> (int32_t n)</td></tr>
<tr class="separator:a5b954cb4102add0e0400a149b37b3a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc7b6cbf949eaed1814d3c28b1eb3cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="uenum_8h.html#a32b7253b2148022535be36a9fcdb5a8d">UEnumeration</a> *U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a2bc7b6cbf949eaed1814d3c28b1eb3cf">ucnv_openAllNames</a> (<a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:a2bc7b6cbf949eaed1814d3c28b1eb3cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39f04062207e225bcbca84747b200fee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> uint16_t U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a39f04062207e225bcbca84747b200fee">ucnv_countAliases</a> (const char *alias, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:a39f04062207e225bcbca84747b200fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c95bfc3450d7b3fcf8e1681f7b172c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char *U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a97c95bfc3450d7b3fcf8e1681f7b172c">ucnv_getAlias</a> (const char *alias, uint16_t n, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:a97c95bfc3450d7b3fcf8e1681f7b172c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82642e5dbf8992c701d96f750e6be53c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a82642e5dbf8992c701d96f750e6be53c">ucnv_getAliases</a> (const char *alias, const char **aliases, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:a82642e5dbf8992c701d96f750e6be53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5f2eac73a564d004b4a3e30d4601c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="uenum_8h.html#a32b7253b2148022535be36a9fcdb5a8d">UEnumeration</a> *U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a7d5f2eac73a564d004b4a3e30d4601c1">ucnv_openStandardNames</a> (const char *convName, const char *standard, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:a7d5f2eac73a564d004b4a3e30d4601c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46831e642b1ff4e4f5fa724bc5a24cb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> uint16_t U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a46831e642b1ff4e4f5fa724bc5a24cb8">ucnv_countStandards</a> (void)</td></tr>
<tr class="separator:a46831e642b1ff4e4f5fa724bc5a24cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97761ff4c82dc46884337e834ba04e78"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char *U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a97761ff4c82dc46884337e834ba04e78">ucnv_getStandard</a> (uint16_t n, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:a97761ff4c82dc46884337e834ba04e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab713bdfeeea22684aa5bbbf2e00d23ef"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char *U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ab713bdfeeea22684aa5bbbf2e00d23ef">ucnv_getStandardName</a> (const char *name, const char *standard, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:ab713bdfeeea22684aa5bbbf2e00d23ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0427bb4cb713666af42dd31c4ca9e55f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char *U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a0427bb4cb713666af42dd31c4ca9e55f">ucnv_getCanonicalName</a> (const char *alias, const char *standard, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:a0427bb4cb713666af42dd31c4ca9e55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a9f2aae7fb71436cab7ace6945d35d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char *U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a34a9f2aae7fb71436cab7ace6945d35d">ucnv_getDefaultName</a> (void)</td></tr>
<tr class="separator:a34a9f2aae7fb71436cab7ace6945d35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a983781f10d4e1e7f19ca2e1c6a4de9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a8a983781f10d4e1e7f19ca2e1c6a4de9">ucnv_setDefaultName</a> (const char *name)</td></tr>
<tr class="separator:a8a983781f10d4e1e7f19ca2e1c6a4de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be456de4ae58f16325f99d097607473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a5be456de4ae58f16325f99d097607473">ucnv_fixFileSeparator</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *source, int32_t sourceLen)</td></tr>
<tr class="separator:a5be456de4ae58f16325f99d097607473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad809545cb8d0edf3067e1a5d690bf71f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#ad809545cb8d0edf3067e1a5d690bf71f">ucnv_isAmbiguous</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv)</td></tr>
<tr class="separator:ad809545cb8d0edf3067e1a5d690bf71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a1f70909aa917783b1ec6f350bde107"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a6a1f70909aa917783b1ec6f350bde107">ucnv_setFallback</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> usesFallback)</td></tr>
<tr class="separator:a6a1f70909aa917783b1ec6f350bde107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ae28ad00c484d5edebed7a80237bfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#aa9ae28ad00c484d5edebed7a80237bfd">ucnv_usesFallback</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv)</td></tr>
<tr class="separator:aa9ae28ad00c484d5edebed7a80237bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be9c90442bc35a27ab42a4c0fbad5c3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char *U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a5be9c90442bc35a27ab42a4c0fbad5c3">ucnv_detectUnicodeSignature</a> (const char *source, int32_t sourceLength, int32_t *signatureLength, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td></tr>
<tr class="separator:a5be9c90442bc35a27ab42a4c0fbad5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b13202c998e661fb112c44476668ce8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a9b13202c998e661fb112c44476668ce8">ucnv_fromUCountPending</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="separator:a9b13202c998e661fb112c44476668ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdb66e7ae11ef4b256096609450bce3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a9cdb66e7ae11ef4b256096609450bce3">ucnv_toUCountPending</a> (const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="separator:a9cdb66e7ae11ef4b256096609450bce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8372ee20e068d100f86db7aaf95f4665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> U_EXPORT2&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ucnv_8h.html#a8372ee20e068d100f86db7aaf95f4665">ucnv_isFixedWidth</a> (<a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *status)</td></tr>
<tr class="separator:a8372ee20e068d100f86db7aaf95f4665"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>C API: Character conversion. </p>
<h2>Character Conversion C API</h2>
<p>This API is used to convert codepage or character encoded data to and from UTF-16. You can open a converter with <a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open()</a>. With that converter, you can get its properties, set options, convert your data and close the converter.</p>
<p>Since many software programs recognize different converter names for different types of converters, there are other functions in this API to iterate over the converter aliases. The functions <a class="el" href="ucnv_8h.html#a5b954cb4102add0e0400a149b37b3a9f">ucnv_getAvailableName()</a>, <a class="el" href="ucnv_8h.html#a97c95bfc3450d7b3fcf8e1681f7b172c">ucnv_getAlias()</a> and <a class="el" href="ucnv_8h.html#ab713bdfeeea22684aa5bbbf2e00d23ef">ucnv_getStandardName()</a> are some of the more frequently used alias functions to get this information.</p>
<p>When a converter encounters an illegal, irregular, invalid or unmappable character its default behavior is to use a substitution character to replace the bad byte sequence. This behavior can be changed by using <a class="el" href="ucnv_8h.html#a304bcaa1f4cbc789d10197d6f51c94f1">ucnv_setFromUCallBack()</a> or <a class="el" href="ucnv_8h.html#afce4464cdb5b488460bf21c116cb1cf2">ucnv_setToUCallBack()</a> on the converter. The header <a class="el" href="ucnv__err_8h.html" title="C UConverter predefined error callbacks.">ucnv_err.h</a> defines many other callback actions that can be used instead of a character substitution.</p>
<p>More information about this API can be found in our <a href="http://icu-project.org/userguide/conversion.html">User's Guide</a>.</p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ab6ef5c3c7c83982313e415e697a26089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ef5c3c7c83982313e415e697a26089">&#9670;&nbsp;</a></span>U_CNV_SAFECLONE_BUFFERSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define U_CNV_SAFECLONE_BUFFERSIZE&#160;&#160;&#160;1024</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Definition of a buffer size that is designed to be large enough for converters to be cloned with <a class="el" href="ucnv_8h.html#aebb51e41917fe9b0488cfdb5717ff826">ucnv_safeClone()</a>. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000038">Deprecated:</a></b></dt><dd>ICU 52. Do not rely on <a class="el" href="ucnv_8h.html#aebb51e41917fe9b0488cfdb5717ff826">ucnv_safeClone()</a> cloning into any provided buffer. </dd></dl>

</div>
</div>
<a id="aa3d7e4ae84f8a95b9735ed3491cdb77e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d7e4ae84f8a95b9735ed3491cdb77e">&#9670;&nbsp;</a></span>UCNV_GET_MAX_BYTES_FOR_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_GET_MAX_BYTES_FOR_STRING</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">length, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">maxCharSize&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((int32_t)(length)+10)*(int32_t)(maxCharSize))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the size of a buffer for conversion from Unicode to a charset. The calculated size is guaranteed to be sufficient for this conversion.</p>
<p>It takes into account initial and final non-character bytes that are output by some converters. It does not take into account callbacks which output more than one charset character sequence per call, like escape callbacks. The default (substitution) callback only outputs one charset character sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">length</td><td>Number of UChars to be converted. </td></tr>
    <tr><td class="paramname">maxCharSize</td><td>Return value from <a class="el" href="ucnv_8h.html#ab284cb660babcd328f4e03f6f0b0b802">ucnv_getMaxCharSize()</a> for the converter that will be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Size of a buffer that will be large enough to hold the output bytes of converting length UChars with the converter that returned the maxCharSize.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#ab284cb660babcd328f4e03f6f0b0b802">ucnv_getMaxCharSize</a> @stable ICU 2.8 </dd></dl>

</div>
</div>
<a id="a867b3f44513565bca406eebe2f87ee99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a867b3f44513565bca406eebe2f87ee99">&#9670;&nbsp;</a></span>UCNV_LOCALE_OPTION_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_LOCALE_OPTION_STRING&#160;&#160;&#160;&quot;,locale=&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converter option for specifying a locale. For example, ucnv_open("SCSU,locale=ja", &amp;errorCode); See convrtrs.txt.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a3ab00bb423db8533da12c35848e4c281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab00bb423db8533da12c35848e4c281">&#9670;&nbsp;</a></span>UCNV_MAX_CONVERTER_NAME_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_MAX_CONVERTER_NAME_LENGTH&#160;&#160;&#160;60</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum length of a converter name including the terminating NULL @stable ICU 2.0 </p>

</div>
</div>
<a id="a1a579f67d05b09f731df5a68eb80b851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a579f67d05b09f731df5a68eb80b851">&#9670;&nbsp;</a></span>UCNV_MAX_FULL_FILE_NAME_LENGTH</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_MAX_FULL_FILE_NAME_LENGTH&#160;&#160;&#160;(600+<a class="el" href="ucnv_8h.html#a3ab00bb423db8533da12c35848e4c281">UCNV_MAX_CONVERTER_NAME_LENGTH</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum length of a converter name including path and terminating NULL @stable ICU 2.0 </p>

</div>
</div>
<a id="a420028eb5f83222307bf16632857b148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420028eb5f83222307bf16632857b148">&#9670;&nbsp;</a></span>UCNV_OPTION_SEP_CHAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_OPTION_SEP_CHAR&#160;&#160;&#160;','</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Character that separates converter names from options and options from each other. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a8f221dc37208cc5c5e9b1d72a7103435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f221dc37208cc5c5e9b1d72a7103435">&#9670;&nbsp;</a></span>UCNV_OPTION_SEP_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_OPTION_SEP_STRING&#160;&#160;&#160;&quot;,&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>String version of UCNV_OPTION_SEP_CHAR. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a082aba7f50746ff6135a4ca2a00f6d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082aba7f50746ff6135a4ca2a00f6d6c">&#9670;&nbsp;</a></span>UCNV_SI</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_SI&#160;&#160;&#160;0x0F</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shift in for EBDCDIC_STATEFUL and iso2022 states @stable ICU 2.0 </p>

</div>
</div>
<a id="ad3918524388c8100107273806bd58c65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3918524388c8100107273806bd58c65">&#9670;&nbsp;</a></span>UCNV_SO</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_SO&#160;&#160;&#160;0x0E</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shift out for EBDCDIC_STATEFUL and iso2022 states @stable ICU 2.0 </p>

</div>
</div>
<a id="a0588f7014923ad969821941f9dd51040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0588f7014923ad969821941f9dd51040">&#9670;&nbsp;</a></span>UCNV_SWAP_LFNL_OPTION_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_SWAP_LFNL_OPTION_STRING&#160;&#160;&#160;&quot;,swaplfnl&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converter option for EBCDIC SBCS or mixed-SBCS/DBCS (stateful) codepages. Swaps Unicode mappings for EBCDIC LF and NL codes, as used on S/390 (z/OS) Unix System Services (Open Edition). For example, ucnv_open("ibm-1047,swaplfnl", &amp;errorCode); See convrtrs.txt.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a> @stable ICU 2.4 </dd></dl>

</div>
</div>
<a id="a92803b44385721ec771befc01b5e8e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92803b44385721ec771befc01b5e8e3b">&#9670;&nbsp;</a></span>UCNV_VALUE_SEP_CHAR</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_VALUE_SEP_CHAR&#160;&#160;&#160;'='</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Character that separates a converter option from its value. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a33cd53c804d95e14388398843e6edc82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33cd53c804d95e14388398843e6edc82">&#9670;&nbsp;</a></span>UCNV_VALUE_SEP_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_VALUE_SEP_STRING&#160;&#160;&#160;&quot;=&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>String version of UCNV_VALUE_SEP_CHAR. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="ac7b80fb72078403f8bdba322b63a5a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b80fb72078403f8bdba322b63a5a93">&#9670;&nbsp;</a></span>UCNV_VERSION_OPTION_STRING</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UCNV_VERSION_OPTION_STRING&#160;&#160;&#160;&quot;,version=&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converter option for specifying a version selector (0..9) for some converters. For example, </p><div class="fragment"><div class="line"><a class="code" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a>(<span class="stringliteral">&quot;UTF-7,version=1&quot;</span>, &amp;errorCode);</div>
</div><!-- fragment --><p> See convrtrs.txt.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a> @stable ICU 2.4 </dd></dl>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a7002374690e3deef6b3ad9fb9ec8b1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7002374690e3deef6b3ad9fb9ec8b1e5">&#9670;&nbsp;</a></span>UConverterFromUCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(U_EXPORT2 * UConverterFromUCallback) (const void *context, <a class="el" href="struct_u_converter_from_unicode_args.html">UConverterFromUnicodeArgs</a> *args, const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *codeUnits, int32_t length, <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> codePoint, <a class="el" href="ucnv__err_8h.html#a19e1a4d55a7679634e84b241b00de01a">UConverterCallbackReason</a> reason, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function pointer for error callback in the unicode to codepage direction. Called when an error has occurred in conversion from unicode, or on open/close of the callback (see reason). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the callback's private data </td></tr>
    <tr><td class="paramname">args</td><td>Information about the conversion in progress </td></tr>
    <tr><td class="paramname">codeUnits</td><td>Points to 'length' UChars of the concerned Unicode sequence </td></tr>
    <tr><td class="paramname">length</td><td>Size (in bytes) of the concerned codepage sequence </td></tr>
    <tr><td class="paramname">codePoint</td><td>Single UChar32 (UTF-32) containing the concerend Unicode codepoint. </td></tr>
    <tr><td class="paramname">reason</td><td>Defines the reason the callback was invoked </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>ICU error code in/out parameter. For converter callback functions, set to a conversion error before the call, and the callback may reset it to U_ZERO_ERROR. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a304bcaa1f4cbc789d10197d6f51c94f1">ucnv_setFromUCallBack</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="ae077d9f2a37d3aa640c3c2032a2baa2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae077d9f2a37d3aa640c3c2032a2baa2c">&#9670;&nbsp;</a></span>UConverterToUCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(U_EXPORT2 * UConverterToUCallback) (const void *context, <a class="el" href="struct_u_converter_to_unicode_args.html">UConverterToUnicodeArgs</a> *args, const char *codeUnits, int32_t length, <a class="el" href="ucnv__err_8h.html#a19e1a4d55a7679634e84b241b00de01a">UConverterCallbackReason</a> reason, <a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function pointer for error callback in the codepage to unicode direction. Called when an error has occurred in conversion to unicode, or on open/close of the callback (see reason). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Pointer to the callback's private data </td></tr>
    <tr><td class="paramname">args</td><td>Information about the conversion in progress </td></tr>
    <tr><td class="paramname">codeUnits</td><td>Points to 'length' bytes of the concerned codepage sequence </td></tr>
    <tr><td class="paramname">length</td><td>Size (in bytes) of the concerned codepage sequence </td></tr>
    <tr><td class="paramname">reason</td><td>Defines the reason the callback was invoked </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>ICU error code in/out parameter. For converter callback functions, set to a conversion error before the call, and the callback may reset it to U_ZERO_ERROR. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#afce4464cdb5b488460bf21c116cb1cf2">ucnv_setToUCallBack</a> </dd>
<dd>
<a class="el" href="struct_u_converter_to_unicode_args.html">UConverterToUnicodeArgs</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a3160ba6268742546123c8fecdbfbabb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3160ba6268742546123c8fecdbfbabb2">&#9670;&nbsp;</a></span>UConverterUnicodeSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="ucnv_8h.html#a402221896b6d7153b14a5ff8dadde806">UConverterUnicodeSet</a> <a class="el" href="ucnv_8h.html#a402221896b6d7153b14a5ff8dadde806">UConverterUnicodeSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selectors for Unicode sets that can be returned by <a class="el" href="ucnv_8h.html#ab94a776ddba4f503fe9ad08a88c66b8d">ucnv_getUnicodeSet()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#ab94a776ddba4f503fe9ad08a88c66b8d">ucnv_getUnicodeSet</a> @stable ICU 2.6 </dd></dl>

</div>
</div>
<a id="adce3fef7c15d7c78196bf977ac96ec9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adce3fef7c15d7c78196bf977ac96ec9c">&#9670;&nbsp;</a></span>USet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="uchar_8h.html#adce3fef7c15d7c78196bf977ac96ec9c">USet</a> <a class="el" href="uchar_8h.html#adce3fef7c15d7c78196bf977ac96ec9c">USet</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>USet is the C API type corresponding to C++ class UnicodeSet. It is forward-declared here to avoid including <a class="el" href="uset_8h.html" title="C API: Unicode Set.">unicode/uset.h</a> file if related conversion APIs are not used.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#ab94a776ddba4f503fe9ad08a88c66b8d">ucnv_getUnicodeSet</a> @stable ICU 2.4 </dd></dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aba5ba7fbc2f113618ba57f4d9825ff85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5ba7fbc2f113618ba57f4d9825ff85">&#9670;&nbsp;</a></span>UConverterPlatform</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ucnv_8h.html#aba5ba7fbc2f113618ba57f4d9825ff85">UConverterPlatform</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum for specifying which platform a converter ID refers to. The use of platform/CCSID is not recommended. See <a class="el" href="ucnv_8h.html#a3f54f96fcedd8d89f433c4bd9437864d">ucnv_openCCSID()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a979fb8ddc407eccd2ac89d502d5245e5">ucnv_getPlatform</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a3f54f96fcedd8d89f433c4bd9437864d">ucnv_openCCSID</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#ad17df5c1434e7f5fd3c2871543428346">ucnv_getCCSID</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="adb0b44c6bd828c9d4cc2defcbba0f902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb0b44c6bd828c9d4cc2defcbba0f902">&#9670;&nbsp;</a></span>UConverterType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enum for specifying basic types of converters </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a84c7d83c0179a90eadab5ebc8040fdb6">ucnv_getType</a> @stable ICU 2.0 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a8ba1940e34a58186b231679da1272904"></a>UCNV_UNSUPPORTED_CONVERTER&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a81e595b85ba86dd7fde25f2a1c59bfc3"></a>UCNV_SBCS&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902af7ed8ed108be1286bd0e01818dae0dbd"></a>UCNV_DBCS&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902ac0f17aec1772eeca6c86d13191b6c852"></a>UCNV_MBCS&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a1211937ef4e044d96014a77c04915554"></a>UCNV_LATIN_1&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a6a63fa949b29c7a55cc7cf5eecc3c89e"></a>UCNV_UTF8&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902aac97a8806bad1e28965f045cdbd8e305"></a>UCNV_UTF16_BigEndian&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a824cb728f9beb71051820f49f74fa4dd"></a>UCNV_UTF16_LittleEndian&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a1c8fa4af063d027b5bc2baa03bc29da8"></a>UCNV_UTF32_BigEndian&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902aa776a4cccf14778c20230da58aa1c38d"></a>UCNV_UTF32_LittleEndian&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902ab5b73d6ee548bda138fc56829800111b"></a>UCNV_EBCDIC_STATEFUL&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a11368f51e102406facd6da0a3ee7d606"></a>UCNV_ISO_2022&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902af2c460935eca00105ad7dc2622d74100"></a>UCNV_LMBCS_1&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902aaafb05c0fda0e6530807fedabf82c261"></a>UCNV_LMBCS_2&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a6020a8e2cc71c9f8d8a64d729db9adb2"></a>UCNV_LMBCS_3&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902ac71afd7dc6b8a304638e52f8a8bed20b"></a>UCNV_LMBCS_4&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902ab126f5ee7a9c722ed0425973cea76df3"></a>UCNV_LMBCS_5&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a443a68687c6c38b7d683fa4070a953bd"></a>UCNV_LMBCS_6&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902aa8001a5fc7d37fa386c3d147106a6a5e"></a>UCNV_LMBCS_8&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a0be612a93cffc67fc042b1bc168ed205"></a>UCNV_LMBCS_11&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a98bc32e41e4d6e7bd75275c7f9738113"></a>UCNV_LMBCS_16&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a41ffccf0b679631558a2547d2e445cea"></a>UCNV_LMBCS_17&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902ad7a7305473e98bb7a9b4bf1f23406599"></a>UCNV_LMBCS_18&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a16ff6cda2e1211eceadda889dbb359ba"></a>UCNV_LMBCS_19&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902aee49b0c0e4b4fc4eb16627fce1620938"></a>UCNV_LMBCS_LAST&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a086920821721b34d9260723ec86d5a71"></a>UCNV_HZ&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902ace8cd9e435b4a5579286931a57c0bd88"></a>UCNV_SCSU&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a59030fe051a4961ab474d0d91017ad47"></a>UCNV_ISCII&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902aaadc5fba9e00621313dd6c9a5be3a84d"></a>UCNV_US_ASCII&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902ad4a8edc0956f24d724441118a8f2226c"></a>UCNV_UTF7&#160;</td><td class="fielddoc"><p>@stable ICU 2.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902add63c4e0987f7622db1f2c2052dd7da8"></a>UCNV_BOCU1&#160;</td><td class="fielddoc"><p>@stable ICU 2.2 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902aab2340e8dc51c36dd8f0b48b07ac82c1"></a>UCNV_UTF16&#160;</td><td class="fielddoc"><p>@stable ICU 2.2 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a4eed53e3582d767aa03cd3ba3828515f"></a>UCNV_UTF32&#160;</td><td class="fielddoc"><p>@stable ICU 2.2 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902afceba4bdab9c135cccabc255e580980b"></a>UCNV_CESU8&#160;</td><td class="fielddoc"><p>@stable ICU 2.2 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a690c232e8a75021df389c39f03869d26"></a>UCNV_IMAP_MAILBOX&#160;</td><td class="fielddoc"><p>@stable ICU 2.4 </p>
</td></tr>
<tr><td class="fieldname"><a id="adb0b44c6bd828c9d4cc2defcbba0f902a15555ec1e53dfa419dc6231f326ef79d"></a>UCNV_COMPOUND_TEXT&#160;</td><td class="fielddoc"><p>@stable ICU 4.8 </p>
</td></tr>
</table>

</div>
</div>
<a id="a402221896b6d7153b14a5ff8dadde806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a402221896b6d7153b14a5ff8dadde806">&#9670;&nbsp;</a></span>UConverterUnicodeSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="ucnv_8h.html#a402221896b6d7153b14a5ff8dadde806">UConverterUnicodeSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selectors for Unicode sets that can be returned by <a class="el" href="ucnv_8h.html#ab94a776ddba4f503fe9ad08a88c66b8d">ucnv_getUnicodeSet()</a>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#ab94a776ddba4f503fe9ad08a88c66b8d">ucnv_getUnicodeSet</a> @stable ICU 2.6 </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a402221896b6d7153b14a5ff8dadde806ab08c09dd129a92d08725b5260b49cbf9"></a>UCNV_ROUNDTRIP_SET&#160;</td><td class="fielddoc"><p>Select the set of roundtrippable Unicode code points. @stable ICU 2.6 </p>
</td></tr>
<tr><td class="fieldname"><a id="a402221896b6d7153b14a5ff8dadde806a38d95100b8b58d2c66c4c83b30d99499"></a>UCNV_ROUNDTRIP_AND_FALLBACK_SET&#160;</td><td class="fielddoc"><p>Select the set of Unicode code points with roundtrip or fallback mappings. @stable ICU 4.0 </p>
</td></tr>
<tr><td class="fieldname"><a id="a402221896b6d7153b14a5ff8dadde806a33cced69d47e6de3cbfd79d17f88fcaf"></a>UCNV_SET_COUNT&#160;</td><td class="fielddoc"><p>Number of UConverterUnicodeSet selectors. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>ICU 58 The numeric value may change over time, see ICU ticket #12420. </dd></dl>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a499316e130bdd073c394c92f55c315d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499316e130bdd073c394c92f55c315d2">&#9670;&nbsp;</a></span>ucnv_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the unicode converter and releases resources associated with just this instance. Does not free up shared converter tables.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the converter object to be deleted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#ad3f473f991769a94f21e195473470157">ucnv_openU</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a3f54f96fcedd8d89f433c4bd9437864d">ucnv_openCCSID</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a8d23f178a9474210cce08530fbfe6ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d23f178a9474210cce08530fbfe6ab3">&#9670;&nbsp;</a></span>ucnv_compareNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int U_EXPORT2 ucnv_compareNames </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do a fuzzy compare of two converter/alias names. The comparison is case-insensitive, ignores leading zeroes if they are not followed by further digits, and ignores all but letters and digits. Thus the strings "UTF-8", "utf_8", "u*T@f08" and "Utf 8" are exactly equivalent. See section 1.4, Charset Alias Matching in Unicode Technical Standard #22 at <a href="http://www.unicode.org/reports/tr22/">http://www.unicode.org/reports/tr22/</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name1</td><td>a converter name or alias, zero-terminated </td></tr>
    <tr><td class="paramname">name2</td><td>a converter name or alias, zero-terminated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if the names match, or a negative value if the name1 lexically precedes name2, or a positive value if the name1 lexically follows name2. @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a942e532c2f02bcaea39741d4b99764b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a942e532c2f02bcaea39741d4b99764b5">&#9670;&nbsp;</a></span>ucnv_convert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2 ucnv_convert </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>toConverterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fromConverterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>targetCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sourceLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from one external charset to another. Internally, two converters are opened according to the name arguments, then the text is converted to and from the 16-bit Unicode "pivot" using <a class="el" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx()</a>, then the converters are closed again.</p>
<p>This is a convenience function, not an efficient way to convert a lot of text: <a class="el" href="ucnv_8h.html#a942e532c2f02bcaea39741d4b99764b5">ucnv_convert()</a></p><ul>
<li>takes charset names, not converter objects, so that<ul>
<li>two converters are opened for each call</li>
<li>only single-string conversion is possible, not streaming operation</li>
</ul>
</li>
<li>does not provide enough information to find out, in case of failure, whether the toUnicode or the fromUnicode conversion failed</li>
<li>allows NUL-terminated input (only a single NUL byte, will not work for charsets with multi-byte NULs) (if sourceLength==-1, see parameters)</li>
<li>terminate with a NUL on output (only a single NUL byte, not useful for charsets with multi-byte NULs), or set U_STRING_NOT_TERMINATED_WARNING if the output exactly fills the target buffer</li>
<li>a pivot buffer is provided internally</li>
</ul>
<p>The function returns when one of the following is true:</p><ul>
<li>the entire source text has been converted successfully to the target buffer and either the target buffer is terminated with a single NUL byte or the error code is set to U_STRING_NOT_TERMINATED_WARNING</li>
<li>a target buffer overflow occurred (U_BUFFER_OVERFLOW_ERROR) and the full output string length is returned ("preflighting")</li>
<li>a conversion error occurred (other <a class="el" href="utypes_8h.html#a4d202200b6aa6f3c965ea370e0c8155f">U_FAILURE()</a>, see description of pErrorCode)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toConverterName</td><td>The name of the converter that is used to convert from the UTF-16 pivot buffer to the target. </td></tr>
    <tr><td class="paramname">fromConverterName</td><td>The name of the converter that is used to convert from the source to the UTF-16 pivot buffer. </td></tr>
    <tr><td class="paramname">target</td><td>Pointer to the output buffer. </td></tr>
    <tr><td class="paramname">targetCapacity</td><td>Capacity of the target, in bytes. </td></tr>
    <tr><td class="paramname">source</td><td>Pointer to the input buffer. </td></tr>
    <tr><td class="paramname">sourceLength</td><td>Length of the input text, in bytes, or -1 for NUL-terminated input. </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the complete output text in bytes, even if it exceeds the targetCapacity and a U_BUFFER_OVERFLOW_ERROR is set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a939c6148e6ebcf39568ce1c6ea0a24f0">ucnv_fromAlgorithmic</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a872d74b772834c4c7924edfe1f933691">ucnv_toAlgorithmic</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#aa63cf11835833041f2ce0ed3662edfcd">ucnv_fromUnicode</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a2cc3d9d8fbab664493a9aa189d120571">ucnv_fromUChars</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#afd107e398535c523d900f030df8326df">ucnv_toUChars</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a00c0fdce8c98e50dea85beb3f086fe8e">ucnv_getNextUChar</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a1ab80dfe1f774537db9d5497a2ba8be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab80dfe1f774537db9d5497a2ba8be7">&#9670;&nbsp;</a></span>ucnv_convertEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_convertEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>targetCnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>sourceCnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>targetLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sourceLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>pivotStart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> **&#160;</td>
          <td class="paramname"><em>pivotSource</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> **&#160;</td>
          <td class="paramname"><em>pivotTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>pivotLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td>
          <td class="paramname"><em>reset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from one external charset to another using two existing UConverters. Internally, two conversions - <a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode()</a> and <a class="el" href="ucnv_8h.html#aa63cf11835833041f2ce0ed3662edfcd">ucnv_fromUnicode()</a> - are used, "pivoting" through 16-bit Unicode.</p>
<p>Important: For streaming conversion (multiple function calls for successive parts of a text stream), the caller must provide a pivot buffer explicitly, and must preserve the pivot buffer and associated pointers from one call to another. (The buffer may be moved if its contents and the relative pointer positions are preserved.)</p>
<p>There is a similar function, <a class="el" href="ucnv_8h.html#a942e532c2f02bcaea39741d4b99764b5">ucnv_convert()</a>, which has the following limitations:</p><ul>
<li>it takes charset names, not converter objects, so that<ul>
<li>two converters are opened for each call</li>
<li>only single-string conversion is possible, not streaming operation</li>
</ul>
</li>
<li>it does not provide enough information to find out, in case of failure, whether the toUnicode or the fromUnicode conversion failed</li>
</ul>
<p>By contrast, <a class="el" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx()</a></p><ul>
<li>takes UConverter parameters instead of charset names</li>
<li>fully exposes the pivot buffer for streaming conversion and complete error handling</li>
</ul>
<p><a class="el" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx()</a> also provides further convenience:</p><ul>
<li>an option to reset the converters at the beginning (if reset==true, see parameters; also sets *pivotTarget=*pivotSource=pivotStart)</li>
<li>allow NUL-terminated input (only a single NUL byte, will not work for charsets with multi-byte NULs) (if sourceLimit==NULL, see parameters)</li>
<li>terminate with a NUL on output (only a single NUL byte, not useful for charsets with multi-byte NULs), or set U_STRING_NOT_TERMINATED_WARNING if the output exactly fills the target buffer</li>
<li>the pivot buffer can be provided internally; possible only for whole-string conversion, not streaming conversion; in this case, the caller will not be able to get details about where an error occurred (if pivotStart==NULL, see below)</li>
</ul>
<p>The function returns when one of the following is true:</p><ul>
<li>the entire source text has been converted successfully to the target buffer</li>
<li>a target buffer overflow occurred (U_BUFFER_OVERFLOW_ERROR)</li>
<li>a conversion error occurred (other <a class="el" href="utypes_8h.html#a4d202200b6aa6f3c965ea370e0c8155f">U_FAILURE()</a>, see description of pErrorCode)</li>
</ul>
<p>Limitation compared to the direct use of <a class="el" href="ucnv_8h.html#aa63cf11835833041f2ce0ed3662edfcd">ucnv_fromUnicode()</a> and <a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode()</a>: <a class="el" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx()</a> does not provide offset information.</p>
<p>Limitation compared to <a class="el" href="ucnv_8h.html#a2cc3d9d8fbab664493a9aa189d120571">ucnv_fromUChars()</a> and <a class="el" href="ucnv_8h.html#afd107e398535c523d900f030df8326df">ucnv_toUChars()</a>: <a class="el" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx()</a> does not support preflighting directly.</p>
<p>Sample code for converting a single string from one external charset to UTF-8, ignoring the location of errors:</p>
<div class="fragment"><div class="line">int32_t</div>
<div class="line">myToUTF8(<a class="code" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *cnv,</div>
<div class="line">         <span class="keyword">const</span> <span class="keywordtype">char</span> *s, int32_t length,</div>
<div class="line">         <span class="keywordtype">char</span> *<a class="code" href="group__gtc__type__precision.html#ga5e3dc67373d5068997d2d9f41c9024d2">u8</a>, int32_t capacity,</div>
<div class="line">         <a class="code" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *pErrorCode) {</div>
<div class="line">    <a class="code" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *utf8Cnv;</div>
<div class="line">    <span class="keywordtype">char</span> *target;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(<a class="code" href="utypes_8h.html#a4d202200b6aa6f3c965ea370e0c8155f">U_FAILURE</a>(*pErrorCode)) {</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    utf8Cnv=myGetCachedUTF8Converter(pErrorCode);</div>
<div class="line">    <span class="keywordflow">if</span>(<a class="code" href="utypes_8h.html#a4d202200b6aa6f3c965ea370e0c8155f">U_FAILURE</a>(*pErrorCode)) {</div>
<div class="line">        <span class="keywordflow">return</span> 0;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span>(length&lt;0) {</div>
<div class="line">        length=strlen(s);</div>
<div class="line">    }</div>
<div class="line">    target=<a class="code" href="group__gtc__type__precision.html#ga5e3dc67373d5068997d2d9f41c9024d2">u8</a>;</div>
<div class="line">    <a class="code" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx</a>(utf8Cnv, cnv,</div>
<div class="line">                   &amp;target, <a class="code" href="group__gtc__type__precision.html#ga5e3dc67373d5068997d2d9f41c9024d2">u8</a>+capacity,</div>
<div class="line">                   &amp;s, s+length,</div>
<div class="line">                   <a class="code" href="utypes_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="utypes_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="utypes_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>, <a class="code" href="utypes_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a>,</div>
<div class="line">                   <span class="keyword">true</span>, <span class="keyword">true</span>,</div>
<div class="line">                   pErrorCode);</div>
<div class="line"> </div>
<div class="line">    myReleaseCachedUTF8Converter(utf8Cnv);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// return the output string length, but without preflighting</span></div>
<div class="line">    <span class="keywordflow">return</span> (int32_t)(target-<a class="code" href="group__gtc__type__precision.html#ga5e3dc67373d5068997d2d9f41c9024d2">u8</a>);</div>
<div class="line">}</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetCnv</td><td>Output converter, used to convert from the UTF-16 pivot to the target using <a class="el" href="ucnv_8h.html#aa63cf11835833041f2ce0ed3662edfcd">ucnv_fromUnicode()</a>. </td></tr>
    <tr><td class="paramname">sourceCnv</td><td>Input converter, used to convert from the source to the UTF-16 pivot using <a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode()</a>. </td></tr>
    <tr><td class="paramname">target</td><td>I/O parameter, same as for <a class="el" href="ucnv_8h.html#a2cc3d9d8fbab664493a9aa189d120571">ucnv_fromUChars()</a>. Input: *target points to the beginning of the target buffer. Output: *target points to the first unit after the last char written. </td></tr>
    <tr><td class="paramname">targetLimit</td><td>Pointer to the first unit after the target buffer. </td></tr>
    <tr><td class="paramname">source</td><td>I/O parameter, same as for <a class="el" href="ucnv_8h.html#afd107e398535c523d900f030df8326df">ucnv_toUChars()</a>. Input: *source points to the beginning of the source buffer. Output: *source points to the first unit after the last char read. </td></tr>
    <tr><td class="paramname">sourceLimit</td><td>Pointer to the first unit after the source buffer. </td></tr>
    <tr><td class="paramname">pivotStart</td><td>Pointer to the UTF-16 pivot buffer. If pivotStart==NULL, then an internal buffer is used and the other pivot arguments are ignored and can be NULL as well. </td></tr>
    <tr><td class="paramname">pivotSource</td><td>I/O parameter, same as source in <a class="el" href="ucnv_8h.html#a2cc3d9d8fbab664493a9aa189d120571">ucnv_fromUChars()</a> for conversion from the pivot buffer to the target buffer. </td></tr>
    <tr><td class="paramname">pivotTarget</td><td>I/O parameter, same as target in <a class="el" href="ucnv_8h.html#afd107e398535c523d900f030df8326df">ucnv_toUChars()</a> for conversion from the source buffer to the pivot buffer. It must be pivotStart&lt;=*pivotSource&lt;=*pivotTarget&lt;=pivotLimit and pivotStart&lt;pivotLimit (unless pivotStart==NULL). </td></tr>
    <tr><td class="paramname">pivotLimit</td><td>Pointer to the first unit after the pivot buffer. </td></tr>
    <tr><td class="paramname">reset</td><td>If true, then ucnv_resetToUnicode(sourceCnv) and ucnv_resetFromUnicode(targetCnv) are called, and the pivot pointers are reset (*pivotTarget=*pivotSource=pivotStart). </td></tr>
    <tr><td class="paramname">flush</td><td>If true, indicates the end of the input. Passed directly to <a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode()</a>, and carried over to <a class="el" href="ucnv_8h.html#aa63cf11835833041f2ce0ed3662edfcd">ucnv_fromUnicode()</a> when the source is empty as well. </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. U_BUFFER_OVERFLOW_ERROR always refers to the target buffer because overflows into the pivot buffer are handled internally. Other conversion errors are from the source-to-pivot conversion if *pivotSource==pivotStart, otherwise from the pivot-to-target conversion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a942e532c2f02bcaea39741d4b99764b5">ucnv_convert</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a939c6148e6ebcf39568ce1c6ea0a24f0">ucnv_fromAlgorithmic</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a872d74b772834c4c7924edfe1f933691">ucnv_toAlgorithmic</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#aa63cf11835833041f2ce0ed3662edfcd">ucnv_fromUnicode</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a2cc3d9d8fbab664493a9aa189d120571">ucnv_fromUChars</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#afd107e398535c523d900f030df8326df">ucnv_toUChars</a> @stable ICU 2.6 </dd></dl>

</div>
</div>
<a id="a39f04062207e225bcbca84747b200fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39f04062207e225bcbca84747b200fee">&#9670;&nbsp;</a></span>ucnv_countAliases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> uint16_t U_EXPORT2 ucnv_countAliases </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the number of aliases for a given converter or alias name. If the alias is ambiguous, then the preferred converter is used and the status is set to U_AMBIGUOUS_ALIAS_WARNING. This method only enumerates the listed entries in the alias file. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>alias name </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>error status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of names on alias list for given alias @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a13d737c9927986829ca6add75af6e792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13d737c9927986829ca6add75af6e792">&#9670;&nbsp;</a></span>ucnv_countAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2 ucnv_countAvailable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of available converters, as per the alias file.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of available converters </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a5b954cb4102add0e0400a149b37b3a9f">ucnv_getAvailableName</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a46831e642b1ff4e4f5fa724bc5a24cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46831e642b1ff4e4f5fa724bc5a24cb8">&#9670;&nbsp;</a></span>ucnv_countStandards()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> uint16_t U_EXPORT2 ucnv_countStandards </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the number of standards associated to converter names. </p><dl class="section return"><dt>Returns</dt><dd>number of standards @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a5be9c90442bc35a27ab42a4c0fbad5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be9c90442bc35a27ab42a4c0fbad5c3">&#9670;&nbsp;</a></span>ucnv_detectUnicodeSignature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char* U_EXPORT2 ucnv_detectUnicodeSignature </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sourceLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>signatureLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detects Unicode signature byte sequences at the start of the byte stream and returns the charset name of the indicated Unicode charset. NULL is returned when no Unicode signature is recognized. The number of bytes in the signature is output as well.</p>
<p>The caller can <a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open()</a> a converter using the charset name. The first code unit (UChar) from the start of the stream will be U+FEFF (the Unicode BOM/signature character) and can usually be ignored.</p>
<p>For most Unicode charsets it is also possible to ignore the indicated number of initial stream bytes and start converting after them. However, there are stateful Unicode charsets (UTF-7 and BOCU-1) for which this will not work. Therefore, it is best to ignore the first output UChar instead of the input signature bytes. </p>
<p>Usage: </p><div class="fragment"></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>The source string in which the signature should be detected. </td></tr>
    <tr><td class="paramname">sourceLength</td><td>Length of the input string, or -1 if terminated with a NUL byte. </td></tr>
    <tr><td class="paramname">signatureLength</td><td>A pointer to int32_t to receive the number of bytes that make up the signature of the detected UTF. 0 if not detected. Can be a NULL pointer. </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The name of the encoding detected. NULL if encoding is not detected. @stable ICU 2.4 </dd></dl>

</div>
</div>
<a id="a5be456de4ae58f16325f99d097607473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be456de4ae58f16325f99d097607473">&#9670;&nbsp;</a></span>ucnv_fixFileSeparator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_fixFileSeparator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sourceLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fixes the backslash character mismapping. For example, in SJIS, the backslash character in the ASCII portion is also used to represent the yen currency sign. When mapping from Unicode character 0x005C, it's unclear whether to map the character back to yen or backslash in SJIS. This function will take the input buffer and replace all the yen sign characters with backslash. This is necessary when the user tries to open a file with the input buffer on Windows. This function will test the converter to see whether such mapping is required. You can sometimes avoid using this function by using the correct version of Shift-JIS.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnv</td><td>The converter representing the target codepage. </td></tr>
    <tr><td class="paramname">source</td><td>the input buffer to be fixed </td></tr>
    <tr><td class="paramname">sourceLen</td><td>the length of the input buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#ad809545cb8d0edf3067e1a5d690bf71f">ucnv_isAmbiguous</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="ae81557ec64ef4902a5bcb56a8cfac369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae81557ec64ef4902a5bcb56a8cfac369">&#9670;&nbsp;</a></span>ucnv_flushCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2 ucnv_flushCache </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees up memory occupied by unused, cached converter shared data.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of cached converters successfully deleted </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a499316e130bdd073c394c92f55c315d2">ucnv_close</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a939c6148e6ebcf39568ce1c6ea0a24f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939c6148e6ebcf39568ce1c6ea0a24f0">&#9670;&nbsp;</a></span>ucnv_fromAlgorithmic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2 ucnv_fromAlgorithmic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a>&#160;</td>
          <td class="paramname"><em>algorithmicType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>targetCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sourceLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from one external charset to another. Internally, the text is converted to and from the 16-bit Unicode "pivot" using <a class="el" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx()</a>. <a class="el" href="ucnv_8h.html#a939c6148e6ebcf39568ce1c6ea0a24f0">ucnv_fromAlgorithmic()</a> works exactly like <a class="el" href="ucnv_8h.html#a942e532c2f02bcaea39741d4b99764b5">ucnv_convert()</a> except that the two converters need not be looked up and opened completely.</p>
<p>The source-to-pivot conversion uses a purely algorithmic converter according to the specified type, e.g., UCNV_UTF8 for a UTF-8 converter. The pivot-to-target conversion uses the cnv converter parameter.</p>
<p>Internally, the algorithmic converter is opened and closed for each function call, which is more efficient than using the public <a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open()</a> but somewhat less efficient than only resetting an existing converter and using <a class="el" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx()</a>.</p>
<p>This function is more convenient than <a class="el" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx()</a> for single-string conversions, especially when "preflighting" is desired (returning the length of the complete output even if it does not fit into the target buffer; see the User Guide Strings chapter). See <a class="el" href="ucnv_8h.html#a942e532c2f02bcaea39741d4b99764b5">ucnv_convert()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnv</td><td>The converter that is used to convert from the UTF-16 pivot buffer to the target. </td></tr>
    <tr><td class="paramname">algorithmicType</td><td>UConverterType constant identifying the desired source charset as a purely algorithmic converter. Those are converters for Unicode charsets like UTF-8, BOCU-1, SCSU, UTF-7, IMAP-mailbox-name, etc., as well as US-ASCII and ISO-8859-1. </td></tr>
    <tr><td class="paramname">target</td><td>Pointer to the output buffer. </td></tr>
    <tr><td class="paramname">targetCapacity</td><td>Capacity of the target, in bytes. </td></tr>
    <tr><td class="paramname">source</td><td>Pointer to the input buffer. </td></tr>
    <tr><td class="paramname">sourceLength</td><td>Length of the input text, in bytes </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the complete output text in bytes, even if it exceeds the targetCapacity and a U_BUFFER_OVERFLOW_ERROR is set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a939c6148e6ebcf39568ce1c6ea0a24f0">ucnv_fromAlgorithmic</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a942e532c2f02bcaea39741d4b99764b5">ucnv_convert</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#aa63cf11835833041f2ce0ed3662edfcd">ucnv_fromUnicode</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a2cc3d9d8fbab664493a9aa189d120571">ucnv_fromUChars</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#afd107e398535c523d900f030df8326df">ucnv_toUChars</a> @stable ICU 2.6 </dd></dl>

</div>
</div>
<a id="a2cc3d9d8fbab664493a9aa189d120571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc3d9d8fbab664493a9aa189d120571">&#9670;&nbsp;</a></span>ucnv_fromUChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2 ucnv_fromUChars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert the Unicode string into a codepage string using an existing UConverter. The output string is NUL-terminated if possible.</p>
<p>This function is a more convenient but less powerful version of <a class="el" href="ucnv_8h.html#aa63cf11835833041f2ce0ed3662edfcd">ucnv_fromUnicode()</a>. It is only useful for whole strings, not for streaming conversion.</p>
<p>The maximum output buffer capacity required (barring output from callbacks) will be <a class="el" href="ucnv_8h.html#aa3d7e4ae84f8a95b9735ed3491cdb77e">UCNV_GET_MAX_BYTES_FOR_STRING(srcLength, ucnv_getMaxCharSize(cnv))</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnv</td><td>the converter object to be used (<a class="el" href="ucnv_8h.html#aeb5938e9be0deb4a17575b073a98d37a">ucnv_resetFromUnicode()</a> will be called) </td></tr>
    <tr><td class="paramname">src</td><td>the input Unicode string </td></tr>
    <tr><td class="paramname">srcLength</td><td>the input string length, or -1 if NUL-terminated </td></tr>
    <tr><td class="paramname">dest</td><td>destination string buffer, can be NULL if destCapacity==0 </td></tr>
    <tr><td class="paramname">destCapacity</td><td>the number of chars available at dest </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>normal ICU error code; common error codes that may be set by this function include U_BUFFER_OVERFLOW_ERROR, U_STRING_NOT_TERMINATED_WARNING, U_ILLEGAL_ARGUMENT_ERROR, and conversion errors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the output string, not counting the terminating NUL; if the length is greater than destCapacity, then the string will not fit and a buffer of the indicated length would need to be passed in </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#aa63cf11835833041f2ce0ed3662edfcd">ucnv_fromUnicode</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a942e532c2f02bcaea39741d4b99764b5">ucnv_convert</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#aa3d7e4ae84f8a95b9735ed3491cdb77e">UCNV_GET_MAX_BYTES_FOR_STRING</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a9b13202c998e661fb112c44476668ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b13202c998e661fb112c44476668ce8">&#9670;&nbsp;</a></span>ucnv_fromUCountPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2 ucnv_fromUCountPending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of UChars held in the converter's internal state because more input is needed for completing the conversion. This function is useful for mapping semantics of ICU's converter interface to those of iconv, and this information is not needed for normal conversion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnv</td><td>The converter in which the input is held </td></tr>
    <tr><td class="paramname">status</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of UChars in the state. -1 if an error is encountered. @stable ICU 3.4 </dd></dl>

</div>
</div>
<a id="aa63cf11835833041f2ce0ed3662edfcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63cf11835833041f2ce0ed3662edfcd">&#9670;&nbsp;</a></span>ucnv_fromUnicode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_fromUnicode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>targetLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> **&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>sourceLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts an array of unicode characters to an array of codepage characters. This function is optimized for converting a continuous stream of data in buffer-sized chunks, where the entire source and target does not fit in available buffers.</p>
<p>The source pointer is an in/out parameter. It starts out pointing where the conversion is to begin, and ends up pointing after the last UChar consumed.</p>
<p>Target similarly starts out pointer at the first available byte in the output buffer, and ends up pointing after the last byte written to the output.</p>
<p>The converter always attempts to consume the entire source buffer, unless (1.) the target buffer is full, or (2.) a failing error is returned from the current callback function. When a successful error status has been returned, it means that all of the source buffer has been consumed. At that point, the caller should reset the source and sourceLimit pointers to point to the next chunk.</p>
<p>At the end of the stream (flush==true), the input is completely consumed when *source==sourceLimit and no error code is set. The converter object is then automatically reset by this function. (This means that a converter need not be reset explicitly between data streams if it finishes the previous stream without errors.)</p>
<p>This is a <em>stateful</em> conversion. Additionally, even when all source data has been consumed, some data may be in the converters' internal state. Call this function repeatedly, updating the target pointers with the next empty chunk of target in case of a <code>U_BUFFER_OVERFLOW_ERROR</code>, and updating the source pointers with the next chunk of source when a successful error status is returned, until there are no more chunks of source data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the Unicode converter </td></tr>
    <tr><td class="paramname">target</td><td>I/O parameter. Input : Points to the beginning of the buffer to copy codepage characters to. Output : points to after the last codepage character copied to <code>target</code>. </td></tr>
    <tr><td class="paramname">targetLimit</td><td>the pointer just after last of the <code>target</code> buffer </td></tr>
    <tr><td class="paramname">source</td><td>I/O parameter, pointer to pointer to the source Unicode character buffer. </td></tr>
    <tr><td class="paramname">sourceLimit</td><td>the pointer just after the last of the source buffer </td></tr>
    <tr><td class="paramname">offsets</td><td>if NULL is passed, nothing will happen to it, otherwise it needs to have the same number of allocated cells as <code>target</code>. Will fill in offsets from target to source pointer e.g: <code>offsets[3]</code> is equal to 6, it means that the <code>target[3]</code> was a result of transcoding <code>source[6]</code> For output data carried across calls, and other data without a specific source character (such as from escape sequences or callbacks) -1 will be placed for offsets. </td></tr>
    <tr><td class="paramname">flush</td><td>set to <code>true</code> if the current source buffer is the last available chunk of the source, <code>false</code> otherwise. Note that if a failing status is returned, this function may have to be called multiple times with flush set to <code>true</code> until the source buffer is consumed. </td></tr>
    <tr><td class="paramname">err</td><td>the error status. <code>U_ILLEGAL_ARGUMENT_ERROR</code> will be set if the converter is <code>NULL</code>. <code>U_BUFFER_OVERFLOW_ERROR</code> will be set if the target is full and there is still data to be written to the target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a2cc3d9d8fbab664493a9aa189d120571">ucnv_fromUChars</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a942e532c2f02bcaea39741d4b99764b5">ucnv_convert</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a65f30417f0f0b249f449eb8d4e1100ce">ucnv_getMinCharSize</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#afce4464cdb5b488460bf21c116cb1cf2">ucnv_setToUCallBack</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a97c95bfc3450d7b3fcf8e1681f7b172c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c95bfc3450d7b3fcf8e1681f7b172c">&#9670;&nbsp;</a></span>ucnv_getAlias()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char* U_EXPORT2 ucnv_getAlias </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the name of the alias at given index of alias list. This method only enumerates the listed entries in the alias file. If the alias is ambiguous, then the preferred converter is used and the status is set to U_AMBIGUOUS_ALIAS_WARNING. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>alias name </td></tr>
    <tr><td class="paramname">n</td><td>index in alias list </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>result of operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the name of the alias at given index </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a39f04062207e225bcbca84747b200fee">ucnv_countAliases</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a82642e5dbf8992c701d96f750e6be53c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82642e5dbf8992c701d96f750e6be53c">&#9670;&nbsp;</a></span>ucnv_getAliases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_getAliases </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>aliases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill-up the list of alias names for the given alias. This method only enumerates the listed entries in the alias file. If the alias is ambiguous, then the preferred converter is used and the status is set to U_AMBIGUOUS_ALIAS_WARNING. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">alias</td><td>alias name </td></tr>
    <tr><td class="paramname">aliases</td><td>fill-in list, aliases is a pointer to an array of <code><a class="el" href="ucnv_8h.html#a39f04062207e225bcbca84747b200fee">ucnv_countAliases()</a></code> string-pointers (<code>const char *</code>) that will be filled in. The strings themselves are owned by the library. </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>result of operation @stable ICU 2.0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b954cb4102add0e0400a149b37b3a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b954cb4102add0e0400a149b37b3a9f">&#9670;&nbsp;</a></span>ucnv_getAvailableName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char* U_EXPORT2 ucnv_getAvailableName </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the canonical converter name of the specified converter from a list of all available converters contained in the alias file. All converters in this list can be opened.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the index to a converter available on the system (in the range <code>[0..<a class="el" href="ucnv_8h.html#a13d737c9927986829ca6add75af6e792">ucnv_countAvailable()</a>]</code>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer a string (library owned), or <code>NULL</code> if the index is out of bounds. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a13d737c9927986829ca6add75af6e792">ucnv_countAvailable</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a0427bb4cb713666af42dd31c4ca9e55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0427bb4cb713666af42dd31c4ca9e55f">&#9670;&nbsp;</a></span>ucnv_getCanonicalName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char* U_EXPORT2 ucnv_getCanonicalName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>alias</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>standard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function will return the internal canonical converter name of the tagged alias. This is the opposite of ucnv_openStandardNames, which returns the tagged alias given the canonical name. </p>
<p>Example alias table:<br  />
 conv alias1 { STANDARD1 } alias2 { STANDARD1* } </p>
<p>Result of ucnv_getStandardName("alias1", "STANDARD1") from example alias table:<br  />
 <b>"conv"</b></p>
<dl class="section return"><dt>Returns</dt><dd>returns the canonical converter name; if a standard or alias name cannot be determined, then <code>NULL</code> is returned. The returned string is owned by the library. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#ab713bdfeeea22684aa5bbbf2e00d23ef">ucnv_getStandardName</a> @stable ICU 2.4 </dd></dl>

</div>
</div>
<a id="ad17df5c1434e7f5fd3c2871543428346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17df5c1434e7f5fd3c2871543428346">&#9670;&nbsp;</a></span>ucnv_getCCSID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2 ucnv_getCCSID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a codepage number associated with the converter. This is not guaranteed to be the one used to create the converter. Some converters do not represent platform registered codepages and return zero for the codepage number. The error code fill-in parameter indicates if the codepage number is available. Does not check if the converter is <code>NULL</code> or if converter's data table is <code>NULL</code>.</p>
<p>Important: The use of CCSIDs is not recommended because it is limited to only two platforms in principle and only one (UCNV_IBM) in the current ICU converter API. Also, CCSIDs are insufficient to identify IBM Unicode conversion tables precisely. For more details see <a class="el" href="ucnv_8h.html#a3f54f96fcedd8d89f433c4bd9437864d">ucnv_openCCSID()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the Unicode converter </td></tr>
    <tr><td class="paramname">err</td><td>the error status code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If any error occurs, -1 will be returned otherwise, the codepage number will be returned </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a3f54f96fcedd8d89f433c4bd9437864d">ucnv_openCCSID</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a979fb8ddc407eccd2ac89d502d5245e5">ucnv_getPlatform</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a34a9f2aae7fb71436cab7ace6945d35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a9f2aae7fb71436cab7ace6945d35d">&#9670;&nbsp;</a></span>ucnv_getDefaultName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char* U_EXPORT2 ucnv_getDefaultName </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current default converter name. If you want to open a default converter, you do not need to use this function. It is faster if you pass a NULL argument to ucnv_open the default converter.</p>
<p>If U_CHARSET_IS_UTF8 is defined to 1 in <a class="el" href="utypes_8h.html" title="Basic definitions for ICU, for both C and C++ APIs.">utypes.h</a> then this function always returns "UTF-8".</p>
<dl class="section return"><dt>Returns</dt><dd>returns the current default converter name. Storage owned by the library </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a8a983781f10d4e1e7f19ca2e1c6a4de9">ucnv_setDefaultName</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="ab7fc1500c99cf888e3b5e1714c17ccd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7fc1500c99cf888e3b5e1714c17ccd0">&#9670;&nbsp;</a></span>ucnv_getDisplayName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2 ucnv_getDisplayName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>displayLocale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>displayName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>displayNameCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the display name of the converter passed in based on the Locale passed in. If the locale contains no display name, the internal ASCII name will be filled in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the Unicode converter. </td></tr>
    <tr><td class="paramname">displayLocale</td><td>is the specific Locale we want to localized for </td></tr>
    <tr><td class="paramname">displayName</td><td>user provided buffer to be filled in </td></tr>
    <tr><td class="paramname">displayNameCapacity</td><td>size of displayName <a class="el" href="class_buffer.html">Buffer</a> </td></tr>
    <tr><td class="paramname">err</td><td>error status code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>displayNameLength number of UChar needed in displayName </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a032612b9d1f370e8831181c50b352dcf">ucnv_getName</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a621359c31651d5615bd063917f41a3eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621359c31651d5615bd063917f41a3eb">&#9670;&nbsp;</a></span>ucnv_getFromUCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_getFromUCallBack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv_8h.html#a7002374690e3deef6b3ad9fb9ec8b1e5">UConverterFromUCallback</a> *&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current callback function used by the converter when illegal or invalid Unicode sequence is found. Context pointers are always owned by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the unicode converter </td></tr>
    <tr><td class="paramname">action</td><td>fillin: returns the callback function pointer </td></tr>
    <tr><td class="paramname">context</td><td>fillin: returns the callback's private void* context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a304bcaa1f4cbc789d10197d6f51c94f1">ucnv_setFromUCallBack</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a000c5d12f9fde6e68289cc84694b5c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a000c5d12f9fde6e68289cc84694b5c3b">&#9670;&nbsp;</a></span>ucnv_getInvalidChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_getInvalidChars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>errBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills in the output parameter, errBytes, with the error characters from the last failing conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the Unicode converter </td></tr>
    <tr><td class="paramname">errBytes</td><td>the codepage bytes which were in error </td></tr>
    <tr><td class="paramname">len</td><td>on input the capacity of errBytes, on output the number of bytes which were copied to it </td></tr>
    <tr><td class="paramname">err</td><td>the error status code. If the substitution character array is too small, an <code>U_INDEX_OUTOFBOUNDS_ERROR</code> will be returned. @stable ICU 2.0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a13ea3b6034be2ed719622c81bdc0ff1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ea3b6034be2ed719622c81bdc0ff1e">&#9670;&nbsp;</a></span>ucnv_getInvalidUChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_getInvalidUChars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>errUChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills in the output parameter, errChars, with the error characters from the last failing conversion.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the Unicode converter </td></tr>
    <tr><td class="paramname">errUChars</td><td>the UChars which were in error </td></tr>
    <tr><td class="paramname">len</td><td>on input the capacity of errUChars, on output the number of UChars which were copied to it </td></tr>
    <tr><td class="paramname">err</td><td>the error status code. If the substitution character array is too small, an <code>U_INDEX_OUTOFBOUNDS_ERROR</code> will be returned. @stable ICU 2.0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab284cb660babcd328f4e03f6f0b0b802"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab284cb660babcd328f4e03f6f0b0b802">&#9670;&nbsp;</a></span>ucnv_getMaxCharSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int8_t U_EXPORT2 ucnv_getMaxCharSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the maximum number of bytes that are output per UChar in conversion from Unicode using this converter. The returned number can be used with UCNV_GET_MAX_BYTES_FOR_STRING to calculate the size of a target buffer for conversion from Unicode.</p>
<p>Note: Before ICU 2.8, this function did not return reliable numbers for some stateful converters (EBCDIC_STATEFUL, ISO-2022) and LMBCS.</p>
<p>This number may not be the same as the maximum number of bytes per "conversion unit". In other words, it may not be the intuitively expected number of bytes per character that would be published for a charset, and may not fulfill any other purpose than the allocation of an output buffer of guaranteed sufficient size for a given input length and converter.</p>
<p>Examples for special cases that are taken into account:</p><ul>
<li>Supplementary code points may convert to more bytes than BMP code points. This function returns bytes per UChar (UTF-16 code unit), not per Unicode code point, for efficient buffer allocation.</li>
<li>State-shifting output (SI/SO, escapes, etc.) from stateful converters.</li>
<li>When m input UChars are converted to n output bytes, then the maximum m/n is taken into account.</li>
</ul>
<p>The number returned here does not take into account (see UCNV_GET_MAX_BYTES_FOR_STRING):</p><ul>
<li>callbacks which output more than one charset character sequence per call, like escape callbacks</li>
<li>initial and final non-character bytes that are output by some converters (automatic BOMs, initial escape sequence, final SI, etc.)</li>
</ul>
<p>Examples for returned values:</p><ul>
<li>SBCS charsets: 1</li>
<li>Shift-JIS: 2</li>
<li>UTF-16: 2 (2 per BMP, 4 per surrogate <em>pair</em>, BOM not counted)</li>
<li>UTF-8: 3 (3 per BMP, 4 per surrogate <em>pair</em>)</li>
<li>EBCDIC_STATEFUL (EBCDIC mixed SBCS/DBCS): 3 (SO + DBCS)</li>
<li>ISO-2022: 3 (always outputs UTF-8)</li>
<li>ISO-2022-JP: 6 (4-byte escape sequences + DBCS)</li>
<li>ISO-2022-CN: 8 (4-byte designator sequences + 2-byte SS2/SS3 + DBCS)</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>The Unicode converter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of bytes per UChar (16 bit code unit) that are output by <a class="el" href="ucnv_8h.html#aa63cf11835833041f2ce0ed3662edfcd">ucnv_fromUnicode()</a>, to be used together with UCNV_GET_MAX_BYTES_FOR_STRING for buffer allocation.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#aa3d7e4ae84f8a95b9735ed3491cdb77e">UCNV_GET_MAX_BYTES_FOR_STRING</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a65f30417f0f0b249f449eb8d4e1100ce">ucnv_getMinCharSize</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a65f30417f0f0b249f449eb8d4e1100ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f30417f0f0b249f449eb8d4e1100ce">&#9670;&nbsp;</a></span>ucnv_getMinCharSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int8_t U_EXPORT2 ucnv_getMinCharSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the minimum byte length (per codepoint) for characters in this codepage. This is usually either 1 or 2. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the Unicode converter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum number of bytes per codepoint allowed by this particular converter </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#ab284cb660babcd328f4e03f6f0b0b802">ucnv_getMaxCharSize</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a032612b9d1f370e8831181c50b352dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032612b9d1f370e8831181c50b352dcf">&#9670;&nbsp;</a></span>ucnv_getName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char* U_EXPORT2 ucnv_getName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the internal, canonical name of the converter (zero-terminated). The lifetime of the returned string will be that of the converter passed to this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the Unicode converter </td></tr>
    <tr><td class="paramname">err</td><td>UErrorCode status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the internal name of the converter </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#ab7fc1500c99cf888e3b5e1714c17ccd0">ucnv_getDisplayName</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a00c0fdce8c98e50dea85beb3f086fe8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00c0fdce8c98e50dea85beb3f086fe8e">&#9670;&nbsp;</a></span>ucnv_getNextUChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a09fff5c3b5a5b015324dc3ec3cf92809">UChar32</a> U_EXPORT2 ucnv_getNextUChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sourceLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a codepage buffer into Unicode one character at a time. The input is completely consumed when the U_INDEX_OUTOFBOUNDS_ERROR is set.</p>
<p>Advantage compared to <a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode()</a> or <a class="el" href="ucnv_8h.html#afd107e398535c523d900f030df8326df">ucnv_toUChars()</a>:</p><ul>
<li>Faster for small amounts of data, for most converters, e.g., US-ASCII, ISO-8859-1, UTF-8/16/32, and most "normal" charsets. (For complex converters, e.g., SCSU, UTF-7 and ISO 2022 variants, it uses <a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode()</a> internally.)</li>
<li>Convenient.</li>
</ul>
<p>Limitations compared to <a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode()</a>:</p><ul>
<li>Always assumes flush=true. This makes <a class="el" href="ucnv_8h.html#a00c0fdce8c98e50dea85beb3f086fe8e">ucnv_getNextUChar()</a> unsuitable for "streaming" conversion, that is, for where the input is supplied in multiple buffers, because <a class="el" href="ucnv_8h.html#a00c0fdce8c98e50dea85beb3f086fe8e">ucnv_getNextUChar()</a> will assume the end of the input at the end of the first buffer.</li>
<li>Does not provide offset output.</li>
</ul>
<p>It is possible to "mix" <a class="el" href="ucnv_8h.html#a00c0fdce8c98e50dea85beb3f086fe8e">ucnv_getNextUChar()</a> and <a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode()</a> because <a class="el" href="ucnv_8h.html#a00c0fdce8c98e50dea85beb3f086fe8e">ucnv_getNextUChar()</a> uses the current state of the converter (unlike <a class="el" href="ucnv_8h.html#afd107e398535c523d900f030df8326df">ucnv_toUChars()</a> which always resets first). However, if <a class="el" href="ucnv_8h.html#a00c0fdce8c98e50dea85beb3f086fe8e">ucnv_getNextUChar()</a> is called after <a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode()</a> stopped in the middle of a character sequence (with flush=false), then <a class="el" href="ucnv_8h.html#a00c0fdce8c98e50dea85beb3f086fe8e">ucnv_getNextUChar()</a> will always use the slower <a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode()</a> internally until the next character boundary. (This is new in ICU 2.6. In earlier releases, <a class="el" href="ucnv_8h.html#a00c0fdce8c98e50dea85beb3f086fe8e">ucnv_getNextUChar()</a> had to start at a character boundary.)</p>
<p>Instead of using <a class="el" href="ucnv_8h.html#a00c0fdce8c98e50dea85beb3f086fe8e">ucnv_getNextUChar()</a>, it is recommended to convert using <a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode()</a> or <a class="el" href="ucnv_8h.html#afd107e398535c523d900f030df8326df">ucnv_toUChars()</a> and then iterate over the text using <a class="el" href="utf16_8h.html#a844bb48486904fdca40c8b883e9c80ee">U16_NEXT()</a> or a <a class="el" href="struct_u_char_iterator.html">UCharIterator</a> (<a class="el" href="uiter_8h.html" title="C API: Unicode Character Iteration.">uiter.h</a>) or a C++ CharacterIterator or similar. This allows streaming conversion and offset output, for example.</p>
<p>Handling of surrogate pairs and supplementary-plane code points:<br  />
 There are two different kinds of codepages that provide mappings for surrogate characters: </p><ul>
<li>
Codepages like UTF-8, UTF-32, and GB 18030 provide direct representations for Unicode code points U+10000-U+10ffff as well as for single surrogates U+d800-U+dfff. Each valid sequence will result in exactly one returned code point. If a sequence results in a single surrogate, then that will be returned by itself, even if a neighboring sequence encodes the matching surrogate. </li>
<li>
Codepages like SCSU and LMBCS (and UTF-16) provide direct representations only for BMP code points including surrogates. Code points in supplementary planes are represented with two sequences, each encoding a surrogate. For these codepages, matching pairs of surrogates will be combined into single code points for returning from this function. (Note that SCSU is actually a mix of these codepage types.) </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>an open UConverter </td></tr>
    <tr><td class="paramname">source</td><td>the address of a pointer to the codepage buffer, will be updated to point after the bytes consumed in the conversion call. </td></tr>
    <tr><td class="paramname">sourceLimit</td><td>points to the end of the input buffer </td></tr>
    <tr><td class="paramname">err</td><td>fills in error status (see ucnv_toUnicode) <code>U_INDEX_OUTOFBOUNDS_ERROR</code> will be set if the input is empty or does not convert to any output (e.g.: pure state-change codes SI/SO, escape sequences for ISO 2022, or if the callback did not output anything, ...). This function will not set a <code>U_BUFFER_OVERFLOW_ERROR</code> because the "buffer" is the return code. However, there might be subsequent output stored in the converter object that will be returned in following calls to this function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a UChar32 resulting from the partial conversion of source </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#afd107e398535c523d900f030df8326df">ucnv_toUChars</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a942e532c2f02bcaea39741d4b99764b5">ucnv_convert</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a979fb8ddc407eccd2ac89d502d5245e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979fb8ddc407eccd2ac89d502d5245e5">&#9670;&nbsp;</a></span>ucnv_getPlatform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="ucnv_8h.html#aba5ba7fbc2f113618ba57f4d9825ff85">UConverterPlatform</a> U_EXPORT2 ucnv_getPlatform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets a codepage platform associated with the converter. Currently, only <code>UCNV_IBM</code> will be returned. Does not test if the converter is <code>NULL</code> or if converter's data table is <code>NULL</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the Unicode converter </td></tr>
    <tr><td class="paramname">err</td><td>the error status code. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The codepage platform @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a97761ff4c82dc46884337e834ba04e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97761ff4c82dc46884337e834ba04e78">&#9670;&nbsp;</a></span>ucnv_getStandard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char* U_EXPORT2 ucnv_getStandard </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the name of the standard at given index of standard list. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>index in standard list </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>result of operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the name of the standard at given index. Owned by the library. @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="ab713bdfeeea22684aa5bbbf2e00d23ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab713bdfeeea22684aa5bbbf2e00d23ef">&#9670;&nbsp;</a></span>ucnv_getStandardName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> char* U_EXPORT2 ucnv_getStandardName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>standard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a standard name for a given converter name. </p>
<p>Example alias table:<br  />
 conv alias1 { STANDARD1 } alias2 { STANDARD1* } </p>
<p>Result of ucnv_getStandardName("conv", "STANDARD1") from example alias table:<br  />
 <b>"alias2"</b></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>original converter name </td></tr>
    <tr><td class="paramname">standard</td><td>name of the standard governing the names; MIME and IANA are such standards </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>result of operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the standard converter name; if a standard converter name cannot be determined, then <code>NULL</code> is returned. Owned by the library. @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a115789580a4449f8b65891be3e04111a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a115789580a4449f8b65891be3e04111a">&#9670;&nbsp;</a></span>ucnv_getStarters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_getStarters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td>
          <td class="paramname"><em>starters</em>[256], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the "starter" (lead) bytes for converters of type MBCS. Will fill in an <code>U_ILLEGAL_ARGUMENT_ERROR</code> if converter passed in is not MBCS. Fills in an array of type UBool, with the value of the byte as offset to the array. For example, if (starters[0x20] == true) at return, it means that the byte 0x20 is a starter byte in this converter. Context pointers are always owned by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>a valid, opened converter of type MBCS </td></tr>
    <tr><td class="paramname">starters</td><td>an array of size 256 to be filled in </td></tr>
    <tr><td class="paramname">err</td><td>error status, <code>U_ILLEGAL_ARGUMENT_ERROR</code> if the converter is not a type which can return starters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a84c7d83c0179a90eadab5ebc8040fdb6">ucnv_getType</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a8a670af025c7632628b450daa50e47df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a670af025c7632628b450daa50e47df">&#9670;&nbsp;</a></span>ucnv_getSubstChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_getSubstChars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>subChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t *&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills in the output parameter, subChars, with the substitution characters as multiple bytes. If <a class="el" href="ucnv_8h.html#a38e2e21ab52bd6fab1c4cb21d00fd23f">ucnv_setSubstString()</a> set a Unicode string because the converter is stateful, then subChars will be an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the Unicode converter </td></tr>
    <tr><td class="paramname">subChars</td><td>the substitution characters </td></tr>
    <tr><td class="paramname">len</td><td>on input the capacity of subChars, on output the number of bytes copied to it </td></tr>
    <tr><td class="paramname">err</td><td>the outgoing error status code. If the substitution character array is too small, an <code>U_INDEX_OUTOFBOUNDS_ERROR</code> will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a38e2e21ab52bd6fab1c4cb21d00fd23f">ucnv_setSubstString</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#aa840af123bebe51ecdb936641087f229">ucnv_setSubstChars</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a9981e203dd727f20ce391e9c1c12d88c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9981e203dd727f20ce391e9c1c12d88c">&#9670;&nbsp;</a></span>ucnv_getToUCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_getToUCallBack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv_8h.html#ae077d9f2a37d3aa640c3c2032a2baa2c">UConverterToUCallback</a> *&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current calback function used by the converter when an illegal or invalid codepage sequence is found. Context pointers are always owned by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the unicode converter </td></tr>
    <tr><td class="paramname">action</td><td>fillin: returns the callback function pointer </td></tr>
    <tr><td class="paramname">context</td><td>fillin: returns the callback's private void* context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#afce4464cdb5b488460bf21c116cb1cf2">ucnv_setToUCallBack</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a84c7d83c0179a90eadab5ebc8040fdb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c7d83c0179a90eadab5ebc8040fdb6">&#9670;&nbsp;</a></span>ucnv_getType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a> U_EXPORT2 ucnv_getType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the type of the converter e.g. SBCS, MBCS, DBCS, UTF8, UTF16_BE, UTF16_LE, ISO_2022, EBCDIC_STATEFUL, LATIN_1 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>a valid, opened converter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the type of the converter @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="ab94a776ddba4f503fe9ad08a88c66b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94a776ddba4f503fe9ad08a88c66b8d">&#9670;&nbsp;</a></span>ucnv_getUnicodeSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_getUnicodeSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="uchar_8h.html#adce3fef7c15d7c78196bf977ac96ec9c">USet</a> *&#160;</td>
          <td class="paramname"><em>setFillIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv_8h.html#a402221896b6d7153b14a5ff8dadde806">UConverterUnicodeSet</a>&#160;</td>
          <td class="paramname"><em>whichSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the set of Unicode code points that can be converted by an ICU converter.</p>
<p>Returns one of several kinds of set:</p>
<ol type="1">
<li>UCNV_ROUNDTRIP_SET</li>
</ol>
<p>The set of all Unicode code points that can be roundtrip-converted (converted without any data loss) with the converter (<a class="el" href="ucnv_8h.html#aa63cf11835833041f2ce0ed3662edfcd">ucnv_fromUnicode()</a>). This set will not include code points that have fallback mappings or are only the result of reverse fallback mappings. This set will also not include PUA code points with fallbacks, although <a class="el" href="ucnv_8h.html#aa63cf11835833041f2ce0ed3662edfcd">ucnv_fromUnicode()</a> will always uses those mappings despite <a class="el" href="ucnv_8h.html#a6a1f70909aa917783b1ec6f350bde107">ucnv_setFallback()</a>. See UTR #22 "Character Mapping Markup Language" at <a href="http://www.unicode.org/reports/tr22/">http://www.unicode.org/reports/tr22/</a></p>
<p>This is useful for example for</p><ul>
<li>checking that a string or document can be roundtrip-converted with a converter, without/before actually performing the conversion</li>
<li>testing if a converter can be used for text for typical text for a certain locale, by comparing its roundtrip set with the set of ExemplarCharacters from ICU's locale data or other sources</li>
</ul>
<ol type="1">
<li>UCNV_ROUNDTRIP_AND_FALLBACK_SET</li>
</ol>
<p>The set of all Unicode code points that can be converted with the converter (<a class="el" href="ucnv_8h.html#aa63cf11835833041f2ce0ed3662edfcd">ucnv_fromUnicode()</a>) when fallbacks are turned on (see <a class="el" href="ucnv_8h.html#a6a1f70909aa917783b1ec6f350bde107">ucnv_setFallback()</a>). This set includes all code points with roundtrips and fallbacks (but not reverse fallbacks).</p>
<p>In the future, there may be more UConverterUnicodeSet choices to select sets with different properties.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnv</td><td>The converter for which a set is requested. </td></tr>
    <tr><td class="paramname">setFillIn</td><td>A valid USet *. It will be cleared by this function before the converter's specific set is filled into the USet. </td></tr>
    <tr><td class="paramname">whichSet</td><td>A UConverterUnicodeSet selector; currently UCNV_ROUNDTRIP_SET is the only supported value. </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a402221896b6d7153b14a5ff8dadde806">UConverterUnicodeSet</a> </dd>
<dd>
<a class="el" href="uset_8h.html#ab9e26f2eca260498b46915aa2b4e684c">uset_open</a> </dd>
<dd>
<a class="el" href="uset_8h.html#abc715a57d57f38e7c6198e3a28c6b4ef">uset_close</a> @stable ICU 2.6 </dd></dl>

</div>
</div>
<a id="ad809545cb8d0edf3067e1a5d690bf71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad809545cb8d0edf3067e1a5d690bf71f">&#9670;&nbsp;</a></span>ucnv_isAmbiguous()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> U_EXPORT2 ucnv_isAmbiguous </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>cnv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if the converter contains ambiguous mappings of the same character or not. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnv</td><td>the converter to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the converter contains ambiguous mapping of the same character, false otherwise. @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a8372ee20e068d100f86db7aaf95f4665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8372ee20e068d100f86db7aaf95f4665">&#9670;&nbsp;</a></span>ucnv_isFixedWidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> U_EXPORT2 ucnv_isFixedWidth </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether or not the charset of the converter has a fixed number of bytes per charset character. An example of this are converters that are of the type UCNV_SBCS or UCNV_DBCS. Another example is UTF-32 which is always 4 bytes per character. A Unicode code point may be represented by more than one UTF-8 or UTF-16 code unit but a UTF-32 converter encodes each code point with 4 bytes. Note: This method is not intended to be used to determine whether the charset has a fixed ratio of bytes to Unicode codes <em>units</em> for any particular Unicode encoding form. false is returned with the UErrorCode if error occurs or cnv is NULL. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnv</td><td>The converter to be tested </td></tr>
    <tr><td class="paramname">status</td><td>ICU error code in/out paramter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the converter is fixed-width @stable ICU 4.8 </dd></dl>

</div>
</div>
<a id="a04af8743cca855974b87fd55a7970d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04af8743cca855974b87fd55a7970d6c">&#9670;&nbsp;</a></span>ucnv_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a>* U_EXPORT2 ucnv_open </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>converterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a UConverter object with the name of a coded character set specified as a C string. The actual name will be resolved with the alias file using a case-insensitive string comparison that ignores leading zeroes and all non-alphanumeric characters. E.g., the names "UTF8", "utf-8", "u*T@f08" and "Utf 8" are all equivalent. (See also <a class="el" href="ucnv_8h.html#a8d23f178a9474210cce08530fbfe6ab3">ucnv_compareNames()</a>.) If <code>NULL</code> is passed for the converter name, it will create one with the getDefaultName return value.</p>
<p>A converter name for ICU 1.5 and above may contain options like a locale specification to control the specific behavior of the newly instantiated converter. The meaning of the options depends on the particular converter. If an option is not defined for or recognized by a given converter, then it is ignored.</p>
<p>Options are appended to the converter name string, with a <code>UCNV_OPTION_SEP_CHAR</code> between the name and the first option and also between adjacent options.</p>
<p>If the alias is ambiguous, then the preferred converter is used and the status is set to U_AMBIGUOUS_ALIAS_WARNING.</p>
<p>The conversion behavior and names can vary between platforms. ICU may convert some characters differently from other platforms. Details on this topic are in the <a href="http://icu-project.org/userguide/conversion.html">User's Guide</a>. Aliases starting with a "cp" prefix have no specific meaning other than its an alias starting with the letters "cp". Please do not associate any meaning to these aliases.</p>
<div class="fragment"></div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converterName</td><td>Name of the coded character set table. This may have options appended to the string. IANA alias character set names, IBM CCSIDs starting with "ibm-", Windows codepage numbers starting with "windows-" are frequently used for this parameter. See ucnv_getAvailableName and ucnv_getAlias for a complete list that is available. If this parameter is NULL, the default converter will be used. </td></tr>
    <tr><td class="paramname">err</td><td>outgoing error status <code>U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created Unicode converter object, or <code>NULL</code> if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#ad3f473f991769a94f21e195473470157">ucnv_openU</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a3f54f96fcedd8d89f433c4bd9437864d">ucnv_openCCSID</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a5b954cb4102add0e0400a149b37b3a9f">ucnv_getAvailableName</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a97c95bfc3450d7b3fcf8e1681f7b172c">ucnv_getAlias</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a34a9f2aae7fb71436cab7ace6945d35d">ucnv_getDefaultName</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a499316e130bdd073c394c92f55c315d2">ucnv_close</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a8d23f178a9474210cce08530fbfe6ab3">ucnv_compareNames</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a2bc7b6cbf949eaed1814d3c28b1eb3cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bc7b6cbf949eaed1814d3c28b1eb3cf">&#9670;&nbsp;</a></span>ucnv_openAllNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="uenum_8h.html#a32b7253b2148022535be36a9fcdb5a8d">UEnumeration</a>* U_EXPORT2 ucnv_openAllNames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a UEnumeration to enumerate all of the canonical converter names, as per the alias file, regardless of the ability to open each converter.</p>
<dl class="section return"><dt>Returns</dt><dd>A UEnumeration object for getting all the recognized canonical converter names. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a5b954cb4102add0e0400a149b37b3a9f">ucnv_getAvailableName</a> </dd>
<dd>
<a class="el" href="uenum_8h.html#a4224a16275bec6313e2355a8cf9b7be8">uenum_close</a> </dd>
<dd>
<a class="el" href="uenum_8h.html#a87d2cf1931e917f98e383b8b63bd1bd0">uenum_next</a> @stable ICU 2.4 </dd></dl>

</div>
</div>
<a id="a3f54f96fcedd8d89f433c4bd9437864d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f54f96fcedd8d89f433c4bd9437864d">&#9670;&nbsp;</a></span>ucnv_openCCSID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a>* U_EXPORT2 ucnv_openCCSID </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>codepage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv_8h.html#aba5ba7fbc2f113618ba57f4d9825ff85">UConverterPlatform</a>&#160;</td>
          <td class="paramname"><em>platform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a UConverter object from a CCSID number and platform pair. Note that the usefulness of this function is limited to platforms with numeric encoding IDs. Only IBM and Microsoft platforms use numeric (16-bit) identifiers for encodings.</p>
<p>In addition, IBM CCSIDs and Unicode conversion tables are not 1:1 related. For many IBM CCSIDs there are multiple (up to six) Unicode conversion tables, and for some Unicode conversion tables there are multiple CCSIDs. Some "alternate" Unicode conversion tables are provided by the IBM CDRA conversion table registry. The most prominent example of a systematic modification of conversion tables that is not provided in the form of conversion table files in the repository is that S/390 Unix System Services swaps the codes for Line Feed and New Line in all EBCDIC codepages, which requires such a swap in the Unicode conversion tables as well.</p>
<p>Only IBM default conversion tables are accessible with <a class="el" href="ucnv_8h.html#a3f54f96fcedd8d89f433c4bd9437864d">ucnv_openCCSID()</a>. <a class="el" href="ucnv_8h.html#ad17df5c1434e7f5fd3c2871543428346">ucnv_getCCSID()</a> will return the same CCSID for all conversion tables that are associated with that CCSID.</p>
<p>Currently, the only "platform" supported in the ICU converter API is UCNV_IBM.</p>
<p>In summary, the use of CCSIDs and the associated API functions is not recommended.</p>
<p>In order to open a converter with the default IBM CDRA Unicode conversion table, you can use this function or use the prefix "ibm-": </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> name[20];</div>
<div class="line">sprintf(name, <span class="stringliteral">&quot;ibm-%hu&quot;</span>, ccsid);</div>
<div class="line">cnv=<a class="code" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a>(name, &amp;errorCode);</div>
</div><!-- fragment --><p>In order to open a converter with the IBM S/390 Unix System Services variant of a Unicode/EBCDIC conversion table, you can use the prefix "ibm-" together with the option string UCNV_SWAP_LFNL_OPTION_STRING: </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> name[20];</div>
<div class="line">sprintf(name, <span class="stringliteral">&quot;ibm-%hu&quot;</span> <a class="code" href="ucnv_8h.html#a0588f7014923ad969821941f9dd51040">UCNV_SWAP_LFNL_OPTION_STRING</a>, ccsid);</div>
<div class="line">cnv=<a class="code" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a>(name, &amp;errorCode);</div>
</div><!-- fragment --><p>In order to open a converter from a Microsoft codepage number, use the prefix "cp": </p><div class="fragment"><div class="line"><span class="keywordtype">char</span> name[20];</div>
<div class="line">sprintf(name, <span class="stringliteral">&quot;cp%hu&quot;</span>, codepageID);</div>
<div class="line">cnv=<a class="code" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a>(name, &amp;errorCode);</div>
</div><!-- fragment --><p>If the alias is ambiguous, then the preferred converter is used and the status is set to U_AMBIGUOUS_ALIAS_WARNING.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codepage</td><td>codepage number to create </td></tr>
    <tr><td class="paramname">platform</td><td>the platform in which the codepage number exists </td></tr>
    <tr><td class="paramname">err</td><td>error status <code>U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created Unicode converter object, or <code>NULL</code> if an error occurred. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#ad3f473f991769a94f21e195473470157">ucnv_openU</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a499316e130bdd073c394c92f55c315d2">ucnv_close</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#ad17df5c1434e7f5fd3c2871543428346">ucnv_getCCSID</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a979fb8ddc407eccd2ac89d502d5245e5">ucnv_getPlatform</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#aba5ba7fbc2f113618ba57f4d9825ff85">UConverterPlatform</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="afee49410890e472b8983b6865b4b964f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee49410890e472b8983b6865b4b964f">&#9670;&nbsp;</a></span>ucnv_openPackage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a>* U_EXPORT2 ucnv_openPackage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>packageName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>converterName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a UConverter object specified from a packageName and a converterName.</p>
<p>The packageName and converterName must point to an ICU udata object, as defined by <code> udata_open( packageName, "cnv", converterName, err) </code> or equivalent. Typically, packageName will refer to a (.dat) file, or to a package registered with <a class="el" href="udata_8h.html#a8a44e57ac1388440e90c58d606df9b90">udata_setAppData()</a>. Using a full file or directory pathname for packageName is deprecated.</p>
<p>The name will NOT be looked up in the alias mechanism, nor will the converter be stored in the converter cache or the alias table. The only way to open further converters is call this function multiple times, or use the <a class="el" href="ucnv_8h.html#aebb51e41917fe9b0488cfdb5717ff826">ucnv_safeClone()</a> function to clone a 'primary' converter.</p>
<p>A future version of ICU may add alias table lookups and/or caching to this function.</p>
<p>Example Use: <code>cnv = ucnv_openPackage("myapp", "myconverter", &amp;err);</code> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">packageName</td><td>name of the package (equivalent to 'path' in <a class="el" href="udata_8h.html#aa665f05301670184392e3ceb8dd149fb">udata_open()</a> call) </td></tr>
    <tr><td class="paramname">converterName</td><td>name of the data item to be used, without suffix. </td></tr>
    <tr><td class="paramname">err</td><td>outgoing error status <code>U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created Unicode converter object, or <code>NULL</code> if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="udata_8h.html#aa665f05301670184392e3ceb8dd149fb">udata_open</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#aebb51e41917fe9b0488cfdb5717ff826">ucnv_safeClone</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a499316e130bdd073c394c92f55c315d2">ucnv_close</a> @stable ICU 2.2 </dd></dl>

</div>
</div>
<a id="a7d5f2eac73a564d004b4a3e30d4601c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5f2eac73a564d004b4a3e30d4601c1">&#9670;&nbsp;</a></span>ucnv_openStandardNames()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="uenum_8h.html#a32b7253b2148022535be36a9fcdb5a8d">UEnumeration</a>* U_EXPORT2 ucnv_openStandardNames </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>convName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>standard</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a new UEnumeration object for enumerating all the alias names for a given converter that are recognized by a standard. This method only enumerates the listed entries in the alias file. The convrtrs.txt file can be modified to change the results of this function. The first result in this list is the same result given by <code>ucnv_getStandardName</code>, which is the default alias for the specified standard name. The returned object must be closed with <code>uenum_close</code> when you are done with the object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">convName</td><td>original converter name </td></tr>
    <tr><td class="paramname">standard</td><td>name of the standard governing the names; MIME and IANA are such standards </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>The error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A UEnumeration object for getting all aliases that are recognized by a standard. If any of the parameters are invalid, NULL is returned. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#ab713bdfeeea22684aa5bbbf2e00d23ef">ucnv_getStandardName</a> </dd>
<dd>
<a class="el" href="uenum_8h.html#a4224a16275bec6313e2355a8cf9b7be8">uenum_close</a> </dd>
<dd>
<a class="el" href="uenum_8h.html#a87d2cf1931e917f98e383b8b63bd1bd0">uenum_next</a> @stable ICU 2.2 </dd></dl>

</div>
</div>
<a id="ad3f473f991769a94f21e195473470157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f473f991769a94f21e195473470157">&#9670;&nbsp;</a></span>ucnv_openU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a>* U_EXPORT2 ucnv_openU </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a Unicode converter with the names specified as unicode string. The name should be limited to the ASCII-7 alphanumerics range. The actual name will be resolved with the alias file using a case-insensitive string comparison that ignores leading zeroes and all non-alphanumeric characters. E.g., the names "UTF8", "utf-8", "u*T@f08" and "Utf 8" are all equivalent. (See also <a class="el" href="ucnv_8h.html#a8d23f178a9474210cce08530fbfe6ab3">ucnv_compareNames()</a>.) If <code>NULL</code> is passed for the converter name, it will create one with the <a class="el" href="ucnv_8h.html#a34a9f2aae7fb71436cab7ace6945d35d">ucnv_getDefaultName()</a> return value. If the alias is ambiguous, then the preferred converter is used and the status is set to U_AMBIGUOUS_ALIAS_WARNING.</p>
<p>See ucnv_open for the complete details</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the UConverter table in a zero terminated Unicode string </td></tr>
    <tr><td class="paramname">err</td><td>outgoing error status <code>U_MEMORY_ALLOCATION_ERROR, U_FILE_ACCESS_ERROR</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the created Unicode converter object, or <code>NULL</code> if an error occurred </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a3f54f96fcedd8d89f433c4bd9437864d">ucnv_openCCSID</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a499316e130bdd073c394c92f55c315d2">ucnv_close</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a8d23f178a9474210cce08530fbfe6ab3">ucnv_compareNames</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="ae68fb6700ceb5168d4dd9ee93d1a6e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68fb6700ceb5168d4dd9ee93d1a6e47">&#9670;&nbsp;</a></span>ucnv_reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the state of a converter to the default state. This is used in the case of an error, to restart a conversion from a known default state. It will also empty the internal output buffers. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the Unicode converter @stable ICU 2.0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeb5938e9be0deb4a17575b073a98d37a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5938e9be0deb4a17575b073a98d37a">&#9670;&nbsp;</a></span>ucnv_resetFromUnicode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_resetFromUnicode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the from-Unicode part of a converter state to the default state. This is used in the case of an error to restart a conversion from Unicode to a known default state. It will also empty the internal output buffers used for the conversion from Unicode codepoints. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the Unicode converter @stable ICU 2.0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedbb912ce9067a392052bc91a7d9ee34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedbb912ce9067a392052bc91a7d9ee34">&#9670;&nbsp;</a></span>ucnv_resetToUnicode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_resetToUnicode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resets the to-Unicode part of a converter state to the default state. This is used in the case of an error to restart a conversion to Unicode to a known default state. It will also empty the internal output buffers used for the conversion to Unicode codepoints. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the Unicode converter @stable ICU 2.0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebb51e41917fe9b0488cfdb5717ff826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb51e41917fe9b0488cfdb5717ff826">&#9670;&nbsp;</a></span>ucnv_safeClone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a>* U_EXPORT2 ucnv_safeClone </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>stackBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>pBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Thread safe converter cloning operation. For most efficient operation, pass in a stackBuffer (and a *pBufferSize) with at least U_CNV_SAFECLONE_BUFFERSIZE bytes of space. If the buffer size is sufficient, then the clone will use the stack buffer; otherwise, it will be allocated, and *pBufferSize will indicate the actual size. (This should not occur with U_CNV_SAFECLONE_BUFFERSIZE.)</p>
<p>You must <a class="el" href="ucnv_8h.html#a499316e130bdd073c394c92f55c315d2">ucnv_close()</a> the clone in any case.</p>
<p>If *pBufferSize==0, (regardless of whether stackBuffer==NULL or not) then *pBufferSize will be changed to a sufficient size for cloning this converter, without actually cloning the converter ("pure pre-flighting").</p>
<p>If *pBufferSize is greater than zero but not large enough for a stack-based clone, then the converter is cloned using newly allocated memory and *pBufferSize is changed to the necessary size.</p>
<p>If the converter clone fits into the stack buffer but the stack buffer is not sufficiently aligned for the clone, then the clone will use an adjusted pointer and use an accordingly smaller buffer size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnv</td><td>converter to be cloned </td></tr>
    <tr><td class="paramname">stackBuffer</td><td><em>Deprecated functionality as of ICU 52, use NULL.</em><br  />
 user allocated space for the new clone. If NULL new memory will be allocated. If buffer is not large enough, new memory will be allocated. Clients can use the U_CNV_SAFECLONE_BUFFERSIZE. This will probably be enough to avoid memory allocations. </td></tr>
    <tr><td class="paramname">pBufferSize</td><td><em>Deprecated functionality as of ICU 52, use NULL or 1.</em><br  />
 pointer to size of allocated space. </td></tr>
    <tr><td class="paramname">status</td><td>to indicate whether the operation went on smoothly or there were errors An informational status value, U_SAFECLONE_ALLOCATED_WARNING, is used if any allocations were necessary. However, it is better to check if *pBufferSize grew for checking for allocations because warning codes can be overridden by subsequent function calls. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to the new clone @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a8a983781f10d4e1e7f19ca2e1c6a4de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a983781f10d4e1e7f19ca2e1c6a4de9">&#9670;&nbsp;</a></span>ucnv_setDefaultName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_setDefaultName </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is not thread safe. DO NOT call this function when ANY ICU function is being used from more than one thread! This function sets the current default converter name. If this function needs to be called, it should be called during application initialization. Most of the time, the results from <a class="el" href="ucnv_8h.html#a34a9f2aae7fb71436cab7ace6945d35d">ucnv_getDefaultName()</a> or ucnv_open with a NULL string argument is sufficient for your application.</p>
<p>If U_CHARSET_IS_UTF8 is defined to 1 in <a class="el" href="utypes_8h.html" title="Basic definitions for ICU, for both C and C++ APIs.">utypes.h</a> then this function does nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>the converter name to be the default (must be known by ICU). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a34a9f2aae7fb71436cab7ace6945d35d">ucnv_getDefaultName</a> @system @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a6a1f70909aa917783b1ec6f350bde107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a1f70909aa917783b1ec6f350bde107">&#9670;&nbsp;</a></span>ucnv_setFallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_setFallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td>
          <td class="paramname"><em>usesFallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the converter to use fallback mappings or not. Regardless of this flag, the converter will always use fallbacks from Unicode Private Use code points, as well as reverse fallbacks (to Unicode). For details see ".ucm File Format" in the Conversion Data chapter of the ICU User Guide: <a href="http://www.icu-project.org/userguide/conversion-data.html#ucmformat">http://www.icu-project.org/userguide/conversion-data.html#ucmformat</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnv</td><td>The converter to set the fallback mapping usage on. </td></tr>
    <tr><td class="paramname">usesFallback</td><td>true if the user wants the converter to take advantage of the fallback mapping, false otherwise. @stable ICU 2.0 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#aa9ae28ad00c484d5edebed7a80237bfd">ucnv_usesFallback</a> </dd></dl>

</div>
</div>
<a id="a304bcaa1f4cbc789d10197d6f51c94f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304bcaa1f4cbc789d10197d6f51c94f1">&#9670;&nbsp;</a></span>ucnv_setFromUCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_setFromUCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv_8h.html#a7002374690e3deef6b3ad9fb9ec8b1e5">UConverterFromUCallback</a>&#160;</td>
          <td class="paramname"><em>newAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>newContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv_8h.html#a7002374690e3deef6b3ad9fb9ec8b1e5">UConverterFromUCallback</a> *&#160;</td>
          <td class="paramname"><em>oldAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>oldContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the current callback function used by the converter when an illegal or invalid sequence is found. Context pointers are always owned by the caller. Predefined actions and contexts can be found in the <a class="el" href="ucnv__err_8h.html" title="C UConverter predefined error callbacks.">ucnv_err.h</a> header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the unicode converter </td></tr>
    <tr><td class="paramname">newAction</td><td>the new callback function </td></tr>
    <tr><td class="paramname">newContext</td><td>the new fromUnicode callback context pointer. This can be NULL. </td></tr>
    <tr><td class="paramname">oldAction</td><td>fillin: returns the old callback function pointer. This can be NULL. </td></tr>
    <tr><td class="paramname">oldContext</td><td>fillin: returns the old callback's private void* context. This can be NULL. </td></tr>
    <tr><td class="paramname">err</td><td>The error code status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a621359c31651d5615bd063917f41a3eb">ucnv_getFromUCallBack</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="aa840af123bebe51ecdb936641087f229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa840af123bebe51ecdb936641087f229">&#9670;&nbsp;</a></span>ucnv_setSubstChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_setSubstChars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>subChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the substitution chars when converting from unicode to a codepage. The substitution is specified as a string of 1-4 bytes, and may contain <code>NULL</code> bytes. The subChars must represent a single character. The caller needs to know the byte sequence of a valid character in the converter's charset. For some converters, for example some ISO 2022 variants, only single-byte substitution characters may be supported. The newer <a class="el" href="ucnv_8h.html#a38e2e21ab52bd6fab1c4cb21d00fd23f">ucnv_setSubstString()</a> function relaxes these limitations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the Unicode converter </td></tr>
    <tr><td class="paramname">subChars</td><td>the substitution character byte sequence we want set </td></tr>
    <tr><td class="paramname">len</td><td>the number of bytes in subChars </td></tr>
    <tr><td class="paramname">err</td><td>the error status code. <code>U_INDEX_OUTOFBOUNDS_ERROR </code> if len is bigger than the maximum number of bytes allowed in subchars </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a38e2e21ab52bd6fab1c4cb21d00fd23f">ucnv_setSubstString</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a8a670af025c7632628b450daa50e47df">ucnv_getSubstChars</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a38e2e21ab52bd6fab1c4cb21d00fd23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e2e21ab52bd6fab1c4cb21d00fd23f">&#9670;&nbsp;</a></span>ucnv_setSubstString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_setSubstString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a substitution string for converting from Unicode to a charset. The caller need not know the charset byte sequence for each charset.</p>
<p>Unlike <a class="el" href="ucnv_8h.html#aa840af123bebe51ecdb936641087f229">ucnv_setSubstChars()</a> which is designed to set a charset byte sequence for a single character, this function takes a Unicode string with zero, one or more characters, and immediately verifies that the string can be converted to the charset. If not, or if the result is too long (more than 32 bytes as of ICU 3.6), then the function returns with an error accordingly.</p>
<p>Also unlike <a class="el" href="ucnv_8h.html#aa840af123bebe51ecdb936641087f229">ucnv_setSubstChars()</a>, this function works for stateful charsets by converting on the fly at the point of substitution rather than setting a fixed byte sequence.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnv</td><td>The UConverter object. </td></tr>
    <tr><td class="paramname">s</td><td>The Unicode string. </td></tr>
    <tr><td class="paramname">length</td><td>The number of UChars in s, or -1 for a NUL-terminated string. </td></tr>
    <tr><td class="paramname">err</td><td>Pointer to a standard ICU error code. Its input value must pass the <a class="el" href="utypes_8h.html#a527f2c69e6b2e3b2c53ad8a99fb36711">U_SUCCESS()</a> test, or else the function returns immediately. Check for <a class="el" href="utypes_8h.html#a4d202200b6aa6f3c965ea370e0c8155f">U_FAILURE()</a> on output or use with function chaining. (See User Guide for details.)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#aa840af123bebe51ecdb936641087f229">ucnv_setSubstChars</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a8a670af025c7632628b450daa50e47df">ucnv_getSubstChars</a> @stable ICU 3.6 </dd></dl>

</div>
</div>
<a id="afce4464cdb5b488460bf21c116cb1cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce4464cdb5b488460bf21c116cb1cf2">&#9670;&nbsp;</a></span>ucnv_setToUCallBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_setToUCallBack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv_8h.html#ae077d9f2a37d3aa640c3c2032a2baa2c">UConverterToUCallback</a>&#160;</td>
          <td class="paramname"><em>newAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>newContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv_8h.html#ae077d9f2a37d3aa640c3c2032a2baa2c">UConverterToUCallback</a> *&#160;</td>
          <td class="paramname"><em>oldAction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>oldContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the callback function used by the converter when an illegal or invalid sequence is found. Context pointers are always owned by the caller. Predefined actions and contexts can be found in the <a class="el" href="ucnv__err_8h.html" title="C UConverter predefined error callbacks.">ucnv_err.h</a> header.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the unicode converter </td></tr>
    <tr><td class="paramname">newAction</td><td>the new callback function </td></tr>
    <tr><td class="paramname">newContext</td><td>the new toUnicode callback context pointer. This can be NULL. </td></tr>
    <tr><td class="paramname">oldAction</td><td>fillin: returns the old callback function pointer. This can be NULL. </td></tr>
    <tr><td class="paramname">oldContext</td><td>fillin: returns the old callback's private void* context. This can be NULL. </td></tr>
    <tr><td class="paramname">err</td><td>The error code status </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a9981e203dd727f20ce391e9c1c12d88c">ucnv_getToUCallBack</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a872d74b772834c4c7924edfe1f933691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872d74b772834c4c7924edfe1f933691">&#9670;&nbsp;</a></span>ucnv_toAlgorithmic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2 ucnv_toAlgorithmic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv_8h.html#adb0b44c6bd828c9d4cc2defcbba0f902">UConverterType</a>&#160;</td>
          <td class="paramname"><em>algorithmicType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>targetCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>sourceLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from one external charset to another. Internally, the text is converted to and from the 16-bit Unicode "pivot" using <a class="el" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx()</a>. <a class="el" href="ucnv_8h.html#a872d74b772834c4c7924edfe1f933691">ucnv_toAlgorithmic()</a> works exactly like <a class="el" href="ucnv_8h.html#a942e532c2f02bcaea39741d4b99764b5">ucnv_convert()</a> except that the two converters need not be looked up and opened completely.</p>
<p>The source-to-pivot conversion uses the cnv converter parameter. The pivot-to-target conversion uses a purely algorithmic converter according to the specified type, e.g., UCNV_UTF8 for a UTF-8 converter.</p>
<p>Internally, the algorithmic converter is opened and closed for each function call, which is more efficient than using the public <a class="el" href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open()</a> but somewhat less efficient than only resetting an existing converter and using <a class="el" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx()</a>.</p>
<p>This function is more convenient than <a class="el" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx()</a> for single-string conversions, especially when "preflighting" is desired (returning the length of the complete output even if it does not fit into the target buffer; see the User Guide Strings chapter). See <a class="el" href="ucnv_8h.html#a942e532c2f02bcaea39741d4b99764b5">ucnv_convert()</a> for details.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">algorithmicType</td><td>UConverterType constant identifying the desired target charset as a purely algorithmic converter. Those are converters for Unicode charsets like UTF-8, BOCU-1, SCSU, UTF-7, IMAP-mailbox-name, etc., as well as US-ASCII and ISO-8859-1. </td></tr>
    <tr><td class="paramname">cnv</td><td>The converter that is used to convert from the source to the UTF-16 pivot buffer. </td></tr>
    <tr><td class="paramname">target</td><td>Pointer to the output buffer. </td></tr>
    <tr><td class="paramname">targetCapacity</td><td>Capacity of the target, in bytes. </td></tr>
    <tr><td class="paramname">source</td><td>Pointer to the input buffer. </td></tr>
    <tr><td class="paramname">sourceLength</td><td>Length of the input text, in bytes </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Length of the complete output text in bytes, even if it exceeds the targetCapacity and a U_BUFFER_OVERFLOW_ERROR is set.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a939c6148e6ebcf39568ce1c6ea0a24f0">ucnv_fromAlgorithmic</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a942e532c2f02bcaea39741d4b99764b5">ucnv_convert</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#aa63cf11835833041f2ce0ed3662edfcd">ucnv_fromUnicode</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a2cc3d9d8fbab664493a9aa189d120571">ucnv_fromUChars</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#afd107e398535c523d900f030df8326df">ucnv_toUChars</a> @stable ICU 2.6 </dd></dl>

</div>
</div>
<a id="afd107e398535c523d900f030df8326df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd107e398535c523d900f030df8326df">&#9670;&nbsp;</a></span>ucnv_toUChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2 ucnv_toUChars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>destCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>srcLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>pErrorCode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert the codepage string into a Unicode string using an existing UConverter. The output string is NUL-terminated if possible.</p>
<p>This function is a more convenient but less powerful version of <a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode()</a>. It is only useful for whole strings, not for streaming conversion.</p>
<p>The maximum output buffer capacity required (barring output from callbacks) will be 2*srcLength (each char may be converted into a surrogate pair).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnv</td><td>the converter object to be used (<a class="el" href="ucnv_8h.html#aedbb912ce9067a392052bc91a7d9ee34">ucnv_resetToUnicode()</a> will be called) </td></tr>
    <tr><td class="paramname">src</td><td>the input codepage string </td></tr>
    <tr><td class="paramname">srcLength</td><td>the input string length, or -1 if NUL-terminated </td></tr>
    <tr><td class="paramname">dest</td><td>destination string buffer, can be NULL if destCapacity==0 </td></tr>
    <tr><td class="paramname">destCapacity</td><td>the number of UChars available at dest </td></tr>
    <tr><td class="paramname">pErrorCode</td><td>normal ICU error code; common error codes that may be set by this function include U_BUFFER_OVERFLOW_ERROR, U_STRING_NOT_TERMINATED_WARNING, U_ILLEGAL_ARGUMENT_ERROR, and conversion errors </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the length of the output string, not counting the terminating NUL; if the length is greater than destCapacity, then the string will not fit and a buffer of the indicated length would need to be passed in </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#afbbface3193728333668691daaf2fbfb">ucnv_toUnicode</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a942e532c2f02bcaea39741d4b99764b5">ucnv_convert</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="a9cdb66e7ae11ef4b256096609450bce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdb66e7ae11ef4b256096609450bce3">&#9670;&nbsp;</a></span>ucnv_toUCountPending()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> int32_t U_EXPORT2 ucnv_toUCountPending </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>cnv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of chars held in the converter's internal state because more input is needed for completing the conversion. This function is useful for mapping semantics of ICU's converter interface to those of iconv, and this information is not needed for normal conversion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnv</td><td>The converter in which the input is held as internal state </td></tr>
    <tr><td class="paramname">status</td><td>ICU error code in/out parameter. Must fulfill U_SUCCESS before the function call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of chars in the state. -1 if an error is encountered. @stable ICU 3.4 </dd></dl>

</div>
</div>
<a id="afbbface3193728333668691daaf2fbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbbface3193728333668691daaf2fbfb">&#9670;&nbsp;</a></span>ucnv_toUnicode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> void U_EXPORT2 ucnv_toUnicode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>converter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> **&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="umachine_8h.html#a6bb9fad572d65b305324ef288165e2ac">UChar</a> *&#160;</td>
          <td class="paramname"><em>targetLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sourceLimit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a>&#160;</td>
          <td class="paramname"><em>flush</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a> *&#160;</td>
          <td class="paramname"><em>err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a buffer of codepage bytes into an array of unicode UChars characters. This function is optimized for converting a continuous stream of data in buffer-sized chunks, where the entire source and target does not fit in available buffers.</p>
<p>The source pointer is an in/out parameter. It starts out pointing where the conversion is to begin, and ends up pointing after the last byte of source consumed.</p>
<p>Target similarly starts out pointer at the first available UChar in the output buffer, and ends up pointing after the last UChar written to the output. It does NOT necessarily keep UChar sequences together.</p>
<p>The converter always attempts to consume the entire source buffer, unless (1.) the target buffer is full, or (2.) a failing error is returned from the current callback function. When a successful error status has been returned, it means that all of the source buffer has been consumed. At that point, the caller should reset the source and sourceLimit pointers to point to the next chunk.</p>
<p>At the end of the stream (flush==true), the input is completely consumed when *source==sourceLimit and no error code is set The converter object is then automatically reset by this function. (This means that a converter need not be reset explicitly between data streams if it finishes the previous stream without errors.)</p>
<p>This is a <em>stateful</em> conversion. Additionally, even when all source data has been consumed, some data may be in the converters' internal state. Call this function repeatedly, updating the target pointers with the next empty chunk of target in case of a <code>U_BUFFER_OVERFLOW_ERROR</code>, and updating the source pointers with the next chunk of source when a successful error status is returned, until there are no more chunks of source data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">converter</td><td>the Unicode converter </td></tr>
    <tr><td class="paramname">target</td><td>I/O parameter. Input : Points to the beginning of the buffer to copy UChars into. Output : points to after the last UChar copied. </td></tr>
    <tr><td class="paramname">targetLimit</td><td>the pointer just after the end of the <code>target</code> buffer </td></tr>
    <tr><td class="paramname">source</td><td>I/O parameter, pointer to pointer to the source codepage buffer. </td></tr>
    <tr><td class="paramname">sourceLimit</td><td>the pointer to the byte after the end of the source buffer </td></tr>
    <tr><td class="paramname">offsets</td><td>if NULL is passed, nothing will happen to it, otherwise it needs to have the same number of allocated cells as <code>target</code>. Will fill in offsets from target to source pointer e.g: <code>offsets[3]</code> is equal to 6, it means that the <code>target[3]</code> was a result of transcoding <code>source[6]</code> For output data carried across calls, and other data without a specific source character (such as from escape sequences or callbacks) -1 will be placed for offsets. </td></tr>
    <tr><td class="paramname">flush</td><td>set to <code>true</code> if the current source buffer is the last available chunk of the source, <code>false</code> otherwise. Note that if a failing status is returned, this function may have to be called multiple times with flush set to <code>true</code> until the source buffer is consumed. </td></tr>
    <tr><td class="paramname">err</td><td>the error status. <code>U_ILLEGAL_ARGUMENT_ERROR</code> will be set if the converter is <code>NULL</code>. <code>U_BUFFER_OVERFLOW_ERROR</code> will be set if the target is full and there is still data to be written to the target. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a2cc3d9d8fbab664493a9aa189d120571">ucnv_fromUChars</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a942e532c2f02bcaea39741d4b99764b5">ucnv_convert</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a65f30417f0f0b249f449eb8d4e1100ce">ucnv_getMinCharSize</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a304bcaa1f4cbc789d10197d6f51c94f1">ucnv_setFromUCallBack</a> </dd>
<dd>
<a class="el" href="ucnv_8h.html#a00c0fdce8c98e50dea85beb3f086fe8e">ucnv_getNextUChar</a> @stable ICU 2.0 </dd></dl>

</div>
</div>
<a id="aa9ae28ad00c484d5edebed7a80237bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ae28ad00c484d5edebed7a80237bfd">&#9670;&nbsp;</a></span>ucnv_usesFallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="umachine_8h.html#a676114b1a64bb7c2de15c919a00b28df">U_CAPI</a> <a class="el" href="umachine_8h.html#a349ef00011f20ccd1d3b424445681aa5">UBool</a> U_EXPORT2 ucnv_usesFallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a> *&#160;</td>
          <td class="paramname"><em>cnv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines if the converter uses fallback mappings or not. This flag has restrictions, see <a class="el" href="ucnv_8h.html#a6a1f70909aa917783b1ec6f350bde107">ucnv_setFallback()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cnv</td><td>The converter to be tested </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the converter uses fallback, false otherwise. @stable ICU 2.0 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ucnv_8h.html#a6a1f70909aa917783b1ec6f350bde107">ucnv_setFallback</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="autypes_8h_html_a070d2ce7b6bb7e5c05602aa8c308d0c4"><div class="ttname"><a href="utypes_8h.html#a070d2ce7b6bb7e5c05602aa8c308d0c4">NULL</a></div><div class="ttdeci">#define NULL</div><div class="ttdef"><b>Definition:</b> utypes.h:188</div></div>
<div class="ttc" id="autypes_8h_html_a4d202200b6aa6f3c965ea370e0c8155f"><div class="ttname"><a href="utypes_8h.html#a4d202200b6aa6f3c965ea370e0c8155f">U_FAILURE</a></div><div class="ttdeci">#define U_FAILURE(x)</div><div class="ttdef"><b>Definition:</b> utypes.h:723</div></div>
<div class="ttc" id="autypes_8h_html_a3343c1c8a8377277046774691c98d78c"><div class="ttname"><a href="utypes_8h.html#a3343c1c8a8377277046774691c98d78c">UErrorCode</a></div><div class="ttdeci">UErrorCode</div><div class="ttdef"><b>Definition:</b> utypes.h:419</div></div>
<div class="ttc" id="agroup__gtc__type__precision_html_ga5e3dc67373d5068997d2d9f41c9024d2"><div class="ttname"><a href="group__gtc__type__precision.html#ga5e3dc67373d5068997d2d9f41c9024d2">glm::u8</a></div><div class="ttdeci">detail::uint8 u8</div><div class="ttdef"><b>Definition:</b> fwd.hpp:894</div></div>
<div class="ttc" id="aucnv_8h_html_a1ab80dfe1f774537db9d5497a2ba8be7"><div class="ttname"><a href="ucnv_8h.html#a1ab80dfe1f774537db9d5497a2ba8be7">ucnv_convertEx</a></div><div class="ttdeci">U_CAPI void U_EXPORT2 ucnv_convertEx(UConverter *targetCnv, UConverter *sourceCnv, char **target, const char *targetLimit, const char **source, const char *sourceLimit, UChar *pivotStart, UChar **pivotSource, UChar **pivotTarget, const UChar *pivotLimit, UBool reset, UBool flush, UErrorCode *pErrorCode)</div></div>
<div class="ttc" id="aucnv_8h_html_a0588f7014923ad969821941f9dd51040"><div class="ttname"><a href="ucnv_8h.html#a0588f7014923ad969821941f9dd51040">UCNV_SWAP_LFNL_OPTION_STRING</a></div><div class="ttdeci">#define UCNV_SWAP_LFNL_OPTION_STRING</div><div class="ttdef"><b>Definition:</b> ucnv.h:297</div></div>
<div class="ttc" id="aucnv__err_8h_html_a0c2dcfbf71ad577f5285869e1ceb26b1"><div class="ttname"><a href="ucnv__err_8h.html#a0c2dcfbf71ad577f5285869e1ceb26b1">UConverter</a></div><div class="ttdeci">struct UConverter UConverter</div><div class="ttdef"><b>Definition:</b> ucnv_err.h:96</div></div>
<div class="ttc" id="aucnv_8h_html_a04af8743cca855974b87fd55a7970d6c"><div class="ttname"><a href="ucnv_8h.html#a04af8743cca855974b87fd55a7970d6c">ucnv_open</a></div><div class="ttdeci">U_CAPI UConverter *U_EXPORT2 ucnv_open(const char *converterName, UErrorCode *err)</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
