<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: SkPath Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_sk_path-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SkPath Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_sk_path_8h_source.html">SkPath.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SkPath:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_sk_path.png" usemap="#SkPath_map" alt=""/>
  <map id="SkPath_map" name="SkPath_map">
<area href="struct_sk_records_1_1_pre_cached_path.html" alt="SkRecords::PreCachedPath" shape="rect" coords="0,56,168,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path_1_1_iter.html">Iter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path_1_1_raw_iter.html">RawIter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a968e6248ebe0a13e74c28e432ca59125"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a968e6248ebe0a13e74c28e432ca59125">ArcSize</a> { <a class="el" href="class_sk_path.html#a968e6248ebe0a13e74c28e432ca59125a06a198c5ed112cc37526f805f194a8ff">kSmall_ArcSize</a>, 
<a class="el" href="class_sk_path.html#a968e6248ebe0a13e74c28e432ca59125adadb866d7c283778e9c495a141aeedc4">kLarge_ArcSize</a>
 }</td></tr>
<tr class="separator:a968e6248ebe0a13e74c28e432ca59125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac80e323d715e26af58106879e7f3d95"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95">AddPathMode</a> { <a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95af2b30d1984c8ddc895cc5e3fd52376ef">kAppend_AddPathMode</a>, 
<a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95a3eaffabb1ede7f0f7a99e7c85cfd2ae8">kExtend_AddPathMode</a>
 }</td></tr>
<tr class="separator:aac80e323d715e26af58106879e7f3d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01e9993d5bbded1779493179ffc143a7"><td class="memItemLeft" align="right" valign="top"><a id="a01e9993d5bbded1779493179ffc143a7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SegmentMask</b> { <b>kLine_SegmentMask</b> = kLine_SkPathSegmentMask, 
<b>kQuad_SegmentMask</b> = kQuad_SkPathSegmentMask, 
<b>kConic_SegmentMask</b> = kConic_SkPathSegmentMask, 
<b>kCubic_SegmentMask</b> = kCubic_SkPathSegmentMask
 }</td></tr>
<tr class="separator:a01e9993d5bbded1779493179ffc143a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36f638ac96f3428626e993eacf84ff0"><td class="memItemLeft" align="right" valign="top"><a id="ac36f638ac96f3428626e993eacf84ff0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Verb</b> { <br />
&#160;&#160;<b>kMove_Verb</b> = static_cast&lt;int&gt;(SkPathVerb::kMove), 
<b>kLine_Verb</b> = static_cast&lt;int&gt;(SkPathVerb::kLine), 
<b>kQuad_Verb</b> = static_cast&lt;int&gt;(SkPathVerb::kQuad), 
<b>kConic_Verb</b> = static_cast&lt;int&gt;(SkPathVerb::kConic), 
<br />
&#160;&#160;<b>kCubic_Verb</b> = static_cast&lt;int&gt;(SkPathVerb::kCubic), 
<b>kClose_Verb</b> = static_cast&lt;int&gt;(SkPathVerb::kClose), 
<b>kDone_Verb</b> = kClose_Verb + 1
<br />
 }</td></tr>
<tr class="separator:ac36f638ac96f3428626e993eacf84ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a19453a0e80054e1cbdd389d31654bcc6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a19453a0e80054e1cbdd389d31654bcc6">SkPath</a> ()</td></tr>
<tr class="separator:a19453a0e80054e1cbdd389d31654bcc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30a9363d49c092958d48e30608df367"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#aa30a9363d49c092958d48e30608df367">SkPath</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path)</td></tr>
<tr class="separator:aa30a9363d49c092958d48e30608df367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ebfe13095d531f1d2bf1cbce725fd4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a66ebfe13095d531f1d2bf1cbce725fd4">~SkPath</a> ()</td></tr>
<tr class="separator:a66ebfe13095d531f1d2bf1cbce725fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e75e150a765d304e8d0c3d087ddc94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a24e75e150a765d304e8d0c3d087ddc94">operator=</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path)</td></tr>
<tr class="separator:a24e75e150a765d304e8d0c3d087ddc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f7eed7de33a798a9859ab16e335fde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a78f7eed7de33a798a9859ab16e335fde">isInterpolatable</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;compare) const</td></tr>
<tr class="separator:a78f7eed7de33a798a9859ab16e335fde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79332188cf437c46f294e77da89920b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a79332188cf437c46f294e77da89920b5">interpolate</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;ending, SkScalar weight, <a class="el" href="class_sk_path.html">SkPath</a> *out) const</td></tr>
<tr class="separator:a79332188cf437c46f294e77da89920b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382204722705384fb74b7abd3e5c3f95"><td class="memItemLeft" align="right" valign="top">SkPathFillType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a382204722705384fb74b7abd3e5c3f95">getFillType</a> () const</td></tr>
<tr class="separator:a382204722705384fb74b7abd3e5c3f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a562e1a9037c6a4cf676febe8073176"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a3a562e1a9037c6a4cf676febe8073176">setFillType</a> (SkPathFillType ft)</td></tr>
<tr class="separator:a3a562e1a9037c6a4cf676febe8073176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b2fe32125d776c2274da5e735eb588"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a06b2fe32125d776c2274da5e735eb588">isInverseFillType</a> () const</td></tr>
<tr class="separator:a06b2fe32125d776c2274da5e735eb588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557a2b002743e15d9bd4f14b0aee3ea6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a557a2b002743e15d9bd4f14b0aee3ea6">toggleInverseFillType</a> ()</td></tr>
<tr class="separator:a557a2b002743e15d9bd4f14b0aee3ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20544ae11a0b20b09565274ca4da740"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#aa20544ae11a0b20b09565274ca4da740">isConvex</a> () const</td></tr>
<tr class="separator:aa20544ae11a0b20b09565274ca4da740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cab201b805a4210074a632fab3e21c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a88cab201b805a4210074a632fab3e21c">isOval</a> (<a class="el" href="struct_sk_rect.html">SkRect</a> *bounds) const</td></tr>
<tr class="separator:a88cab201b805a4210074a632fab3e21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cac7a51ebe9607dbc1b3ddde5a4e5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#ae8cac7a51ebe9607dbc1b3ddde5a4e5f">isRRect</a> (<a class="el" href="class_sk_r_rect.html">SkRRect</a> *rrect) const</td></tr>
<tr class="separator:ae8cac7a51ebe9607dbc1b3ddde5a4e5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977497439155df168c935114be1fa148"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a977497439155df168c935114be1fa148">reset</a> ()</td></tr>
<tr class="separator:a977497439155df168c935114be1fa148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704fc5e57bfbadd6a7560291fc7fc1fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a704fc5e57bfbadd6a7560291fc7fc1fa">rewind</a> ()</td></tr>
<tr class="separator:a704fc5e57bfbadd6a7560291fc7fc1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0289c6eed642e4d74c95fda08b0df63a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a0289c6eed642e4d74c95fda08b0df63a">isEmpty</a> () const</td></tr>
<tr class="separator:a0289c6eed642e4d74c95fda08b0df63a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88bb37821fd59e93954de3c3d7ed9a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#ac88bb37821fd59e93954de3c3d7ed9a9">isLastContourClosed</a> () const</td></tr>
<tr class="separator:ac88bb37821fd59e93954de3c3d7ed9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244a91414b71bf2192825098b0216233"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a244a91414b71bf2192825098b0216233">isFinite</a> () const</td></tr>
<tr class="separator:a244a91414b71bf2192825098b0216233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e82bf8ec4993ced919ddc1e54a8e07c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a6e82bf8ec4993ced919ddc1e54a8e07c">isVolatile</a> () const</td></tr>
<tr class="separator:a6e82bf8ec4993ced919ddc1e54a8e07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5734897ba1c06cd48cd4f8726d3a3af6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a5734897ba1c06cd48cd4f8726d3a3af6">setIsVolatile</a> (bool <a class="el" href="class_sk_path.html#a6e82bf8ec4993ced919ddc1e54a8e07c">isVolatile</a>)</td></tr>
<tr class="separator:a5734897ba1c06cd48cd4f8726d3a3af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b79cc08d313b8e5f3f6b98281a9fd4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a2b79cc08d313b8e5f3f6b98281a9fd4e">isLine</a> (<a class="el" href="struct_sk_point.html">SkPoint</a> line[2]) const</td></tr>
<tr class="separator:a2b79cc08d313b8e5f3f6b98281a9fd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d1b347ac162821b37c26ff4ce75ba3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a18d1b347ac162821b37c26ff4ce75ba3">countPoints</a> () const</td></tr>
<tr class="separator:a18d1b347ac162821b37c26ff4ce75ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28741ac1ee01f1f626b8537f327720c5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a28741ac1ee01f1f626b8537f327720c5">getPoint</a> (int index) const</td></tr>
<tr class="separator:a28741ac1ee01f1f626b8537f327720c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5540ce3ec6f55b99e154a743de5d6b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a3a5540ce3ec6f55b99e154a743de5d6b">getPoints</a> (<a class="el" href="struct_sk_point.html">SkPoint</a> points[], int max) const</td></tr>
<tr class="separator:a3a5540ce3ec6f55b99e154a743de5d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15ef795d4c26bf12bad01a194567934"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#ac15ef795d4c26bf12bad01a194567934">countVerbs</a> () const</td></tr>
<tr class="separator:ac15ef795d4c26bf12bad01a194567934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bc5e41461af1093d62e7bb4fba012e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a94bc5e41461af1093d62e7bb4fba012e">getVerbs</a> (uint8_t verbs[], int max) const</td></tr>
<tr class="separator:a94bc5e41461af1093d62e7bb4fba012e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbe80ea3d2514edc4094329a1faed28"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a5bbe80ea3d2514edc4094329a1faed28">approximateBytesUsed</a> () const</td></tr>
<tr class="separator:a5bbe80ea3d2514edc4094329a1faed28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ded6edd025942b925cc9be8e54732c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#ad4ded6edd025942b925cc9be8e54732c">swap</a> (<a class="el" href="class_sk_path.html">SkPath</a> &amp;other)</td></tr>
<tr class="separator:ad4ded6edd025942b925cc9be8e54732c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60188dc6075d6ebb56b5398fbba0c10"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#ac60188dc6075d6ebb56b5398fbba0c10">getBounds</a> () const</td></tr>
<tr class="separator:ac60188dc6075d6ebb56b5398fbba0c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de7de42175fe3ce5ff92f3d2267ec2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a6de7de42175fe3ce5ff92f3d2267ec2d">updateBoundsCache</a> () const</td></tr>
<tr class="separator:a6de7de42175fe3ce5ff92f3d2267ec2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597c8fcc5e4750542e2688b057a14e9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_rect.html">SkRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a597c8fcc5e4750542e2688b057a14e9e">computeTightBounds</a> () const</td></tr>
<tr class="separator:a597c8fcc5e4750542e2688b057a14e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c796f9353ce45a7c41fa5c065ea4f2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a1c796f9353ce45a7c41fa5c065ea4f2c">conservativelyContainsRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect) const</td></tr>
<tr class="separator:a1c796f9353ce45a7c41fa5c065ea4f2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efb0417f01be1c29e2ba9c173a1977c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a2efb0417f01be1c29e2ba9c173a1977c">incReserve</a> (int extraPtCount)</td></tr>
<tr class="separator:a2efb0417f01be1c29e2ba9c173a1977c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28dc5683b9a3e75ad55393cd233e8341"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a28dc5683b9a3e75ad55393cd233e8341">moveTo</a> (SkScalar x, SkScalar y)</td></tr>
<tr class="separator:a28dc5683b9a3e75ad55393cd233e8341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85ad85fdec8bb0d4c39d46c45f2d9581"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a85ad85fdec8bb0d4c39d46c45f2d9581">moveTo</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p)</td></tr>
<tr class="separator:a85ad85fdec8bb0d4c39d46c45f2d9581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7923238a1ebf57f75020d0439744e434"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a7923238a1ebf57f75020d0439744e434">rMoveTo</a> (SkScalar dx, SkScalar dy)</td></tr>
<tr class="separator:a7923238a1ebf57f75020d0439744e434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457f1f4f0d45339c6eb2d2ca15610a84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a457f1f4f0d45339c6eb2d2ca15610a84">lineTo</a> (SkScalar x, SkScalar y)</td></tr>
<tr class="separator:a457f1f4f0d45339c6eb2d2ca15610a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c6505cd16db954d6f0268e2de5d87f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a27c6505cd16db954d6f0268e2de5d87f">lineTo</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p)</td></tr>
<tr class="separator:a27c6505cd16db954d6f0268e2de5d87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af44de3514295effc0d1319d419b5a745"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#af44de3514295effc0d1319d419b5a745">rLineTo</a> (SkScalar dx, SkScalar dy)</td></tr>
<tr class="separator:af44de3514295effc0d1319d419b5a745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d554f5ea596598762ba7c903029bc2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a9d554f5ea596598762ba7c903029bc2d">quadTo</a> (SkScalar x1, SkScalar y1, SkScalar x2, SkScalar y2)</td></tr>
<tr class="separator:a9d554f5ea596598762ba7c903029bc2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95f346ea768b989b355f7922594f0399"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a95f346ea768b989b355f7922594f0399">quadTo</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p1, const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p2)</td></tr>
<tr class="separator:a95f346ea768b989b355f7922594f0399"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd57395bc59b3e2350490ddfe5cf8cc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#acd57395bc59b3e2350490ddfe5cf8cc8">rQuadTo</a> (SkScalar dx1, SkScalar dy1, SkScalar dx2, SkScalar dy2)</td></tr>
<tr class="separator:acd57395bc59b3e2350490ddfe5cf8cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8a605100b42d1192e8badc827ccd0b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#ac8a605100b42d1192e8badc827ccd0b5">conicTo</a> (SkScalar x1, SkScalar y1, SkScalar x2, SkScalar y2, SkScalar w)</td></tr>
<tr class="separator:ac8a605100b42d1192e8badc827ccd0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a049ffb8ea45050736235712ec5a764"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a0a049ffb8ea45050736235712ec5a764">conicTo</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p1, const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p2, SkScalar w)</td></tr>
<tr class="separator:a0a049ffb8ea45050736235712ec5a764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a233092825009d8da04c52b2f62527b03"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a233092825009d8da04c52b2f62527b03">rConicTo</a> (SkScalar dx1, SkScalar dy1, SkScalar dx2, SkScalar dy2, SkScalar w)</td></tr>
<tr class="separator:a233092825009d8da04c52b2f62527b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60d4fd3434c01c2763f86993e5f5bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#ac60d4fd3434c01c2763f86993e5f5bf0">cubicTo</a> (SkScalar x1, SkScalar y1, SkScalar x2, SkScalar y2, SkScalar x3, SkScalar y3)</td></tr>
<tr class="separator:ac60d4fd3434c01c2763f86993e5f5bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a7a69f1756f198d35171e00abb0c46"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a95a7a69f1756f198d35171e00abb0c46">cubicTo</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p1, const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p2, const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p3)</td></tr>
<tr class="separator:a95a7a69f1756f198d35171e00abb0c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3b1374fd88e0986ddaea3f3b0379db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a4c3b1374fd88e0986ddaea3f3b0379db">rCubicTo</a> (SkScalar dx1, SkScalar dy1, SkScalar dx2, SkScalar dy2, SkScalar dx3, SkScalar dy3)</td></tr>
<tr class="separator:a4c3b1374fd88e0986ddaea3f3b0379db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ec2323a5b6e45bf7f2420384f535e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;oval, SkScalar startAngle, SkScalar sweepAngle, bool forceMoveTo)</td></tr>
<tr class="separator:a22ec2323a5b6e45bf7f2420384f535e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e519d08f7c192d6e6260ccb1d1c290"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a23e519d08f7c192d6e6260ccb1d1c290">arcTo</a> (SkScalar x1, SkScalar y1, SkScalar x2, SkScalar y2, SkScalar radius)</td></tr>
<tr class="separator:a23e519d08f7c192d6e6260ccb1d1c290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae98cabd97136bd55b70474622dc7ccae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#ae98cabd97136bd55b70474622dc7ccae">arcTo</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> p1, const <a class="el" href="struct_sk_point.html">SkPoint</a> p2, SkScalar radius)</td></tr>
<tr class="separator:ae98cabd97136bd55b70474622dc7ccae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f69c180940e0be63060d18cbd30a75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a56f69c180940e0be63060d18cbd30a75">arcTo</a> (SkScalar rx, SkScalar ry, SkScalar xAxisRotate, <a class="el" href="class_sk_path.html#a968e6248ebe0a13e74c28e432ca59125">ArcSize</a> largeArc, SkPathDirection sweep, SkScalar x, SkScalar y)</td></tr>
<tr class="separator:a56f69c180940e0be63060d18cbd30a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07a8971e107e34be8004d874b01a043"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#ab07a8971e107e34be8004d874b01a043">arcTo</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> r, SkScalar xAxisRotate, <a class="el" href="class_sk_path.html#a968e6248ebe0a13e74c28e432ca59125">ArcSize</a> largeArc, SkPathDirection sweep, const <a class="el" href="struct_sk_point.html">SkPoint</a> xy)</td></tr>
<tr class="separator:ab07a8971e107e34be8004d874b01a043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020cba27507f10809a57b8f26a0af35c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a020cba27507f10809a57b8f26a0af35c">rArcTo</a> (SkScalar rx, SkScalar ry, SkScalar xAxisRotate, <a class="el" href="class_sk_path.html#a968e6248ebe0a13e74c28e432ca59125">ArcSize</a> largeArc, SkPathDirection sweep, SkScalar dx, SkScalar dy)</td></tr>
<tr class="separator:a020cba27507f10809a57b8f26a0af35c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c03218bb3887585e28116684172c17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#ad2c03218bb3887585e28116684172c17">close</a> ()</td></tr>
<tr class="separator:ad2c03218bb3887585e28116684172c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6086fc1a35ef838b38f8730ae534762"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#ad6086fc1a35ef838b38f8730ae534762">isRect</a> (<a class="el" href="struct_sk_rect.html">SkRect</a> *rect, bool *isClosed=nullptr, SkPathDirection *direction=nullptr) const</td></tr>
<tr class="separator:ad6086fc1a35ef838b38f8730ae534762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8e17b2b8b030d150edd71a4081db8f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#af8e17b2b8b030d150edd71a4081db8f7">addRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, SkPathDirection dir, unsigned start)</td></tr>
<tr class="separator:af8e17b2b8b030d150edd71a4081db8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30259f7d64b3f0498f8262a467cdea8d"><td class="memItemLeft" align="right" valign="top"><a id="a30259f7d64b3f0498f8262a467cdea8d"></a>
<a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>addRect</b> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, SkPathDirection dir=SkPathDirection::kCW)</td></tr>
<tr class="separator:a30259f7d64b3f0498f8262a467cdea8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc6949b738ef41ff6fa4e95ab43ea22"><td class="memItemLeft" align="right" valign="top"><a id="abdc6949b738ef41ff6fa4e95ab43ea22"></a>
<a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>addRect</b> (SkScalar left, SkScalar top, SkScalar right, SkScalar bottom, SkPathDirection dir=SkPathDirection::kCW)</td></tr>
<tr class="separator:abdc6949b738ef41ff6fa4e95ab43ea22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39cb6c5b07d25431388f5011f2c2de9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#ac39cb6c5b07d25431388f5011f2c2de9">addOval</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;oval, SkPathDirection dir=SkPathDirection::kCW)</td></tr>
<tr class="separator:ac39cb6c5b07d25431388f5011f2c2de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a6311b780ee5ea7fade5d61b9d1415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a82a6311b780ee5ea7fade5d61b9d1415">addOval</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;oval, SkPathDirection dir, unsigned start)</td></tr>
<tr class="separator:a82a6311b780ee5ea7fade5d61b9d1415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2067a391815733504bb47c2523de8c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a2067a391815733504bb47c2523de8c3d">addCircle</a> (SkScalar x, SkScalar y, SkScalar radius, SkPathDirection dir=SkPathDirection::kCW)</td></tr>
<tr class="separator:a2067a391815733504bb47c2523de8c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83f861c8385ab523a04e4907a11cfeed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a83f861c8385ab523a04e4907a11cfeed">addArc</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;oval, SkScalar startAngle, SkScalar sweepAngle)</td></tr>
<tr class="separator:a83f861c8385ab523a04e4907a11cfeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f660f4fe89b00f7edcc3cb0ba6e7d89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a9f660f4fe89b00f7edcc3cb0ba6e7d89">addRoundRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, SkScalar rx, SkScalar ry, SkPathDirection dir=SkPathDirection::kCW)</td></tr>
<tr class="separator:a9f660f4fe89b00f7edcc3cb0ba6e7d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd42bb437ff854792e3196dc4aafcd85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#abd42bb437ff854792e3196dc4aafcd85">addRoundRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, const SkScalar radii[], SkPathDirection dir=SkPathDirection::kCW)</td></tr>
<tr class="separator:abd42bb437ff854792e3196dc4aafcd85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b013ced8525d572291195b660527d9c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a4b013ced8525d572291195b660527d9c">addRRect</a> (const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;rrect, SkPathDirection dir=SkPathDirection::kCW)</td></tr>
<tr class="separator:a4b013ced8525d572291195b660527d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25f9ab392623374058c28001de9d16c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a25f9ab392623374058c28001de9d16c2">addRRect</a> (const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;rrect, SkPathDirection dir, unsigned start)</td></tr>
<tr class="separator:a25f9ab392623374058c28001de9d16c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd2dcd2f254df8c4e9bcb61ce4daadf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a3cd2dcd2f254df8c4e9bcb61ce4daadf">addPoly</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> pts[], int count, bool <a class="el" href="class_sk_path.html#ad2c03218bb3887585e28116684172c17">close</a>)</td></tr>
<tr class="separator:a3cd2dcd2f254df8c4e9bcb61ce4daadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbb9ff9b25a6ca5510b0727b8b2a9672"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#acbb9ff9b25a6ca5510b0727b8b2a9672">addPoly</a> (const std::initializer_list&lt; <a class="el" href="struct_sk_point.html">SkPoint</a> &gt; &amp;list, bool <a class="el" href="class_sk_path.html#ad2c03218bb3887585e28116684172c17">close</a>)</td></tr>
<tr class="separator:acbb9ff9b25a6ca5510b0727b8b2a9672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50e791ed1bb4a6ca9faccb838cefe6e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a50e791ed1bb4a6ca9faccb838cefe6e0">addPath</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;src, SkScalar dx, SkScalar dy, <a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95">AddPathMode</a> mode=<a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95af2b30d1984c8ddc895cc5e3fd52376ef">kAppend_AddPathMode</a>)</td></tr>
<tr class="separator:a50e791ed1bb4a6ca9faccb838cefe6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4543638cafa6226c87d87a7e5ec727"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a9f4543638cafa6226c87d87a7e5ec727">addPath</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;src, <a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95">AddPathMode</a> mode=<a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95af2b30d1984c8ddc895cc5e3fd52376ef">kAppend_AddPathMode</a>)</td></tr>
<tr class="separator:a9f4543638cafa6226c87d87a7e5ec727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905600494fca1eae24404228f45e7dff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a905600494fca1eae24404228f45e7dff">addPath</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;src, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;matrix, <a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95">AddPathMode</a> mode=<a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95af2b30d1984c8ddc895cc5e3fd52376ef">kAppend_AddPathMode</a>)</td></tr>
<tr class="separator:a905600494fca1eae24404228f45e7dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070aab0bed84e1137a186cef1f10192f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a070aab0bed84e1137a186cef1f10192f">reverseAddPath</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;src)</td></tr>
<tr class="separator:a070aab0bed84e1137a186cef1f10192f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4a9414537a0df5e2354d521d8cf6aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a0b4a9414537a0df5e2354d521d8cf6aa">offset</a> (SkScalar dx, SkScalar dy, <a class="el" href="class_sk_path.html">SkPath</a> *dst) const</td></tr>
<tr class="separator:a0b4a9414537a0df5e2354d521d8cf6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a6ccd0f6608a0decb3af050d81da21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a62a6ccd0f6608a0decb3af050d81da21">offset</a> (SkScalar dx, SkScalar dy)</td></tr>
<tr class="separator:a62a6ccd0f6608a0decb3af050d81da21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad814203ce342490f699698d9c308b889"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#ad814203ce342490f699698d9c308b889">transform</a> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;matrix, <a class="el" href="class_sk_path.html">SkPath</a> *dst, SkApplyPerspectiveClip pc=SkApplyPerspectiveClip::kYes) const</td></tr>
<tr class="separator:ad814203ce342490f699698d9c308b889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b555a598f122e7f2911334c1a4a9f51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a8b555a598f122e7f2911334c1a4a9f51">transform</a> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;matrix, SkApplyPerspectiveClip pc=SkApplyPerspectiveClip::kYes)</td></tr>
<tr class="separator:a8b555a598f122e7f2911334c1a4a9f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb61cc6b00906f4be9b9866460ba60b2"><td class="memItemLeft" align="right" valign="top"><a id="aeb61cc6b00906f4be9b9866460ba60b2"></a>
<a class="el" href="class_sk_path.html">SkPath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>makeTransform</b> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;m, SkApplyPerspectiveClip pc=SkApplyPerspectiveClip::kYes) const</td></tr>
<tr class="separator:aeb61cc6b00906f4be9b9866460ba60b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dae9554cd7a7fc9898ce879e00a300c"><td class="memItemLeft" align="right" valign="top"><a id="a7dae9554cd7a7fc9898ce879e00a300c"></a>
<a class="el" href="class_sk_path.html">SkPath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>makeScale</b> (SkScalar sx, SkScalar sy)</td></tr>
<tr class="separator:a7dae9554cd7a7fc9898ce879e00a300c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3068074d7295495def2671c36ad83361"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a3068074d7295495def2671c36ad83361">getLastPt</a> (<a class="el" href="struct_sk_point.html">SkPoint</a> *lastPt) const</td></tr>
<tr class="separator:a3068074d7295495def2671c36ad83361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce8d91669e01e7724c27a4d453516fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a1ce8d91669e01e7724c27a4d453516fb">setLastPt</a> (SkScalar x, SkScalar y)</td></tr>
<tr class="separator:a1ce8d91669e01e7724c27a4d453516fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829354d382186c11a95b2214b40d1685"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a829354d382186c11a95b2214b40d1685">setLastPt</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p)</td></tr>
<tr class="separator:a829354d382186c11a95b2214b40d1685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8e4461582ac723a866a4fe27031181"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#aac8e4461582ac723a866a4fe27031181">getSegmentMasks</a> () const</td></tr>
<tr class="separator:aac8e4461582ac723a866a4fe27031181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63b8abc6efff13607af2147ce6d7f8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#af63b8abc6efff13607af2147ce6d7f8e">contains</a> (SkScalar x, SkScalar y) const</td></tr>
<tr class="separator:af63b8abc6efff13607af2147ce6d7f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb0662af45f3fd2cfb17380dd41a515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#addb0662af45f3fd2cfb17380dd41a515">dump</a> (<a class="el" href="class_sk_w_stream.html">SkWStream</a> *stream, bool dumpAsHex) const</td></tr>
<tr class="separator:addb0662af45f3fd2cfb17380dd41a515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753ef4f01a674824b09613fc1ef2df6c"><td class="memItemLeft" align="right" valign="top"><a id="a753ef4f01a674824b09613fc1ef2df6c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dump</b> () const</td></tr>
<tr class="separator:a753ef4f01a674824b09613fc1ef2df6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae379675bbca5c29419c97ecad0a135d"><td class="memItemLeft" align="right" valign="top"><a id="aae379675bbca5c29419c97ecad0a135d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpHex</b> () const</td></tr>
<tr class="separator:aae379675bbca5c29419c97ecad0a135d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6c31630475cd11cb98463ae7557a883"><td class="memItemLeft" align="right" valign="top"><a id="ab6c31630475cd11cb98463ae7557a883"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpArrays</b> (<a class="el" href="class_sk_w_stream.html">SkWStream</a> *stream, bool dumpAsHex) const</td></tr>
<tr class="separator:ab6c31630475cd11cb98463ae7557a883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0542fd540552583eefcc132de053d704"><td class="memItemLeft" align="right" valign="top"><a id="a0542fd540552583eefcc132de053d704"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dumpArrays</b> () const</td></tr>
<tr class="separator:a0542fd540552583eefcc132de053d704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34720f80c02d5854cc6b09675b5d907"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#ab34720f80c02d5854cc6b09675b5d907">writeToMemory</a> (void *<a class="el" href="structbuffer.html">buffer</a>) const</td></tr>
<tr class="separator:ab34720f80c02d5854cc6b09675b5d907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8586ce1afff7e7f41e1e7bac0b418b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#aac8586ce1afff7e7f41e1e7bac0b418b">serialize</a> () const</td></tr>
<tr class="separator:aac8586ce1afff7e7f41e1e7bac0b418b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f6fe6f7f3caf7212ed37b0d2712da2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a02f6fe6f7f3caf7212ed37b0d2712da2">readFromMemory</a> (const void *<a class="el" href="structbuffer.html">buffer</a>, size_t length)</td></tr>
<tr class="separator:a02f6fe6f7f3caf7212ed37b0d2712da2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07772c885789e0369c8b6817c93b6031"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a07772c885789e0369c8b6817c93b6031">getGenerationID</a> () const</td></tr>
<tr class="separator:a07772c885789e0369c8b6817c93b6031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39cea91b553eec0446c1b62475612e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#ad39cea91b553eec0446c1b62475612e3">isValid</a> () const</td></tr>
<tr class="separator:ad39cea91b553eec0446c1b62475612e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a86b3be3b522fc2b36044e4cb9c43e59f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_sk_path.html">SkPath</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a86b3be3b522fc2b36044e4cb9c43e59f">Make</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a>[], int pointCount, const uint8_t[], int verbCount, const SkScalar[], int conicWeightCount, SkPathFillType, bool <a class="el" href="class_sk_path.html#a6e82bf8ec4993ced919ddc1e54a8e07c">isVolatile</a>=false)</td></tr>
<tr class="separator:a86b3be3b522fc2b36044e4cb9c43e59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a980c32d7839dabcf60c87e30cf1d6a"><td class="memItemLeft" align="right" valign="top"><a id="a1a980c32d7839dabcf60c87e30cf1d6a"></a>
static <a class="el" href="class_sk_path.html">SkPath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Rect</b> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;, SkPathDirection=SkPathDirection::kCW, unsigned startIndex=0)</td></tr>
<tr class="separator:a1a980c32d7839dabcf60c87e30cf1d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c8eba06f0a660b0776ad042844062d"><td class="memItemLeft" align="right" valign="top"><a id="ab2c8eba06f0a660b0776ad042844062d"></a>
static <a class="el" href="class_sk_path.html">SkPath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Oval</b> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;, SkPathDirection=SkPathDirection::kCW)</td></tr>
<tr class="separator:ab2c8eba06f0a660b0776ad042844062d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd7ca7730e923b166dc93b8288bb62f"><td class="memItemLeft" align="right" valign="top"><a id="a1bd7ca7730e923b166dc93b8288bb62f"></a>
static <a class="el" href="class_sk_path.html">SkPath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Oval</b> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;, SkPathDirection, unsigned startIndex)</td></tr>
<tr class="separator:a1bd7ca7730e923b166dc93b8288bb62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2f399ed7bd99edd6f3682e4696c21d"><td class="memItemLeft" align="right" valign="top"><a id="a9d2f399ed7bd99edd6f3682e4696c21d"></a>
static <a class="el" href="class_sk_path.html">SkPath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Circle</b> (SkScalar center_x, SkScalar center_y, SkScalar radius, SkPathDirection dir=SkPathDirection::kCW)</td></tr>
<tr class="separator:a9d2f399ed7bd99edd6f3682e4696c21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f091ba5681813d767b14f753b324262"><td class="memItemLeft" align="right" valign="top"><a id="a0f091ba5681813d767b14f753b324262"></a>
static <a class="el" href="class_sk_path.html">SkPath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RRect</b> (const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;, SkPathDirection dir=SkPathDirection::kCW)</td></tr>
<tr class="separator:a0f091ba5681813d767b14f753b324262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a910e70e96a93207ed9ea7ae4962bc95b"><td class="memItemLeft" align="right" valign="top"><a id="a910e70e96a93207ed9ea7ae4962bc95b"></a>
static <a class="el" href="class_sk_path.html">SkPath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RRect</b> (const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;, SkPathDirection, unsigned startIndex)</td></tr>
<tr class="separator:a910e70e96a93207ed9ea7ae4962bc95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56f24d647bb451f48f4b18ee7159cc78"><td class="memItemLeft" align="right" valign="top"><a id="a56f24d647bb451f48f4b18ee7159cc78"></a>
static <a class="el" href="class_sk_path.html">SkPath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>RRect</b> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;bounds, SkScalar rx, SkScalar ry, SkPathDirection dir=SkPathDirection::kCW)</td></tr>
<tr class="separator:a56f24d647bb451f48f4b18ee7159cc78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a6df040ebec70693e3d57dbd0c1a40"><td class="memItemLeft" align="right" valign="top"><a id="ac4a6df040ebec70693e3d57dbd0c1a40"></a>
static <a class="el" href="class_sk_path.html">SkPath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Polygon</b> (const <a class="el" href="struct_sk_point.html">SkPoint</a> pts[], int count, bool isClosed, SkPathFillType=SkPathFillType::kWinding, bool <a class="el" href="class_sk_path.html#a6e82bf8ec4993ced919ddc1e54a8e07c">isVolatile</a>=false)</td></tr>
<tr class="separator:ac4a6df040ebec70693e3d57dbd0c1a40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8283c9336cbb76e7b2f819a6a67ebe93"><td class="memItemLeft" align="right" valign="top"><a id="a8283c9336cbb76e7b2f819a6a67ebe93"></a>
static <a class="el" href="class_sk_path.html">SkPath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Polygon</b> (const std::initializer_list&lt; <a class="el" href="struct_sk_point.html">SkPoint</a> &gt; &amp;list, bool isClosed, SkPathFillType fillType=SkPathFillType::kWinding, bool <a class="el" href="class_sk_path.html#a6e82bf8ec4993ced919ddc1e54a8e07c">isVolatile</a>=false)</td></tr>
<tr class="separator:a8283c9336cbb76e7b2f819a6a67ebe93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8736f631a168ccd70942cf7eaa01b94"><td class="memItemLeft" align="right" valign="top"><a id="af8736f631a168ccd70942cf7eaa01b94"></a>
static <a class="el" href="class_sk_path.html">SkPath</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Line</b> (const <a class="el" href="struct_sk_point.html">SkPoint</a> a, const <a class="el" href="struct_sk_point.html">SkPoint</a> b)</td></tr>
<tr class="separator:af8736f631a168ccd70942cf7eaa01b94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d3dcaa99b0e0701944e2d5d6f45113a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a0d3dcaa99b0e0701944e2d5d6f45113a">IsLineDegenerate</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p1, const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p2, bool exact)</td></tr>
<tr class="separator:a0d3dcaa99b0e0701944e2d5d6f45113a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bcc5d4d51e3f124e77d43093a49837"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a35bcc5d4d51e3f124e77d43093a49837">IsQuadDegenerate</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p1, const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p2, const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p3, bool exact)</td></tr>
<tr class="separator:a35bcc5d4d51e3f124e77d43093a49837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46110bc288d9416e58dc216a5a475ebd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a46110bc288d9416e58dc216a5a475ebd">IsCubicDegenerate</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p1, const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p2, const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p3, const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p4, bool exact)</td></tr>
<tr class="separator:a46110bc288d9416e58dc216a5a475ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b3d8db8d55498a9f4db710fe9990f7"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#aa3b3d8db8d55498a9f4db710fe9990f7">ConvertConicToQuads</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p0, const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p1, const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;p2, SkScalar w, <a class="el" href="struct_sk_point.html">SkPoint</a> pts[], int pow2)</td></tr>
<tr class="separator:aa3b3d8db8d55498a9f4db710fe9990f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1aa9543a703214f24b87e027ccd38be5"><td class="memItemLeft" align="right" valign="top"><a id="a1aa9543a703214f24b87e027ccd38be5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>Iter</b></td></tr>
<tr class="separator:a1aa9543a703214f24b87e027ccd38be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a0490cef71e330bab1a82755e4ee48"><td class="memItemLeft" align="right" valign="top"><a id="a31a0490cef71e330bab1a82755e4ee48"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkPathPriv</b></td></tr>
<tr class="separator:a31a0490cef71e330bab1a82755e4ee48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb9cd113ecfc0af1df09076d0b14d2a"><td class="memItemLeft" align="right" valign="top"><a id="a4cb9cd113ecfc0af1df09076d0b14d2a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkPathStroker</b></td></tr>
<tr class="separator:a4cb9cd113ecfc0af1df09076d0b14d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94cde5f7b4b0d4068a6575b0bcdf8d21"><td class="memItemLeft" align="right" valign="top"><a id="a94cde5f7b4b0d4068a6575b0bcdf8d21"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkAutoPathBoundsUpdate</b></td></tr>
<tr class="separator:a94cde5f7b4b0d4068a6575b0bcdf8d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea1010ec7b78381b906629988ac65a5"><td class="memItemLeft" align="right" valign="top"><a id="aeea1010ec7b78381b906629988ac65a5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkAutoDisableOvalCheck</b></td></tr>
<tr class="separator:aeea1010ec7b78381b906629988ac65a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d0fe5caf2638b5ac36051b5d26de90"><td class="memItemLeft" align="right" valign="top"><a id="a75d0fe5caf2638b5ac36051b5d26de90"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkAutoDisableDirectionCheck</b></td></tr>
<tr class="separator:a75d0fe5caf2638b5ac36051b5d26de90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d50b70a69e90cd8fd87e795b21d919"><td class="memItemLeft" align="right" valign="top"><a id="af8d50b70a69e90cd8fd87e795b21d919"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkPathBuilder</b></td></tr>
<tr class="separator:af8d50b70a69e90cd8fd87e795b21d919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4192654d55ac9b14907c31021a997ea"><td class="memItemLeft" align="right" valign="top"><a id="ab4192654d55ac9b14907c31021a997ea"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkPathEdgeIter</b></td></tr>
<tr class="separator:ab4192654d55ac9b14907c31021a997ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861bde4a4253d171ad3a934c876bba00"><td class="memItemLeft" align="right" valign="top"><a id="a861bde4a4253d171ad3a934c876bba00"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkPathWriter</b></td></tr>
<tr class="separator:a861bde4a4253d171ad3a934c876bba00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955acf6a147588ed5a0719716cfac68e"><td class="memItemLeft" align="right" valign="top"><a id="a955acf6a147588ed5a0719716cfac68e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkOpBuilder</b></td></tr>
<tr class="separator:a955acf6a147588ed5a0719716cfac68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a186bc5b5e25c0d824d79dd7adab49506"><td class="memItemLeft" align="right" valign="top"><a id="a186bc5b5e25c0d824d79dd7adab49506"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkBench_AddPathTest</b></td></tr>
<tr class="separator:a186bc5b5e25c0d824d79dd7adab49506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25cb1b9c410a1e9828ac9817e4988d20"><td class="memItemLeft" align="right" valign="top"><a id="a25cb1b9c410a1e9828ac9817e4988d20"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>PathTest_Private</b></td></tr>
<tr class="separator:a25cb1b9c410a1e9828ac9817e4988d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51942369c3e4b3e574001c68f15541b9"><td class="memItemLeft" align="right" valign="top"><a id="a51942369c3e4b3e574001c68f15541b9"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>ForceIsRRect_Private</b></td></tr>
<tr class="separator:a51942369c3e4b3e574001c68f15541b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf4d311acd5b570b74c8df76151d52b"><td class="memItemLeft" align="right" valign="top"><a id="a0bf4d311acd5b570b74c8df76151d52b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>FuzzPath</b></td></tr>
<tr class="separator:a0bf4d311acd5b570b74c8df76151d52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba232f3a5c2d5cf27c9ff846c0b830c"><td class="memItemLeft" align="right" valign="top">SK_API bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a2ba232f3a5c2d5cf27c9ff846c0b830c">operator==</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;a, const <a class="el" href="class_sk_path.html">SkPath</a> &amp;b)</td></tr>
<tr class="separator:a2ba232f3a5c2d5cf27c9ff846c0b830c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f95dae0ce68ac158edb5bf7a5a19260"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_path.html#a4f95dae0ce68ac158edb5bf7a5a19260">operator!=</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;a, const <a class="el" href="class_sk_path.html">SkPath</a> &amp;b)</td></tr>
<tr class="separator:a4f95dae0ce68ac158edb5bf7a5a19260"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_sk_path.html">SkPath</a> contain geometry. <a class="el" href="class_sk_path.html">SkPath</a> may be empty, or contain one or more verbs that outline a figure. <a class="el" href="class_sk_path.html">SkPath</a> always starts with a move verb to a Cartesian coordinate, and may be followed by additional verbs that add lines or curves. Adding a close verb makes the geometry into a continuous loop, a closed contour. <a class="el" href="class_sk_path.html">SkPath</a> may contain any number of contours, each beginning with a move verb.</p>
<p><a class="el" href="class_sk_path.html">SkPath</a> contours may contain only a move verb, or may also contain lines, quadratic beziers, conics, and cubic beziers. <a class="el" href="class_sk_path.html">SkPath</a> contours may be open or closed.</p>
<p>When used to draw a filled area, <a class="el" href="class_sk_path.html">SkPath</a> describes whether the fill is inside or outside the geometry. <a class="el" href="class_sk_path.html">SkPath</a> also describes the winding rule used to fill overlapping contours.</p>
<p>Internally, <a class="el" href="class_sk_path.html">SkPath</a> lazily computes metrics likes bounds and convexity. Call <a class="el" href="class_sk_path.html#a6de7de42175fe3ce5ff92f3d2267ec2d">SkPath::updateBoundsCache</a> to make <a class="el" href="class_sk_path.html">SkPath</a> thread safe. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aac80e323d715e26af58106879e7f3d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac80e323d715e26af58106879e7f3d95">&#9670;&nbsp;</a></span>AddPathMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95">SkPath::AddPathMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aac80e323d715e26af58106879e7f3d95af2b30d1984c8ddc895cc5e3fd52376ef"></a>kAppend_AddPathMode&#160;</td><td class="fielddoc"><p>appended to destination unaltered </p>
</td></tr>
<tr><td class="fieldname"><a id="aac80e323d715e26af58106879e7f3d95a3eaffabb1ede7f0f7a99e7c85cfd2ae8"></a>kExtend_AddPathMode&#160;</td><td class="fielddoc"><p>add line if prior contour is not closed </p>
</td></tr>
</table>

</div>
</div>
<a id="a968e6248ebe0a13e74c28e432ca59125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a968e6248ebe0a13e74c28e432ca59125">&#9670;&nbsp;</a></span>ArcSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_path.html#a968e6248ebe0a13e74c28e432ca59125">SkPath::ArcSize</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a968e6248ebe0a13e74c28e432ca59125a06a198c5ed112cc37526f805f194a8ff"></a>kSmall_ArcSize&#160;</td><td class="fielddoc"><p>smaller of arc pair </p>
</td></tr>
<tr><td class="fieldname"><a id="a968e6248ebe0a13e74c28e432ca59125adadb866d7c283778e9c495a141aeedc4"></a>kLarge_ArcSize&#160;</td><td class="fielddoc"><p>larger of arc pair </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a19453a0e80054e1cbdd389d31654bcc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19453a0e80054e1cbdd389d31654bcc6">&#9670;&nbsp;</a></span>SkPath() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkPath::SkPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an empty <a class="el" href="class_sk_path.html">SkPath</a>. By default, <a class="el" href="class_sk_path.html">SkPath</a> has no verbs, no <a class="el" href="struct_sk_point.html">SkPoint</a>, and no weights. FillType is set to kWinding.</p>
<dl class="section return"><dt>Returns</dt><dd>empty <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_empty_constructor">https://fiddle.skia.org/c/@Path_empty_constructor</a> </p>

</div>
</div>
<a id="aa30a9363d49c092958d48e30608df367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30a9363d49c092958d48e30608df367">&#9670;&nbsp;</a></span>SkPath() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkPath::SkPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a copy of an existing path. Copy constructor makes two paths identical by value. Internally, path and the returned result share pointer values. The underlying verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array and weights are copied when modified.</p>
<p>Creating a <a class="el" href="class_sk_path.html">SkPath</a> copy is very efficient and never allocates memory. <a class="el" href="class_sk_path.html">SkPath</a> are always copied by value from the interface; the underlying shared pointers are not exposed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td><a class="el" href="class_sk_path.html">SkPath</a> to copy by value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_copy_const_SkPath">https://fiddle.skia.org/c/@Path_copy_const_SkPath</a> </p>

</div>
</div>
<a id="a66ebfe13095d531f1d2bf1cbce725fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ebfe13095d531f1d2bf1cbce725fd4">&#9670;&nbsp;</a></span>~SkPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkPath::~SkPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases ownership of any shared data and deletes data if <a class="el" href="class_sk_path.html">SkPath</a> is sole owner.</p>
<p>example: <a href="https://fiddle.skia.org/c/@Path_destructor">https://fiddle.skia.org/c/@Path_destructor</a> </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a83f861c8385ab523a04e4907a11cfeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f861c8385ab523a04e4907a11cfeed">&#9670;&nbsp;</a></span>addArc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::addArc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>oval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sweepAngle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends arc to <a class="el" href="class_sk_path.html">SkPath</a>, as the start of new contour. Arc added is part of ellipse bounded by oval, from startAngle through sweepAngle. Both startAngle and sweepAngle are measured in degrees, where zero degrees is aligned with the positive x-axis, and positive sweeps extends arc clockwise.</p>
<p>If sweepAngle &lt;= -360, or sweepAngle &gt;= 360; and startAngle modulo 90 is nearly zero, append oval instead of arc. Otherwise, sweepAngle values are treated modulo 360, and arc may or may not draw depending on numeric rounding.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oval</td><td>bounds of ellipse containing arc </td></tr>
    <tr><td class="paramname">startAngle</td><td>starting angle of arc in degrees </td></tr>
    <tr><td class="paramname">sweepAngle</td><td>sweep, in degrees. Positive is clockwise; treated modulo 360 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_addArc">https://fiddle.skia.org/c/@Path_addArc</a> </p>

</div>
</div>
<a id="a2067a391815733504bb47c2523de8c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2067a391815733504bb47c2523de8c3d">&#9670;&nbsp;</a></span>addCircle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::addCircle </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkPathDirection&#160;</td>
          <td class="paramname"><em>dir</em> = <code>SkPathDirection::kCW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds circle centered at (x, y) of size radius to <a class="el" href="class_sk_path.html">SkPath</a>, appending kMove_Verb, four kConic_Verb, and kClose_Verb. Circle begins at: (x + radius, y), continuing clockwise if dir is kCW_Direction, and counterclockwise if dir is kCCW_Direction.</p>
<p>Has no effect if radius is zero or negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>center of circle </td></tr>
    <tr><td class="paramname">y</td><td>center of circle </td></tr>
    <tr><td class="paramname">radius</td><td>distance from center to edge </td></tr>
    <tr><td class="paramname">dir</td><td>SkPath::Direction to wind circle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a82a6311b780ee5ea7fade5d61b9d1415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a6311b780ee5ea7fade5d61b9d1415">&#9670;&nbsp;</a></span>addOval() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::addOval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>oval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkPathDirection&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds oval to <a class="el" href="class_sk_path.html">SkPath</a>, appending kMove_Verb, four kConic_Verb, and kClose_Verb. Oval is upright ellipse bounded by <a class="el" href="struct_sk_rect.html">SkRect</a> oval with radii equal to half oval width and half oval height. Oval begins at start and continues clockwise if dir is kCW_Direction, counterclockwise if dir is kCCW_Direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oval</td><td>bounds of ellipse added </td></tr>
    <tr><td class="paramname">dir</td><td>SkPath::Direction to wind ellipse </td></tr>
    <tr><td class="paramname">start</td><td>index of initial point of ellipse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_addOval_2">https://fiddle.skia.org/c/@Path_addOval_2</a> </p>

</div>
</div>
<a id="ac39cb6c5b07d25431388f5011f2c2de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac39cb6c5b07d25431388f5011f2c2de9">&#9670;&nbsp;</a></span>addOval() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::addOval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>oval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkPathDirection&#160;</td>
          <td class="paramname"><em>dir</em> = <code>SkPathDirection::kCW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds oval to path, appending kMove_Verb, four kConic_Verb, and kClose_Verb. Oval is upright ellipse bounded by <a class="el" href="struct_sk_rect.html">SkRect</a> oval with radii equal to half oval width and half oval height. Oval begins at (oval.fRight, oval.centerY()) and continues clockwise if dir is kCW_Direction, counterclockwise if dir is kCCW_Direction.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oval</td><td>bounds of ellipse added </td></tr>
    <tr><td class="paramname">dir</td><td>SkPath::Direction to wind ellipse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_addOval">https://fiddle.skia.org/c/@Path_addOval</a> </p>

</div>
</div>
<a id="a9f4543638cafa6226c87d87a7e5ec727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4543638cafa6226c87d87a7e5ec727">&#9670;&nbsp;</a></span>addPath() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a>&amp; SkPath::addPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95">AddPathMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95af2b30d1984c8ddc895cc5e3fd52376ef">kAppend_AddPathMode</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends src to <a class="el" href="class_sk_path.html">SkPath</a>.</p>
<p>If mode is kAppend_AddPathMode, src verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array, and conic weights are added unaltered. If mode is kExtend_AddPathMode, add line before appending verbs, <a class="el" href="struct_sk_point.html">SkPoint</a>, and conic weights.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="class_sk_path.html">SkPath</a> verbs, <a class="el" href="struct_sk_point.html">SkPoint</a>, and conic weights to add </td></tr>
    <tr><td class="paramname">mode</td><td>kAppend_AddPathMode or kExtend_AddPathMode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a905600494fca1eae24404228f45e7dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a905600494fca1eae24404228f45e7dff">&#9670;&nbsp;</a></span>addPath() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::addPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95">AddPathMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95af2b30d1984c8ddc895cc5e3fd52376ef">kAppend_AddPathMode</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends src to <a class="el" href="class_sk_path.html">SkPath</a>, transformed by matrix. Transformed curves may have different verbs, <a class="el" href="struct_sk_point.html">SkPoint</a>, and conic weights.</p>
<p>If mode is kAppend_AddPathMode, src verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array, and conic weights are added unaltered. If mode is kExtend_AddPathMode, add line before appending verbs, <a class="el" href="struct_sk_point.html">SkPoint</a>, and conic weights.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="class_sk_path.html">SkPath</a> verbs, <a class="el" href="struct_sk_point.html">SkPoint</a>, and conic weights to add </td></tr>
    <tr><td class="paramname">matrix</td><td>transform applied to src </td></tr>
    <tr><td class="paramname">mode</td><td>kAppend_AddPathMode or kExtend_AddPathMode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a50e791ed1bb4a6ca9faccb838cefe6e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50e791ed1bb4a6ca9faccb838cefe6e0">&#9670;&nbsp;</a></span>addPath() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::addPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95">AddPathMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="class_sk_path.html#aac80e323d715e26af58106879e7f3d95af2b30d1984c8ddc895cc5e3fd52376ef">kAppend_AddPathMode</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends src to <a class="el" href="class_sk_path.html">SkPath</a>, offset by (dx, dy).</p>
<p>If mode is kAppend_AddPathMode, src verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array, and conic weights are added unaltered. If mode is kExtend_AddPathMode, add line before appending verbs, <a class="el" href="struct_sk_point.html">SkPoint</a>, and conic weights.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="class_sk_path.html">SkPath</a> verbs, <a class="el" href="struct_sk_point.html">SkPoint</a>, and conic weights to add </td></tr>
    <tr><td class="paramname">dx</td><td>offset added to src <a class="el" href="struct_sk_point.html">SkPoint</a> array x-axis coordinates </td></tr>
    <tr><td class="paramname">dy</td><td>offset added to src <a class="el" href="struct_sk_point.html">SkPoint</a> array y-axis coordinates </td></tr>
    <tr><td class="paramname">mode</td><td>kAppend_AddPathMode or kExtend_AddPathMode </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a3cd2dcd2f254df8c4e9bcb61ce4daadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd2dcd2f254df8c4e9bcb61ce4daadf">&#9670;&nbsp;</a></span>addPoly() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::addPoly </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>pts</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>close</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds contour created from line array, adding (count - 1) line segments. Contour added starts at pts[0], then adds a line for every additional <a class="el" href="struct_sk_point.html">SkPoint</a> in pts array. If close is true, appends kClose_Verb to <a class="el" href="class_sk_path.html">SkPath</a>, connecting pts[count - 1] and pts[0].</p>
<p>If count is zero, append kMove_Verb to path. Has no effect if count is less than one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pts</td><td>array of line sharing end and start <a class="el" href="struct_sk_point.html">SkPoint</a> </td></tr>
    <tr><td class="paramname">count</td><td>length of <a class="el" href="struct_sk_point.html">SkPoint</a> array </td></tr>
    <tr><td class="paramname">close</td><td>true to add line connecting contour end and start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_addPoly">https://fiddle.skia.org/c/@Path_addPoly</a> </p>

</div>
</div>
<a id="acbb9ff9b25a6ca5510b0727b8b2a9672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbb9ff9b25a6ca5510b0727b8b2a9672">&#9670;&nbsp;</a></span>addPoly() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a>&amp; SkPath::addPoly </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; <a class="el" href="struct_sk_point.html">SkPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>close</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds contour created from list. Contour added starts at list[0], then adds a line for every additional <a class="el" href="struct_sk_point.html">SkPoint</a> in list. If close is true, appends kClose_Verb to <a class="el" href="class_sk_path.html">SkPath</a>, connecting last and first <a class="el" href="struct_sk_point.html">SkPoint</a> in list.</p>
<p>If list is empty, append kMove_Verb to path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">list</td><td>array of <a class="el" href="struct_sk_point.html">SkPoint</a> </td></tr>
    <tr><td class="paramname">close</td><td>true to add line connecting contour end and start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="af8e17b2b8b030d150edd71a4081db8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8e17b2b8b030d150edd71a4081db8f7">&#9670;&nbsp;</a></span>addRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::addRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkPathDirection&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a new contour to the path, defined by the rect, and wound in the specified direction. The verbs added to the path will be:</p>
<p>kMove, kLine, kLine, kLine, kClose</p>
<p>start specifies which corner to begin the contour: 0: upper-left corner 1: upper-right corner 2: lower-right corner 3: lower-left corner</p>
<p>This start point also acts as the implied beginning of the subsequent, contour, if it does not have an explicit <a class="el" href="class_sk_path.html#a28dc5683b9a3e75ad55393cd233e8341">moveTo()</a>. e.g. </p><pre class="fragment">path.addRect(...)
</pre><p> if we don't say <a class="el" href="class_sk_path.html#a28dc5683b9a3e75ad55393cd233e8341">moveTo()</a> here, we will use the rect's start point path.lineTo(...)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to add as a closed contour </td></tr>
    <tr><td class="paramname">dir</td><td>SkPath::Direction to orient the new contour </td></tr>
    <tr><td class="paramname">start</td><td>initial corner of <a class="el" href="struct_sk_rect.html">SkRect</a> to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_addRect_2">https://fiddle.skia.org/c/@Path_addRect_2</a> </p>

</div>
</div>
<a id="abd42bb437ff854792e3196dc4aafcd85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd42bb437ff854792e3196dc4aafcd85">&#9670;&nbsp;</a></span>addRoundRect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::addRoundRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SkScalar&#160;</td>
          <td class="paramname"><em>radii</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkPathDirection&#160;</td>
          <td class="paramname"><em>dir</em> = <code>SkPathDirection::kCW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends <a class="el" href="class_sk_r_rect.html">SkRRect</a> to <a class="el" href="class_sk_path.html">SkPath</a>, creating a new closed contour. <a class="el" href="class_sk_r_rect.html">SkRRect</a> has bounds equal to rect; each corner is 90 degrees of an ellipse with radii from the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>bounds of <a class="el" href="class_sk_r_rect.html">SkRRect</a> </td></tr>
    <tr><td class="paramname">radii</td><td>array of 8 SkScalar values, a radius pair for each corner </td></tr>
    <tr><td class="paramname">dir</td><td>SkPath::Direction to wind <a class="el" href="class_sk_r_rect.html">SkRRect</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a9f660f4fe89b00f7edcc3cb0ba6e7d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f660f4fe89b00f7edcc3cb0ba6e7d89">&#9670;&nbsp;</a></span>addRoundRect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::addRoundRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>rx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>ry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkPathDirection&#160;</td>
          <td class="paramname"><em>dir</em> = <code>SkPathDirection::kCW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends <a class="el" href="class_sk_r_rect.html">SkRRect</a> to <a class="el" href="class_sk_path.html">SkPath</a>, creating a new closed contour. <a class="el" href="class_sk_r_rect.html">SkRRect</a> has bounds equal to rect; each corner is 90 degrees of an ellipse with radii (rx, ry). If dir is kCW_Direction, <a class="el" href="class_sk_r_rect.html">SkRRect</a> starts at top-left of the lower-left corner and winds clockwise. If dir is kCCW_Direction, <a class="el" href="class_sk_r_rect.html">SkRRect</a> starts at the bottom-left of the upper-left corner and winds counterclockwise.</p>
<p>If either rx or ry is too large, rx and ry are scaled uniformly until the corners fit. If rx or ry is less than or equal to zero, <a class="el" href="class_sk_path.html#a9f660f4fe89b00f7edcc3cb0ba6e7d89">addRoundRect()</a> appends <a class="el" href="struct_sk_rect.html">SkRect</a> rect to <a class="el" href="class_sk_path.html">SkPath</a>.</p>
<p>After appending, <a class="el" href="class_sk_path.html">SkPath</a> may be empty, or may contain: <a class="el" href="struct_sk_rect.html">SkRect</a>, oval, or <a class="el" href="class_sk_r_rect.html">SkRRect</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>bounds of <a class="el" href="class_sk_r_rect.html">SkRRect</a> </td></tr>
    <tr><td class="paramname">rx</td><td>x-axis radius of rounded corners on the <a class="el" href="class_sk_r_rect.html">SkRRect</a> </td></tr>
    <tr><td class="paramname">ry</td><td>y-axis radius of rounded corners on the <a class="el" href="class_sk_r_rect.html">SkRRect</a> </td></tr>
    <tr><td class="paramname">dir</td><td>SkPath::Direction to wind <a class="el" href="class_sk_r_rect.html">SkRRect</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a25f9ab392623374058c28001de9d16c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25f9ab392623374058c28001de9d16c2">&#9670;&nbsp;</a></span>addRRect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::addRRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rrect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkPathDirection&#160;</td>
          <td class="paramname"><em>dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rrect to <a class="el" href="class_sk_path.html">SkPath</a>, creating a new closed contour. If dir is kCW_Direction, rrect winds clockwise; if dir is kCCW_Direction, rrect winds counterclockwise. start determines the first point of rrect to add.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rrect</td><td>bounds and radii of rounded rectangle </td></tr>
    <tr><td class="paramname">dir</td><td>SkPath::Direction to wind <a class="el" href="class_sk_r_rect.html">SkRRect</a> </td></tr>
    <tr><td class="paramname">start</td><td>index of initial point of <a class="el" href="class_sk_r_rect.html">SkRRect</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_addRRect_2">https://fiddle.skia.org/c/@Path_addRRect_2</a> </p>

</div>
</div>
<a id="a4b013ced8525d572291195b660527d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b013ced8525d572291195b660527d9c">&#9670;&nbsp;</a></span>addRRect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::addRRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rrect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkPathDirection&#160;</td>
          <td class="paramname"><em>dir</em> = <code>SkPathDirection::kCW</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds rrect to <a class="el" href="class_sk_path.html">SkPath</a>, creating a new closed contour. If dir is kCW_Direction, rrect starts at top-left of the lower-left corner and winds clockwise. If dir is kCCW_Direction, rrect starts at the bottom-left of the upper-left corner and winds counterclockwise.</p>
<p>After appending, <a class="el" href="class_sk_path.html">SkPath</a> may be empty, or may contain: <a class="el" href="struct_sk_rect.html">SkRect</a>, oval, or <a class="el" href="class_sk_r_rect.html">SkRRect</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rrect</td><td>bounds and radii of rounded rectangle </td></tr>
    <tr><td class="paramname">dir</td><td>SkPath::Direction to wind <a class="el" href="class_sk_r_rect.html">SkRRect</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_addRRect">https://fiddle.skia.org/c/@Path_addRRect</a> </p>

</div>
</div>
<a id="a5bbe80ea3d2514edc4094329a1faed28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbe80ea3d2514edc4094329a1faed28">&#9670;&nbsp;</a></span>approximateBytesUsed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SkPath::approximateBytesUsed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the approximate byte size of the <a class="el" href="class_sk_path.html">SkPath</a> in memory.</p>
<dl class="section return"><dt>Returns</dt><dd>approximate size </dd></dl>

</div>
</div>
<a id="ae98cabd97136bd55b70474622dc7ccae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae98cabd97136bd55b70474622dc7ccae">&#9670;&nbsp;</a></span>arcTo() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a>&amp; SkPath::arcTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends arc to <a class="el" href="class_sk_path.html">SkPath</a>, after appending line if needed. Arc is implemented by conic weighted to describe part of circle. Arc is contained by tangent from last <a class="el" href="class_sk_path.html">SkPath</a> point to p1, and tangent from p1 to p2. Arc is part of circle sized to radius, positioned so it touches both tangent lines.</p>
<p>If last <a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> does not start arc, <a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> appends connecting line to <a class="el" href="class_sk_path.html">SkPath</a>. The length of vector from p1 to p2 does not affect arc.</p>
<p>Arc sweep is always less than 180 degrees. If radius is zero, or if tangents are nearly parallel, <a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> appends line from last <a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> to p1.</p>
<p><a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> appends at most one line and one conic. <a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> implements the functionality of PostScript arct and HTML Canvas arcTo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td><a class="el" href="struct_sk_point.html">SkPoint</a> common to pair of tangents </td></tr>
    <tr><td class="paramname">p2</td><td>end of second tangent </td></tr>
    <tr><td class="paramname">radius</td><td>distance from arc to circle center </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="ab07a8971e107e34be8004d874b01a043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab07a8971e107e34be8004d874b01a043">&#9670;&nbsp;</a></span>arcTo() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a>&amp; SkPath::arcTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>xAxisRotate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_path.html#a968e6248ebe0a13e74c28e432ca59125">ArcSize</a>&#160;</td>
          <td class="paramname"><em>largeArc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkPathDirection&#160;</td>
          <td class="paramname"><em>sweep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>xy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends arc to <a class="el" href="class_sk_path.html">SkPath</a>. Arc is implemented by one or more conic weighted to describe part of oval with radii (r.fX, r.fY) rotated by xAxisRotate degrees. Arc curves from last <a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> to (xy.fX, xy.fY), choosing one of four possible routes: clockwise or counterclockwise, and smaller or larger.</p>
<p>Arc sweep is always less than 360 degrees. <a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> appends line to xy if either radii are zero, or if last <a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> equals (xy.fX, xy.fY). <a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> scales radii r to fit last <a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> and xy if both are greater than zero but too small to describe an arc.</p>
<p><a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> appends up to four conic curves. <a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> implements the functionality of SVG arc, although SVG sweep-flag value is opposite the integer value of sweep; SVG sweep-flag uses 1 for clockwise, while kCW_Direction cast to int is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>radii on axes before x-axis rotation </td></tr>
    <tr><td class="paramname">xAxisRotate</td><td>x-axis rotation in degrees; positive values are clockwise </td></tr>
    <tr><td class="paramname">largeArc</td><td>chooses smaller or larger arc </td></tr>
    <tr><td class="paramname">sweep</td><td>chooses clockwise or counterclockwise arc </td></tr>
    <tr><td class="paramname">xy</td><td>end of arc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a22ec2323a5b6e45bf7f2420384f535e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ec2323a5b6e45bf7f2420384f535e6">&#9670;&nbsp;</a></span>arcTo() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::arcTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>oval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sweepAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceMoveTo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends arc to <a class="el" href="class_sk_path.html">SkPath</a>. Arc added is part of ellipse bounded by oval, from startAngle through sweepAngle. Both startAngle and sweepAngle are measured in degrees, where zero degrees is aligned with the positive x-axis, and positive sweeps extends arc clockwise.</p>
<p><a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> adds line connecting <a class="el" href="class_sk_path.html">SkPath</a> last <a class="el" href="struct_sk_point.html">SkPoint</a> to initial arc <a class="el" href="struct_sk_point.html">SkPoint</a> if forceMoveTo is false and <a class="el" href="class_sk_path.html">SkPath</a> is not empty. Otherwise, added contour begins with first point of arc. Angles greater than -360 and less than 360 are treated modulo 360.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oval</td><td>bounds of ellipse containing arc </td></tr>
    <tr><td class="paramname">startAngle</td><td>starting angle of arc in degrees </td></tr>
    <tr><td class="paramname">sweepAngle</td><td>sweep, in degrees. Positive is clockwise; treated modulo 360 </td></tr>
    <tr><td class="paramname">forceMoveTo</td><td>true to start a new contour with arc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_arcTo">https://fiddle.skia.org/c/@Path_arcTo</a> </p>

</div>
</div>
<a id="a56f69c180940e0be63060d18cbd30a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56f69c180940e0be63060d18cbd30a75">&#9670;&nbsp;</a></span>arcTo() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::arcTo </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>rx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>ry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>xAxisRotate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_path.html#a968e6248ebe0a13e74c28e432ca59125">SkPath::ArcSize</a>&#160;</td>
          <td class="paramname"><em>arcLarge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkPathDirection&#160;</td>
          <td class="paramname"><em>sweep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends arc to <a class="el" href="class_sk_path.html">SkPath</a>. Arc is implemented by one or more conics weighted to describe part of oval with radii (rx, ry) rotated by xAxisRotate degrees. Arc curves from last <a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> to (x, y), choosing one of four possible routes: clockwise or counterclockwise, and smaller or larger.</p>
<p>Arc sweep is always less than 360 degrees. <a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> appends line to (x, y) if either radii are zero, or if last <a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> equals (x, y). <a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> scales radii (rx, ry) to fit last <a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> and (x, y) if both are greater than zero but too small.</p>
<p><a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> appends up to four conic curves. <a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> implements the functionality of SVG arc, although SVG sweep-flag value is opposite the integer value of sweep; SVG sweep-flag uses 1 for clockwise, while kCW_Direction cast to int is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rx</td><td>radius on x-axis before x-axis rotation </td></tr>
    <tr><td class="paramname">ry</td><td>radius on y-axis before x-axis rotation </td></tr>
    <tr><td class="paramname">xAxisRotate</td><td>x-axis rotation in degrees; positive values are clockwise </td></tr>
    <tr><td class="paramname">largeArc</td><td>chooses smaller or larger arc </td></tr>
    <tr><td class="paramname">sweep</td><td>chooses clockwise or counterclockwise arc </td></tr>
    <tr><td class="paramname">x</td><td>end of arc </td></tr>
    <tr><td class="paramname">y</td><td>end of arc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a23e519d08f7c192d6e6260ccb1d1c290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e519d08f7c192d6e6260ccb1d1c290">&#9670;&nbsp;</a></span>arcTo() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::arcTo </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends arc to <a class="el" href="class_sk_path.html">SkPath</a>, after appending line if needed. Arc is implemented by conic weighted to describe part of circle. Arc is contained by tangent from last <a class="el" href="class_sk_path.html">SkPath</a> point to (x1, y1), and tangent from (x1, y1) to (x2, y2). Arc is part of circle sized to radius, positioned so it touches both tangent lines.</p>
<p>If last Path Point does not start Arc, arcTo appends connecting Line to Path. The length of Vector from (x1, y1) to (x2, y2) does not affect Arc.</p>
<p>Arc sweep is always less than 180 degrees. If radius is zero, or if tangents are nearly parallel, arcTo appends Line from last Path Point to (x1, y1).</p>
<p>arcTo appends at most one Line and one conic. arcTo implements the functionality of PostScript arct and HTML Canvas arcTo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>x-axis value common to pair of tangents </td></tr>
    <tr><td class="paramname">y1</td><td>y-axis value common to pair of tangents </td></tr>
    <tr><td class="paramname">x2</td><td>x-axis value end of second tangent </td></tr>
    <tr><td class="paramname">y2</td><td>y-axis value end of second tangent </td></tr>
    <tr><td class="paramname">radius</td><td>distance from arc to circle center </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_arcTo_2_a">https://fiddle.skia.org/c/@Path_arcTo_2_a</a> example: <a href="https://fiddle.skia.org/c/@Path_arcTo_2_b">https://fiddle.skia.org/c/@Path_arcTo_2_b</a> example: <a href="https://fiddle.skia.org/c/@Path_arcTo_2_c">https://fiddle.skia.org/c/@Path_arcTo_2_c</a> </p>

</div>
</div>
<a id="ad2c03218bb3887585e28116684172c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2c03218bb3887585e28116684172c17">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends kClose_Verb to <a class="el" href="class_sk_path.html">SkPath</a>. A closed contour connects the first and last <a class="el" href="struct_sk_point.html">SkPoint</a> with line, forming a continuous loop. Open and closed contour draw the same with <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fdab18888b04d1a69cee2f4b03f3191e611" title="set to fill geometry">SkPaint::kFill_Style</a>. With <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fda4bcc9f35fd6468ad92012c70daf7a495" title="set to stroke geometry">SkPaint::kStroke_Style</a>, open contour draws <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333">SkPaint::Cap</a> at contour start and end; closed contour draws <a class="el" href="class_sk_paint.html#ac582b0cbf59909c9056de34a6b977cca">SkPaint::Join</a> at contour start and end.</p>
<p><a class="el" href="class_sk_path.html#ad2c03218bb3887585e28116684172c17">close()</a> has no effect if <a class="el" href="class_sk_path.html">SkPath</a> is empty or last <a class="el" href="class_sk_path.html">SkPath</a> SkPath::Verb is kClose_Verb.</p>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_close">https://fiddle.skia.org/c/@Path_close</a> </p>

</div>
</div>
<a id="a597c8fcc5e4750542e2688b057a14e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597c8fcc5e4750542e2688b057a14e9e">&#9670;&nbsp;</a></span>computeTightBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_rect.html">SkRect</a> SkPath::computeTightBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns minimum and maximum axes values of the lines and curves in <a class="el" href="class_sk_path.html">SkPath</a>. Returns (0, 0, 0, 0) if <a class="el" href="class_sk_path.html">SkPath</a> contains no points. Returned bounds width and height may be larger or smaller than area affected when <a class="el" href="class_sk_path.html">SkPath</a> is drawn.</p>
<p>Includes <a class="el" href="struct_sk_point.html">SkPoint</a> associated with kMove_Verb that define empty contours.</p>
<p>Behaves identically to <a class="el" href="class_sk_path.html#ac60188dc6075d6ebb56b5398fbba0c10">getBounds()</a> when <a class="el" href="class_sk_path.html">SkPath</a> contains only lines. If <a class="el" href="class_sk_path.html">SkPath</a> contains curves, computed bounds includes the maximum extent of the quad, conic, or cubic; is slower than <a class="el" href="class_sk_path.html#ac60188dc6075d6ebb56b5398fbba0c10">getBounds()</a>; and unlike <a class="el" href="class_sk_path.html#ac60188dc6075d6ebb56b5398fbba0c10">getBounds()</a>, does not cache the result.</p>
<dl class="section return"><dt>Returns</dt><dd>tight bounds of curves in <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_computeTightBounds">https://fiddle.skia.org/c/@Path_computeTightBounds</a> </p>

</div>
</div>
<a id="a0a049ffb8ea45050736235712ec5a764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a049ffb8ea45050736235712ec5a764">&#9670;&nbsp;</a></span>conicTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a>&amp; SkPath::conicTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds conic from last point towards <a class="el" href="struct_sk_point.html">SkPoint</a> p1, to <a class="el" href="struct_sk_point.html">SkPoint</a> p2, weighted by w. If <a class="el" href="class_sk_path.html">SkPath</a> is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0) before adding conic.</p>
<p>Appends kMove_Verb to verb array and (0, 0) to <a class="el" href="struct_sk_point.html">SkPoint</a> array, if needed.</p>
<p>If w is finite and not one, appends kConic_Verb to verb array; and <a class="el" href="struct_sk_point.html">SkPoint</a> p1, p2 to <a class="el" href="struct_sk_point.html">SkPoint</a> array; and w to conic weights.</p>
<p>If w is one, appends kQuad_Verb to verb array, and <a class="el" href="struct_sk_point.html">SkPoint</a> p1, p2 to <a class="el" href="struct_sk_point.html">SkPoint</a> array.</p>
<p>If w is not finite, appends kLine_Verb twice to verb array, and <a class="el" href="struct_sk_point.html">SkPoint</a> p1, p2 to <a class="el" href="struct_sk_point.html">SkPoint</a> array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>control <a class="el" href="struct_sk_point.html">SkPoint</a> of added conic </td></tr>
    <tr><td class="paramname">p2</td><td>end <a class="el" href="struct_sk_point.html">SkPoint</a> of added conic </td></tr>
    <tr><td class="paramname">w</td><td>weight of added conic </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="ac8a605100b42d1192e8badc827ccd0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8a605100b42d1192e8badc827ccd0b5">&#9670;&nbsp;</a></span>conicTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::conicTo </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds conic from last point towards (x1, y1), to (x2, y2), weighted by w. If <a class="el" href="class_sk_path.html">SkPath</a> is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0) before adding conic.</p>
<p>Appends kMove_Verb to verb array and (0, 0) to <a class="el" href="struct_sk_point.html">SkPoint</a> array, if needed.</p>
<p>If w is finite and not one, appends kConic_Verb to verb array; and (x1, y1), (x2, y2) to <a class="el" href="struct_sk_point.html">SkPoint</a> array; and w to conic weights.</p>
<p>If w is one, appends kQuad_Verb to verb array, and (x1, y1), (x2, y2) to <a class="el" href="struct_sk_point.html">SkPoint</a> array.</p>
<p>If w is not finite, appends kLine_Verb twice to verb array, and (x1, y1), (x2, y2) to <a class="el" href="struct_sk_point.html">SkPoint</a> array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>control <a class="el" href="struct_sk_point.html">SkPoint</a> of conic on x-axis </td></tr>
    <tr><td class="paramname">y1</td><td>control <a class="el" href="struct_sk_point.html">SkPoint</a> of conic on y-axis </td></tr>
    <tr><td class="paramname">x2</td><td>end <a class="el" href="struct_sk_point.html">SkPoint</a> of conic on x-axis </td></tr>
    <tr><td class="paramname">y2</td><td>end <a class="el" href="struct_sk_point.html">SkPoint</a> of conic on y-axis </td></tr>
    <tr><td class="paramname">w</td><td>weight of added conic </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a1c796f9353ce45a7c41fa5c065ea4f2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c796f9353ce45a7c41fa5c065ea4f2c">&#9670;&nbsp;</a></span>conservativelyContainsRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::conservativelyContainsRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if rect is contained by <a class="el" href="class_sk_path.html">SkPath</a>. May return false when rect is contained by <a class="el" href="class_sk_path.html">SkPath</a>.</p>
<p>For now, only returns true if <a class="el" href="class_sk_path.html">SkPath</a> has one contour and is convex. rect may share points and edges with <a class="el" href="class_sk_path.html">SkPath</a> and be contained. Returns true if rect is empty, that is, it has zero width or height; and the <a class="el" href="struct_sk_point.html">SkPoint</a> or line described by rect is contained by <a class="el" href="class_sk_path.html">SkPath</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td><a class="el" href="struct_sk_rect.html">SkRect</a>, line, or <a class="el" href="struct_sk_point.html">SkPoint</a> checked for containment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rect is contained</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_conservativelyContainsRect">https://fiddle.skia.org/c/@Path_conservativelyContainsRect</a> </p>

</div>
</div>
<a id="af63b8abc6efff13607af2147ce6d7f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63b8abc6efff13607af2147ce6d7f8e">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::contains </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the point (x, y) is contained by <a class="el" href="class_sk_path.html">SkPath</a>, taking into account FillType.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x-axis value of containment test </td></tr>
    <tr><td class="paramname">y</td><td>y-axis value of containment test </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="struct_sk_point.html">SkPoint</a> is in <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_contains">https://fiddle.skia.org/c/@Path_contains</a> </p>

</div>
</div>
<a id="aa3b3d8db8d55498a9f4db710fe9990f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b3d8db8d55498a9f4db710fe9990f7">&#9670;&nbsp;</a></span>ConvertConicToQuads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SkPath::ConvertConicToQuads </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>pts</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pow2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Approximates conic with quad array. Conic is constructed from start <a class="el" href="struct_sk_point.html">SkPoint</a> p0, control <a class="el" href="struct_sk_point.html">SkPoint</a> p1, end <a class="el" href="struct_sk_point.html">SkPoint</a> p2, and weight w. Quad array is stored in pts; this storage is supplied by caller. Maximum quad count is 2 to the pow2. Every third point in array shares last <a class="el" href="struct_sk_point.html">SkPoint</a> of previous quad and first <a class="el" href="struct_sk_point.html">SkPoint</a> of next quad. Maximum pts storage size is given by: (1 + 2 * (1 &lt;&lt; pow2)) * sizeof(SkPoint).</p>
<p>Returns quad count used the approximation, which may be smaller than the number requested.</p>
<p>conic weight determines the amount of influence conic control point has on the curve. w less than one represents an elliptical section. w greater than one represents a hyperbolic section. w equal to one represents a parabolic section.</p>
<p>Two quad curves are sufficient to approximate an elliptical conic with a sweep of up to 90 degrees; in this case, set pow2 to one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p0</td><td>conic start <a class="el" href="struct_sk_point.html">SkPoint</a> </td></tr>
    <tr><td class="paramname">p1</td><td>conic control <a class="el" href="struct_sk_point.html">SkPoint</a> </td></tr>
    <tr><td class="paramname">p2</td><td>conic end <a class="el" href="struct_sk_point.html">SkPoint</a> </td></tr>
    <tr><td class="paramname">w</td><td>conic weight </td></tr>
    <tr><td class="paramname">pts</td><td>storage for quad array </td></tr>
    <tr><td class="paramname">pow2</td><td>quad count, as power of two, normally 0 to 5 (1 to 32 quad curves) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of quad curves written to pts </dd></dl>

</div>
</div>
<a id="a18d1b347ac162821b37c26ff4ce75ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18d1b347ac162821b37c26ff4ce75ba3">&#9670;&nbsp;</a></span>countPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SkPath::countPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of points in <a class="el" href="class_sk_path.html">SkPath</a>. <a class="el" href="struct_sk_point.html">SkPoint</a> count is initially zero.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> array length</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_countPoints">https://fiddle.skia.org/c/@Path_countPoints</a> </p>

</div>
</div>
<a id="ac15ef795d4c26bf12bad01a194567934"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15ef795d4c26bf12bad01a194567934">&#9670;&nbsp;</a></span>countVerbs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SkPath::countVerbs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of verbs: kMove_Verb, kLine_Verb, kQuad_Verb, kConic_Verb, kCubic_Verb, and kClose_Verb; added to <a class="el" href="class_sk_path.html">SkPath</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>length of verb array</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_countVerbs">https://fiddle.skia.org/c/@Path_countVerbs</a> </p>

</div>
</div>
<a id="a95a7a69f1756f198d35171e00abb0c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a7a69f1756f198d35171e00abb0c46">&#9670;&nbsp;</a></span>cubicTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a>&amp; SkPath::cubicTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds cubic from last point towards <a class="el" href="struct_sk_point.html">SkPoint</a> p1, then towards <a class="el" href="struct_sk_point.html">SkPoint</a> p2, ending at <a class="el" href="struct_sk_point.html">SkPoint</a> p3. If <a class="el" href="class_sk_path.html">SkPath</a> is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0) before adding cubic.</p>
<p>Appends kMove_Verb to verb array and (0, 0) to <a class="el" href="struct_sk_point.html">SkPoint</a> array, if needed; then appends kCubic_Verb to verb array; and <a class="el" href="struct_sk_point.html">SkPoint</a> p1, p2, p3 to <a class="el" href="struct_sk_point.html">SkPoint</a> array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>first control <a class="el" href="struct_sk_point.html">SkPoint</a> of cubic </td></tr>
    <tr><td class="paramname">p2</td><td>second control <a class="el" href="struct_sk_point.html">SkPoint</a> of cubic </td></tr>
    <tr><td class="paramname">p3</td><td>end <a class="el" href="struct_sk_point.html">SkPoint</a> of cubic </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="ac60d4fd3434c01c2763f86993e5f5bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60d4fd3434c01c2763f86993e5f5bf0">&#9670;&nbsp;</a></span>cubicTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::cubicTo </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds cubic from last point towards (x1, y1), then towards (x2, y2), ending at (x3, y3). If <a class="el" href="class_sk_path.html">SkPath</a> is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0) before adding cubic.</p>
<p>Appends kMove_Verb to verb array and (0, 0) to <a class="el" href="struct_sk_point.html">SkPoint</a> array, if needed; then appends kCubic_Verb to verb array; and (x1, y1), (x2, y2), (x3, y3) to <a class="el" href="struct_sk_point.html">SkPoint</a> array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>first control <a class="el" href="struct_sk_point.html">SkPoint</a> of cubic on x-axis </td></tr>
    <tr><td class="paramname">y1</td><td>first control <a class="el" href="struct_sk_point.html">SkPoint</a> of cubic on y-axis </td></tr>
    <tr><td class="paramname">x2</td><td>second control <a class="el" href="struct_sk_point.html">SkPoint</a> of cubic on x-axis </td></tr>
    <tr><td class="paramname">y2</td><td>second control <a class="el" href="struct_sk_point.html">SkPoint</a> of cubic on y-axis </td></tr>
    <tr><td class="paramname">x3</td><td>end <a class="el" href="struct_sk_point.html">SkPoint</a> of cubic on x-axis </td></tr>
    <tr><td class="paramname">y3</td><td>end <a class="el" href="struct_sk_point.html">SkPoint</a> of cubic on y-axis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="addb0662af45f3fd2cfb17380dd41a515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb0662af45f3fd2cfb17380dd41a515">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkPath::dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_w_stream.html">SkWStream</a> *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dumpAsHex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes text representation of <a class="el" href="class_sk_path.html">SkPath</a> to stream. If stream is nullptr, writes to standard output. Set dumpAsHex true to generate exact binary representations of floating point numbers used in <a class="el" href="struct_sk_point.html">SkPoint</a> array and conic weights.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>writable <a class="el" href="class_sk_w_stream.html">SkWStream</a> receiving <a class="el" href="class_sk_path.html">SkPath</a> text representation; may be nullptr </td></tr>
    <tr><td class="paramname">dumpAsHex</td><td>true if SkScalar values are written as hexadecimal</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_dump">https://fiddle.skia.org/c/@Path_dump</a> </p>

</div>
</div>
<a id="ac60188dc6075d6ebb56b5398fbba0c10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60188dc6075d6ebb56b5398fbba0c10">&#9670;&nbsp;</a></span>getBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_sk_rect.html">SkRect</a>&amp; SkPath::getBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns minimum and maximum axes values of <a class="el" href="struct_sk_point.html">SkPoint</a> array. Returns (0, 0, 0, 0) if <a class="el" href="class_sk_path.html">SkPath</a> contains no points. Returned bounds width and height may be larger or smaller than area affected when <a class="el" href="class_sk_path.html">SkPath</a> is drawn.</p>
<p><a class="el" href="struct_sk_rect.html">SkRect</a> returned includes all <a class="el" href="struct_sk_point.html">SkPoint</a> added to <a class="el" href="class_sk_path.html">SkPath</a>, including <a class="el" href="struct_sk_point.html">SkPoint</a> associated with kMove_Verb that define empty contours.</p>
<dl class="section return"><dt>Returns</dt><dd>bounds of all <a class="el" href="struct_sk_point.html">SkPoint</a> in <a class="el" href="struct_sk_point.html">SkPoint</a> array </dd></dl>

</div>
</div>
<a id="a382204722705384fb74b7abd3e5c3f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a382204722705384fb74b7abd3e5c3f95">&#9670;&nbsp;</a></span>getFillType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkPathFillType SkPath::getFillType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns SkPathFillType, the rule used to fill <a class="el" href="class_sk_path.html">SkPath</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>current SkPathFillType setting </dd></dl>

</div>
</div>
<a id="a07772c885789e0369c8b6817c93b6031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07772c885789e0369c8b6817c93b6031">&#9670;&nbsp;</a></span>getGenerationID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SkPath::getGenerationID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(See Skia bug 1762.) Returns a non-zero, globally unique value. A different value is returned if verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array, or conic weight changes.</p>
<p>Setting SkPath::FillType does not change generation identifier.</p>
<p>Each time the path is modified, a different generation identifier will be returned. SkPath::FillType does affect generation identifier on Android framework.</p>
<dl class="section return"><dt>Returns</dt><dd>non-zero, globally unique value</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_getGenerationID">https://fiddle.skia.org/c/@Path_getGenerationID</a> </p>

</div>
</div>
<a id="a3068074d7295495def2671c36ad83361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3068074d7295495def2671c36ad83361">&#9670;&nbsp;</a></span>getLastPt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::getLastPt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a> *&#160;</td>
          <td class="paramname"><em>lastPt</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns last point on <a class="el" href="class_sk_path.html">SkPath</a> in lastPt. Returns false if <a class="el" href="struct_sk_point.html">SkPoint</a> array is empty, storing (0, 0) if lastPt is not nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lastPt</td><td>storage for final <a class="el" href="struct_sk_point.html">SkPoint</a> in <a class="el" href="struct_sk_point.html">SkPoint</a> array; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="struct_sk_point.html">SkPoint</a> array contains one or more <a class="el" href="struct_sk_point.html">SkPoint</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_getLastPt">https://fiddle.skia.org/c/@Path_getLastPt</a> </p>

</div>
</div>
<a id="a28741ac1ee01f1f626b8537f327720c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28741ac1ee01f1f626b8537f327720c5">&#9670;&nbsp;</a></span>getPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_point.html">SkPoint</a> SkPath::getPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_point.html">SkPoint</a> at index in <a class="el" href="struct_sk_point.html">SkPoint</a> array. Valid range for index is 0 to <a class="el" href="class_sk_path.html#a18d1b347ac162821b37c26ff4ce75ba3">countPoints()</a> - 1. Returns (0, 0) if index is out of range.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td><a class="el" href="struct_sk_point.html">SkPoint</a> array element selector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_sk_point.html">SkPoint</a> array value or (0, 0)</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_getPoint">https://fiddle.skia.org/c/@Path_getPoint</a> </p>

</div>
</div>
<a id="a3a5540ce3ec6f55b99e154a743de5d6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a5540ce3ec6f55b99e154a743de5d6b">&#9670;&nbsp;</a></span>getPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SkPath::getPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>points</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns number of points in <a class="el" href="class_sk_path.html">SkPath</a>. Up to max points are copied. points may be nullptr; then, max must be zero. If max is greater than number of points, excess points storage is unaltered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>storage for <a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> array. May be nullptr </td></tr>
    <tr><td class="paramname">max</td><td>maximum to copy; must be greater than or equal to zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> array length</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_getPoints">https://fiddle.skia.org/c/@Path_getPoints</a> </p>

</div>
</div>
<a id="aac8e4461582ac723a866a4fe27031181"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8e4461582ac723a866a4fe27031181">&#9670;&nbsp;</a></span>getSegmentMasks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SkPath::getSegmentMasks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a mask, where each set bit corresponds to a SegmentMask constant if <a class="el" href="class_sk_path.html">SkPath</a> contains one or more verbs of that type. Returns zero if <a class="el" href="class_sk_path.html">SkPath</a> contains no lines, or curves: quads, conics, or cubics.</p>
<p><a class="el" href="class_sk_path.html#aac8e4461582ac723a866a4fe27031181">getSegmentMasks()</a> returns a cached result; it is very fast.</p>
<dl class="section return"><dt>Returns</dt><dd>SegmentMask bits or zero </dd></dl>

</div>
</div>
<a id="a94bc5e41461af1093d62e7bb4fba012e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bc5e41461af1093d62e7bb4fba012e">&#9670;&nbsp;</a></span>getVerbs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SkPath::getVerbs </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>verbs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of verbs in the path. Up to max verbs are copied. The verbs are copied as one byte per verb.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">verbs</td><td>storage for verbs, may be nullptr </td></tr>
    <tr><td class="paramname">max</td><td>maximum number to copy into verbs </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the actual number of verbs in the path</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_getVerbs">https://fiddle.skia.org/c/@Path_getVerbs</a> </p>

</div>
</div>
<a id="a2efb0417f01be1c29e2ba9c173a1977c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2efb0417f01be1c29e2ba9c173a1977c">&#9670;&nbsp;</a></span>incReserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkPath::incReserve </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extraPtCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Grows <a class="el" href="class_sk_path.html">SkPath</a> verb array and <a class="el" href="struct_sk_point.html">SkPoint</a> array to contain extraPtCount additional <a class="el" href="struct_sk_point.html">SkPoint</a>. May improve performance and use less memory by reducing the number and size of allocations when creating <a class="el" href="class_sk_path.html">SkPath</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extraPtCount</td><td>number of additional <a class="el" href="struct_sk_point.html">SkPoint</a> to allocate</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_incReserve">https://fiddle.skia.org/c/@Path_incReserve</a> </p>

</div>
</div>
<a id="a79332188cf437c46f294e77da89920b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79332188cf437c46f294e77da89920b5">&#9670;&nbsp;</a></span>interpolate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>ending</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>weight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_path.html">SkPath</a> *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpolates between <a class="el" href="class_sk_path.html">SkPath</a> with <a class="el" href="struct_sk_point.html">SkPoint</a> array of equal size. Copy verb array and weights to out, and set out <a class="el" href="struct_sk_point.html">SkPoint</a> array to a weighted average of this <a class="el" href="struct_sk_point.html">SkPoint</a> array and ending <a class="el" href="struct_sk_point.html">SkPoint</a> array, using the formula: (Path Point * weight) + ending Point * (1 - weight).</p>
<p>weight is most useful when between zero (ending <a class="el" href="struct_sk_point.html">SkPoint</a> array) and one (this Point_Array); will work with values outside of this range.</p>
<p><a class="el" href="class_sk_path.html#a79332188cf437c46f294e77da89920b5">interpolate()</a> returns false and leaves out unchanged if <a class="el" href="struct_sk_point.html">SkPoint</a> array is not the same size as ending <a class="el" href="struct_sk_point.html">SkPoint</a> array. Call <a class="el" href="class_sk_path.html#a78f7eed7de33a798a9859ab16e335fde">isInterpolatable()</a> to check <a class="el" href="class_sk_path.html">SkPath</a> compatibility prior to calling <a class="el" href="class_sk_path.html#a79332188cf437c46f294e77da89920b5">interpolate()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ending</td><td><a class="el" href="struct_sk_point.html">SkPoint</a> array averaged with this <a class="el" href="struct_sk_point.html">SkPoint</a> array </td></tr>
    <tr><td class="paramname">weight</td><td>contribution of this <a class="el" href="struct_sk_point.html">SkPoint</a> array, and one minus contribution of ending <a class="el" href="struct_sk_point.html">SkPoint</a> array </td></tr>
    <tr><td class="paramname">out</td><td><a class="el" href="class_sk_path.html">SkPath</a> replaced by interpolated averages </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_path.html">SkPath</a> contain same number of <a class="el" href="struct_sk_point.html">SkPoint</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_interpolate">https://fiddle.skia.org/c/@Path_interpolate</a> </p>

</div>
</div>
<a id="aa20544ae11a0b20b09565274ca4da740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20544ae11a0b20b09565274ca4da740">&#9670;&nbsp;</a></span>isConvex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::isConvex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the path is convex. If necessary, it will first compute the convexity. </p>

</div>
</div>
<a id="a46110bc288d9416e58dc216a5a475ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46110bc288d9416e58dc216a5a475ebd">&#9670;&nbsp;</a></span>IsCubicDegenerate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::IsCubicDegenerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tests if cubic is degenerate. Cubic with no length or that moves a very short distance is degenerate; it is treated as a point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>cubic start point </td></tr>
    <tr><td class="paramname">p2</td><td>cubic control point 1 </td></tr>
    <tr><td class="paramname">p3</td><td>cubic control point 2 </td></tr>
    <tr><td class="paramname">p4</td><td>cubic end point </td></tr>
    <tr><td class="paramname">exact</td><td>if true, returns true only if p1, p2, p3, and p4 are equal; if false, returns true if p1, p2, p3, and p4 are equal or nearly equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if cubic is degenerate; its length is effectively zero </dd></dl>

</div>
</div>
<a id="a0289c6eed642e4d74c95fda08b0df63a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0289c6eed642e4d74c95fda08b0df63a">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns if <a class="el" href="class_sk_path.html">SkPath</a> is empty. Empty <a class="el" href="class_sk_path.html">SkPath</a> may have FillType but has no <a class="el" href="struct_sk_point.html">SkPoint</a>, SkPath::Verb, or conic weight. <a class="el" href="class_sk_path.html#a19453a0e80054e1cbdd389d31654bcc6">SkPath()</a> constructs empty <a class="el" href="class_sk_path.html">SkPath</a>; <a class="el" href="class_sk_path.html#a977497439155df168c935114be1fa148">reset()</a> and <a class="el" href="class_sk_path.html#a704fc5e57bfbadd6a7560291fc7fc1fa">rewind()</a> make <a class="el" href="class_sk_path.html">SkPath</a> empty.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the path contains no SkPath::Verb array </dd></dl>

</div>
</div>
<a id="a244a91414b71bf2192825098b0216233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244a91414b71bf2192825098b0216233">&#9670;&nbsp;</a></span>isFinite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::isFinite </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true for finite <a class="el" href="struct_sk_point.html">SkPoint</a> array values between negative SK_ScalarMax and positive SK_ScalarMax. Returns false for any <a class="el" href="struct_sk_point.html">SkPoint</a> array value of SK_ScalarInfinity, SK_ScalarNegativeInfinity, or SK_ScalarNaN.</p>
<dl class="section return"><dt>Returns</dt><dd>true if all <a class="el" href="struct_sk_point.html">SkPoint</a> values are finite </dd></dl>

</div>
</div>
<a id="a78f7eed7de33a798a9859ab16e335fde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f7eed7de33a798a9859ab16e335fde">&#9670;&nbsp;</a></span>isInterpolatable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::isInterpolatable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>compare</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="class_sk_path.html">SkPath</a> contain equal verbs and equal weights. If <a class="el" href="class_sk_path.html">SkPath</a> contain one or more conics, the weights must match.</p>
<p><a class="el" href="class_sk_path.html#ac8a605100b42d1192e8badc827ccd0b5">conicTo()</a> may add different verbs depending on conic weight, so it is not trivial to interpolate a pair of <a class="el" href="class_sk_path.html">SkPath</a> containing conics with different conic weight values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">compare</td><td><a class="el" href="class_sk_path.html">SkPath</a> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_path.html">SkPath</a> verb array and weights are equivalent</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_isInterpolatable">https://fiddle.skia.org/c/@Path_isInterpolatable</a> </p>

</div>
</div>
<a id="a06b2fe32125d776c2274da5e735eb588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b2fe32125d776c2274da5e735eb588">&#9670;&nbsp;</a></span>isInverseFillType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::isInverseFillType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns if FillType describes area outside <a class="el" href="class_sk_path.html">SkPath</a> geometry. The inverse fill area extends indefinitely.</p>
<dl class="section return"><dt>Returns</dt><dd>true if FillType is kInverseWinding or kInverseEvenOdd </dd></dl>

</div>
</div>
<a id="ac88bb37821fd59e93954de3c3d7ed9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88bb37821fd59e93954de3c3d7ed9a9">&#9670;&nbsp;</a></span>isLastContourClosed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::isLastContourClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns if contour is closed. Contour is closed if <a class="el" href="class_sk_path.html">SkPath</a> SkPath::Verb array was last modified by <a class="el" href="class_sk_path.html#ad2c03218bb3887585e28116684172c17">close()</a>. When stroked, closed contour draws <a class="el" href="class_sk_paint.html#ac582b0cbf59909c9056de34a6b977cca">SkPaint::Join</a> instead of <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333">SkPaint::Cap</a> at first and last <a class="el" href="struct_sk_point.html">SkPoint</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the last contour ends with a kClose_Verb</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_isLastContourClosed">https://fiddle.skia.org/c/@Path_isLastContourClosed</a> </p>

</div>
</div>
<a id="a2b79cc08d313b8e5f3f6b98281a9fd4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b79cc08d313b8e5f3f6b98281a9fd4e">&#9670;&nbsp;</a></span>isLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::isLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>line</em>[2]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="class_sk_path.html">SkPath</a> contains only one line; SkPath::Verb array has two entries: kMove_Verb, kLine_Verb. If <a class="el" href="class_sk_path.html">SkPath</a> contains one line and line is not nullptr, line is set to line start point and line end point. Returns false if <a class="el" href="class_sk_path.html">SkPath</a> is not one line; line is unaltered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">line</td><td>storage for line. May be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_path.html">SkPath</a> contains exactly one line</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_isLine">https://fiddle.skia.org/c/@Path_isLine</a> </p>

</div>
</div>
<a id="a0d3dcaa99b0e0701944e2d5d6f45113a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3dcaa99b0e0701944e2d5d6f45113a">&#9670;&nbsp;</a></span>IsLineDegenerate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::IsLineDegenerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tests if line between <a class="el" href="struct_sk_point.html">SkPoint</a> pair is degenerate. Line with no length or that moves a very short distance is degenerate; it is treated as a point.</p>
<p>exact changes the equality test. If true, returns true only if p1 equals p2. If false, returns true if p1 equals or nearly equals p2.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>line start point </td></tr>
    <tr><td class="paramname">p2</td><td>line end point </td></tr>
    <tr><td class="paramname">exact</td><td>if false, allow nearly equals </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if line is degenerate; its length is effectively zero</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_IsLineDegenerate">https://fiddle.skia.org/c/@Path_IsLineDegenerate</a> </p>

</div>
</div>
<a id="a88cab201b805a4210074a632fab3e21c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cab201b805a4210074a632fab3e21c">&#9670;&nbsp;</a></span>isOval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::isOval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_rect.html">SkRect</a> *&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this path is recognized as an oval or circle.</p>
<p>bounds receives bounds of oval.</p>
<p>bounds is unmodified if oval is not found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounds</td><td>storage for bounding <a class="el" href="struct_sk_rect.html">SkRect</a> of oval; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_path.html">SkPath</a> is recognized as an oval or circle</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_isOval">https://fiddle.skia.org/c/@Path_isOval</a> </p>

</div>
</div>
<a id="a35bcc5d4d51e3f124e77d43093a49837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bcc5d4d51e3f124e77d43093a49837">&#9670;&nbsp;</a></span>IsQuadDegenerate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::IsQuadDegenerate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exact</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tests if quad is degenerate. Quad with no length or that moves a very short distance is degenerate; it is treated as a point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>quad start point </td></tr>
    <tr><td class="paramname">p2</td><td>quad control point </td></tr>
    <tr><td class="paramname">p3</td><td>quad end point </td></tr>
    <tr><td class="paramname">exact</td><td>if true, returns true only if p1, p2, and p3 are equal; if false, returns true if p1, p2, and p3 are equal or nearly equal </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if quad is degenerate; its length is effectively zero </dd></dl>

</div>
</div>
<a id="ad6086fc1a35ef838b38f8730ae534762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6086fc1a35ef838b38f8730ae534762">&#9670;&nbsp;</a></span>isRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::isRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_rect.html">SkRect</a> *&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isClosed</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkPathDirection *&#160;</td>
          <td class="paramname"><em>direction</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="class_sk_path.html">SkPath</a> is equivalent to <a class="el" href="struct_sk_rect.html">SkRect</a> when filled. If false: rect, isClosed, and direction are unchanged. If true: rect, isClosed, and direction are written to if not nullptr.</p>
<p>rect may be smaller than the <a class="el" href="class_sk_path.html">SkPath</a> bounds. <a class="el" href="class_sk_path.html">SkPath</a> bounds may include kMove_Verb points that do not alter the area drawn by the returned rect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>storage for bounds of <a class="el" href="struct_sk_rect.html">SkRect</a>; may be nullptr </td></tr>
    <tr><td class="paramname">isClosed</td><td>storage set to true if <a class="el" href="class_sk_path.html">SkPath</a> is closed; may be nullptr </td></tr>
    <tr><td class="paramname">direction</td><td>storage set to <a class="el" href="struct_sk_rect.html">SkRect</a> direction; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_path.html">SkPath</a> contains <a class="el" href="struct_sk_rect.html">SkRect</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_isRect">https://fiddle.skia.org/c/@Path_isRect</a> </p>

</div>
</div>
<a id="ae8cac7a51ebe9607dbc1b3ddde5a4e5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8cac7a51ebe9607dbc1b3ddde5a4e5f">&#9670;&nbsp;</a></span>isRRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::isRRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_r_rect.html">SkRRect</a> *&#160;</td>
          <td class="paramname"><em>rrect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if path is representable as <a class="el" href="class_sk_r_rect.html">SkRRect</a>. Returns false if path is representable as oval, circle, or <a class="el" href="struct_sk_rect.html">SkRect</a>.</p>
<p>rrect receives bounds of <a class="el" href="class_sk_r_rect.html">SkRRect</a>.</p>
<p>rrect is unmodified if <a class="el" href="class_sk_r_rect.html">SkRRect</a> is not found.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rrect</td><td>storage for bounding <a class="el" href="struct_sk_rect.html">SkRect</a> of <a class="el" href="class_sk_r_rect.html">SkRRect</a>; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_path.html">SkPath</a> contains only <a class="el" href="class_sk_r_rect.html">SkRRect</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_isRRect">https://fiddle.skia.org/c/@Path_isRRect</a> </p>

</div>
</div>
<a id="ad39cea91b553eec0446c1b62475612e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39cea91b553eec0446c1b62475612e3">&#9670;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns if <a class="el" href="class_sk_path.html">SkPath</a> data is consistent. Corrupt <a class="el" href="class_sk_path.html">SkPath</a> data is detected if internal values are out of range or internal storage does not match array dimensions.</p>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_path.html">SkPath</a> data is consistent </dd></dl>

</div>
</div>
<a id="a6e82bf8ec4993ced919ddc1e54a8e07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e82bf8ec4993ced919ddc1e54a8e07c">&#9670;&nbsp;</a></span>isVolatile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkPath::isVolatile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if the path is volatile; it will not be altered or discarded by the caller after it is drawn. <a class="el" href="class_sk_path.html">SkPath</a> by default have volatile set false, allowing <a class="el" href="class_sk_surface.html">SkSurface</a> to attach a cache of data which speeds repeated drawing. If true, <a class="el" href="class_sk_surface.html">SkSurface</a> may not speed repeated drawing.</p>
<dl class="section return"><dt>Returns</dt><dd>true if caller will alter <a class="el" href="class_sk_path.html">SkPath</a> after drawing </dd></dl>

</div>
</div>
<a id="a27c6505cd16db954d6f0268e2de5d87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c6505cd16db954d6f0268e2de5d87f">&#9670;&nbsp;</a></span>lineTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a>&amp; SkPath::lineTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds line from last point to <a class="el" href="struct_sk_point.html">SkPoint</a> p. If <a class="el" href="class_sk_path.html">SkPath</a> is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0) before adding line.</p>
<p><a class="el" href="class_sk_path.html#a457f1f4f0d45339c6eb2d2ca15610a84">lineTo()</a> first appends kMove_Verb to verb array and (0, 0) to <a class="el" href="struct_sk_point.html">SkPoint</a> array, if needed. <a class="el" href="class_sk_path.html#a457f1f4f0d45339c6eb2d2ca15610a84">lineTo()</a> then appends kLine_Verb to verb array and <a class="el" href="struct_sk_point.html">SkPoint</a> p to <a class="el" href="struct_sk_point.html">SkPoint</a> array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>end <a class="el" href="struct_sk_point.html">SkPoint</a> of added line </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a457f1f4f0d45339c6eb2d2ca15610a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457f1f4f0d45339c6eb2d2ca15610a84">&#9670;&nbsp;</a></span>lineTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::lineTo </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds line from last point to (x, y). If <a class="el" href="class_sk_path.html">SkPath</a> is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0) before adding line.</p>
<p><a class="el" href="class_sk_path.html#a457f1f4f0d45339c6eb2d2ca15610a84">lineTo()</a> appends kMove_Verb to verb array and (0, 0) to <a class="el" href="struct_sk_point.html">SkPoint</a> array, if needed. <a class="el" href="class_sk_path.html#a457f1f4f0d45339c6eb2d2ca15610a84">lineTo()</a> then appends kLine_Verb to verb array and (x, y) to <a class="el" href="struct_sk_point.html">SkPoint</a> array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>end of added line on x-axis </td></tr>
    <tr><td class="paramname">y</td><td>end of added line on y-axis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_lineTo">https://fiddle.skia.org/c/@Path_lineTo</a> </p>

</div>
</div>
<a id="a86b3be3b522fc2b36044e4cb9c43e59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b3be3b522fc2b36044e4cb9c43e59f">&#9670;&nbsp;</a></span>Make()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> SkPath::Make </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>pts</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pointCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>vbs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SkScalar&#160;</td>
          <td class="paramname"><em>ws</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>conicWeightCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkPathFillType&#160;</td>
          <td class="paramname"><em>ft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVolatile</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new path with the specified segments.</p>
<p>The points and weights arrays are read in order, based on the sequence of verbs.</p>
<p>Move 1 point Line 1 point Quad 2 points Conic 2 points and 1 weight Cubic 3 points Close 0 points</p>
<p>If an illegal sequence of verbs is encountered, or the specified number of points or weights is not sufficient given the verbs, an empty Path is returned.</p>
<p>A legal sequence of verbs consists of any number of Contours. A contour always begins with a Move verb, followed by 0 or more segments: Line, Quad, Conic, Cubic, followed by an optional Close. </p>

</div>
</div>
<a id="a85ad85fdec8bb0d4c39d46c45f2d9581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85ad85fdec8bb0d4c39d46c45f2d9581">&#9670;&nbsp;</a></span>moveTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a>&amp; SkPath::moveTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds beginning of contour at <a class="el" href="struct_sk_point.html">SkPoint</a> p.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>contour start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a28dc5683b9a3e75ad55393cd233e8341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28dc5683b9a3e75ad55393cd233e8341">&#9670;&nbsp;</a></span>moveTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::moveTo </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds beginning of contour at <a class="el" href="struct_sk_point.html">SkPoint</a> (x, y).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>x-axis value of contour start </td></tr>
    <tr><td class="paramname">y</td><td>y-axis value of contour start </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_moveTo">https://fiddle.skia.org/c/@Path_moveTo</a> </p>

</div>
</div>
<a id="a62a6ccd0f6608a0decb3af050d81da21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a6ccd0f6608a0decb3af050d81da21">&#9670;&nbsp;</a></span>offset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkPath::offset </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Offsets <a class="el" href="struct_sk_point.html">SkPoint</a> array by (dx, dy). <a class="el" href="class_sk_path.html">SkPath</a> is replaced by offset data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>offset added to <a class="el" href="struct_sk_point.html">SkPoint</a> array x-axis coordinates </td></tr>
    <tr><td class="paramname">dy</td><td>offset added to <a class="el" href="struct_sk_point.html">SkPoint</a> array y-axis coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b4a9414537a0df5e2354d521d8cf6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4a9414537a0df5e2354d521d8cf6aa">&#9670;&nbsp;</a></span>offset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkPath::offset </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_path.html">SkPath</a> *&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Offsets <a class="el" href="struct_sk_point.html">SkPoint</a> array by (dx, dy). Offset <a class="el" href="class_sk_path.html">SkPath</a> replaces dst. If dst is nullptr, <a class="el" href="class_sk_path.html">SkPath</a> is replaced by offset data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>offset added to <a class="el" href="struct_sk_point.html">SkPoint</a> array x-axis coordinates </td></tr>
    <tr><td class="paramname">dy</td><td>offset added to <a class="el" href="struct_sk_point.html">SkPoint</a> array y-axis coordinates </td></tr>
    <tr><td class="paramname">dst</td><td>overwritten, translated copy of <a class="el" href="class_sk_path.html">SkPath</a>; may be nullptr</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_offset">https://fiddle.skia.org/c/@Path_offset</a> </p>

</div>
</div>
<a id="a24e75e150a765d304e8d0c3d087ddc94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e75e150a765d304e8d0c3d087ddc94">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a copy of an existing path. <a class="el" href="class_sk_path.html">SkPath</a> assignment makes two paths identical by value. Internally, assignment shares pointer values. The underlying verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array and weights are copied when modified.</p>
<p>Copying <a class="el" href="class_sk_path.html">SkPath</a> by assignment is very efficient and never allocates memory. <a class="el" href="class_sk_path.html">SkPath</a> are always copied by value from the interface; the underlying shared pointers are not exposed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array, weights, and SkPath::FillType to copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_path.html">SkPath</a> copied by value</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_copy_operator">https://fiddle.skia.org/c/@Path_copy_operator</a> </p>

</div>
</div>
<a id="a95f346ea768b989b355f7922594f0399"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95f346ea768b989b355f7922594f0399">&#9670;&nbsp;</a></span>quadTo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a>&amp; SkPath::quadTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds quad from last point towards <a class="el" href="struct_sk_point.html">SkPoint</a> p1, to <a class="el" href="struct_sk_point.html">SkPoint</a> p2. If <a class="el" href="class_sk_path.html">SkPath</a> is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0) before adding quad.</p>
<p>Appends kMove_Verb to verb array and (0, 0) to <a class="el" href="struct_sk_point.html">SkPoint</a> array, if needed; then appends kQuad_Verb to verb array; and <a class="el" href="struct_sk_point.html">SkPoint</a> p1, p2 to <a class="el" href="struct_sk_point.html">SkPoint</a> array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>control <a class="el" href="struct_sk_point.html">SkPoint</a> of added quad </td></tr>
    <tr><td class="paramname">p2</td><td>end <a class="el" href="struct_sk_point.html">SkPoint</a> of added quad </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a9d554f5ea596598762ba7c903029bc2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d554f5ea596598762ba7c903029bc2d">&#9670;&nbsp;</a></span>quadTo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::quadTo </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds quad from last point towards (x1, y1), to (x2, y2). If <a class="el" href="class_sk_path.html">SkPath</a> is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0) before adding quad.</p>
<p>Appends kMove_Verb to verb array and (0, 0) to <a class="el" href="struct_sk_point.html">SkPoint</a> array, if needed; then appends kQuad_Verb to verb array; and (x1, y1), (x2, y2) to <a class="el" href="struct_sk_point.html">SkPoint</a> array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>control <a class="el" href="struct_sk_point.html">SkPoint</a> of quad on x-axis </td></tr>
    <tr><td class="paramname">y1</td><td>control <a class="el" href="struct_sk_point.html">SkPoint</a> of quad on y-axis </td></tr>
    <tr><td class="paramname">x2</td><td>end <a class="el" href="struct_sk_point.html">SkPoint</a> of quad on x-axis </td></tr>
    <tr><td class="paramname">y2</td><td>end <a class="el" href="struct_sk_point.html">SkPoint</a> of quad on y-axis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_quadTo">https://fiddle.skia.org/c/@Path_quadTo</a> </p>

</div>
</div>
<a id="a020cba27507f10809a57b8f26a0af35c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020cba27507f10809a57b8f26a0af35c">&#9670;&nbsp;</a></span>rArcTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::rArcTo </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>rx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>ry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>xAxisRotate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_path.html#a968e6248ebe0a13e74c28e432ca59125">SkPath::ArcSize</a>&#160;</td>
          <td class="paramname"><em>largeArc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkPathDirection&#160;</td>
          <td class="paramname"><em>sweep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends arc to <a class="el" href="class_sk_path.html">SkPath</a>, relative to last <a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a>. Arc is implemented by one or more conic, weighted to describe part of oval with radii (rx, ry) rotated by xAxisRotate degrees. Arc curves from last <a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> to relative end <a class="el" href="struct_sk_point.html">SkPoint</a>: (dx, dy), choosing one of four possible routes: clockwise or counterclockwise, and smaller or larger. If <a class="el" href="class_sk_path.html">SkPath</a> is empty, the start arc <a class="el" href="struct_sk_point.html">SkPoint</a> is (0, 0).</p>
<p>Arc sweep is always less than 360 degrees. <a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> appends line to end <a class="el" href="struct_sk_point.html">SkPoint</a> if either radii are zero, or if last <a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> equals end <a class="el" href="struct_sk_point.html">SkPoint</a>. <a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> scales radii (rx, ry) to fit last <a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> and end <a class="el" href="struct_sk_point.html">SkPoint</a> if both are greater than zero but too small to describe an arc.</p>
<p><a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> appends up to four conic curves. <a class="el" href="class_sk_path.html#a22ec2323a5b6e45bf7f2420384f535e6">arcTo()</a> implements the functionality of svg arc, although SVG "sweep-flag" value is opposite the integer value of sweep; SVG "sweep-flag" uses 1 for clockwise, while kCW_Direction cast to int is zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rx</td><td>radius before x-axis rotation </td></tr>
    <tr><td class="paramname">ry</td><td>radius before x-axis rotation </td></tr>
    <tr><td class="paramname">xAxisRotate</td><td>x-axis rotation in degrees; positive values are clockwise </td></tr>
    <tr><td class="paramname">largeArc</td><td>chooses smaller or larger arc </td></tr>
    <tr><td class="paramname">sweep</td><td>chooses clockwise or counterclockwise arc </td></tr>
    <tr><td class="paramname">dx</td><td>x-axis offset end of arc from last <a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> </td></tr>
    <tr><td class="paramname">dy</td><td>y-axis offset end of arc from last <a class="el" href="class_sk_path.html">SkPath</a> <a class="el" href="struct_sk_point.html">SkPoint</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a233092825009d8da04c52b2f62527b03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a233092825009d8da04c52b2f62527b03">&#9670;&nbsp;</a></span>rConicTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::rConicTo </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds conic from last point towards vector (dx1, dy1), to vector (dx2, dy2), weighted by w. If <a class="el" href="class_sk_path.html">SkPath</a> is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0) before adding conic.</p>
<p>Appends kMove_Verb to verb array and (0, 0) to <a class="el" href="struct_sk_point.html">SkPoint</a> array, if needed.</p>
<p>If w is finite and not one, next appends kConic_Verb to verb array, and w is recorded as conic weight; otherwise, if w is one, appends kQuad_Verb to verb array; or if w is not finite, appends kLine_Verb twice to verb array.</p>
<p>In all cases appends <a class="el" href="struct_sk_point.html">SkPoint</a> control and end to <a class="el" href="struct_sk_point.html">SkPoint</a> array. control is last point plus vector (dx1, dy1). end is last point plus vector (dx2, dy2).</p>
<p>Function name stands for "relative conic to".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx1</td><td>offset from last point to conic control on x-axis </td></tr>
    <tr><td class="paramname">dy1</td><td>offset from last point to conic control on y-axis </td></tr>
    <tr><td class="paramname">dx2</td><td>offset from last point to conic end on x-axis </td></tr>
    <tr><td class="paramname">dy2</td><td>offset from last point to conic end on y-axis </td></tr>
    <tr><td class="paramname">w</td><td>weight of added conic </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a4c3b1374fd88e0986ddaea3f3b0379db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3b1374fd88e0986ddaea3f3b0379db">&#9670;&nbsp;</a></span>rCubicTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::rCubicTo </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds cubic from last point towards vector (dx1, dy1), then towards vector (dx2, dy2), to vector (dx3, dy3). If <a class="el" href="class_sk_path.html">SkPath</a> is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0) before adding cubic.</p>
<p>Appends kMove_Verb to verb array and (0, 0) to <a class="el" href="struct_sk_point.html">SkPoint</a> array, if needed; then appends kCubic_Verb to verb array; and appends cubic control and cubic end to <a class="el" href="struct_sk_point.html">SkPoint</a> array. Cubic control is last point plus vector (dx1, dy1). Cubic end is last point plus vector (dx2, dy2). Function name stands for "relative cubic to".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx1</td><td>offset from last point to first cubic control on x-axis </td></tr>
    <tr><td class="paramname">dy1</td><td>offset from last point to first cubic control on y-axis </td></tr>
    <tr><td class="paramname">dx2</td><td>offset from last point to second cubic control on x-axis </td></tr>
    <tr><td class="paramname">dy2</td><td>offset from last point to second cubic control on y-axis </td></tr>
    <tr><td class="paramname">dx3</td><td>offset from last point to cubic end on x-axis </td></tr>
    <tr><td class="paramname">dy3</td><td>offset from last point to cubic end on y-axis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a02f6fe6f7f3caf7212ed37b0d2712da2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f6fe6f7f3caf7212ed37b0d2712da2">&#9670;&nbsp;</a></span>readFromMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SkPath::readFromMemory </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes <a class="el" href="class_sk_path.html">SkPath</a> from buffer of size length. Returns zero if the buffer is data is inconsistent, or the length is too small.</p>
<p>Reads SkPath::FillType, verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array, conic weight, and additionally reads computed information like SkPath::Convexity and bounds.</p>
<p>Used only in concert with <a class="el" href="class_sk_path.html#ab34720f80c02d5854cc6b09675b5d907">writeToMemory()</a>; the format used for <a class="el" href="class_sk_path.html">SkPath</a> in memory is not guaranteed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>storage for <a class="el" href="class_sk_path.html">SkPath</a> </td></tr>
    <tr><td class="paramname">length</td><td>buffer size in bytes; must be multiple of 4 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read, or zero on failure</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_readFromMemory">https://fiddle.skia.org/c/@Path_readFromMemory</a> </p>

</div>
</div>
<a id="a977497439155df168c935114be1fa148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977497439155df168c935114be1fa148">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_path.html">SkPath</a> to its initial state. Removes verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array, and weights, and sets FillType to kWinding. Internal storage associated with <a class="el" href="class_sk_path.html">SkPath</a> is released.</p>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_reset">https://fiddle.skia.org/c/@Path_reset</a> </p>

</div>
</div>
<a id="a070aab0bed84e1137a186cef1f10192f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070aab0bed84e1137a186cef1f10192f">&#9670;&nbsp;</a></span>reverseAddPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::reverseAddPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends src to <a class="el" href="class_sk_path.html">SkPath</a>, from back to front. Reversed src always appends a new contour to <a class="el" href="class_sk_path.html">SkPath</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td><a class="el" href="class_sk_path.html">SkPath</a> verbs, <a class="el" href="struct_sk_point.html">SkPoint</a>, and conic weights to add </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_reverseAddPath">https://fiddle.skia.org/c/@Path_reverseAddPath</a> </p>

</div>
</div>
<a id="a704fc5e57bfbadd6a7560291fc7fc1fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704fc5e57bfbadd6a7560291fc7fc1fa">&#9670;&nbsp;</a></span>rewind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::rewind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_path.html">SkPath</a> to its initial state, preserving internal storage. Removes verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array, and weights, and sets FillType to kWinding. Internal storage associated with <a class="el" href="class_sk_path.html">SkPath</a> is retained.</p>
<p>Use <a class="el" href="class_sk_path.html#a704fc5e57bfbadd6a7560291fc7fc1fa">rewind()</a> instead of <a class="el" href="class_sk_path.html#a977497439155df168c935114be1fa148">reset()</a> if <a class="el" href="class_sk_path.html">SkPath</a> storage will be reused and performance is critical.</p>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_rewind">https://fiddle.skia.org/c/@Path_rewind</a> </p>

</div>
</div>
<a id="af44de3514295effc0d1319d419b5a745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af44de3514295effc0d1319d419b5a745">&#9670;&nbsp;</a></span>rLineTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::rLineTo </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds line from last point to vector (dx, dy). If <a class="el" href="class_sk_path.html">SkPath</a> is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0) before adding line.</p>
<p>Appends kMove_Verb to verb array and (0, 0) to <a class="el" href="struct_sk_point.html">SkPoint</a> array, if needed; then appends kLine_Verb to verb array and line end to <a class="el" href="struct_sk_point.html">SkPoint</a> array. Line end is last point plus vector (dx, dy). Function name stands for "relative line to".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>offset from last point to line end on x-axis </td></tr>
    <tr><td class="paramname">dy</td><td>offset from last point to line end on y-axis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_rLineTo">https://fiddle.skia.org/c/@Path_rLineTo</a> example: <a href="https://fiddle.skia.org/c/@Quad_a">https://fiddle.skia.org/c/@Quad_a</a> example: <a href="https://fiddle.skia.org/c/@Quad_b">https://fiddle.skia.org/c/@Quad_b</a> </p>

</div>
</div>
<a id="a7923238a1ebf57f75020d0439744e434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7923238a1ebf57f75020d0439744e434">&#9670;&nbsp;</a></span>rMoveTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::rMoveTo </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds beginning of contour relative to last point. If <a class="el" href="class_sk_path.html">SkPath</a> is empty, starts contour at (dx, dy). Otherwise, start contour at last point offset by (dx, dy). Function name stands for "relative move to".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>offset from last point to contour start on x-axis </td></tr>
    <tr><td class="paramname">dy</td><td>offset from last point to contour start on y-axis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_rMoveTo">https://fiddle.skia.org/c/@Path_rMoveTo</a> </p>

</div>
</div>
<a id="acd57395bc59b3e2350490ddfe5cf8cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd57395bc59b3e2350490ddfe5cf8cc8">&#9670;&nbsp;</a></span>rQuadTo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a> &amp; SkPath::rQuadTo </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds quad from last point towards vector (dx1, dy1), to vector (dx2, dy2). If <a class="el" href="class_sk_path.html">SkPath</a> is empty, or last SkPath::Verb is kClose_Verb, last point is set to (0, 0) before adding quad.</p>
<p>Appends kMove_Verb to verb array and (0, 0) to <a class="el" href="struct_sk_point.html">SkPoint</a> array, if needed; then appends kQuad_Verb to verb array; and appends quad control and quad end to <a class="el" href="struct_sk_point.html">SkPoint</a> array. Quad control is last point plus vector (dx1, dy1). Quad end is last point plus vector (dx2, dy2). Function name stands for "relative quad to".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx1</td><td>offset from last point to quad control on x-axis </td></tr>
    <tr><td class="paramname">dy1</td><td>offset from last point to quad control on y-axis </td></tr>
    <tr><td class="paramname">dx2</td><td>offset from last point to quad end on x-axis </td></tr>
    <tr><td class="paramname">dy2</td><td>offset from last point to quad end on y-axis </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Conic_Weight_a">https://fiddle.skia.org/c/@Conic_Weight_a</a> example: <a href="https://fiddle.skia.org/c/@Conic_Weight_b">https://fiddle.skia.org/c/@Conic_Weight_b</a> example: <a href="https://fiddle.skia.org/c/@Conic_Weight_c">https://fiddle.skia.org/c/@Conic_Weight_c</a> example: <a href="https://fiddle.skia.org/c/@Path_rQuadTo">https://fiddle.skia.org/c/@Path_rQuadTo</a> </p>

</div>
</div>
<a id="aac8586ce1afff7e7f41e1e7bac0b418b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8586ce1afff7e7f41e1e7bac0b418b">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt; SkPath::serialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes <a class="el" href="class_sk_path.html">SkPath</a> to buffer, returning the buffer written to, wrapped in <a class="el" href="class_sk_data.html">SkData</a>.</p>
<p><a class="el" href="class_sk_path.html#aac8586ce1afff7e7f41e1e7bac0b418b">serialize()</a> writes SkPath::FillType, verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array, conic weight, and additionally writes computed information like SkPath::Convexity and bounds.</p>
<p><a class="el" href="class_sk_path.html#aac8586ce1afff7e7f41e1e7bac0b418b">serialize()</a> should only be used in concert with <a class="el" href="class_sk_path.html#a02f6fe6f7f3caf7212ed37b0d2712da2">readFromMemory()</a>. The format used for <a class="el" href="class_sk_path.html">SkPath</a> in memory is not guaranteed.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_path.html">SkPath</a> data wrapped in <a class="el" href="class_sk_data.html">SkData</a> buffer</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_serialize">https://fiddle.skia.org/c/@Path_serialize</a> </p>

</div>
</div>
<a id="a3a562e1a9037c6a4cf676febe8073176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a562e1a9037c6a4cf676febe8073176">&#9670;&nbsp;</a></span>setFillType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkPath::setFillType </td>
          <td>(</td>
          <td class="paramtype">SkPathFillType&#160;</td>
          <td class="paramname"><em>ft</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets FillType, the rule used to fill <a class="el" href="class_sk_path.html">SkPath</a>. While there is no check that ft is legal, values outside of FillType are not supported. </p>

</div>
</div>
<a id="a5734897ba1c06cd48cd4f8726d3a3af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5734897ba1c06cd48cd4f8726d3a3af6">&#9670;&nbsp;</a></span>setIsVolatile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_path.html">SkPath</a>&amp; SkPath::setIsVolatile </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isVolatile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specifies whether <a class="el" href="class_sk_path.html">SkPath</a> is volatile; whether it will be altered or discarded by the caller after it is drawn. <a class="el" href="class_sk_path.html">SkPath</a> by default have volatile set false, allowing <a class="el" href="class_sk_base_device.html">SkBaseDevice</a> to attach a cache of data which speeds repeated drawing.</p>
<p>Mark temporary paths, discarded or modified after use, as volatile to inform <a class="el" href="class_sk_base_device.html">SkBaseDevice</a> that the path need not be cached.</p>
<p>Mark animating <a class="el" href="class_sk_path.html">SkPath</a> volatile to improve performance. Mark unchanging <a class="el" href="class_sk_path.html">SkPath</a> non-volatile to improve repeated rendering.</p>
<p>raster surface <a class="el" href="class_sk_path.html">SkPath</a> draws are affected by volatile for some shadows. GPU surface <a class="el" href="class_sk_path.html">SkPath</a> draws are affected by volatile for some shadows and concave geometries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">isVolatile</td><td>true if caller will alter <a class="el" href="class_sk_path.html">SkPath</a> after drawing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to <a class="el" href="class_sk_path.html">SkPath</a> </dd></dl>

</div>
</div>
<a id="a829354d382186c11a95b2214b40d1685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829354d382186c11a95b2214b40d1685">&#9670;&nbsp;</a></span>setLastPt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkPath::setLastPt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the last point on the path. If <a class="el" href="struct_sk_point.html">SkPoint</a> array is empty, append kMove_Verb to verb array and append p to <a class="el" href="struct_sk_point.html">SkPoint</a> array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>set value of last point </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ce8d91669e01e7724c27a4d453516fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce8d91669e01e7724c27a4d453516fb">&#9670;&nbsp;</a></span>setLastPt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkPath::setLastPt </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets last point to (x, y). If <a class="el" href="struct_sk_point.html">SkPoint</a> array is empty, append kMove_Verb to verb array and append (x, y) to <a class="el" href="struct_sk_point.html">SkPoint</a> array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>set x-axis value of last point </td></tr>
    <tr><td class="paramname">y</td><td>set y-axis value of last point</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_setLastPt">https://fiddle.skia.org/c/@Path_setLastPt</a> </p>

</div>
</div>
<a id="ad4ded6edd025942b925cc9be8e54732c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ded6edd025942b925cc9be8e54732c">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkPath::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exchanges the verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array, weights, and SkPath::FillType with other. Cached state is also exchanged. <a class="el" href="class_sk_path.html#ad4ded6edd025942b925cc9be8e54732c">swap()</a> internally exchanges pointers, so it is lightweight and does not allocate memory.</p>
<p><a class="el" href="class_sk_path.html#ad4ded6edd025942b925cc9be8e54732c">swap()</a> usage has largely been replaced by <a class="el" href="class_sk_path.html#a24e75e150a765d304e8d0c3d087ddc94">operator=(const SkPath&amp; path)</a>. <a class="el" href="class_sk_path.html">SkPath</a> do not copy their content on assignment until they are written to, making assignment as efficient as <a class="el" href="class_sk_path.html#ad4ded6edd025942b925cc9be8e54732c">swap()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td><a class="el" href="class_sk_path.html">SkPath</a> exchanged by value</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_swap">https://fiddle.skia.org/c/@Path_swap</a> </p>

</div>
</div>
<a id="a557a2b002743e15d9bd4f14b0aee3ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557a2b002743e15d9bd4f14b0aee3ea6">&#9670;&nbsp;</a></span>toggleInverseFillType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkPath::toggleInverseFillType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces FillType with its inverse. The inverse of FillType describes the area unmodified by the original FillType. </p>

</div>
</div>
<a id="a8b555a598f122e7f2911334c1a4a9f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b555a598f122e7f2911334c1a4a9f51">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkPath::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkApplyPerspectiveClip&#160;</td>
          <td class="paramname"><em>pc</em> = <code>SkApplyPerspectiveClip::kYes</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transforms verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array, and weight by matrix. transform may change verbs and increase their number. <a class="el" href="class_sk_path.html">SkPath</a> is replaced by transformed data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td><a class="el" href="class_sk_matrix.html">SkMatrix</a> to apply to <a class="el" href="class_sk_path.html">SkPath</a> </td></tr>
    <tr><td class="paramname">pc</td><td>whether to apply perspective clipping </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad814203ce342490f699698d9c308b889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad814203ce342490f699698d9c308b889">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkPath::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_path.html">SkPath</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkApplyPerspectiveClip&#160;</td>
          <td class="paramname"><em>pc</em> = <code>SkApplyPerspectiveClip::kYes</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transforms verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array, and weight by matrix. transform may change verbs and increase their number. Transformed <a class="el" href="class_sk_path.html">SkPath</a> replaces dst; if dst is nullptr, original data is replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td><a class="el" href="class_sk_matrix.html">SkMatrix</a> to apply to <a class="el" href="class_sk_path.html">SkPath</a> </td></tr>
    <tr><td class="paramname">dst</td><td>overwritten, transformed copy of <a class="el" href="class_sk_path.html">SkPath</a>; may be nullptr </td></tr>
    <tr><td class="paramname">pc</td><td>whether to apply perspective clipping</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_transform">https://fiddle.skia.org/c/@Path_transform</a> </p>

</div>
</div>
<a id="a6de7de42175fe3ce5ff92f3d2267ec2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de7de42175fe3ce5ff92f3d2267ec2d">&#9670;&nbsp;</a></span>updateBoundsCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkPath::updateBoundsCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Updates internal bounds so that subsequent calls to <a class="el" href="class_sk_path.html#ac60188dc6075d6ebb56b5398fbba0c10">getBounds()</a> are instantaneous. Unaltered copies of <a class="el" href="class_sk_path.html">SkPath</a> may also access cached bounds through <a class="el" href="class_sk_path.html#ac60188dc6075d6ebb56b5398fbba0c10">getBounds()</a>.</p>
<p>For now, identical to calling <a class="el" href="class_sk_path.html#ac60188dc6075d6ebb56b5398fbba0c10">getBounds()</a> and ignoring the returned value.</p>
<p>Call to prepare <a class="el" href="class_sk_path.html">SkPath</a> subsequently drawn from multiple threads, to avoid a race condition where each draw separately computes the bounds. </p>

</div>
</div>
<a id="ab34720f80c02d5854cc6b09675b5d907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34720f80c02d5854cc6b09675b5d907">&#9670;&nbsp;</a></span>writeToMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t SkPath::writeToMemory </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes <a class="el" href="class_sk_path.html">SkPath</a> to buffer, returning the number of bytes written. Pass nullptr to obtain the storage size.</p>
<p>Writes SkPath::FillType, verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array, conic weight, and additionally writes computed information like SkPath::Convexity and bounds.</p>
<p>Use only be used in concert with <a class="el" href="class_sk_path.html#a02f6fe6f7f3caf7212ed37b0d2712da2">readFromMemory()</a>; the format used for <a class="el" href="class_sk_path.html">SkPath</a> in memory is not guaranteed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>storage for <a class="el" href="class_sk_path.html">SkPath</a>; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of storage required for <a class="el" href="class_sk_path.html">SkPath</a>; always a multiple of 4</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Path_writeToMemory">https://fiddle.skia.org/c/@Path_writeToMemory</a> </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a4f95dae0ce68ac158edb5bf7a5a19260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f95dae0ce68ac158edb5bf7a5a19260">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares a and b; returns true if SkPath::FillType, verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array, and weights are not equivalent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_sk_path.html">SkPath</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_sk_path.html">SkPath</a> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_path.html">SkPath</a> pair are not equivalent </dd></dl>

</div>
</div>
<a id="a2ba232f3a5c2d5cf27c9ff846c0b830c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba232f3a5c2d5cf27c9ff846c0b830c">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SK_API bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compares a and b; returns true if SkPath::FillType, verb array, <a class="el" href="struct_sk_point.html">SkPoint</a> array, and weights are equivalent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="class_sk_path.html">SkPath</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="class_sk_path.html">SkPath</a> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_path.html">SkPath</a> pair are equivalent </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/include/core/<a class="el" href="_sk_path_8h_source.html">SkPath.h</a></li>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/src/core/SkPath.cpp</li>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/src/core/SkPath_serial.cpp</li>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/src/core/SkPathRef.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
