<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Deploying Faust DSP on the Web</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Deploying <a class="el" href="struct_faust.html">Faust</a> <a class="el" href="class_d_s_p.html">DSP</a> on the Web </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Using developments done for the Web (WebAssembly backends and <b>libfaust</b> library compiled in WebAssembly with <a href="https://emscripten.org">Emscripten</a>), statically and dynamically <a class="el" href="struct_faust.html">Faust</a> generated WebAudio nodes can be easily produced and deployed on the Web.</p>
<h1><a class="anchor" id="autotoc_md1290"></a>
Deploying statically compiled Faust WebAudio nodes</h1>
<p>From a <b>foo.dsp</b> source file, JavaScript and the associated WebAssembly files can be produced with the following script: </p><pre class="fragment">faust2wasm -worklet foo.dsp 
</pre><p>This will generate a <b>foo.wasm</b> file with the WebAssembly module as binary code, as well as a <b>foo.js</b> wrapper file containing the code needed to turn the <a class="el" href="struct_faust.html">Faust</a> <a class="el" href="class_d_s_p.html">DSP</a> in a fully working WebAudio node (using an extended <b>AudioWorkletNode</b> node). The name of the <a class="el" href="struct_faust.html">Faust</a> <a class="el" href="class_d_s_p.html">DSP</a> code file is used to define the final AudioWorkletNode constructor name. So for instance if <b>osc.dsp</b> file is compiled, the <b>Faustosc</b> class will be generated and can be used the following way:</p>
<div class="fragment"><div class="line">// Create the Faust generated node</div>
<div class="line">var pluginURL = &quot;.&quot;;</div>
<div class="line">var plugin = new Faustosc(audio_context, pluginURL);</div>
<div class="line">plugin.load().then(node =&gt; {....});</div>
</div><!-- fragment --><p>The resulting node is an extended AudioWorkletNode, to be used as a regular node (like connected to other WebAudio nodes), as well as JavaScript more specific functions. For instance the following ones will have to be used to control the node: </p><pre class="fragment">var paths = node.getParams(); // get the set of paths to read/write input control parameters
</pre><p>Then knowing the path for a given parameter, the following function is used to change the parameter value: </p><pre class="fragment">node.setParamValue("/Oscillator/freq", 0.6);
</pre><p>A full JSON description of the node with the complete <a class="el" href="class_u_i.html">UI</a>, can be retrieved with: <br  />
 </p><pre class="fragment">var json = node.getJSON(); 
</pre><p>The complete usable API is fully documented in the generated JavaScript file in the <em>Public API</em> section. <b>To properly deallocate ressources at the end of its life, be sure to call the <em>destroy</em> function on the node.</b>. Use <code>faust2wasm -h</code> to see all available options.</p>
<h2><a class="anchor" id="autotoc_md1291"></a>
A simple example Web page</h2>
<p>A simple Web page using the files generated by <b>faust2wasm</b> on the <b>noise.dsp</b> file can be defined with the following parts:</p>
<div class="fragment"><div class="line">&lt;!-- Load &#39;faust2wasm&#39; script generated .js file --&gt;</div>
<div class="line">&lt;script src=&quot;noise.js&quot;&gt;&lt;/script&gt;</div>
</div><!-- fragment --><p>A slider to control the noise volume parameter is defined with:</p>
<div class="fragment"><div class="line">&lt;P&gt; Noise volume:</div>
<div class="line">&lt;input type=&quot;range&quot; oninput=&quot;changeVolume(event) &quot;min=&quot;0&quot; max=&quot;1&quot; value=&quot;0.5&quot; step=&quot;0.01&quot;/&gt;</div>
</div><!-- fragment --><p>The WebAudio context is created and the noise slide hander is defined with:</p>
<div class="fragment"><div class="line">var isWebKitAudio = (typeof (webkitAudioContext) !== &quot;undefined&quot;);</div>
<div class="line">var audio_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext();</div>
<div class="line">var noise_dsp = null;</div>
<div class="line"> </div>
<div class="line">// Slider handler to change the &#39;noise&#39; volume</div>
<div class="line">function changeVolume(event)</div>
<div class="line">{</div>
<div class="line">    noise_dsp.setParamValue(&quot;/Noise/Volume&quot;, parseFloat(event.target.value));</div>
<div class="line">}</div>
</div><!-- fragment --><p>A <b>startnoise</b> function which creates the <a class="el" href="struct_faust.html">Faust</a> WebAudio node is defined with:</p>
<div class="fragment"><div class="line">function startnoise()</div>
<div class="line">{</div>
<div class="line">    // Create the Faust generated node</div>
<div class="line">    var pluginURL = &quot;.&quot;;</div>
<div class="line">    var plugin = new Faustnoise(audio_context, pluginURL);</div>
<div class="line">    plugin.load().then(node =&gt; {</div>
<div class="line">        noise_dsp = node;</div>
<div class="line">        console.log(noise_dsp.getJSON());</div>
<div class="line">        // Print path to be used with &#39;setParamValue&#39;</div>
<div class="line">        console.log(noise_dsp.getParams());</div>
<div class="line">        // Connect it to output as a regular WebAudio node</div>
<div class="line">        noise_dsp.connect(audio_context.destination);</div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><p>An finally the load handler is defined to activate the code: </p><pre class="fragment">window.addEventListener("load", startnoise);
</pre><p>Look at the <a href="noise-wasm.html">Noise</a> and <a href="osc-wasm.html">OSC</a> pages for the complete code.</p>
<p>Note that pages loading an additional .wasm file cannot directly be loaded in Chrome. You'll have to start a local server (using the <em>python -m SimpleHTTPServer</em> command for instance) and access them with their <em><a href="http://">http://</a></em> based URL. <br  />
</p>
<h2><a class="anchor" id="autotoc_md1292"></a>
Generating Polyphonic WebAudio nodes</h2>
<p>Assuming that the compiled <a class="el" href="struct_faust.html">Faust</a> <a class="el" href="class_d_s_p.html">DSP</a> file is <a href="https://faust.grame.fr/doc/manual/index.html#midi-polyphony-support">polyphonic ready</a>, a polyphonic ready WebAudio node can be created by adding the <em>-poly</em> option, and will generate the following class for the node, to be used like:</p>
<div class="fragment"><div class="line">// Create the Faust generated node with 16 voices</div>
<div class="line">var pluginURL = &quot;.&quot;;</div>
<div class="line">var plugin = new FaustorganPoly(audio_context, 16, pluginURL);</div>
<div class="line">plugin.load().then(node =&gt; {....});</div>
</div><!-- fragment --><p>Polyphonic nodes have an extended API to be controled with MIDI messages:</p>
<div class="fragment"><div class="line">/**</div>
<div class="line">* Instantiates a new polyphonic voice. </div>
<div class="line">*</div>
<div class="line">* @param channel - the MIDI channel (0..15, not used for now)</div>
<div class="line">* @param pitch - the MIDI pitch (0..127)</div>
<div class="line">* @param velocity - the MIDI velocity (0..127)</div>
<div class="line">*/</div>
<div class="line">keyOn = function (channel, pitch, velocity) </div>
</div><!-- fragment --><div class="fragment"><div class="line">/**</div>
<div class="line">* De-instantiates a polyphonic voice. </div>
<div class="line">*</div>
<div class="line">* @param channel - the MIDI channel (0..15, not used for now)</div>
<div class="line">* @param pitch - the MIDI pitch (0..127)</div>
<div class="line">* @param velocity - the MIDI velocity (0..127)</div>
<div class="line">*/</div>
<div class="line">keyOff = function (channel, pitch, velocity)</div>
</div><!-- fragment --><p>``` /**</p><ul>
<li>Gently terminates all the active voices. */ allNotesOff = function () ````</li>
</ul>
<p>Look at the <a href="organ-wasm.html">Organ</a> page for the complete code. Look at the JavaScript public documentation section for the complete description.</p>
<h1><a class="anchor" id="autotoc_md1293"></a>
Deploying WebAudio Plugins (WAP)</h1>
<p>The <a href="https://github.com/micbuffa/WebAudioPlugins">WebAudio Plugins</a> is a plugin format currently developed by a group of researchers and developers. <a class="el" href="struct_faust.html">Faust</a> <a class="el" href="class_d_s_p.html">DSP</a> code can be directly compiled for it using the <em>-wap</em> parameter, like this: </p><pre class="fragment">faust2wasm -wap osc.dsp 
</pre><p>In this case a generic <b>main.js</b> file is created, a <b>main.json</b> file to describe the plugin, and an <b>index.html</b> file to test it.</p>
<h1><a class="anchor" id="autotoc_md1294"></a>
Generating fully working self-contained HTML pages</h1>
<p>The <b>faust2webaudiowasm</b> script can be used to generate a fully working self-contained HTML page, with a SVG/CSS a Graphical User Interface. From the <b>osc.dsp</b> <a class="el" href="struct_faust.html">Faust</a> <a class="el" href="class_d_s_p.html">DSP</a> source file, it will generate an <b>osc.html</b> file: </p><pre class="fragment">faust2webaudiowasm -worklet osc.dsp
</pre><p>Assuming that the compiled <a class="el" href="struct_faust.html">Faust</a> <a class="el" href="class_d_s_p.html">DSP</a> file is polyphonic ready, the <em>-poly</em> parameter can be used to generate a polyphonic MIDI controllable instrument, to be used with a MIDI application or device. Use <code>faust2webaudiowasm -h</code> to see all available options.</p>
<h1><a class="anchor" id="autotoc_md1295"></a>
Deploying dynamically compiled Faust WebAudio nodes</h1>
<p>Since the <b>libfaust</b> library is available for the Web, it becomes possible to <b>embed the complete dynamic compilation chain in a Web page</b>, from the <a class="el" href="struct_faust.html">Faust</a> <a class="el" href="class_d_s_p.html">DSP</a> source to the executable WebAudio node. First the following resources (located on the <a class="el" href="struct_faust.html">Faust</a> GitHub in architecture/webaudio folder) have to be loaded in the page:</p>
<div class="fragment"><div class="line">&lt;!-- Load &#39;libfaust&#39; library and wrapper code --&gt;</div>
<div class="line">&lt;script src=&quot;libfaust-wasm.js&quot;&gt;&lt;/script&gt;</div>
<div class="line">&lt;script src=&quot;webaudio-wasm-wrapper.js&quot;&gt;&lt;/script&gt;</div>
</div><!-- fragment --><p>The <b>faust_module</b> global is defined in webaudio-wasm-wrapper.js file, <code>onRuntimeInitialized</code> will be called when the code is ready. So something like the following line has to be written:</p>
<div class="fragment"><div class="line">faust_module[&#39;onRuntimeInitialized&#39;] = init;</div>
</div><!-- fragment --><p>The two following functions are then used to generate factories, creating later on <em>monophonic</em> or <em>polyphonic</em> instances (this is necessary because of the way internal WebAssembly memory is managed):</p>
<div class="fragment"><div class="line">/**</div>
<div class="line">* Create a DSP factory from source code as a string to be used to create monophonic DSP </div>
<div class="line">*</div>
<div class="line">* @param code - the source code as a string</div>
<div class="line">* @param argv - an array of parameters to be given to the Faust compiler</div>
<div class="line">* @param callback - a callback taking the created DSP factory as parameter, or null in case of error</div>
<div class="line">*/</div>
<div class="line">faust.createDSPFactory = function (code, argv, callback) </div>
</div><!-- fragment --><div class="fragment"><div class="line">/**</div>
<div class="line">* Create a DSP factory from source code as a string to be used to create polyphonic DSP </div>
<div class="line">*</div>
<div class="line">* @param code - the source code as a string</div>
<div class="line">* @param argv - an array of parameters to be given to the Faust compiler</div>
<div class="line">* @param callback - a callback taking the created DSP factory as parameter, or null in case of error</div>
<div class="line">*/</div>
<div class="line">faust.createPolyDSPFactory = function (code, argv, callback) </div>
</div><!-- fragment --><p>The two following functions are used to generate <em>monophonic</em> or <em>polyphonic</em> <a class="el" href="struct_faust.html">Faust</a> WebAudio nodes:</p>
<div class="fragment"><div class="line">/**</div>
<div class="line">* Create a AudioWorklet Web Audio object from a factory</div>
<div class="line">*</div>
<div class="line">* @param factory - the DSP factory</div>
<div class="line">* @param context - the Web Audio context</div>
<div class="line">* @param callback - a callback taking the created AudioWorklet as parameter, or null in case of error</div>
<div class="line">*/</div>
<div class="line">faust.createDSPWorkletInstance = function (factory, context, callback) </div>
</div><!-- fragment --><div class="fragment"><div class="line">/**</div>
<div class="line">* Create a &#39;polyphonic&#39; AudioWorklet Web Audio object from a factory</div>
<div class="line">*</div>
<div class="line">* @param factory - the DSP factory</div>
<div class="line">* @param context - the Web Audio context</div>
<div class="line">* @param polyphony - the number of polyphonic voices</div>
<div class="line">* @param callback - a callback taking the created AudioWorklet as parameter, or null in case of error</div>
<div class="line">*/</div>
<div class="line">faust.createPolyDSPWorkletInstance = function (factory, context, polyphony, callback) </div>
</div><!-- fragment --><p>The resulting nodes have the same API as statically compiled nodes described in the first section, so can be controlled the same way, including the polyphonic ones. Here is a code example using <b>faust.createDSPFactory</b> and <b>faust.createDSPWorkletInstance</b>:</p>
<div class="fragment"><div class="line">var isWebKitAudio = (typeof (webkitAudioContext) !== &quot;undefined&quot;);</div>
<div class="line">var audio_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext();</div>
<div class="line">var dsp_code = &quot;import(\&quot;stdfaust.lib\&quot;); vol = hslider(\&quot;volume [unit:dB]\&quot;, 0, -96, 0, 0.1) : ba.db2linear : si.smoo; freq = hslider(\&quot;freq [unit:Hz]\&quot;, 1000, 20, 24000, 1); process = vgroup(\&quot;Oscillator\&quot;, os.osc(freq) * vol);&quot;;</div>
<div class="line">var osc = null;</div>
<div class="line">var libraries_url = &quot;/modules/libraries/&quot;;</div>
<div class="line"> </div>
<div class="line">function startosc()</div>
<div class="line">{</div>
<div class="line">    // Prepare argv list</div>
<div class="line">    var argv = [];</div>
<div class="line">    argv.push(&quot;-ftz&quot;);</div>
<div class="line">    argv.push(&quot;2&quot;);</div>
<div class="line">    argv.push(&quot;-I&quot;);</div>
<div class="line">    argv.push(libraries_url);</div>
<div class="line"> </div>
<div class="line">    // Dynamically create the Faust generated node from explicit DSP source in &#39;dsp_code&#39;</div>
<div class="line">    faust.createDSPFactory(dsp_code,</div>
<div class="line">                            argv,</div>
<div class="line">                            function (factory) {</div>
<div class="line">                            faust.createDSPWorkletInstance(factory, audio_context</div>
<div class="line">                                                            function (node) {</div>
<div class="line">                                                                osc = node;</div>
<div class="line">                                                                console.log(osc.getJSON());</div>
<div class="line">                                                                // Print paths to be used with &#39;setParamValue&#39;</div>
<div class="line">                                                                console.log(osc.getParams());</div>
<div class="line">                                                                // Connect it to output as a regular WebAudio node</div>
<div class="line">                                                                osc.connect(audio_context.destination);</div>
<div class="line">                                                            })});</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <a href="dynamic-osc-worklet-wasm.html">Dynamic OSC</a> page demonstrates the dynamic OSC complete code (based on the example seen before). The <a href="dynamic-organ-worklet-wasm.html">Dynamic Organ</a> page demonstrates a polyphonic organ instrument, which loads a <a class="el" href="class_d_s_p.html">DSP</a> from an url, and ready to be controlled with a MIDI device or application. Look at the <a href="faustlive-wasm.html">Dynamic Faust compiler</a> page for a more complete use-case of the dynamic compiler.</p>
<h1><a class="anchor" id="autotoc_md1296"></a>
Float denormal handling</h1>
<p>A specific problem occurs when audio computation produces denormal float values, which is quite common with recursive filters, and can be extremely costly to compute on some processors like the Intel family for instance. A Flush To Zero (FTZ) mode for denormals can usually be set at hardware level, but it not yet available in the WebAssembly MVP version, which strictly conform to the IEEE 754 norm 8.</p>
<p>Thus an automatic software strategy which consists in adding FTZ code in all recursive loops has been implemented in the <a class="el" href="struct_faust.html">Faust</a> compiler. To activate it, the <em>-ftz</em> compilation parameter must be used at compilation time.</p>
<p>The <em>-ftz 1</em> mode adds a test in each recursive loop which uses the <em>fabs</em> function and a threshold to detect subnormal samples (slower). The <em>-ftz 2</em> mode adds a test in each recursive loop which uses a mask to detect subnormal samples (faster).</p>
<p>Use for example the following line to active software denormal handing when using <b>faust2wasm</b> tool: </p><pre class="fragment">faust2wasm -worklet -ftz 2 foo.dsp 
</pre><p>The same for the <b>faust2webaudiowasm</b> tool: </p><pre class="fragment">faust2webaudiowasm -worklet -ftz 2 foo.dsp 
</pre><p>For dynamic compilation, the <em>-ftz v</em> flag will have to be added in the <em>argv</em> parameter in <b>faust.createDSPFactory</b> or <b>faust.createPolyDSPFactory</b>, like for instance: </p><pre class="fragment">faust.createPolyDSPFactory(dsp_code, ['-ftz', '2'], callback);
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
