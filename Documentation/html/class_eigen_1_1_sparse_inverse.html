<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Eigen::SparseInverse&lt; Scalar &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_eigen.html">Eigen</a></li><li class="navelem"><a class="el" href="class_eigen_1_1_sparse_inverse.html">SparseInverse</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_eigen_1_1_sparse_inverse-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Eigen::SparseInverse&lt; Scalar &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>calculate sparse subset of inverse of sparse matrix  
 <a href="class_eigen_1_1_sparse_inverse.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="eigen_2unsupported_2_eigen_2src_2_sparse_extra_2_sparse_inverse_8h_source.html">SparseInverse.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:adf460334d18180cc2575868ae2aec6a8"><td class="memItemLeft" align="right" valign="top"><a id="adf460334d18180cc2575868ae2aec6a8"></a>
typedef <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a">ColMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixType</b></td></tr>
<tr class="separator:adf460334d18180cc2575868ae2aec6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4317913aa0cd19c7328b9348fef793b"><td class="memItemLeft" align="right" valign="top"><a id="ac4317913aa0cd19c7328b9348fef793b"></a>
typedef <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3">RowMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RowMatrixType</b></td></tr>
<tr class="separator:ac4317913aa0cd19c7328b9348fef793b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf460334d18180cc2575868ae2aec6a8"><td class="memItemLeft" align="right" valign="top"><a id="adf460334d18180cc2575868ae2aec6a8"></a>
typedef <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a">ColMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MatrixType</b></td></tr>
<tr class="separator:adf460334d18180cc2575868ae2aec6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4317913aa0cd19c7328b9348fef793b"><td class="memItemLeft" align="right" valign="top"><a id="ac4317913aa0cd19c7328b9348fef793b"></a>
typedef <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar, <a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3">RowMajor</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>RowMatrixType</b></td></tr>
<tr class="separator:ac4317913aa0cd19c7328b9348fef793b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a896ca5138d8d0575a1315f087fdce7f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_inverse.html#a896ca5138d8d0575a1315f087fdce7f5">SparseInverse</a> (const <a class="el" href="class_eigen_1_1_sparse_l_u.html">SparseLU</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> &gt; &amp;slu)</td></tr>
<tr class="memdesc:a896ca5138d8d0575a1315f087fdce7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Constructor is for if you already have a factored <a class="el" href="class_eigen_1_1_sparse_l_u.html" title="Sparse supernodal LU factorization for general matrices.">SparseLU</a> and would like to use it to calculate a sparse inverse.  <a href="class_eigen_1_1_sparse_inverse.html#a896ca5138d8d0575a1315f087fdce7f5">More...</a><br /></td></tr>
<tr class="separator:a896ca5138d8d0575a1315f087fdce7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771817bb7bc9355fbe65b41d97e26f71"><td class="memItemLeft" align="right" valign="top"><a id="a771817bb7bc9355fbe65b41d97e26f71"></a>
<a class="el" href="class_eigen_1_1_sparse_inverse.html">SparseInverse</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_inverse.html#a771817bb7bc9355fbe65b41d97e26f71">compute</a> (const <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar &gt; &amp;<a class="el" href="class_eigen_1_1_matrix.html">A</a>)</td></tr>
<tr class="memdesc:a771817bb7bc9355fbe65b41d97e26f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the sparse inverse from a given sparse input. <br /></td></tr>
<tr class="separator:a771817bb7bc9355fbe65b41d97e26f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179f6394af5aa6355c9e56420396fb3d"><td class="memItemLeft" align="right" valign="top"><a id="a179f6394af5aa6355c9e56420396fb3d"></a>
const <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_inverse.html#a179f6394af5aa6355c9e56420396fb3d">inverse</a> () const</td></tr>
<tr class="memdesc:a179f6394af5aa6355c9e56420396fb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the already-calculated sparse inverse, or a 0x0 matrix if it could not be computed <br /></td></tr>
<tr class="separator:a179f6394af5aa6355c9e56420396fb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a896ca5138d8d0575a1315f087fdce7f5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_inverse.html#a896ca5138d8d0575a1315f087fdce7f5">SparseInverse</a> (const <a class="el" href="class_eigen_1_1_sparse_l_u.html">SparseLU</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> &gt; &amp;slu)</td></tr>
<tr class="memdesc:a896ca5138d8d0575a1315f087fdce7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This Constructor is for if you already have a factored <a class="el" href="class_eigen_1_1_sparse_l_u.html" title="Sparse supernodal LU factorization for general matrices.">SparseLU</a> and would like to use it to calculate a sparse inverse.  <a href="class_eigen_1_1_sparse_inverse.html#a896ca5138d8d0575a1315f087fdce7f5">More...</a><br /></td></tr>
<tr class="separator:a896ca5138d8d0575a1315f087fdce7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771817bb7bc9355fbe65b41d97e26f71"><td class="memItemLeft" align="right" valign="top"><a id="a771817bb7bc9355fbe65b41d97e26f71"></a>
<a class="el" href="class_eigen_1_1_sparse_inverse.html">SparseInverse</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_inverse.html#a771817bb7bc9355fbe65b41d97e26f71">compute</a> (const <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar &gt; &amp;<a class="el" href="class_eigen_1_1_matrix.html">A</a>)</td></tr>
<tr class="memdesc:a771817bb7bc9355fbe65b41d97e26f71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the sparse inverse from a given sparse input. <br /></td></tr>
<tr class="separator:a771817bb7bc9355fbe65b41d97e26f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a179f6394af5aa6355c9e56420396fb3d"><td class="memItemLeft" align="right" valign="top"><a id="a179f6394af5aa6355c9e56420396fb3d"></a>
const <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_inverse.html#a179f6394af5aa6355c9e56420396fb3d">inverse</a> () const</td></tr>
<tr class="memdesc:a179f6394af5aa6355c9e56420396fb3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the already-calculated sparse inverse, or a 0x0 matrix if it could not be computed <br /></td></tr>
<tr class="separator:a179f6394af5aa6355c9e56420396fb3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9f84420419d1cf40e89220dae96aaea0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_inverse.html#a9f84420419d1cf40e89220dae96aaea0">computeInverse</a> (const <a class="el" href="class_eigen_1_1_sparse_l_u.html">SparseLU</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> &gt; &amp;slu)</td></tr>
<tr class="memdesc:a9f84420419d1cf40e89220dae96aaea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to calculate the sparse inverse in a functional way.  <a href="class_eigen_1_1_sparse_inverse.html#a9f84420419d1cf40e89220dae96aaea0">More...</a><br /></td></tr>
<tr class="separator:a9f84420419d1cf40e89220dae96aaea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463d5141bbcb323d5b6d8ff5420367ae"><td class="memItemLeft" align="right" valign="top"><a id="a463d5141bbcb323d5b6d8ff5420367ae"></a>
static <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_inverse.html#a463d5141bbcb323d5b6d8ff5420367ae">computeInverse</a> (const <a class="el" href="class_eigen_1_1_sparse_matrix.html">RowMatrixType</a> &amp;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec">Upper</a>, const <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; Scalar, <a class="el" href="namespace_eigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, 1 &gt; &amp;inverseDiagonal, const <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> &amp;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6">Lower</a>)</td></tr>
<tr class="memdesc:a463d5141bbcb323d5b6d8ff5420367ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to calculate the inverse from strictly upper, diagonal and strictly lower components. <br /></td></tr>
<tr class="separator:a463d5141bbcb323d5b6d8ff5420367ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f84420419d1cf40e89220dae96aaea0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_inverse.html#a9f84420419d1cf40e89220dae96aaea0">computeInverse</a> (const <a class="el" href="class_eigen_1_1_sparse_l_u.html">SparseLU</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> &gt; &amp;slu)</td></tr>
<tr class="memdesc:a9f84420419d1cf40e89220dae96aaea0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to calculate the sparse inverse in a functional way.  <a href="class_eigen_1_1_sparse_inverse.html#a9f84420419d1cf40e89220dae96aaea0">More...</a><br /></td></tr>
<tr class="separator:a9f84420419d1cf40e89220dae96aaea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463d5141bbcb323d5b6d8ff5420367ae"><td class="memItemLeft" align="right" valign="top"><a id="a463d5141bbcb323d5b6d8ff5420367ae"></a>
static <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_inverse.html#a463d5141bbcb323d5b6d8ff5420367ae">computeInverse</a> (const <a class="el" href="class_eigen_1_1_sparse_matrix.html">RowMatrixType</a> &amp;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec">Upper</a>, const <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; Scalar, <a class="el" href="namespace_eigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, 1 &gt; &amp;inverseDiagonal, const <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> &amp;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6">Lower</a>)</td></tr>
<tr class="memdesc:a463d5141bbcb323d5b6d8ff5420367ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function to calculate the inverse from strictly upper, diagonal and strictly lower components. <br /></td></tr>
<tr class="separator:a463d5141bbcb323d5b6d8ff5420367ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Scalar&gt;<br />
class Eigen::SparseInverse&lt; Scalar &gt;</h3>

<p>calculate sparse subset of inverse of sparse matrix </p>
<p>This class returns a sparse subset of the inverse of the input matrix. The nonzeros correspond to the nonzeros of the input, plus any additional elements required due to fill-in of the internal LU factorization. This is is minimized via a applying a fill-reducing permutation as part of the LU factorization.</p>
<p>If there are specific entries of the input matrix which you need inverse values for, which are zero for the input, you need to insert entries into the input sparse matrix for them to be calculated.</p>
<p>Due to the sensitive nature of matrix inversion, particularly on large matrices which are made possible via sparsity, high accuracy dot products based on Kahan summation are used to reduce numerical error. If you still encounter numerical errors you may with to equilibrate your matrix before calculating the inverse, as well as making sure it is actually full rank. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a896ca5138d8d0575a1315f087fdce7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896ca5138d8d0575a1315f087fdce7f5">&#9670;&nbsp;</a></span>SparseInverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_sparse_inverse.html">Eigen::SparseInverse</a>&lt; Scalar &gt;::<a class="el" href="class_eigen_1_1_sparse_inverse.html">SparseInverse</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_l_u.html">SparseLU</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>slu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This Constructor is for if you already have a factored <a class="el" href="class_eigen_1_1_sparse_l_u.html" title="Sparse supernodal LU factorization for general matrices.">SparseLU</a> and would like to use it to calculate a sparse inverse. </p>
<p>Just call this constructor with your already factored <a class="el" href="class_eigen_1_1_sparse_l_u.html" title="Sparse supernodal LU factorization for general matrices.">SparseLU</a> class and you can directly call the .<a class="el" href="class_eigen_1_1_sparse_inverse.html#a179f6394af5aa6355c9e56420396fb3d" title="return the already-calculated sparse inverse, or a 0x0 matrix if it could not be computed">inverse()</a> method to get the result. </p>

</div>
</div>
<a id="a896ca5138d8d0575a1315f087fdce7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a896ca5138d8d0575a1315f087fdce7f5">&#9670;&nbsp;</a></span>SparseInverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_sparse_inverse.html">Eigen::SparseInverse</a>&lt; Scalar &gt;::<a class="el" href="class_eigen_1_1_sparse_inverse.html">SparseInverse</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_l_u.html">SparseLU</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>slu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This Constructor is for if you already have a factored <a class="el" href="class_eigen_1_1_sparse_l_u.html" title="Sparse supernodal LU factorization for general matrices.">SparseLU</a> and would like to use it to calculate a sparse inverse. </p>
<p>Just call this constructor with your already factored <a class="el" href="class_eigen_1_1_sparse_l_u.html" title="Sparse supernodal LU factorization for general matrices.">SparseLU</a> class and you can directly call the .<a class="el" href="class_eigen_1_1_sparse_inverse.html#a179f6394af5aa6355c9e56420396fb3d" title="return the already-calculated sparse inverse, or a 0x0 matrix if it could not be computed">inverse()</a> method to get the result. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9f84420419d1cf40e89220dae96aaea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f84420419d1cf40e89220dae96aaea0">&#9670;&nbsp;</a></span>computeInverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> <a class="el" href="class_eigen_1_1_sparse_inverse.html">Eigen::SparseInverse</a>&lt; Scalar &gt;::computeInverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_l_u.html">SparseLU</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>slu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to calculate the sparse inverse in a functional way. </p>
<dl class="section return"><dt>Returns</dt><dd>A sparse inverse representation, or, if the decomposition didn't complete, a 0x0 matrix. </dd></dl>

</div>
</div>
<a id="a9f84420419d1cf40e89220dae96aaea0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f84420419d1cf40e89220dae96aaea0">&#9670;&nbsp;</a></span>computeInverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> <a class="el" href="class_eigen_1_1_sparse_inverse.html">Eigen::SparseInverse</a>&lt; Scalar &gt;::computeInverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_l_u.html">SparseLU</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">MatrixType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>slu</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function to calculate the sparse inverse in a functional way. </p>
<dl class="section return"><dt>Returns</dt><dd>A sparse inverse representation, or, if the decomposition didn't complete, a 0x0 matrix. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/eigen/unsupported/Eigen/src/SparseExtra/<a class="el" href="eigen_2unsupported_2_eigen_2src_2_sparse_extra_2_sparse_inverse_8h_source.html">SparseInverse.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
