<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: SkCodec Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_sk_codec-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SkCodec Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_sk_codec_8h_source.html">SkCodec.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SkCodec:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_sk_codec.png" usemap="#SkCodec_map" alt=""/>
  <map id="SkCodec_map" name="SkCodec_map">
<area href="class_sk_noncopyable.html" alt="SkNoncopyable" shape="rect" coords="0,0,101,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_codec_1_1_frame_info.html">FrameInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_codec_1_1_options.html">Options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab43dd53de9d731e34e7ce9e42cfad1f0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a> { <br />
&#160;&#160;<a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0af28b992d9388cc8642654166640ec1f5">kSuccess</a>, 
<a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0a281db21a336583487cd0bd21a9c4ac7e">kIncompleteInput</a>, 
<a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0af58aff50960c54080c1601b94b43420a">kErrorInInput</a>, 
<a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0a02c7eafb6cbb102d5e37da5adb243453">kInvalidConversion</a>, 
<br />
&#160;&#160;<a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0a0f22b10314f4485a95b8de52c85c62e9">kInvalidScale</a>, 
<a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0aa164f152463ccb4d3eba3979de1d729b">kInvalidParameters</a>, 
<a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0a9b5d53c120a6aa375a3226d23f1a77fb">kInvalidInput</a>, 
<a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0aa749a4b6013200f97e945ee7d2029a10">kCouldNotRewind</a>, 
<br />
&#160;&#160;<a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0aa3976b51cdb453b2b9a0a25621f58be0">kInternalError</a>, 
<a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0abaeee713abd66d9a77ff5696a73d8805">kUnimplemented</a>
<br />
 }</td></tr>
<tr class="separator:ab43dd53de9d731e34e7ce9e42cfad1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54f614159c048c5fc7065e3558e966e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#ab54f614159c048c5fc7065e3558e966e">SelectionPolicy</a> { <a class="el" href="class_sk_codec.html#ab54f614159c048c5fc7065e3558e966ea5136a0dddb26f4ca4844b54ca82fad5d">SelectionPolicy::kPreferStillImage</a>, 
<a class="el" href="class_sk_codec.html#ab54f614159c048c5fc7065e3558e966ea9c4e30992ac98b63be20b56930376d7f">SelectionPolicy::kPreferAnimation</a>
 }</td></tr>
<tr class="separator:ab54f614159c048c5fc7065e3558e966e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63868ae492c5effb2196d3f40f5b8ad8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a63868ae492c5effb2196d3f40f5b8ad8">ZeroInitialized</a> { <a class="el" href="class_sk_codec.html#a63868ae492c5effb2196d3f40f5b8ad8a174e9e42ebf13bdec44f5676438872f5">kYes_ZeroInitialized</a>, 
<a class="el" href="class_sk_codec.html#a63868ae492c5effb2196d3f40f5b8ad8a5e57df28301694970868c2c9196bc4c9">kNo_ZeroInitialized</a>
 }</td></tr>
<tr class="separator:a63868ae492c5effb2196d3f40f5b8ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77847b2f814711a4e08d1d10147bb884"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a77847b2f814711a4e08d1d10147bb884">SkScanlineOrder</a> { <b>kTopDown_SkScanlineOrder</b>, 
<b>kBottomUp_SkScanlineOrder</b>
 }</td></tr>
<tr class="separator:a77847b2f814711a4e08d1d10147bb884"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af08867a592789e9577ae2e7d3933d292"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_image_info.html">SkImageInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#af08867a592789e9577ae2e7d3933d292">getInfo</a> () const</td></tr>
<tr class="separator:af08867a592789e9577ae2e7d3933d292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35805ee38cc2254edde820945cfb9103"><td class="memItemLeft" align="right" valign="top"><a id="a35805ee38cc2254edde820945cfb9103"></a>
<a class="el" href="struct_sk_i_size.html">SkISize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>dimensions</b> () const</td></tr>
<tr class="separator:a35805ee38cc2254edde820945cfb9103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0770def081538abb95f95f8b007d34"><td class="memItemLeft" align="right" valign="top"><a id="a6a0770def081538abb95f95f8b007d34"></a>
<a class="el" href="struct_sk_i_rect.html">SkIRect</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bounds</b> () const</td></tr>
<tr class="separator:a6a0770def081538abb95f95f8b007d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0138a8ac40a3dceddbcbbd5b9215e8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structskcms___i_c_c_profile.html">skcms_ICCProfile</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a0f0138a8ac40a3dceddbcbbd5b9215e8">getICCProfile</a> () const</td></tr>
<tr class="separator:a0f0138a8ac40a3dceddbcbbd5b9215e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f6e062472900190f71c56be5f43144"><td class="memItemLeft" align="right" valign="top">SkEncodedOrigin&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#ae4f6e062472900190f71c56be5f43144">getOrigin</a> () const</td></tr>
<tr class="separator:ae4f6e062472900190f71c56be5f43144"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4729235361cb7f387688c9ac40b79f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_i_size.html">SkISize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#ac4729235361cb7f387688c9ac40b79f3">getScaledDimensions</a> (float desiredScale) const</td></tr>
<tr class="separator:ac4729235361cb7f387688c9ac40b79f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da8966fb6dabd6584f955c0f5e70aee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a1da8966fb6dabd6584f955c0f5e70aee">getValidSubset</a> (<a class="el" href="struct_sk_i_rect.html">SkIRect</a> *desiredSubset) const</td></tr>
<tr class="separator:a1da8966fb6dabd6584f955c0f5e70aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7573e6b32c540dfc3f67b9eaeef1bd5"><td class="memItemLeft" align="right" valign="top">SkEncodedImageFormat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#aa7573e6b32c540dfc3f67b9eaeef1bd5">getEncodedFormat</a> () const</td></tr>
<tr class="separator:aa7573e6b32c540dfc3f67b9eaeef1bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affddeb85741238d2a275cedf1f627da5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#affddeb85741238d2a275cedf1f627da5">getPixels</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;info, void *pixels, size_t rowBytes, const <a class="el" href="struct_sk_codec_1_1_options.html">Options</a> *)</td></tr>
<tr class="separator:affddeb85741238d2a275cedf1f627da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d622127e713e0f623e9defebca4f773"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a6d622127e713e0f623e9defebca4f773">getPixels</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;info, void *pixels, size_t rowBytes)</td></tr>
<tr class="separator:a6d622127e713e0f623e9defebca4f773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70bb647fdbffc2732c8255532d6fd860"><td class="memItemLeft" align="right" valign="top"><a id="a70bb647fdbffc2732c8255532d6fd860"></a>
<a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>getPixels</b> (const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> &amp;pm, const <a class="el" href="struct_sk_codec_1_1_options.html">Options</a> *opts=nullptr)</td></tr>
<tr class="separator:a70bb647fdbffc2732c8255532d6fd860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f54973c7ea1d57062c3f9d49eea634"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_image.html">SkImage</a> &gt;, <a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">SkCodec::Result</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#aa9f54973c7ea1d57062c3f9d49eea634">getImage</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;info, const <a class="el" href="struct_sk_codec_1_1_options.html">Options</a> *opts=nullptr)</td></tr>
<tr class="separator:aa9f54973c7ea1d57062c3f9d49eea634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4832e34cbd4a004fea6c86c2ae7f9a38"><td class="memItemLeft" align="right" valign="top"><a id="a4832e34cbd4a004fea6c86c2ae7f9a38"></a>
std::tuple&lt; <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_image.html">SkImage</a> &gt;, <a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">SkCodec::Result</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getImage</b> ()</td></tr>
<tr class="separator:a4832e34cbd4a004fea6c86c2ae7f9a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa1d1b5ac807579b98bf56678c87e7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a4fa1d1b5ac807579b98bf56678c87e7b">queryYUVAInfo</a> (const <a class="el" href="class_sk_y_u_v_a_pixmap_info_1_1_supported_data_types.html">SkYUVAPixmapInfo::SupportedDataTypes</a> &amp;supportedDataTypes, <a class="el" href="class_sk_y_u_v_a_pixmap_info.html">SkYUVAPixmapInfo</a> *yuvaPixmapInfo) const</td></tr>
<tr class="separator:a4fa1d1b5ac807579b98bf56678c87e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fa230b3f5cfd8baf4e12778c7264fd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a3fa230b3f5cfd8baf4e12778c7264fd2">getYUVAPlanes</a> (const <a class="el" href="class_sk_y_u_v_a_pixmaps.html">SkYUVAPixmaps</a> &amp;yuvaPixmaps)</td></tr>
<tr class="separator:a3fa230b3f5cfd8baf4e12778c7264fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8b46291b91638c58391665f7a96b5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#adc8b46291b91638c58391665f7a96b5b">startIncrementalDecode</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;dstInfo, void *dst, size_t rowBytes, const <a class="el" href="struct_sk_codec_1_1_options.html">Options</a> *)</td></tr>
<tr class="separator:adc8b46291b91638c58391665f7a96b5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6324de4de977f9db266c6bd113f4376"><td class="memItemLeft" align="right" valign="top"><a id="ad6324de4de977f9db266c6bd113f4376"></a>
<a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>startIncrementalDecode</b> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;dstInfo, void *dst, size_t rowBytes)</td></tr>
<tr class="separator:ad6324de4de977f9db266c6bd113f4376"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da5958ea146f27a624285cbd4e280ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a9da5958ea146f27a624285cbd4e280ad">incrementalDecode</a> (int *rowsDecoded=nullptr)</td></tr>
<tr class="separator:a9da5958ea146f27a624285cbd4e280ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a952a6ca87c12d4c2482bd54c4eda1ba9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a952a6ca87c12d4c2482bd54c4eda1ba9">startScanlineDecode</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;dstInfo, const <a class="el" href="struct_sk_codec_1_1_options.html">Options</a> *options)</td></tr>
<tr class="separator:a952a6ca87c12d4c2482bd54c4eda1ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade349e283630bdf80d816e89f0d250cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#ade349e283630bdf80d816e89f0d250cb">startScanlineDecode</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;dstInfo)</td></tr>
<tr class="separator:ade349e283630bdf80d816e89f0d250cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d129c55ba6889be63c790918a0e374"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a05d129c55ba6889be63c790918a0e374">getScanlines</a> (void *dst, int countLines, size_t rowBytes)</td></tr>
<tr class="separator:a05d129c55ba6889be63c790918a0e374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07efc4311f76f25535969998b2d2377"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#af07efc4311f76f25535969998b2d2377">skipScanlines</a> (int countLines)</td></tr>
<tr class="separator:af07efc4311f76f25535969998b2d2377"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960496ac4d6f886b99878aaeb0901a5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_codec.html#a77847b2f814711a4e08d1d10147bb884">SkScanlineOrder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a960496ac4d6f886b99878aaeb0901a5e">getScanlineOrder</a> () const</td></tr>
<tr class="separator:a960496ac4d6f886b99878aaeb0901a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c8cfaf7754ca3929626a010df66392"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#af6c8cfaf7754ca3929626a010df66392">nextScanline</a> () const</td></tr>
<tr class="separator:af6c8cfaf7754ca3929626a010df66392"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81cd31a6144db8eddf7b96246a1ec08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#ad81cd31a6144db8eddf7b96246a1ec08">outputScanline</a> (int inputScanline) const</td></tr>
<tr class="separator:ad81cd31a6144db8eddf7b96246a1ec08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82806b5f7b331a4152cc529703afdf2b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a82806b5f7b331a4152cc529703afdf2b">getFrameCount</a> ()</td></tr>
<tr class="separator:a82806b5f7b331a4152cc529703afdf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0365f020979f47404572d0e0e85e42f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a0365f020979f47404572d0e0e85e42f4">getFrameInfo</a> (int index, <a class="el" href="struct_sk_codec_1_1_frame_info.html">FrameInfo</a> *info) const</td></tr>
<tr class="separator:a0365f020979f47404572d0e0e85e42f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d73b25fe06bdbc28a62abf7bc8ea66"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_sk_codec_1_1_frame_info.html">FrameInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a10d73b25fe06bdbc28a62abf7bc8ea66">getFrameInfo</a> ()</td></tr>
<tr class="separator:a10d73b25fe06bdbc28a62abf7bc8ea66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b34fa67ae57bca7dc50c717d7cdad09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a3b34fa67ae57bca7dc50c717d7cdad09">getRepetitionCount</a> ()</td></tr>
<tr class="separator:a3b34fa67ae57bca7dc50c717d7cdad09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a619e4149e0eeda445f561f1d850d70e9"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a619e4149e0eeda445f561f1d850d70e9">MinBufferedBytesNeeded</a> ()</td></tr>
<tr class="separator:a619e4149e0eeda445f561f1d850d70e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7733c4d013384bfec645aa0c9c8249e"><td class="memItemLeft" align="right" valign="top">static const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#ab7733c4d013384bfec645aa0c9c8249e">ResultToString</a> (<a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a>)</td></tr>
<tr class="separator:ab7733c4d013384bfec645aa0c9c8249e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3704593dd81ecd2b5c2962c0687a309"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="class_sk_codec.html">SkCodec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#ab3704593dd81ecd2b5c2962c0687a309">MakeFromStream</a> (std::unique_ptr&lt; <a class="el" href="class_sk_stream.html">SkStream</a> &gt;, <a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a> *=nullptr, <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> *=nullptr, <a class="el" href="class_sk_codec.html#ab54f614159c048c5fc7065e3558e966e">SelectionPolicy</a> selectionPolicy=<a class="el" href="class_sk_codec.html#ab54f614159c048c5fc7065e3558e966ea5136a0dddb26f4ca4844b54ca82fad5d">SelectionPolicy::kPreferStillImage</a>)</td></tr>
<tr class="separator:ab3704593dd81ecd2b5c2962c0687a309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc7c7b794754dfe2302a74553149980"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="class_sk_codec.html">SkCodec</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a7dc7c7b794754dfe2302a74553149980">MakeFromData</a> (<a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt;, <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> *=nullptr)</td></tr>
<tr class="separator:a7dc7c7b794754dfe2302a74553149980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c716f571200130fcd1dc1ce7c3d0614"><td class="memItemLeft" align="right" valign="top"><a id="a7c716f571200130fcd1dc1ce7c3d0614"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>Register</b> (bool(*peek)(const void *, size_t), std::unique_ptr&lt; <a class="el" href="class_sk_codec.html">SkCodec</a> &gt;(*make)(std::unique_ptr&lt; <a class="el" href="class_sk_stream.html">SkStream</a> &gt;, <a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">SkCodec::Result</a> *))</td></tr>
<tr class="separator:a7c716f571200130fcd1dc1ce7c3d0614"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aea5d645540a83c7c6d88e29791e86567"><td class="memItemLeft" align="right" valign="top"><a id="aea5d645540a83c7c6d88e29791e86567"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kNoFrame</b> = -1</td></tr>
<tr class="separator:aea5d645540a83c7c6d88e29791e86567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd490dd156e8a8d89ee282a2d32b344c"><td class="memItemLeft" align="right" valign="top"><a id="abd490dd156e8a8d89ee282a2d32b344c"></a>
static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><b>kRepetitionCountInfinite</b> = -1</td></tr>
<tr class="separator:abd490dd156e8a8d89ee282a2d32b344c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a7a33c22ea36f93e17e53d2898a8b1c3d"><td class="memItemLeft" align="right" valign="top"><a id="a7a33c22ea36f93e17e53d2898a8b1c3d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>XformFormat</b> = skcms_PixelFormat</td></tr>
<tr class="separator:a7a33c22ea36f93e17e53d2898a8b1c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab0b72e4c22b948d94ff88c63fe1c04f7"><td class="memItemLeft" align="right" valign="top"><a id="ab0b72e4c22b948d94ff88c63fe1c04f7"></a>
const <a class="el" href="struct_sk_encoded_info.html">SkEncodedInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>getEncodedInfo</b> () const</td></tr>
<tr class="separator:ab0b72e4c22b948d94ff88c63fe1c04f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a31c721e7e6de169aef649d25a08a6"><td class="memItemLeft" align="right" valign="top"><a id="a73a31c721e7e6de169aef649d25a08a6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SkCodec</b> (<a class="el" href="struct_sk_encoded_info.html">SkEncodedInfo</a> &amp;&amp;, XformFormat srcFormat, std::unique_ptr&lt; <a class="el" href="class_sk_stream.html">SkStream</a> &gt;, SkEncodedOrigin=kTopLeft_SkEncodedOrigin)</td></tr>
<tr class="separator:a73a31c721e7e6de169aef649d25a08a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaedb167064ff3e0323d9ba13e91b7808"><td class="memItemLeft" align="right" valign="top"><a id="aaedb167064ff3e0323d9ba13e91b7808"></a>
virtual <a class="el" href="struct_sk_i_size.html">SkISize</a>&#160;</td><td class="memItemRight" valign="bottom"><b>onGetScaledDimensions</b> (float) const</td></tr>
<tr class="separator:aaedb167064ff3e0323d9ba13e91b7808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eca650de18970858729e32bad46f70f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a4eca650de18970858729e32bad46f70f">onDimensionsSupported</a> (const <a class="el" href="struct_sk_i_size.html">SkISize</a> &amp;)</td></tr>
<tr class="separator:a4eca650de18970858729e32bad46f70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d72867b852c931dc8da70ce6d5493b"><td class="memItemLeft" align="right" valign="top"><a id="a30d72867b852c931dc8da70ce6d5493b"></a>
virtual SkEncodedImageFormat&#160;</td><td class="memItemRight" valign="bottom"><b>onGetEncodedFormat</b> () const =0</td></tr>
<tr class="separator:a30d72867b852c931dc8da70ce6d5493b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a058da1d38eac36ad2165e47758e0adca"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a058da1d38eac36ad2165e47758e0adca">onGetPixels</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;info, void *pixels, size_t rowBytes, const <a class="el" href="struct_sk_codec_1_1_options.html">Options</a> &amp;, int *rowsDecoded)=0</td></tr>
<tr class="separator:a058da1d38eac36ad2165e47758e0adca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bc8d621ca5ee02bcfa1ccaae74bd7f"><td class="memItemLeft" align="right" valign="top"><a id="ab0bc8d621ca5ee02bcfa1ccaae74bd7f"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>onQueryYUVAInfo</b> (const <a class="el" href="class_sk_y_u_v_a_pixmap_info_1_1_supported_data_types.html">SkYUVAPixmapInfo::SupportedDataTypes</a> &amp;, <a class="el" href="class_sk_y_u_v_a_pixmap_info.html">SkYUVAPixmapInfo</a> *) const</td></tr>
<tr class="separator:ab0bc8d621ca5ee02bcfa1ccaae74bd7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6898760a0f653e2beabb17c492d4a62c"><td class="memItemLeft" align="right" valign="top"><a id="a6898760a0f653e2beabb17c492d4a62c"></a>
virtual <a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a>&#160;</td><td class="memItemRight" valign="bottom"><b>onGetYUVAPlanes</b> (const <a class="el" href="class_sk_y_u_v_a_pixmaps.html">SkYUVAPixmaps</a> &amp;)</td></tr>
<tr class="separator:a6898760a0f653e2beabb17c492d4a62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c281d62d2f9c86ee6da59ff5901863"><td class="memItemLeft" align="right" valign="top"><a id="ae6c281d62d2f9c86ee6da59ff5901863"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>onGetValidSubset</b> (<a class="el" href="struct_sk_i_rect.html">SkIRect</a> *) const</td></tr>
<tr class="separator:ae6c281d62d2f9c86ee6da59ff5901863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7030ce3cb132ac1653a6b6ba3cf46e26"><td class="memItemLeft" align="right" valign="top">bool SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a7030ce3cb132ac1653a6b6ba3cf46e26">rewindIfNeeded</a> ()</td></tr>
<tr class="separator:a7030ce3cb132ac1653a6b6ba3cf46e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f3174541928a80dfe8ec3ac9d555a9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a13f3174541928a80dfe8ec3ac9d555a9">onRewind</a> ()</td></tr>
<tr class="separator:a13f3174541928a80dfe8ec3ac9d555a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adae675dae4722d5bcadfe93bf6f8ab42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_stream.html">SkStream</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#adae675dae4722d5bcadfe93bf6f8ab42">stream</a> ()</td></tr>
<tr class="separator:adae675dae4722d5bcadfe93bf6f8ab42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0e3e7003c6a5ca380a13be9bd71c86"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_sk_codec.html#a77847b2f814711a4e08d1d10147bb884">SkScanlineOrder</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a4f0e3e7003c6a5ca380a13be9bd71c86">onGetScanlineOrder</a> () const</td></tr>
<tr class="separator:a4f0e3e7003c6a5ca380a13be9bd71c86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd385519b060c27d2f938f01793adcf"><td class="memItemLeft" align="right" valign="top"><a id="addd385519b060c27d2f938f01793adcf"></a>
const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>dstInfo</b> () const</td></tr>
<tr class="separator:addd385519b060c27d2f938f01793adcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bb3c3b61d416b6eab718f179757f49"><td class="memItemLeft" align="right" valign="top"><a id="a92bb3c3b61d416b6eab718f179757f49"></a>
const <a class="el" href="struct_sk_codec_1_1_options.html">Options</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>options</b> () const</td></tr>
<tr class="separator:a92bb3c3b61d416b6eab718f179757f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932c2f4ce92c8e7683514de6145d3e11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a932c2f4ce92c8e7683514de6145d3e11">currScanline</a> () const</td></tr>
<tr class="separator:a932c2f4ce92c8e7683514de6145d3e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad005735716216519558b490ac5b27465"><td class="memItemLeft" align="right" valign="top"><a id="ad005735716216519558b490ac5b27465"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>onOutputScanline</b> (int inputScanline) const</td></tr>
<tr class="separator:ad005735716216519558b490ac5b27465"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9fad3de001df07534d56c80b785be5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_codec.html#a9a9fad3de001df07534d56c80b785be5">conversionSupported</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;dst, bool srcIsOpaque, bool needsColorXform)</td></tr>
<tr class="separator:a9a9fad3de001df07534d56c80b785be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c019ce04b1e11c2aa2dc695b381b82"><td class="memItemLeft" align="right" valign="top"><a id="aa3c019ce04b1e11c2aa2dc695b381b82"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>usesColorXform</b> () const</td></tr>
<tr class="separator:aa3c019ce04b1e11c2aa2dc695b381b82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a301752a90f58d74103d60c8be6588"><td class="memItemLeft" align="right" valign="top"><a id="a52a301752a90f58d74103d60c8be6588"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>applyColorXform</b> (void *dst, const void *src, int count) const</td></tr>
<tr class="separator:a52a301752a90f58d74103d60c8be6588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4bd2ffe1bc6cdfc685c640f9e19c46"><td class="memItemLeft" align="right" valign="top"><a id="adc4bd2ffe1bc6cdfc685c640f9e19c46"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>colorXform</b> () const</td></tr>
<tr class="separator:adc4bd2ffe1bc6cdfc685c640f9e19c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fec65cb41e34965573878b29c371773"><td class="memItemLeft" align="right" valign="top"><a id="a3fec65cb41e34965573878b29c371773"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>xformOnDecode</b> () const</td></tr>
<tr class="separator:a3fec65cb41e34965573878b29c371773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc59f4ff13c3dbc0e9916b74bb4855f"><td class="memItemLeft" align="right" valign="top"><a id="a8bc59f4ff13c3dbc0e9916b74bb4855f"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>onGetFrameCount</b> ()</td></tr>
<tr class="separator:a8bc59f4ff13c3dbc0e9916b74bb4855f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae0e4b7b36e3643a8e886c4c7a85593"><td class="memItemLeft" align="right" valign="top"><a id="a3ae0e4b7b36e3643a8e886c4c7a85593"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>onGetFrameInfo</b> (int, <a class="el" href="struct_sk_codec_1_1_frame_info.html">FrameInfo</a> *) const</td></tr>
<tr class="separator:a3ae0e4b7b36e3643a8e886c4c7a85593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcff3cf2d9174695328fd3a27a37f7a"><td class="memItemLeft" align="right" valign="top"><a id="a6dcff3cf2d9174695328fd3a27a37f7a"></a>
virtual int&#160;</td><td class="memItemRight" valign="bottom"><b>onGetRepetitionCount</b> ()</td></tr>
<tr class="separator:a6dcff3cf2d9174695328fd3a27a37f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a1820206d2680c26ce73132f9a0c5350b"><td class="memItemLeft" align="right" valign="top"><a id="a1820206d2680c26ce73132f9a0c5350b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>DM::CodecSrc</b></td></tr>
<tr class="separator:a1820206d2680c26ce73132f9a0c5350b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2deb5590aca86113255c90b4eb83be4b"><td class="memItemLeft" align="right" valign="top"><a id="a2deb5590aca86113255c90b4eb83be4b"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkSampledCodec</b></td></tr>
<tr class="separator:a2deb5590aca86113255c90b4eb83be4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25c2d44ceabc930ced51c55062dfe27"><td class="memItemLeft" align="right" valign="top"><a id="aa25c2d44ceabc930ced51c55062dfe27"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkIcoCodec</b></td></tr>
<tr class="separator:aa25c2d44ceabc930ced51c55062dfe27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a860e3aed81ec6a11fc97b56fb832d6"><td class="memItemLeft" align="right" valign="top"><a id="a0a860e3aed81ec6a11fc97b56fb832d6"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkAndroidCodec</b></td></tr>
<tr class="separator:a0a860e3aed81ec6a11fc97b56fb832d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstraction layer directly on top of an image codec. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ab43dd53de9d731e34e7ce9e42cfad1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab43dd53de9d731e34e7ce9e42cfad1f0">&#9670;&nbsp;</a></span>Result</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">SkCodec::Result</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Error codes for various <a class="el" href="class_sk_codec.html">SkCodec</a> methods. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab43dd53de9d731e34e7ce9e42cfad1f0af28b992d9388cc8642654166640ec1f5"></a>kSuccess&#160;</td><td class="fielddoc"><p>General return value for success. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab43dd53de9d731e34e7ce9e42cfad1f0a281db21a336583487cd0bd21a9c4ac7e"></a>kIncompleteInput&#160;</td><td class="fielddoc"><p>The input is incomplete. A partial image was generated. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab43dd53de9d731e34e7ce9e42cfad1f0af58aff50960c54080c1601b94b43420a"></a>kErrorInInput&#160;</td><td class="fielddoc"><p>Like kIncompleteInput, except the input had an error.</p>
<p>If returned from an incremental decode, decoding cannot continue, even with more data. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab43dd53de9d731e34e7ce9e42cfad1f0a02c7eafb6cbb102d5e37da5adb243453"></a>kInvalidConversion&#160;</td><td class="fielddoc"><p>The generator cannot convert to match the request, ignoring dimensions. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab43dd53de9d731e34e7ce9e42cfad1f0a0f22b10314f4485a95b8de52c85c62e9"></a>kInvalidScale&#160;</td><td class="fielddoc"><p>The generator cannot scale to requested size. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab43dd53de9d731e34e7ce9e42cfad1f0aa164f152463ccb4d3eba3979de1d729b"></a>kInvalidParameters&#160;</td><td class="fielddoc"><p>Parameters (besides info) are invalid. e.g. NULL pixels, rowBytes too small, etc. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab43dd53de9d731e34e7ce9e42cfad1f0a9b5d53c120a6aa375a3226d23f1a77fb"></a>kInvalidInput&#160;</td><td class="fielddoc"><p>The input did not contain a valid image. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab43dd53de9d731e34e7ce9e42cfad1f0aa749a4b6013200f97e945ee7d2029a10"></a>kCouldNotRewind&#160;</td><td class="fielddoc"><p>Fulfilling this request requires rewinding the input, which is not supported for this input. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab43dd53de9d731e34e7ce9e42cfad1f0aa3976b51cdb453b2b9a0a25621f58be0"></a>kInternalError&#160;</td><td class="fielddoc"><p>An internal error, such as OOM. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab43dd53de9d731e34e7ce9e42cfad1f0abaeee713abd66d9a77ff5696a73d8805"></a>kUnimplemented&#160;</td><td class="fielddoc"><p>This method is not implemented by this codec. FIXME: Perhaps this should be kUnsupported? </p>
</td></tr>
</table>

</div>
</div>
<a id="ab54f614159c048c5fc7065e3558e966e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54f614159c048c5fc7065e3558e966e">&#9670;&nbsp;</a></span>SelectionPolicy</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_codec.html#ab54f614159c048c5fc7065e3558e966e">SkCodec::SelectionPolicy</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For container formats that contain both still images and image sequences, instruct the decoder how the output should be selected. (Refer to comments for each value for more details.) </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab54f614159c048c5fc7065e3558e966ea5136a0dddb26f4ca4844b54ca82fad5d"></a>kPreferStillImage&#160;</td><td class="fielddoc"><p>If the container format contains both still images and image sequences, <a class="el" href="class_sk_codec.html">SkCodec</a> should choose one of the still images. This is the default. </p>
</td></tr>
<tr><td class="fieldname"><a id="ab54f614159c048c5fc7065e3558e966ea9c4e30992ac98b63be20b56930376d7f"></a>kPreferAnimation&#160;</td><td class="fielddoc"><p>If the container format contains both still images and image sequences, <a class="el" href="class_sk_codec.html">SkCodec</a> should choose one of the image sequences for animation. </p>
</td></tr>
</table>

</div>
</div>
<a id="a77847b2f814711a4e08d1d10147bb884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77847b2f814711a4e08d1d10147bb884">&#9670;&nbsp;</a></span>SkScanlineOrder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_codec.html#a77847b2f814711a4e08d1d10147bb884">SkCodec::SkScanlineOrder</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The order in which rows are output from the scanline decoder is not the same for all variations of all image types. This explains the possible output row orderings. </p>

</div>
</div>
<a id="a63868ae492c5effb2196d3f40f5b8ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63868ae492c5effb2196d3f40f5b8ad8">&#9670;&nbsp;</a></span>ZeroInitialized</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_codec.html#a63868ae492c5effb2196d3f40f5b8ad8">SkCodec::ZeroInitialized</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Whether or not the memory passed to getPixels is zero initialized. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a63868ae492c5effb2196d3f40f5b8ad8a174e9e42ebf13bdec44f5676438872f5"></a>kYes_ZeroInitialized&#160;</td><td class="fielddoc"><p>The memory passed to getPixels is zero initialized. The <a class="el" href="class_sk_codec.html">SkCodec</a> may take advantage of this by skipping writing zeroes. </p>
</td></tr>
<tr><td class="fieldname"><a id="a63868ae492c5effb2196d3f40f5b8ad8a5e57df28301694970868c2c9196bc4c9"></a>kNo_ZeroInitialized&#160;</td><td class="fielddoc"><p>The memory passed to getPixels has not been initialized to zero, so the <a class="el" href="class_sk_codec.html">SkCodec</a> must write all zeroes to memory.</p>
<p>This is the default. It will be used if no <a class="el" href="struct_sk_codec_1_1_options.html">Options</a> struct is used. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9a9fad3de001df07534d56c80b785be5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9fad3de001df07534d56c80b785be5">&#9670;&nbsp;</a></span>conversionSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkCodec::conversionSupported </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>srcIsOpaque</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>needsColorXform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether we can convert to dst.</p>
<p>Will be called for the appropriate frame, prior to initializing the colorXform. </p>

</div>
</div>
<a id="a932c2f4ce92c8e7683514de6145d3e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932c2f4ce92c8e7683514de6145d3e11">&#9670;&nbsp;</a></span>currScanline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SkCodec::currScanline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of scanlines that have been decoded so far. This is unaffected by the SkScanlineOrder.</p>
<p>Returns -1 if we have not started a scanline decode. </p>

</div>
</div>
<a id="aa7573e6b32c540dfc3f67b9eaeef1bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7573e6b32c540dfc3f67b9eaeef1bd5">&#9670;&nbsp;</a></span>getEncodedFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkEncodedImageFormat SkCodec::getEncodedFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Format of the encoded data. </p>

</div>
</div>
<a id="a82806b5f7b331a4152cc529703afdf2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82806b5f7b331a4152cc529703afdf2b">&#9670;&nbsp;</a></span>getFrameCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SkCodec::getFrameCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of frames in the image.</p>
<p>May require reading through the stream. </p>

</div>
</div>
<a id="a10d73b25fe06bdbc28a62abf7bc8ea66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d73b25fe06bdbc28a62abf7bc8ea66">&#9670;&nbsp;</a></span>getFrameInfo() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_sk_codec_1_1_frame_info.html">FrameInfo</a>&gt; SkCodec::getFrameInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return info about all the frames in the image.</p>
<p>May require reading through the stream to determine info about the frames (including the count).</p>
<p>As such, future decoding calls may require a rewind.</p>
<p>For still (non-animated) image codecs, this will return an empty vector. </p>

</div>
</div>
<a id="a0365f020979f47404572d0e0e85e42f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0365f020979f47404572d0e0e85e42f4">&#9670;&nbsp;</a></span>getFrameInfo() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCodec::getFrameInfo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sk_codec_1_1_frame_info.html">FrameInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return info about a single frame.</p>
<p>Only supported by multi-frame images. Does not read through the stream, so it should be called after <a class="el" href="class_sk_codec.html#a82806b5f7b331a4152cc529703afdf2b">getFrameCount()</a> to parse any frames that have not already been parsed. </p>

</div>
</div>
<a id="a0f0138a8ac40a3dceddbcbbd5b9215e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0138a8ac40a3dceddbcbbd5b9215e8">&#9670;&nbsp;</a></span>getICCProfile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structskcms___i_c_c_profile.html">skcms_ICCProfile</a>* SkCodec::getICCProfile </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the ICC profile of the encoded data. </p>

</div>
</div>
<a id="aa9f54973c7ea1d57062c3f9d49eea634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f54973c7ea1d57062c3f9d49eea634">&#9670;&nbsp;</a></span>getImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt;<a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_image.html">SkImage</a>&gt;, <a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">SkCodec::Result</a>&gt; SkCodec::getImage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_codec_1_1_options.html">Options</a> *&#160;</td>
          <td class="paramname"><em>opts</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an image containing the pixels. </p>

</div>
</div>
<a id="af08867a592789e9577ae2e7d3933d292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af08867a592789e9577ae2e7d3933d292">&#9670;&nbsp;</a></span>getInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_image_info.html">SkImageInfo</a> SkCodec::getInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reasonable <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> to decode into.</p>
<p>If the image has an ICC profile that does not map to an <a class="el" href="class_sk_color_space.html">SkColorSpace</a>, the returned <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> will use SRGB. </p>

</div>
</div>
<a id="ae4f6e062472900190f71c56be5f43144"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f6e062472900190f71c56be5f43144">&#9670;&nbsp;</a></span>getOrigin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkEncodedOrigin SkCodec::getOrigin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the image orientation stored in the EXIF data. If there is no EXIF data, or if we cannot read the EXIF data, returns kTopLeft. </p>

</div>
</div>
<a id="a6d622127e713e0f623e9defebca4f773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d622127e713e0f623e9defebca4f773">&#9670;&nbsp;</a></span>getPixels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a> SkCodec::getPixels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simplified version of <a class="el" href="class_sk_codec.html#affddeb85741238d2a275cedf1f627da5">getPixels()</a> that uses the default <a class="el" href="struct_sk_codec_1_1_options.html">Options</a>. </p>

</div>
</div>
<a id="affddeb85741238d2a275cedf1f627da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affddeb85741238d2a275cedf1f627da5">&#9670;&nbsp;</a></span>getPixels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a> SkCodec::getPixels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_codec_1_1_options.html">Options</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decode into the given pixels, a block of memory of size at least (info.fHeight - 1) * rowBytes + (info.fWidth * bytesPerPixel)</p>
<p>Repeated calls to this function should give the same results, allowing the PixelRef to be immutable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>A description of the format (config, size) expected by the caller. This can simply be identical to the info returned by <a class="el" href="class_sk_codec.html#af08867a592789e9577ae2e7d3933d292">getInfo()</a>.</td></tr>
  </table>
  </dd>
</dl>
<p>This contract also allows the caller to specify different output-configs, which the implementation can decide to support or not.</p>
<p>A size that does not match <a class="el" href="class_sk_codec.html#af08867a592789e9577ae2e7d3933d292">getInfo()</a> implies a request to scale. If the generator cannot perform this scale, it will return kInvalidScale.</p>
<p>If the info contains a non-null <a class="el" href="class_sk_color_space.html">SkColorSpace</a>, the codec will perform the appropriate color space transformation.</p>
<p>If the caller passes in the <a class="el" href="class_sk_color_space.html">SkColorSpace</a> that maps to the ICC profile reported by <a class="el" href="class_sk_codec.html#a0f0138a8ac40a3dceddbcbbd5b9215e8">getICCProfile()</a>, the color space transformation is a no-op.</p>
<p>If the caller passes a null <a class="el" href="class_sk_color_space.html">SkColorSpace</a>, no color space transformation will be done.</p>
<p>If a scanline decode is in progress, scanline mode will end, requiring the client to call <a class="el" href="class_sk_codec.html#a952a6ca87c12d4c2482bd54c4eda1ba9">startScanlineDecode()</a> in order to return to decoding scanlines.</p>
<dl class="section return"><dt>Returns</dt><dd>Result kSuccess, or another value explaining the type of failure. </dd></dl>

</div>
</div>
<a id="a3b34fa67ae57bca7dc50c717d7cdad09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b34fa67ae57bca7dc50c717d7cdad09">&#9670;&nbsp;</a></span>getRepetitionCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SkCodec::getRepetitionCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of times to repeat, if this image is animated. This number does not include the first play through of each frame. For example, a repetition count of 4 means that each frame is played 5 times and then the animation stops.</p>
<p>It can return kRepetitionCountInfinite, a negative number, meaning that the animation should loop forever.</p>
<p>May require reading the stream to find the repetition count.</p>
<p>As such, future decoding calls may require a rewind.</p>
<p>For still (non-animated) image codecs, this will return 0. </p>

</div>
</div>
<a id="ac4729235361cb7f387688c9ac40b79f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4729235361cb7f387688c9ac40b79f3">&#9670;&nbsp;</a></span>getScaledDimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_i_size.html">SkISize</a> SkCodec::getScaledDimensions </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>desiredScale</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a size that approximately supports the desired scale factor. The codec may not be able to scale efficiently to the exact scale factor requested, so return a size that approximates that scale. The returned value is the codec's suggestion for the closest valid scale that it can natively support </p>

</div>
</div>
<a id="a960496ac4d6f886b99878aaeb0901a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960496ac4d6f886b99878aaeb0901a5e">&#9670;&nbsp;</a></span>getScanlineOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_codec.html#a77847b2f814711a4e08d1d10147bb884">SkScanlineOrder</a> SkCodec::getScanlineOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An enum representing the order in which scanlines will be returned by the scanline decoder.</p>
<p>This is undefined before <a class="el" href="class_sk_codec.html#a952a6ca87c12d4c2482bd54c4eda1ba9">startScanlineDecode()</a> is called. </p>

</div>
</div>
<a id="a05d129c55ba6889be63c790918a0e374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d129c55ba6889be63c790918a0e374">&#9670;&nbsp;</a></span>getScanlines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SkCodec::getScanlines </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>countLines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the next countLines scanlines into dst.</p>
<p>Not valid to call before calling <a class="el" href="class_sk_codec.html#a952a6ca87c12d4c2482bd54c4eda1ba9">startScanlineDecode()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>Must be non-null, and large enough to hold countLines scanlines of size rowBytes. </td></tr>
    <tr><td class="paramname">countLines</td><td>Number of lines to write. </td></tr>
    <tr><td class="paramname">rowBytes</td><td>Number of bytes per row. Must be large enough to hold a scanline based on the <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> used to create this object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of lines successfully decoded. If this value is less than countLines, this will fill the remaining lines with a default value. </dd></dl>

</div>
</div>
<a id="a1da8966fb6dabd6584f955c0f5e70aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da8966fb6dabd6584f955c0f5e70aee">&#9670;&nbsp;</a></span>getValidSubset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCodec::getValidSubset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_i_rect.html">SkIRect</a> *&#160;</td>
          <td class="paramname"><em>desiredSubset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return (via desiredSubset) a subset which can decoded from this codec, or false if this codec cannot decode subsets or anything similar to desiredSubset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desiredSubset</td><td>In/out parameter. As input, a desired subset of the original bounds (as specified by getInfo). If true is returned, desiredSubset may have been modified to a subset which is supported. Although a particular change may have been made to desiredSubset to create something supported, it is possible other changes could result in a valid subset. If false is returned, desiredSubset's value is undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this codec supports decoding desiredSubset (as returned, potentially modified) </dd></dl>

</div>
</div>
<a id="a3fa230b3f5cfd8baf4e12778c7264fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fa230b3f5cfd8baf4e12778c7264fd2">&#9670;&nbsp;</a></span>getYUVAPlanes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a> SkCodec::getYUVAPlanes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_y_u_v_a_pixmaps.html">SkYUVAPixmaps</a> &amp;&#160;</td>
          <td class="paramname"><em>yuvaPixmaps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns kSuccess, or another value explaining the type of failure. This always attempts to perform a full decode. To get the planar configuration without decoding use <a class="el" href="class_sk_codec.html#a4fa1d1b5ac807579b98bf56678c87e7b">queryYUVAInfo()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yuvaPixmaps</td><td>Contains preallocated pixmaps configured according to a successful call to <a class="el" href="class_sk_codec.html#a4fa1d1b5ac807579b98bf56678c87e7b">queryYUVAInfo()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9da5958ea146f27a624285cbd4e280ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da5958ea146f27a624285cbd4e280ad">&#9670;&nbsp;</a></span>incrementalDecode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a> SkCodec::incrementalDecode </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rowsDecoded</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start/continue the incremental decode.</p>
<p>Not valid to call before a call to <a class="el" href="class_sk_codec.html#adc8b46291b91638c58391665f7a96b5b">startIncrementalDecode()</a> returns kSuccess.</p>
<p>If kIncompleteInput is returned, may be called again after more data has been provided to the source <a class="el" href="class_sk_stream.html">SkStream</a>.</p>
<p>Unlike getPixels and getScanlines, this does not do any filling. This is left up to the caller, since they may be skipping lines or continuing the decode later. In the latter case, they may choose to initialize all lines first, or only initialize the remaining lines after the first call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowsDecoded</td><td>Optional output variable returning the total number of lines initialized. Only meaningful if this method returns kIncompleteInput. Otherwise the implementation may not set it. Note that some implementations may have initialized this many rows, but not necessarily finished those rows (e.g. interlaced PNG). This may be useful for determining what rows the client needs to initialize. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kSuccess if all lines requested in startIncrementalDecode have been completely decoded. kIncompleteInput otherwise. </dd></dl>

</div>
</div>
<a id="a7dc7c7b794754dfe2302a74553149980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc7c7b794754dfe2302a74553149980">&#9670;&nbsp;</a></span>MakeFromData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="class_sk_codec.html">SkCodec</a>&gt; SkCodec::MakeFromData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this data represents an encoded image that we know how to decode, return an <a class="el" href="class_sk_codec.html">SkCodec</a> that can decode it. Otherwise return NULL.</p>
<p>If the <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> is not NULL then: If the image is not a PNG, the <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> will be ignored. If the image is a PNG, the <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> will be reffed. If the PNG has unknown chunks, the <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> will be used to handle these chunks. <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> will be called to read any unknown chunk at any point during the creation of the codec or the decode. Note that if <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> fails to read a chunk, this could result in a failure to create the codec or a failure to decode the image. If the PNG does not contain unknown chunks, the <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> will not be used or modified. </p>

</div>
</div>
<a id="ab3704593dd81ecd2b5c2962c0687a309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3704593dd81ecd2b5c2962c0687a309">&#9670;&nbsp;</a></span>MakeFromStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="class_sk_codec.html">SkCodec</a>&gt; SkCodec::MakeFromStream </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="class_sk_stream.html">SkStream</a> &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a> *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_codec.html#ab54f614159c048c5fc7065e3558e966e">SelectionPolicy</a>&#160;</td>
          <td class="paramname"><em>selectionPolicy</em> = <code><a class="el" href="class_sk_codec.html#ab54f614159c048c5fc7065e3558e966ea5136a0dddb26f4ca4844b54ca82fad5d">SelectionPolicy::kPreferStillImage</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this stream represents an encoded image that we know how to decode, return an <a class="el" href="class_sk_codec.html">SkCodec</a> that can decode it. Otherwise return NULL.</p>
<p>As stated above, this call must be able to peek or read MinBufferedBytesNeeded to determine the correct format, and then start reading from the beginning. First it will attempt to peek, and it assumes that if less than MinBufferedBytesNeeded bytes (but more than zero) are returned, this is because the stream is shorter than this, so falling back to reading would not provide more data. If peek() returns zero bytes, this call will instead attempt to read(). This will require that the stream can be rewind()ed.</p>
<p>If Result is not NULL, it will be set to either kSuccess if an <a class="el" href="class_sk_codec.html">SkCodec</a> is returned or a reason for the failure if NULL is returned.</p>
<p>If <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> is not NULL, take a ref and pass it to libpng if the image is a png.</p>
<p>If the <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> is not NULL then: If the image is not a PNG, the <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> will be ignored. If the image is a PNG, the <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> will be reffed. If the PNG has unknown chunks, the <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> will be used to handle these chunks. <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> will be called to read any unknown chunk at any point during the creation of the codec or the decode. Note that if <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> fails to read a chunk, this could result in a failure to create the codec or a failure to decode the image. If the PNG does not contain unknown chunks, the <a class="el" href="class_sk_png_chunk_reader.html">SkPngChunkReader</a> will not be used or modified.</p>
<p>If NULL is returned, the stream is deleted immediately. Otherwise, the <a class="el" href="class_sk_codec.html">SkCodec</a> takes ownership of it, and will delete it when done with it. </p>

</div>
</div>
<a id="a619e4149e0eeda445f561f1d850d70e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a619e4149e0eeda445f561f1d850d70e9">&#9670;&nbsp;</a></span>MinBufferedBytesNeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr size_t SkCodec::MinBufferedBytesNeeded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Minimum number of bytes that must be buffered in <a class="el" href="class_sk_stream.html">SkStream</a> input.</p>
<p>An <a class="el" href="class_sk_stream.html">SkStream</a> passed to NewFromStream must be able to use this many bytes to determine the image type. Then the same <a class="el" href="class_sk_stream.html">SkStream</a> must be passed to the correct decoder to read from the beginning.</p>
<p>This can be accomplished by implementing peek() to support peeking this many bytes, or by implementing rewind() to be able to rewind() after reading this many bytes. </p>

</div>
</div>
<a id="af6c8cfaf7754ca3929626a010df66392"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c8cfaf7754ca3929626a010df66392">&#9670;&nbsp;</a></span>nextScanline()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SkCodec::nextScanline </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the y-coordinate of the next row to be returned by the scanline decoder.</p>
<p>This will equal fCurrScanline, except in the case of strangely encoded image types (bottom-up bmps).</p>
<p>Results are undefined when not in scanline decoding mode. </p>

</div>
</div>
<a id="a4eca650de18970858729e32bad46f70f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eca650de18970858729e32bad46f70f">&#9670;&nbsp;</a></span>onDimensionsSupported()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkCodec::onDimensionsSupported </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_size.html">SkISize</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subclasses should override if they support dimensions other than the srcInfo's. </p>

</div>
</div>
<a id="a058da1d38eac36ad2165e47758e0adca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058da1d38eac36ad2165e47758e0adca">&#9670;&nbsp;</a></span>onGetPixels()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a> SkCodec::onGetPixels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_codec_1_1_options.html">Options</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rowsDecoded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rowsDecoded</td><td>When the encoded image stream is incomplete, this function will return kIncompleteInput and rowsDecoded will be set to the number of scanlines that were successfully decoded. This will allow <a class="el" href="class_sk_codec.html#affddeb85741238d2a275cedf1f627da5">getPixels()</a> to fill the uninitialized memory. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4f0e3e7003c6a5ca380a13be9bd71c86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f0e3e7003c6a5ca380a13be9bd71c86">&#9670;&nbsp;</a></span>onGetScanlineOrder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_sk_codec.html#a77847b2f814711a4e08d1d10147bb884">SkScanlineOrder</a> SkCodec::onGetScanlineOrder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The remaining functions revolve around decoding scanlines. Most images types will be kTopDown and will not need to override this function. </p>

</div>
</div>
<a id="a13f3174541928a80dfe8ec3ac9d555a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f3174541928a80dfe8ec3ac9d555a9">&#9670;&nbsp;</a></span>onRewind()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool SkCodec::onRewind </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called by rewindIfNeeded, if the stream needed to be rewound.</p>
<p>Subclasses should do any set up needed after a rewind. </p>

</div>
</div>
<a id="ad81cd31a6144db8eddf7b96246a1ec08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81cd31a6144db8eddf7b96246a1ec08">&#9670;&nbsp;</a></span>outputScanline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SkCodec::outputScanline </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>inputScanline</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the output y-coordinate of the row that corresponds to an input y-coordinate. The input y-coordinate represents where the scanline is located in the encoded data.</p>
<p>This will equal inputScanline, except in the case of strangely encoded image types (bottom-up bmps, interlaced gifs). </p>

</div>
</div>
<a id="a4fa1d1b5ac807579b98bf56678c87e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa1d1b5ac807579b98bf56678c87e7b">&#9670;&nbsp;</a></span>queryYUVAInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCodec::queryYUVAInfo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_y_u_v_a_pixmap_info_1_1_supported_data_types.html">SkYUVAPixmapInfo::SupportedDataTypes</a> &amp;&#160;</td>
          <td class="paramname"><em>supportedDataTypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_y_u_v_a_pixmap_info.html">SkYUVAPixmapInfo</a> *&#160;</td>
          <td class="paramname"><em>yuvaPixmapInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If decoding to YUV is supported, this returns true. Otherwise, this returns false and the caller will ignore output parameter yuvaPixmapInfo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">supportedDataTypes</td><td>Indicates the data type/planar config combinations that are supported by the caller. If the generator supports decoding to YUV(A), but not as a type in supportedDataTypes, this method returns false. </td></tr>
    <tr><td class="paramname">yuvaPixmapInfo</td><td>Output parameter that specifies the planar configuration, subsampling, orientation, chroma siting, plane color types, and row bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7733c4d013384bfec645aa0c9c8249e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7733c4d013384bfec645aa0c9c8249e">&#9670;&nbsp;</a></span>ResultToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const char* SkCodec::ResultToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Readable string representing the error code. </p>

</div>
</div>
<a id="a7030ce3cb132ac1653a6b6ba3cf46e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7030ce3cb132ac1653a6b6ba3cf46e26">&#9670;&nbsp;</a></span>rewindIfNeeded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SK_WARN_UNUSED_RESULT SkCodec::rewindIfNeeded </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the stream was previously read, attempt to rewind.</p>
<p>If the stream needed to be rewound, call onRewind. </p><dl class="section return"><dt>Returns</dt><dd>true if the codec is at the right position and can be used. false if there was a failure to rewind.</dd></dl>
<p>This is called by <a class="el" href="class_sk_codec.html#affddeb85741238d2a275cedf1f627da5">getPixels()</a>, getYUV8Planes(), <a class="el" href="class_sk_codec.html#adc8b46291b91638c58391665f7a96b5b">startIncrementalDecode()</a> and <a class="el" href="class_sk_codec.html#a952a6ca87c12d4c2482bd54c4eda1ba9">startScanlineDecode()</a>. Subclasses may call if they need to rewind at another time. </p>

</div>
</div>
<a id="af07efc4311f76f25535969998b2d2377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07efc4311f76f25535969998b2d2377">&#9670;&nbsp;</a></span>skipScanlines()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCodec::skipScanlines </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>countLines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Skip count scanlines.</p>
<p>Not valid to call before calling <a class="el" href="class_sk_codec.html#a952a6ca87c12d4c2482bd54c4eda1ba9">startScanlineDecode()</a>.</p>
<p>The default version just calls onGetScanlines and discards the dst. NOTE: If skipped lines are the only lines with alpha, this default will make reallyHasAlpha return true, when it could have returned false.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the scanlines were successfully skipped false on failure, possible reasons for failure include: An incomplete input image stream. Calling this function before calling <a class="el" href="class_sk_codec.html#a952a6ca87c12d4c2482bd54c4eda1ba9">startScanlineDecode()</a>. If countLines is less than zero or so large that it moves the current scanline past the end of the image. </dd></dl>

</div>
</div>
<a id="adc8b46291b91638c58391665f7a96b5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8b46291b91638c58391665f7a96b5b">&#9670;&nbsp;</a></span>startIncrementalDecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a> SkCodec::startIncrementalDecode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>dstInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_codec_1_1_options.html">Options</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepare for an incremental decode with the specified options.</p>
<p>This may require a rewind.</p>
<p>If kIncompleteInput is returned, may be called again after more data has been provided to the source <a class="el" href="class_sk_stream.html">SkStream</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstInfo</td><td>Info of the destination. If the dimensions do not match those of getInfo, this implies a scale. </td></tr>
    <tr><td class="paramname">dst</td><td>Memory to write to. Needs to be large enough to hold the subset, if present, or the full image as described in dstInfo. </td></tr>
    <tr><td class="paramname">options</td><td>Contains decoding options, including if memory is zero initialized and whether to decode a subset. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enum representing success or reason for failure. </dd></dl>

</div>
</div>
<a id="ade349e283630bdf80d816e89f0d250cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade349e283630bdf80d816e89f0d250cb">&#9670;&nbsp;</a></span>startScanlineDecode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a> SkCodec::startScanlineDecode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>dstInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simplified version of <a class="el" href="class_sk_codec.html#a952a6ca87c12d4c2482bd54c4eda1ba9">startScanlineDecode()</a> that uses the default <a class="el" href="struct_sk_codec_1_1_options.html">Options</a>. </p>

</div>
</div>
<a id="a952a6ca87c12d4c2482bd54c4eda1ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a952a6ca87c12d4c2482bd54c4eda1ba9">&#9670;&nbsp;</a></span>startScanlineDecode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_codec.html#ab43dd53de9d731e34e7ce9e42cfad1f0">Result</a> SkCodec::startScanlineDecode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>dstInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_codec_1_1_options.html">Options</a> *&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The remaining functions revolve around decoding scanlines. Prepare for a scanline decode with the specified options.</p>
<p>After this call, this class will be ready to decode the first scanline.</p>
<p>This must be called in order to call getScanlines or skipScanlines.</p>
<p>This may require rewinding the stream.</p>
<p>Not all SkCodecs support this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstInfo</td><td>Info of the destination. If the dimensions do not match those of getInfo, this implies a scale. </td></tr>
    <tr><td class="paramname">options</td><td>Contains decoding options, including if memory is zero initialized. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Enum representing success or reason for failure. </dd></dl>

</div>
</div>
<a id="adae675dae4722d5bcadfe93bf6f8ab42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adae675dae4722d5bcadfe93bf6f8ab42">&#9670;&nbsp;</a></span>stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_stream.html">SkStream</a>* SkCodec::stream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get method for the input stream </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/include/codec/<a class="el" href="_sk_codec_8h_source.html">SkCodec.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
