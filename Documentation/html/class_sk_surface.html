<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: SkSurface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_sk_surface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SkSurface Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_sk_surface_8h_source.html">SkSurface.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SkSurface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_sk_surface.png" usemap="#SkSurface_map" alt=""/>
  <map id="SkSurface_map" name="SkSurface_map">
<area href="class_sk_ref_cnt.html" alt="SkRefCnt" shape="rect" coords="0,56,92,80"/>
<area href="class_sk_ref_cnt_base.html" alt="SkRefCntBase" shape="rect" coords="0,0,92,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a09e73a19d8d3d1ea85c38a515fc48538"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a09e73a19d8d3d1ea85c38a515fc48538">ContentChangeMode</a> { <a class="el" href="class_sk_surface.html#a09e73a19d8d3d1ea85c38a515fc48538a14b5a82c953bee6eb475b860005ae341">kDiscard_ContentChangeMode</a>, 
<a class="el" href="class_sk_surface.html#a09e73a19d8d3d1ea85c38a515fc48538a61df574700828a9f039c6cd8ec4c39df">kRetain_ContentChangeMode</a>
 }</td></tr>
<tr class="separator:a09e73a19d8d3d1ea85c38a515fc48538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68c874f3e621291d54c5b62f3165209"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209">BackendHandleAccess</a> { <a class="el" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209a2061b9bbc92672b5168fbd018b47ec7a">kFlushRead_BackendHandleAccess</a>, 
<a class="el" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209a2c2b35a88238afbf7e7b79ff52048db4">kFlushWrite_BackendHandleAccess</a>, 
<a class="el" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209a265463cfb4ba17bb7948556f12c73b95">kDiscardWrite_BackendHandleAccess</a>
 }</td></tr>
<tr class="separator:ae68c874f3e621291d54c5b62f3165209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfaaa14115fc8fcb3e6074e3d9240c21"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#acfaaa14115fc8fcb3e6074e3d9240c21">BackendSurfaceAccess</a> { <a class="el" href="class_sk_surface.html#acfaaa14115fc8fcb3e6074e3d9240c21af5d6f15f85f8db76149a52e2f4a2aa70">BackendSurfaceAccess::kNoAccess</a>, 
<a class="el" href="class_sk_surface.html#acfaaa14115fc8fcb3e6074e3d9240c21a019665dfbd21bc633282967ea7b6d5b8">BackendSurfaceAccess::kPresent</a>
 }</td></tr>
<tr class="separator:acfaaa14115fc8fcb3e6074e3d9240c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91b4f130cbb53ecde3a1d9261eadc54"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#ae91b4f130cbb53ecde3a1d9261eadc54">ReleaseContext</a></td></tr>
<tr class="separator:ae91b4f130cbb53ecde3a1d9261eadc54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45233f6282af6774d6175485cc327e0c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a45233f6282af6774d6175485cc327e0c">RenderTargetReleaseProc</a>) (<a class="el" href="class_sk_surface.html#ae91b4f130cbb53ecde3a1d9261eadc54">ReleaseContext</a> releaseContext)</td></tr>
<tr class="separator:a45233f6282af6774d6175485cc327e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e552eaf3124ef4e6fbb3490b321ea60"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a0e552eaf3124ef4e6fbb3490b321ea60">TextureReleaseProc</a>) (<a class="el" href="class_sk_surface.html#ae91b4f130cbb53ecde3a1d9261eadc54">ReleaseContext</a> releaseContext)</td></tr>
<tr class="separator:a0e552eaf3124ef4e6fbb3490b321ea60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adeb48872dbe98ea996ac682edf95eb"><td class="memItemLeft" align="right" valign="top"><a id="a4adeb48872dbe98ea996ac682edf95eb"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>AsyncReadResult</b> = <a class="el" href="class_sk_image_1_1_async_read_result.html">SkImage::AsyncReadResult</a></td></tr>
<tr class="separator:a4adeb48872dbe98ea996ac682edf95eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af503b9dfb01853ec8baf91953d750d20"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#af503b9dfb01853ec8baf91953d750d20">ReadPixelsContext</a> = void *</td></tr>
<tr class="separator:af503b9dfb01853ec8baf91953d750d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238d34561a4e6ac34b037135cff08555"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a238d34561a4e6ac34b037135cff08555">ReadPixelsCallback</a> = void(<a class="el" href="class_sk_surface.html#af503b9dfb01853ec8baf91953d750d20">ReadPixelsContext</a>, std::unique_ptr&lt; const <a class="el" href="class_sk_image_1_1_async_read_result.html">AsyncReadResult</a> &gt;)</td></tr>
<tr class="separator:a238d34561a4e6ac34b037135cff08555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bfc34aaf34209ab66e083c1f284cd41"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a6bfc34aaf34209ab66e083c1f284cd41">RescaleGamma</a> = SkImage::RescaleGamma</td></tr>
<tr class="separator:a6bfc34aaf34209ab66e083c1f284cd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91fe86f1ecced96979cbd18a8e69d810"><td class="memItemLeft" align="right" valign="top"><a id="a91fe86f1ecced96979cbd18a8e69d810"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>RescaleMode</b> = SkImage::RescaleMode</td></tr>
<tr class="separator:a91fe86f1ecced96979cbd18a8e69d810"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a68f8dfb17ce83f40180acefb844c6352"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a68f8dfb17ce83f40180acefb844c6352">isCompatible</a> (const <a class="el" href="class_sk_surface_characterization.html">SkSurfaceCharacterization</a> &amp;characterization) const</td></tr>
<tr class="separator:a68f8dfb17ce83f40180acefb844c6352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351ef72e03fba91865a321e8e081a842"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a351ef72e03fba91865a321e8e081a842">width</a> () const</td></tr>
<tr class="separator:a351ef72e03fba91865a321e8e081a842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa30771352bbeb37532669127fa16494e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#aa30771352bbeb37532669127fa16494e">height</a> () const</td></tr>
<tr class="separator:aa30771352bbeb37532669127fa16494e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f86fa89d5cf1706c31d10c8845c2000"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_image_info.html">SkImageInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a2f86fa89d5cf1706c31d10c8845c2000">imageInfo</a> ()</td></tr>
<tr class="separator:a2f86fa89d5cf1706c31d10c8845c2000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af977ef6c5da6bc9b95747e5961672433"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#af977ef6c5da6bc9b95747e5961672433">generationID</a> ()</td></tr>
<tr class="separator:af977ef6c5da6bc9b95747e5961672433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae577c5cac83c670f87c51eddab87aa9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#ae577c5cac83c670f87c51eddab87aa9f">notifyContentWillChange</a> (<a class="el" href="class_sk_surface.html#a09e73a19d8d3d1ea85c38a515fc48538">ContentChangeMode</a> mode)</td></tr>
<tr class="separator:ae577c5cac83c670f87c51eddab87aa9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e10b31a98c0b93e6d6fb23b32b8519f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a7e10b31a98c0b93e6d6fb23b32b8519f">recordingContext</a> ()</td></tr>
<tr class="separator:a7e10b31a98c0b93e6d6fb23b32b8519f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285a711149f69823597c3763eab03dd1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a285a711149f69823597c3763eab03dd1">getBackendTexture</a> (<a class="el" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209">BackendHandleAccess</a> backendHandleAccess)</td></tr>
<tr class="separator:a285a711149f69823597c3763eab03dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e996e7dafe610f933830c22196eff1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_gr_backend_render_target.html">GrBackendRenderTarget</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a38e996e7dafe610f933830c22196eff1">getBackendRenderTarget</a> (<a class="el" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209">BackendHandleAccess</a> backendHandleAccess)</td></tr>
<tr class="separator:a38e996e7dafe610f933830c22196eff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6335b4e9e654c197aa9802bf74facc5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a6335b4e9e654c197aa9802bf74facc5b">replaceBackendTexture</a> (const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;backendTexture, GrSurfaceOrigin origin, <a class="el" href="class_sk_surface.html#a09e73a19d8d3d1ea85c38a515fc48538">ContentChangeMode</a> mode=<a class="el" href="class_sk_surface.html#a09e73a19d8d3d1ea85c38a515fc48538a61df574700828a9f039c6cd8ec4c39df">kRetain_ContentChangeMode</a>, <a class="el" href="class_sk_surface.html#a0e552eaf3124ef4e6fbb3490b321ea60">TextureReleaseProc</a> textureReleaseProc=nullptr, <a class="el" href="class_sk_surface.html#ae91b4f130cbb53ecde3a1d9261eadc54">ReleaseContext</a> releaseContext=nullptr)</td></tr>
<tr class="separator:a6335b4e9e654c197aa9802bf74facc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedab202bc98dad9a0d089b85274435aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_canvas.html">SkCanvas</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#aedab202bc98dad9a0d089b85274435aa">getCanvas</a> ()</td></tr>
<tr class="separator:aedab202bc98dad9a0d089b85274435aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ed11229ed16cbb2b9d377deac2ca08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a56ed11229ed16cbb2b9d377deac2ca08">makeSurface</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;<a class="el" href="class_sk_surface.html#a2f86fa89d5cf1706c31d10c8845c2000">imageInfo</a>)</td></tr>
<tr class="separator:a56ed11229ed16cbb2b9d377deac2ca08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925f99aeda52481cdedc9bc5e24ea57a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a925f99aeda52481cdedc9bc5e24ea57a">makeSurface</a> (int <a class="el" href="class_sk_surface.html#a351ef72e03fba91865a321e8e081a842">width</a>, int <a class="el" href="class_sk_surface.html#aa30771352bbeb37532669127fa16494e">height</a>)</td></tr>
<tr class="separator:a925f99aeda52481cdedc9bc5e24ea57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0831e582fff299df12786801fbd2bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_image.html">SkImage</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a9e0831e582fff299df12786801fbd2bf">makeImageSnapshot</a> ()</td></tr>
<tr class="separator:a9e0831e582fff299df12786801fbd2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b4058c4d8708cae31993d41f7c377f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_image.html">SkImage</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#af6b4058c4d8708cae31993d41f7c377f">makeImageSnapshot</a> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;bounds)</td></tr>
<tr class="separator:af6b4058c4d8708cae31993d41f7c377f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df6eac244797f29fedd501ce66e4b8c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a6df6eac244797f29fedd501ce66e4b8c">draw</a> (<a class="el" href="class_sk_canvas.html">SkCanvas</a> *canvas, SkScalar x, SkScalar y, const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;sampling, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint)</td></tr>
<tr class="separator:a6df6eac244797f29fedd501ce66e4b8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dfe72438211bcb0d0c3139ad36fba4"><td class="memItemLeft" align="right" valign="top"><a id="a85dfe72438211bcb0d0c3139ad36fba4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>draw</b> (<a class="el" href="class_sk_canvas.html">SkCanvas</a> *canvas, SkScalar x, SkScalar y, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint=nullptr)</td></tr>
<tr class="separator:a85dfe72438211bcb0d0c3139ad36fba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de5913a3bca21fccd77e92755b26432"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a8de5913a3bca21fccd77e92755b26432">peekPixels</a> (<a class="el" href="class_sk_pixmap.html">SkPixmap</a> *pixmap)</td></tr>
<tr class="separator:a8de5913a3bca21fccd77e92755b26432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fe3696a898f644c0b3136d94771588"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#af3fe3696a898f644c0b3136d94771588">readPixels</a> (const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> &amp;dst, int srcX, int srcY)</td></tr>
<tr class="separator:af3fe3696a898f644c0b3136d94771588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbe87fec06fb10cc5f2ea34b6bff55e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a1fbe87fec06fb10cc5f2ea34b6bff55e">readPixels</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;dstInfo, void *dstPixels, size_t dstRowBytes, int srcX, int srcY)</td></tr>
<tr class="separator:a1fbe87fec06fb10cc5f2ea34b6bff55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf11d4d743be6d2d94007e8d923c987c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#abf11d4d743be6d2d94007e8d923c987c">readPixels</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;dst, int srcX, int srcY)</td></tr>
<tr class="separator:abf11d4d743be6d2d94007e8d923c987c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757d32ec2ef6749a848e6b6510c6ff52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a757d32ec2ef6749a848e6b6510c6ff52">asyncRescaleAndReadPixels</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;info, const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;srcRect, <a class="el" href="class_sk_surface.html#a6bfc34aaf34209ab66e083c1f284cd41">RescaleGamma</a> rescaleGamma, RescaleMode rescaleMode, <a class="el" href="class_sk_surface.html#a238d34561a4e6ac34b037135cff08555">ReadPixelsCallback</a> callback, <a class="el" href="class_sk_surface.html#af503b9dfb01853ec8baf91953d750d20">ReadPixelsContext</a> context)</td></tr>
<tr class="separator:a757d32ec2ef6749a848e6b6510c6ff52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac733f55bd42631443bc4332902c65ab4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#ac733f55bd42631443bc4332902c65ab4">asyncRescaleAndReadPixelsYUV420</a> (SkYUVColorSpace yuvColorSpace, <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_color_space.html">SkColorSpace</a> &gt; dstColorSpace, const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;srcRect, const <a class="el" href="struct_sk_i_size.html">SkISize</a> &amp;dstSize, <a class="el" href="class_sk_surface.html#a6bfc34aaf34209ab66e083c1f284cd41">RescaleGamma</a> rescaleGamma, RescaleMode rescaleMode, <a class="el" href="class_sk_surface.html#a238d34561a4e6ac34b037135cff08555">ReadPixelsCallback</a> callback, <a class="el" href="class_sk_surface.html#af503b9dfb01853ec8baf91953d750d20">ReadPixelsContext</a> context)</td></tr>
<tr class="separator:ac733f55bd42631443bc4332902c65ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22a0f49d435f78820918fbf06c0dd61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#ae22a0f49d435f78820918fbf06c0dd61">writePixels</a> (const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> &amp;src, int dstX, int dstY)</td></tr>
<tr class="separator:ae22a0f49d435f78820918fbf06c0dd61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a898652100042350bce30cb348c781"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a59a898652100042350bce30cb348c781">writePixels</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;src, int dstX, int dstY)</td></tr>
<tr class="separator:a59a898652100042350bce30cb348c781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3c4c19cc65a7eb602cb196b1c40556"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a0a3c4c19cc65a7eb602cb196b1c40556">props</a> () const</td></tr>
<tr class="separator:a0a3c4c19cc65a7eb602cb196b1c40556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b204d1ac715f3c6efe29ed4576517ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a0b204d1ac715f3c6efe29ed4576517ec">flushAndSubmit</a> (bool syncCpu=false)</td></tr>
<tr class="separator:a0b204d1ac715f3c6efe29ed4576517ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63598d1fc23ac43eb4e39ae330fb7af"><td class="memItemLeft" align="right" valign="top">GrSemaphoresSubmitted&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#ac63598d1fc23ac43eb4e39ae330fb7af">flush</a> (<a class="el" href="class_sk_surface.html#acfaaa14115fc8fcb3e6074e3d9240c21">BackendSurfaceAccess</a> <a class="el" href="structaccess.html">access</a>, const <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a> &amp;info)</td></tr>
<tr class="separator:ac63598d1fc23ac43eb4e39ae330fb7af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e98a032ac0291743ad97a3b54db6b22"><td class="memItemLeft" align="right" valign="top">GrSemaphoresSubmitted&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a7e98a032ac0291743ad97a3b54db6b22">flush</a> (const <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a> &amp;info, const <a class="el" href="class_gr_backend_surface_mutable_state.html">GrBackendSurfaceMutableState</a> *newState=nullptr)</td></tr>
<tr class="separator:a7e98a032ac0291743ad97a3b54db6b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41ac73b5f6a0a59c9ce1cfb2520c39a"><td class="memItemLeft" align="right" valign="top"><a id="ab41ac73b5f6a0a59c9ce1cfb2520c39a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>flush</b> ()</td></tr>
<tr class="separator:ab41ac73b5f6a0a59c9ce1cfb2520c39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf60b11a45f03386aecc5f673d36bac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#aebf60b11a45f03386aecc5f673d36bac">wait</a> (int numSemaphores, const <a class="el" href="class_gr_backend_semaphore.html">GrBackendSemaphore</a> *waitSemaphores, bool deleteSemaphoresAfterWait=true)</td></tr>
<tr class="separator:aebf60b11a45f03386aecc5f673d36bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffe89cb0d9217a40223e0d37abd28b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a0ffe89cb0d9217a40223e0d37abd28b0">characterize</a> (<a class="el" href="class_sk_surface_characterization.html">SkSurfaceCharacterization</a> *characterization) const</td></tr>
<tr class="separator:a0ffe89cb0d9217a40223e0d37abd28b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa135fac4a1536ef0885b0279eb7382c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#aa135fac4a1536ef0885b0279eb7382c7">draw</a> (<a class="el" href="classsk__sp.html">sk_sp</a>&lt; const <a class="el" href="class_sk_deferred_display_list.html">SkDeferredDisplayList</a> &gt; deferredDisplayList, int xOffset=0, int yOffset=0)</td></tr>
<tr class="separator:aa135fac4a1536ef0885b0279eb7382c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_sk_ref_cnt_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_sk_ref_cnt_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_sk_ref_cnt_base.html">SkRefCntBase</a></td></tr>
<tr class="memitem:a5a774880256081e9e5cf33c8cf7ea9bc inherit pub_methods_class_sk_ref_cnt_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_ref_cnt_base.html#a5a774880256081e9e5cf33c8cf7ea9bc">SkRefCntBase</a> ()</td></tr>
<tr class="separator:a5a774880256081e9e5cf33c8cf7ea9bc inherit pub_methods_class_sk_ref_cnt_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0afdb3774d0e065874ecb0d0a288b83 inherit pub_methods_class_sk_ref_cnt_base"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_ref_cnt_base.html#ad0afdb3774d0e065874ecb0d0a288b83">~SkRefCntBase</a> ()</td></tr>
<tr class="separator:ad0afdb3774d0e065874ecb0d0a288b83 inherit pub_methods_class_sk_ref_cnt_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae058eee2ac4793db6bd663e59a235ce7 inherit pub_methods_class_sk_ref_cnt_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_ref_cnt_base.html#ae058eee2ac4793db6bd663e59a235ce7">unique</a> () const</td></tr>
<tr class="separator:ae058eee2ac4793db6bd663e59a235ce7 inherit pub_methods_class_sk_ref_cnt_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbbd318b36c9e232c70488254e1f5e67 inherit pub_methods_class_sk_ref_cnt_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_ref_cnt_base.html#abbbd318b36c9e232c70488254e1f5e67">ref</a> () const</td></tr>
<tr class="separator:abbbd318b36c9e232c70488254e1f5e67 inherit pub_methods_class_sk_ref_cnt_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed65f99f91ef48a7892fafe4829d2f1 inherit pub_methods_class_sk_ref_cnt_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_ref_cnt_base.html#afed65f99f91ef48a7892fafe4829d2f1">unref</a> () const</td></tr>
<tr class="separator:afed65f99f91ef48a7892fafe4829d2f1 inherit pub_methods_class_sk_ref_cnt_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af025ece3e61fea154e5bc303f76e78b1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#af025ece3e61fea154e5bc303f76e78b1">MakeRasterDirect</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;<a class="el" href="class_sk_surface.html#a2f86fa89d5cf1706c31d10c8845c2000">imageInfo</a>, void *pixels, size_t rowBytes, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *surfaceProps=nullptr)</td></tr>
<tr class="separator:af025ece3e61fea154e5bc303f76e78b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83da5d273aca02285c5a07a5af18ce81"><td class="memItemLeft" align="right" valign="top"><a id="a83da5d273aca02285c5a07a5af18ce81"></a>
static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>MakeRasterDirect</b> (const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> &amp;pm, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *<a class="el" href="class_sk_surface.html#a0a3c4c19cc65a7eb602cb196b1c40556">props</a>=nullptr)</td></tr>
<tr class="separator:a83da5d273aca02285c5a07a5af18ce81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa000cb9fdcb3b5ec5bf92408fd0df3a0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#aa000cb9fdcb3b5ec5bf92408fd0df3a0">MakeRasterDirectReleaseProc</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;<a class="el" href="class_sk_surface.html#a2f86fa89d5cf1706c31d10c8845c2000">imageInfo</a>, void *pixels, size_t rowBytes, void(*releaseProc)(void *pixels, void *context), void *context, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *surfaceProps=nullptr)</td></tr>
<tr class="separator:aa000cb9fdcb3b5ec5bf92408fd0df3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ed88112b3622f7a7474e9e2b771004"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#ae4ed88112b3622f7a7474e9e2b771004">MakeRaster</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;<a class="el" href="class_sk_surface.html#a2f86fa89d5cf1706c31d10c8845c2000">imageInfo</a>, size_t rowBytes, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *surfaceProps)</td></tr>
<tr class="separator:ae4ed88112b3622f7a7474e9e2b771004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b9671ebd493fdb8185e118d7691c50"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a99b9671ebd493fdb8185e118d7691c50">MakeRaster</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;<a class="el" href="class_sk_surface.html#a2f86fa89d5cf1706c31d10c8845c2000">imageInfo</a>, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *<a class="el" href="class_sk_surface.html#a0a3c4c19cc65a7eb602cb196b1c40556">props</a>=nullptr)</td></tr>
<tr class="separator:a99b9671ebd493fdb8185e118d7691c50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ac34d6cf6f05d76db8d27b3e811e01c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a8ac34d6cf6f05d76db8d27b3e811e01c">MakeRasterN32Premul</a> (int <a class="el" href="class_sk_surface.html#a351ef72e03fba91865a321e8e081a842">width</a>, int <a class="el" href="class_sk_surface.html#aa30771352bbeb37532669127fa16494e">height</a>, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *surfaceProps=nullptr)</td></tr>
<tr class="separator:a8ac34d6cf6f05d76db8d27b3e811e01c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d1d58f5e13f77d94697d6e408cdfad"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a71d1d58f5e13f77d94697d6e408cdfad">MakeFromBackendTexture</a> (<a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> *context, const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;backendTexture, GrSurfaceOrigin origin, int sampleCnt, SkColorType colorType, <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_color_space.html">SkColorSpace</a> &gt; colorSpace, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *surfaceProps, <a class="el" href="class_sk_surface.html#a0e552eaf3124ef4e6fbb3490b321ea60">TextureReleaseProc</a> textureReleaseProc=nullptr, <a class="el" href="class_sk_surface.html#ae91b4f130cbb53ecde3a1d9261eadc54">ReleaseContext</a> releaseContext=nullptr)</td></tr>
<tr class="separator:a71d1d58f5e13f77d94697d6e408cdfad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5ba93640ce8e65a7cb401d5554e84c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a5e5ba93640ce8e65a7cb401d5554e84c">MakeFromBackendRenderTarget</a> (<a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> *context, const <a class="el" href="class_gr_backend_render_target.html">GrBackendRenderTarget</a> &amp;backendRenderTarget, GrSurfaceOrigin origin, SkColorType colorType, <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_color_space.html">SkColorSpace</a> &gt; colorSpace, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *surfaceProps, <a class="el" href="class_sk_surface.html#a45233f6282af6774d6175485cc327e0c">RenderTargetReleaseProc</a> releaseProc=nullptr, <a class="el" href="class_sk_surface.html#ae91b4f130cbb53ecde3a1d9261eadc54">ReleaseContext</a> releaseContext=nullptr)</td></tr>
<tr class="separator:a5e5ba93640ce8e65a7cb401d5554e84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32278bea58b9f229190c45b59f01548"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#aa32278bea58b9f229190c45b59f01548">MakeRenderTarget</a> (<a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> *context, <a class="el" href="_sk_types_8h.html#a66f73362220ea988583a7980b6634374">SkBudgeted</a> budgeted, const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;<a class="el" href="class_sk_surface.html#a2f86fa89d5cf1706c31d10c8845c2000">imageInfo</a>, int sampleCount, GrSurfaceOrigin surfaceOrigin, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *surfaceProps, bool shouldCreateWithMips=false)</td></tr>
<tr class="separator:aa32278bea58b9f229190c45b59f01548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71929ad95b166b7b98df684056724e1e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a71929ad95b166b7b98df684056724e1e">MakeRenderTarget</a> (<a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> *context, <a class="el" href="_sk_types_8h.html#a66f73362220ea988583a7980b6634374">SkBudgeted</a> budgeted, const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;<a class="el" href="class_sk_surface.html#a2f86fa89d5cf1706c31d10c8845c2000">imageInfo</a>, int sampleCount, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *surfaceProps)</td></tr>
<tr class="separator:a71929ad95b166b7b98df684056724e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad836deaf72354a6eebe21565e9906f67"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#ad836deaf72354a6eebe21565e9906f67">MakeRenderTarget</a> (<a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> *context, <a class="el" href="_sk_types_8h.html#a66f73362220ea988583a7980b6634374">SkBudgeted</a> budgeted, const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;<a class="el" href="class_sk_surface.html#a2f86fa89d5cf1706c31d10c8845c2000">imageInfo</a>)</td></tr>
<tr class="separator:ad836deaf72354a6eebe21565e9906f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13494920609f783f66d3246a6ea26236"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a13494920609f783f66d3246a6ea26236">MakeRenderTarget</a> (<a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> *context, const <a class="el" href="class_sk_surface_characterization.html">SkSurfaceCharacterization</a> &amp;characterization, <a class="el" href="_sk_types_8h.html#a66f73362220ea988583a7980b6634374">SkBudgeted</a> budgeted)</td></tr>
<tr class="separator:a13494920609f783f66d3246a6ea26236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eed158c914df86a8855919974421a3f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a8eed158c914df86a8855919974421a3f">MakeNull</a> (int <a class="el" href="class_sk_surface.html#a351ef72e03fba91865a321e8e081a842">width</a>, int <a class="el" href="class_sk_surface.html#aa30771352bbeb37532669127fa16494e">height</a>)</td></tr>
<tr class="separator:a8eed158c914df86a8855919974421a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a87371ae0497a248a1f9567950670b709"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209">BackendHandleAccess</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a87371ae0497a248a1f9567950670b709">kFlushRead_TextureHandleAccess</a></td></tr>
<tr class="separator:a87371ae0497a248a1f9567950670b709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c51fc4193e7e91806b109af59d242f"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209">BackendHandleAccess</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a13c51fc4193e7e91806b109af59d242f">kFlushWrite_TextureHandleAccess</a></td></tr>
<tr class="separator:a13c51fc4193e7e91806b109af59d242f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff636605c412060f5ffe6bc0a5039e1"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209">BackendHandleAccess</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_surface.html#a1ff636605c412060f5ffe6bc0a5039e1">kDiscardWrite_TextureHandleAccess</a></td></tr>
<tr class="separator:a1ff636605c412060f5ffe6bc0a5039e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae1561ab052cb86c3718ffa152c869cd3"><td class="memItemLeft" align="right" valign="top"><a id="ae1561ab052cb86c3718ffa152c869cd3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SkSurface</b> (int <a class="el" href="class_sk_surface.html#a351ef72e03fba91865a321e8e081a842">width</a>, int <a class="el" href="class_sk_surface.html#aa30771352bbeb37532669127fa16494e">height</a>, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *surfaceProps)</td></tr>
<tr class="separator:ae1561ab052cb86c3718ffa152c869cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d28ffb38af5890b1c353e768bcfebec"><td class="memItemLeft" align="right" valign="top"><a id="a9d28ffb38af5890b1c353e768bcfebec"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SkSurface</b> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;<a class="el" href="class_sk_surface.html#a2f86fa89d5cf1706c31d10c8845c2000">imageInfo</a>, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *surfaceProps)</td></tr>
<tr class="separator:a9d28ffb38af5890b1c353e768bcfebec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b2bdea7327716d78b5d690fbeb99f0"><td class="memItemLeft" align="right" valign="top"><a id="a03b2bdea7327716d78b5d690fbeb99f0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dirtyGenerationID</b> ()</td></tr>
<tr class="separator:a03b2bdea7327716d78b5d690fbeb99f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_sk_surface.html">SkSurface</a> is responsible for managing the pixels that a canvas draws into. The pixels can be allocated either in CPU memory (a raster surface) or on the GPU (a GrRenderTarget surface). <a class="el" href="class_sk_surface.html">SkSurface</a> takes care of allocating a <a class="el" href="class_sk_canvas.html">SkCanvas</a> that will draw into the surface. Call surface-&gt;<a class="el" href="class_sk_surface.html#aedab202bc98dad9a0d089b85274435aa">getCanvas()</a> to use that canvas (but don't delete it, it is owned by the surface). <a class="el" href="class_sk_surface.html">SkSurface</a> always has non-zero dimensions. If there is a request for a new surface, and either of the requested dimensions are zero, then nullptr will be returned. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a238d34561a4e6ac34b037135cff08555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238d34561a4e6ac34b037135cff08555">&#9670;&nbsp;</a></span>ReadPixelsCallback</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_sk_surface.html#a238d34561a4e6ac34b037135cff08555">SkSurface::ReadPixelsCallback</a> =  void(<a class="el" href="class_sk_surface.html#af503b9dfb01853ec8baf91953d750d20">ReadPixelsContext</a>, std::unique_ptr&lt;const <a class="el" href="class_sk_image_1_1_async_read_result.html">AsyncReadResult</a>&gt;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Client-provided callback to <a class="el" href="class_sk_surface.html#a757d32ec2ef6749a848e6b6510c6ff52">asyncRescaleAndReadPixels()</a> or <a class="el" href="class_sk_surface.html#ac733f55bd42631443bc4332902c65ab4">asyncRescaleAndReadPixelsYUV420()</a> that is called when read result is ready or on failure. </p>

</div>
</div>
<a id="af503b9dfb01853ec8baf91953d750d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af503b9dfb01853ec8baf91953d750d20">&#9670;&nbsp;</a></span>ReadPixelsContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_sk_surface.html#af503b9dfb01853ec8baf91953d750d20">SkSurface::ReadPixelsContext</a> =  void*</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Client-provided context that is passed to client-provided ReadPixelsContext. </p>

</div>
</div>
<a id="ae91b4f130cbb53ecde3a1d9261eadc54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae91b4f130cbb53ecde3a1d9261eadc54">&#9670;&nbsp;</a></span>ReleaseContext</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="class_sk_surface.html#ae91b4f130cbb53ecde3a1d9261eadc54">SkSurface::ReleaseContext</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Caller data passed to RenderTarget/TextureReleaseProc; may be nullptr. </p>

</div>
</div>
<a id="a45233f6282af6774d6175485cc327e0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45233f6282af6774d6175485cc327e0c">&#9670;&nbsp;</a></span>RenderTargetReleaseProc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SkSurface::RenderTargetReleaseProc) (<a class="el" href="class_sk_surface.html#ae91b4f130cbb53ecde3a1d9261eadc54">ReleaseContext</a> releaseContext)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>User function called when supplied render target may be deleted. </p>

</div>
</div>
<a id="a6bfc34aaf34209ab66e083c1f284cd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bfc34aaf34209ab66e083c1f284cd41">&#9670;&nbsp;</a></span>RescaleGamma</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using SkSurface::RescaleGamma =  SkImage::RescaleGamma</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls the gamma that rescaling occurs in for <a class="el" href="class_sk_surface.html#a757d32ec2ef6749a848e6b6510c6ff52">asyncRescaleAndReadPixels()</a> and <a class="el" href="class_sk_surface.html#ac733f55bd42631443bc4332902c65ab4">asyncRescaleAndReadPixelsYUV420()</a>. </p>

</div>
</div>
<a id="a0e552eaf3124ef4e6fbb3490b321ea60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e552eaf3124ef4e6fbb3490b321ea60">&#9670;&nbsp;</a></span>TextureReleaseProc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* SkSurface::TextureReleaseProc) (<a class="el" href="class_sk_surface.html#ae91b4f130cbb53ecde3a1d9261eadc54">ReleaseContext</a> releaseContext)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>User function called when supplied texture may be deleted. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ae68c874f3e621291d54c5b62f3165209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68c874f3e621291d54c5b62f3165209">&#9670;&nbsp;</a></span>BackendHandleAccess</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209">SkSurface::BackendHandleAccess</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae68c874f3e621291d54c5b62f3165209a2061b9bbc92672b5168fbd018b47ec7a"></a>kFlushRead_BackendHandleAccess&#160;</td><td class="fielddoc"><p>back-end object is readable </p>
</td></tr>
<tr><td class="fieldname"><a id="ae68c874f3e621291d54c5b62f3165209a2c2b35a88238afbf7e7b79ff52048db4"></a>kFlushWrite_BackendHandleAccess&#160;</td><td class="fielddoc"><p>back-end object is writable </p>
</td></tr>
<tr><td class="fieldname"><a id="ae68c874f3e621291d54c5b62f3165209a265463cfb4ba17bb7948556f12c73b95"></a>kDiscardWrite_BackendHandleAccess&#160;</td><td class="fielddoc"><p>back-end object must be overwritten </p>
</td></tr>
</table>

</div>
</div>
<a id="acfaaa14115fc8fcb3e6074e3d9240c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfaaa14115fc8fcb3e6074e3d9240c21">&#9670;&nbsp;</a></span>BackendSurfaceAccess</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_surface.html#acfaaa14115fc8fcb3e6074e3d9240c21">SkSurface::BackendSurfaceAccess</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acfaaa14115fc8fcb3e6074e3d9240c21af5d6f15f85f8db76149a52e2f4a2aa70"></a>kNoAccess&#160;</td><td class="fielddoc"><p>back-end object will not be used by client </p>
</td></tr>
<tr><td class="fieldname"><a id="acfaaa14115fc8fcb3e6074e3d9240c21a019665dfbd21bc633282967ea7b6d5b8"></a>kPresent&#160;</td><td class="fielddoc"><p>back-end surface will be used for presenting to screen </p>
</td></tr>
</table>

</div>
</div>
<a id="a09e73a19d8d3d1ea85c38a515fc48538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09e73a19d8d3d1ea85c38a515fc48538">&#9670;&nbsp;</a></span>ContentChangeMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_surface.html#a09e73a19d8d3d1ea85c38a515fc48538">SkSurface::ContentChangeMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a09e73a19d8d3d1ea85c38a515fc48538a14b5a82c953bee6eb475b860005ae341"></a>kDiscard_ContentChangeMode&#160;</td><td class="fielddoc"><p>discards surface on change </p>
</td></tr>
<tr><td class="fieldname"><a id="a09e73a19d8d3d1ea85c38a515fc48538a61df574700828a9f039c6cd8ec4c39df"></a>kRetain_ContentChangeMode&#160;</td><td class="fielddoc"><p>preserves surface on change </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a757d32ec2ef6749a848e6b6510c6ff52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757d32ec2ef6749a848e6b6510c6ff52">&#9670;&nbsp;</a></span>asyncRescaleAndReadPixels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkSurface::asyncRescaleAndReadPixels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>srcRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#a6bfc34aaf34209ab66e083c1f284cd41">RescaleGamma</a>&#160;</td>
          <td class="paramname"><em>rescaleGamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RescaleMode&#160;</td>
          <td class="paramname"><em>rescaleMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#a238d34561a4e6ac34b037135cff08555">ReadPixelsCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#af503b9dfb01853ec8baf91953d750d20">ReadPixelsContext</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes surface pixel data available to caller, possibly asynchronously. It can also rescale the surface pixels.</p>
<p>Currently asynchronous reads are only supported on the GPU backend and only when the underlying 3D API supports transfer buffers and CPU/GPU synchronization primitives. In all other cases this operates synchronously.</p>
<p>Data is read from the source sub-rectangle, is optionally converted to a linear gamma, is rescaled to the size indicated by 'info', is then converted to the color space, color type, and alpha type of 'info'. A 'srcRect' that is not contained by the bounds of the surface causes failure.</p>
<p>When the pixel data is ready the caller's ReadPixelsCallback is called with a AsyncReadResult containing pixel data in the requested color type, alpha type, and color space. The AsyncReadResult will have count() == 1. Upon failure the callback is called with nullptr for AsyncReadResult. For a GPU surface this flushes work but a submit must occur to guarantee a finite time before the callback is called.</p>
<p>The data is valid for the lifetime of AsyncReadResult with the exception that if the <a class="el" href="class_sk_surface.html">SkSurface</a> is GPU-backed the data is immediately invalidated if the context is abandoned or destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>info of the requested pixels </td></tr>
    <tr><td class="paramname">srcRect</td><td>subrectangle of surface to read </td></tr>
    <tr><td class="paramname">rescaleGamma</td><td>controls whether rescaling is done in the surface's gamma or whether the source data is transformed to a linear gamma before rescaling. </td></tr>
    <tr><td class="paramname">rescaleMode</td><td>controls the technique of the rescaling </td></tr>
    <tr><td class="paramname">callback</td><td>function to call with result of the read </td></tr>
    <tr><td class="paramname">context</td><td>passed to callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac733f55bd42631443bc4332902c65ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac733f55bd42631443bc4332902c65ab4">&#9670;&nbsp;</a></span>asyncRescaleAndReadPixelsYUV420()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkSurface::asyncRescaleAndReadPixelsYUV420 </td>
          <td>(</td>
          <td class="paramtype">SkYUVColorSpace&#160;</td>
          <td class="paramname"><em>yuvColorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_color_space.html">SkColorSpace</a> &gt;&#160;</td>
          <td class="paramname"><em>dstColorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>srcRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_size.html">SkISize</a> &amp;&#160;</td>
          <td class="paramname"><em>dstSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#a6bfc34aaf34209ab66e083c1f284cd41">RescaleGamma</a>&#160;</td>
          <td class="paramname"><em>rescaleGamma</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RescaleMode&#160;</td>
          <td class="paramname"><em>rescaleMode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#a238d34561a4e6ac34b037135cff08555">ReadPixelsCallback</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#af503b9dfb01853ec8baf91953d750d20">ReadPixelsContext</a>&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to asyncRescaleAndReadPixels but performs an additional conversion to YUV. The RGB-&gt;YUV conversion is controlled by 'yuvColorSpace'. The YUV data is returned as three planes ordered y, u, v. The u and v planes are half the width and height of the resized rectangle. The y, u, and v values are single bytes. Currently this fails if 'dstSize' width and height are not even. A 'srcRect' that is not contained by the bounds of the surface causes failure.</p>
<p>When the pixel data is ready the caller's ReadPixelsCallback is called with a AsyncReadResult containing the planar data. The AsyncReadResult will have count() == 3. Upon failure the callback is called with nullptr for AsyncReadResult. For a GPU surface this flushes work but a submit must occur to guarantee a finite time before the callback is called.</p>
<p>The data is valid for the lifetime of AsyncReadResult with the exception that if the <a class="el" href="class_sk_surface.html">SkSurface</a> is GPU-backed the data is immediately invalidated if the context is abandoned or destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">yuvColorSpace</td><td>The transformation from RGB to YUV. Applied to the resized image after it is converted to dstColorSpace. </td></tr>
    <tr><td class="paramname">dstColorSpace</td><td>The color space to convert the resized image to, after rescaling. </td></tr>
    <tr><td class="paramname">srcRect</td><td>The portion of the surface to rescale and convert to YUV planes. </td></tr>
    <tr><td class="paramname">dstSize</td><td>The size to rescale srcRect to </td></tr>
    <tr><td class="paramname">rescaleGamma</td><td>controls whether rescaling is done in the surface's gamma or whether the source data is transformed to a linear gamma before rescaling. </td></tr>
    <tr><td class="paramname">rescaleMode</td><td>controls the sampling technique of the rescaling </td></tr>
    <tr><td class="paramname">callback</td><td>function to call with the planar read result </td></tr>
    <tr><td class="paramname">context</td><td>passed to callback </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ffe89cb0d9217a40223e0d37abd28b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffe89cb0d9217a40223e0d37abd28b0">&#9670;&nbsp;</a></span>characterize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkSurface::characterize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_surface_characterization.html">SkSurfaceCharacterization</a> *&#160;</td>
          <td class="paramname"><em>characterization</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes <a class="el" href="class_sk_surface_characterization.html">SkSurfaceCharacterization</a> that can be used to perform GPU back-end processing in a separate thread. Typically this is used to divide drawing into multiple tiles. <a class="el" href="class_sk_deferred_display_list_recorder.html">SkDeferredDisplayListRecorder</a> records the drawing commands for each tile.</p>
<p>Return true if <a class="el" href="class_sk_surface.html">SkSurface</a> supports characterization. raster surface returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">characterization</td><td>properties for parallel drawing </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if supported</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_characterize">https://fiddle.skia.org/c/@Surface_characterize</a> </p>

</div>
</div>
<a id="aa135fac4a1536ef0885b0279eb7382c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa135fac4a1536ef0885b0279eb7382c7">&#9670;&nbsp;</a></span>draw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkSurface::draw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; const <a class="el" href="class_sk_deferred_display_list.html">SkDeferredDisplayList</a> &gt;&#160;</td>
          <td class="paramname"><em>deferredDisplayList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>yOffset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws the deferred display list created via a <a class="el" href="class_sk_deferred_display_list_recorder.html">SkDeferredDisplayListRecorder</a>. If the deferred display list is not compatible with this <a class="el" href="class_sk_surface.html">SkSurface</a>, the draw is skipped and false is return.</p>
<p>The xOffset and yOffset parameters are experimental and, if not both zero, will cause the draw to be ignored. When implemented, if xOffset or yOffset are non-zero, the DDL will be drawn offset by that amount into the surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deferredDisplayList</td><td>drawing commands </td></tr>
    <tr><td class="paramname">xOffset</td><td>x-offset at which to draw the DDL </td></tr>
    <tr><td class="paramname">yOffset</td><td>y-offset at which to draw the DDL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if deferredDisplayList is not compatible</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_draw_2">https://fiddle.skia.org/c/@Surface_draw_2</a> </p>

</div>
</div>
<a id="a6df6eac244797f29fedd501ce66e4b8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df6eac244797f29fedd501ce66e4b8c">&#9670;&nbsp;</a></span>draw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkSurface::draw </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html">SkCanvas</a> *&#160;</td>
          <td class="paramname"><em>canvas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>sampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_surface.html">SkSurface</a> contents to canvas, with its top-left corner at (x, y).</p>
<p>If <a class="el" href="class_sk_paint.html">SkPaint</a> paint is not nullptr, apply <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, alpha, <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>, and SkBlendMode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canvas</td><td><a class="el" href="class_sk_canvas.html">SkCanvas</a> drawn into </td></tr>
    <tr><td class="paramname">x</td><td>horizontal offset in <a class="el" href="class_sk_canvas.html">SkCanvas</a> </td></tr>
    <tr><td class="paramname">y</td><td>vertical offset in <a class="el" href="class_sk_canvas.html">SkCanvas</a> </td></tr>
    <tr><td class="paramname">sampling</td><td>what technique to use when sampling the surface pixels </td></tr>
    <tr><td class="paramname">paint</td><td><a class="el" href="class_sk_paint.html">SkPaint</a> containing SkBlendMode, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>, and so on; or nullptr</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_draw">https://fiddle.skia.org/c/@Surface_draw</a> </p>

</div>
</div>
<a id="ac63598d1fc23ac43eb4e39ae330fb7af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63598d1fc23ac43eb4e39ae330fb7af">&#9670;&nbsp;</a></span>flush() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GrSemaphoresSubmitted SkSurface::flush </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#acfaaa14115fc8fcb3e6074e3d9240c21">BackendSurfaceAccess</a>&#160;</td>
          <td class="paramname"><em>access</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issues pending <a class="el" href="class_sk_surface.html">SkSurface</a> commands to the GPU-backed API objects and resolves any <a class="el" href="class_sk_surface.html">SkSurface</a> MSAA. A call to <a class="el" href="class_gr_direct_context.html#a2e6391e15ee021f864a9d4fbef930732">GrDirectContext::submit</a> is always required to ensure work is actually sent to the gpu. Some specific API details: GL: Commands are actually sent to the driver, but glFlush is never called. Thus some sync objects from the flush will not be valid until a submission occurs.</p>
<p>Vulkan/Metal/D3D/Dawn: Commands are recorded to the backend APIs corresponding command buffer or encoder objects. However, these objects are not sent to the gpu until a submission occurs.</p>
<p>The work that is submitted to the GPU will be dependent on the BackendSurfaceAccess that is passed in.</p>
<p>If <a class="el" href="class_sk_surface.html#acfaaa14115fc8fcb3e6074e3d9240c21af5d6f15f85f8db76149a52e2f4a2aa70" title="back-end object will not be used by client">BackendSurfaceAccess::kNoAccess</a> is passed in all commands will be issued to the GPU.</p>
<p>If <a class="el" href="class_sk_surface.html#acfaaa14115fc8fcb3e6074e3d9240c21a019665dfbd21bc633282967ea7b6d5b8" title="back-end surface will be used for presenting to screen">BackendSurfaceAccess::kPresent</a> is passed in and the backend API is not Vulkan, it is treated the same as kNoAccess. If the backend API is Vulkan, the VkImage that backs the <a class="el" href="class_sk_surface.html">SkSurface</a> will be transferred back to its original queue. If the <a class="el" href="class_sk_surface.html">SkSurface</a> was created by wrapping a VkImage, the queue will be set to the queue which was originally passed in on the <a class="el" href="struct_gr_vk_image_info.html">GrVkImageInfo</a>. Additionally, if the original queue was not external or foreign the layout of the VkImage will be set to VK_IMAGE_LAYOUT_PRESENT_SRC_KHR.</p>
<p>The <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a> describes additional options to flush. Please see documentation at <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a> for more info.</p>
<p>If the return is GrSemaphoresSubmitted::kYes, only initialized GrBackendSemaphores will be submitted to the gpu during the next submit call (it is possible Skia failed to create a subset of the semaphores). The client should not wait on these semaphores until after submit has been called, but must keep them alive until then. If a submit flag was passed in with the flush these valid semaphores can we waited on immediately. If this call returns GrSemaphoresSubmitted::kNo, the GPU backend will not submit any semaphores to be signaled on the GPU. Thus the client should not have the GPU wait on any of the semaphores passed in with the <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a>. Regardless of whether semaphores were submitted to the GPU or not, the client is still responsible for deleting any initialized semaphores. Regardleess of semaphore submission the context will still be flushed. It should be emphasized that a return value of GrSemaphoresSubmitted::kNo does not mean the flush did not happen. It simply means there were no semaphores submitted to the GPU. A caller should only take this as a failure if they passed in semaphores to be submitted.</p>
<p>Pending surface commands are flushed regardless of the return result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">access</td><td>type of access the call will do on the backend object after flush </td></tr>
    <tr><td class="paramname">info</td><td>flush options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e98a032ac0291743ad97a3b54db6b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e98a032ac0291743ad97a3b54db6b22">&#9670;&nbsp;</a></span>flush() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GrSemaphoresSubmitted SkSurface::flush </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_surface_mutable_state.html">GrBackendSurfaceMutableState</a> *&#160;</td>
          <td class="paramname"><em>newState</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issues pending <a class="el" href="class_sk_surface.html">SkSurface</a> commands to the GPU-backed API objects and resolves any <a class="el" href="class_sk_surface.html">SkSurface</a> MSAA. A call to <a class="el" href="class_gr_direct_context.html#a2e6391e15ee021f864a9d4fbef930732">GrDirectContext::submit</a> is always required to ensure work is actually sent to the gpu. Some specific API details: GL: Commands are actually sent to the driver, but glFlush is never called. Thus some sync objects from the flush will not be valid until a submission occurs.</p>
<p>Vulkan/Metal/D3D/Dawn: Commands are recorded to the backend APIs corresponding command buffer or encoder objects. However, these objects are not sent to the gpu until a submission occurs.</p>
<p>The <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a> describes additional options to flush. Please see documentation at <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a> for more info.</p>
<p>If a <a class="el" href="class_gr_backend_surface_mutable_state.html">GrBackendSurfaceMutableState</a> is passed in, at the end of the flush we will transition the surface to be in the state requested by the <a class="el" href="class_gr_backend_surface_mutable_state.html">GrBackendSurfaceMutableState</a>. If the surface (or <a class="el" href="class_sk_image.html">SkImage</a> or GrBackendSurface wrapping the same backend object) is used again after this flush the state may be changed and no longer match what is requested here. This is often used if the surface will be used for presenting or external use and the client wants backend object to be prepped for that use. A finishedProc or semaphore on the <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a> will also include the work for any requested state change.</p>
<p>If the backend API is Vulkan, the caller can set the <a class="el" href="class_gr_backend_surface_mutable_state.html">GrBackendSurfaceMutableState</a>'s VkImageLayout to VK_IMAGE_LAYOUT_UNDEFINED or queueFamilyIndex to VK_QUEUE_FAMILY_IGNORED to tell Skia to not change those respective states.</p>
<p>If the return is GrSemaphoresSubmitted::kYes, only initialized GrBackendSemaphores will be submitted to the gpu during the next submit call (it is possible Skia failed to create a subset of the semaphores). The client should not wait on these semaphores until after submit has been called, but must keep them alive until then. If a submit flag was passed in with the flush these valid semaphores can we waited on immediately. If this call returns GrSemaphoresSubmitted::kNo, the GPU backend will not submit any semaphores to be signaled on the GPU. Thus the client should not have the GPU wait on any of the semaphores passed in with the <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a>. Regardless of whether semaphores were submitted to the GPU or not, the client is still responsible for deleting any initialized semaphores. Regardleess of semaphore submission the context will still be flushed. It should be emphasized that a return value of GrSemaphoresSubmitted::kNo does not mean the flush did not happen. It simply means there were no semaphores submitted to the GPU. A caller should only take this as a failure if they passed in semaphores to be submitted.</p>
<p>Pending surface commands are flushed regardless of the return result.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>flush options </td></tr>
    <tr><td class="paramname">access</td><td>optional state change request after flush </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0b204d1ac715f3c6efe29ed4576517ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b204d1ac715f3c6efe29ed4576517ec">&#9670;&nbsp;</a></span>flushAndSubmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkSurface::flushAndSubmit </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>syncCpu</em> = <code>false</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call to ensure all reads/writes of the surface have been issued to the underlying 3D API. Skia will correctly order its own draws and pixel operations. This must to be used to ensure correct ordering when the surface backing store is accessed outside Skia (e.g. direct use of the 3D API or a windowing system). <a class="el" href="class_gr_direct_context.html">GrDirectContext</a> has additional flush and submit methods that apply to all surfaces and images created from a <a class="el" href="class_gr_direct_context.html">GrDirectContext</a>. This is equivalent to calling <a class="el" href="class_sk_surface.html#ac63598d1fc23ac43eb4e39ae330fb7af">SkSurface::flush</a> with a default <a class="el" href="struct_gr_flush_info.html">GrFlushInfo</a> followed by GrDirectContext::submit(syncCpu). </p>

</div>
</div>
<a id="af977ef6c5da6bc9b95747e5961672433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af977ef6c5da6bc9b95747e5961672433">&#9670;&nbsp;</a></span>generationID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t SkSurface::generationID </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns unique value identifying the content of <a class="el" href="class_sk_surface.html">SkSurface</a>. Returned value changes each time the content changes. Content is changed by drawing, or by calling <a class="el" href="class_sk_surface.html#ae577c5cac83c670f87c51eddab87aa9f">notifyContentWillChange()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>unique content identifier</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_notifyContentWillChange">https://fiddle.skia.org/c/@Surface_notifyContentWillChange</a> </p>

</div>
</div>
<a id="a38e996e7dafe610f933830c22196eff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e996e7dafe610f933830c22196eff1">&#9670;&nbsp;</a></span>getBackendRenderTarget()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_gr_backend_render_target.html">GrBackendRenderTarget</a> SkSurface::getBackendRenderTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209">BackendHandleAccess</a>&#160;</td>
          <td class="paramname"><em>backendHandleAccess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the back-end render target. If <a class="el" href="class_sk_surface.html">SkSurface</a> has no back-end render target, an invalid object is returned. Call GrBackendRenderTarget::isValid to determine if the result is valid.</p>
<p>The returned <a class="el" href="class_gr_backend_render_target.html">GrBackendRenderTarget</a> should be discarded if the <a class="el" href="class_sk_surface.html">SkSurface</a> is drawn to or deleted.</p>
<dl class="section return"><dt>Returns</dt><dd>GPU render target reference; invalid on failure </dd></dl>

</div>
</div>
<a id="a285a711149f69823597c3763eab03dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285a711149f69823597c3763eab03dd1">&#9670;&nbsp;</a></span>getBackendTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> SkSurface::getBackendTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209">BackendHandleAccess</a>&#160;</td>
          <td class="paramname"><em>backendHandleAccess</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the back-end texture. If <a class="el" href="class_sk_surface.html">SkSurface</a> has no back-end texture, an invalid object is returned. Call GrBackendTexture::isValid to determine if the result is valid.</p>
<p>The returned <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> should be discarded if the <a class="el" href="class_sk_surface.html">SkSurface</a> is drawn to or deleted.</p>
<dl class="section return"><dt>Returns</dt><dd>GPU texture reference; invalid on failure </dd></dl>

</div>
</div>
<a id="aedab202bc98dad9a0d089b85274435aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedab202bc98dad9a0d089b85274435aa">&#9670;&nbsp;</a></span>getCanvas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_canvas.html">SkCanvas</a>* SkSurface::getCanvas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <a class="el" href="class_sk_canvas.html">SkCanvas</a> that draws into <a class="el" href="class_sk_surface.html">SkSurface</a>. Subsequent calls return the same <a class="el" href="class_sk_canvas.html">SkCanvas</a>. <a class="el" href="class_sk_canvas.html">SkCanvas</a> returned is managed and owned by <a class="el" href="class_sk_surface.html">SkSurface</a>, and is deleted when <a class="el" href="class_sk_surface.html">SkSurface</a> is deleted.</p>
<dl class="section return"><dt>Returns</dt><dd>drawing <a class="el" href="class_sk_canvas.html">SkCanvas</a> for <a class="el" href="class_sk_surface.html">SkSurface</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_getCanvas">https://fiddle.skia.org/c/@Surface_getCanvas</a> </p>

</div>
</div>
<a id="aa30771352bbeb37532669127fa16494e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa30771352bbeb37532669127fa16494e">&#9670;&nbsp;</a></span>height()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SkSurface::height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns pixel row count; may be zero or greater.</p>
<dl class="section return"><dt>Returns</dt><dd>number of pixel rows </dd></dl>

</div>
</div>
<a id="a2f86fa89d5cf1706c31d10c8845c2000"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f86fa89d5cf1706c31d10c8845c2000">&#9670;&nbsp;</a></span>imageInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_image_info.html">SkImageInfo</a> SkSurface::imageInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an ImageInfo describing the surface. </p>

</div>
</div>
<a id="a68f8dfb17ce83f40180acefb844c6352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f8dfb17ce83f40180acefb844c6352">&#9670;&nbsp;</a></span>isCompatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkSurface::isCompatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_surface_characterization.html">SkSurfaceCharacterization</a> &amp;&#160;</td>
          <td class="paramname"><em>characterization</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is this surface compatible with the provided characterization?</p>
<p>This method can be used to determine if an existing <a class="el" href="class_sk_surface.html">SkSurface</a> is a viable destination for an <a class="el" href="class_sk_deferred_display_list.html">SkDeferredDisplayList</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">characterization</td><td>The characterization for which a compatibility check is desired </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this surface is compatible with the characterization; false otherwise </dd></dl>

</div>
</div>
<a id="a5e5ba93640ce8e65a7cb401d5554e84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5ba93640ce8e65a7cb401d5554e84c">&#9670;&nbsp;</a></span>MakeFromBackendRenderTarget()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_surface.html">SkSurface</a>&gt; SkSurface::MakeFromBackendRenderTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_render_target.html">GrBackendRenderTarget</a> &amp;&#160;</td>
          <td class="paramname"><em>backendRenderTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrSurfaceOrigin&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkColorType&#160;</td>
          <td class="paramname"><em>colorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_color_space.html">SkColorSpace</a> &gt;&#160;</td>
          <td class="paramname"><em>colorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *&#160;</td>
          <td class="paramname"><em>surfaceProps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#a45233f6282af6774d6175485cc327e0c">RenderTargetReleaseProc</a>&#160;</td>
          <td class="paramname"><em>releaseProc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#ae91b4f130cbb53ecde3a1d9261eadc54">ReleaseContext</a>&#160;</td>
          <td class="paramname"><em>releaseContext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wraps a GPU-backed buffer into <a class="el" href="class_sk_surface.html">SkSurface</a>. Caller must ensure backendRenderTarget is valid for the lifetime of returned <a class="el" href="class_sk_surface.html">SkSurface</a>.</p>
<p><a class="el" href="class_sk_surface.html">SkSurface</a> is returned if all parameters are valid. backendRenderTarget is valid if its pixel configuration agrees with colorSpace and context; for instance, if backendRenderTarget has an sRGB configuration, then context must support sRGB, and colorSpace must be present. Further, backendRenderTarget width and height must not exceed context capabilities, and the context must be able to support back-end render targets.</p>
<p>Upon success releaseProc is called when it is safe to delete the render target in the backend API (accounting only for use of the render target by this surface). If <a class="el" href="class_sk_surface.html">SkSurface</a> creation fails releaseProc is called before this function returns.</p>
<p>If SK_SUPPORT_GPU is defined as zero, has no effect and returns nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>GPU context </td></tr>
    <tr><td class="paramname">backendRenderTarget</td><td>GPU intermediate memory buffer </td></tr>
    <tr><td class="paramname">colorSpace</td><td>range of colors </td></tr>
    <tr><td class="paramname">surfaceProps</td><td>LCD striping orientation and setting for device independent fonts; may be nullptr </td></tr>
    <tr><td class="paramname">releaseProc</td><td>function called when backendRenderTarget can be released </td></tr>
    <tr><td class="paramname">releaseContext</td><td>state passed to releaseProc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_surface.html">SkSurface</a> if all parameters are valid; otherwise, nullptr </dd></dl>

</div>
</div>
<a id="a71d1d58f5e13f77d94697d6e408cdfad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d1d58f5e13f77d94697d6e408cdfad">&#9670;&nbsp;</a></span>MakeFromBackendTexture()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_surface.html">SkSurface</a>&gt; SkSurface::MakeFromBackendTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;&#160;</td>
          <td class="paramname"><em>backendTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrSurfaceOrigin&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkColorType&#160;</td>
          <td class="paramname"><em>colorType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_color_space.html">SkColorSpace</a> &gt;&#160;</td>
          <td class="paramname"><em>colorSpace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *&#160;</td>
          <td class="paramname"><em>surfaceProps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#a0e552eaf3124ef4e6fbb3490b321ea60">TextureReleaseProc</a>&#160;</td>
          <td class="paramname"><em>textureReleaseProc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#ae91b4f130cbb53ecde3a1d9261eadc54">ReleaseContext</a>&#160;</td>
          <td class="paramname"><em>releaseContext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wraps a GPU-backed texture into <a class="el" href="class_sk_surface.html">SkSurface</a>. Caller must ensure the texture is valid for the lifetime of returned <a class="el" href="class_sk_surface.html">SkSurface</a>. If sampleCnt greater than zero, creates an intermediate MSAA <a class="el" href="class_sk_surface.html">SkSurface</a> which is used for drawing backendTexture.</p>
<p><a class="el" href="class_sk_surface.html">SkSurface</a> is returned if all parameters are valid. backendTexture is valid if its pixel configuration agrees with colorSpace and context; for instance, if backendTexture has an sRGB configuration, then context must support sRGB, and colorSpace must be present. Further, backendTexture width and height must not exceed context capabilities, and the context must be able to support back-end textures.</p>
<p>Upon success textureReleaseProc is called when it is safe to delete the texture in the backend API (accounting only for use of the texture by this surface). If <a class="el" href="class_sk_surface.html">SkSurface</a> creation fails textureReleaseProc is called before this function returns.</p>
<p>If SK_SUPPORT_GPU is defined as zero, has no effect and returns nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>GPU context </td></tr>
    <tr><td class="paramname">backendTexture</td><td>texture residing on GPU </td></tr>
    <tr><td class="paramname">sampleCnt</td><td>samples per pixel, or 0 to disable full scene anti-aliasing </td></tr>
    <tr><td class="paramname">colorSpace</td><td>range of colors; may be nullptr </td></tr>
    <tr><td class="paramname">surfaceProps</td><td>LCD striping orientation and setting for device independent fonts; may be nullptr </td></tr>
    <tr><td class="paramname">textureReleaseProc</td><td>function called when texture can be released </td></tr>
    <tr><td class="paramname">releaseContext</td><td>state passed to textureReleaseProc </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_surface.html">SkSurface</a> if all parameters are valid; otherwise, nullptr </dd></dl>

</div>
</div>
<a id="a9e0831e582fff299df12786801fbd2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e0831e582fff299df12786801fbd2bf">&#9670;&nbsp;</a></span>makeImageSnapshot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_image.html">SkImage</a>&gt; SkSurface::makeImageSnapshot </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <a class="el" href="class_sk_image.html">SkImage</a> capturing <a class="el" href="class_sk_surface.html">SkSurface</a> contents. Subsequent drawing to <a class="el" href="class_sk_surface.html">SkSurface</a> contents are not captured. <a class="el" href="class_sk_image.html">SkImage</a> allocation is accounted for if <a class="el" href="class_sk_surface.html">SkSurface</a> was created with SkBudgeted::kYes.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_image.html">SkImage</a> initialized with <a class="el" href="class_sk_surface.html">SkSurface</a> contents</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_makeImageSnapshot">https://fiddle.skia.org/c/@Surface_makeImageSnapshot</a> </p>

</div>
</div>
<a id="af6b4058c4d8708cae31993d41f7c377f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b4058c4d8708cae31993d41f7c377f">&#9670;&nbsp;</a></span>makeImageSnapshot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_image.html">SkImage</a>&gt; SkSurface::makeImageSnapshot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the no-parameter version, this returns an image of the current surface contents. This variant takes a rectangle specifying the subset of the surface that is of interest. These bounds will be sanitized before being used.</p><ul>
<li>If bounds extends beyond the surface, it will be trimmed to just the intersection of it and the surface.</li>
<li>If bounds does not intersect the surface, then this returns nullptr.</li>
<li>If bounds == the surface, then this is the same as calling the no-parameter variant.</li>
</ul>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_makeImageSnapshot_2">https://fiddle.skia.org/c/@Surface_makeImageSnapshot_2</a> </p>

</div>
</div>
<a id="a8eed158c914df86a8855919974421a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eed158c914df86a8855919974421a3f">&#9670;&nbsp;</a></span>MakeNull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_surface.html">SkSurface</a>&gt; SkSurface::MakeNull </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="class_sk_surface.html">SkSurface</a> without backing pixels. Drawing to <a class="el" href="class_sk_canvas.html">SkCanvas</a> returned from <a class="el" href="class_sk_surface.html">SkSurface</a> has no effect. Calling <a class="el" href="class_sk_surface.html#a9e0831e582fff299df12786801fbd2bf">makeImageSnapshot()</a> on returned <a class="el" href="class_sk_surface.html">SkSurface</a> returns nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>one or greater </td></tr>
    <tr><td class="paramname">height</td><td>one or greater </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_surface.html">SkSurface</a> if width and height are positive; otherwise, nullptr</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_MakeNull">https://fiddle.skia.org/c/@Surface_MakeNull</a> </p>

</div>
</div>
<a id="a99b9671ebd493fdb8185e118d7691c50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b9671ebd493fdb8185e118d7691c50">&#9670;&nbsp;</a></span>MakeRaster() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_surface.html">SkSurface</a>&gt; SkSurface::MakeRaster </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>imageInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *&#160;</td>
          <td class="paramname"><em>props</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates raster <a class="el" href="class_sk_surface.html">SkSurface</a>. <a class="el" href="class_sk_canvas.html">SkCanvas</a> returned by <a class="el" href="class_sk_surface.html">SkSurface</a> draws directly into pixels. Allocates and zeroes pixel memory. <a class="el" href="struct_pixel.html">Pixel</a> memory size is imageInfo.height() times imageInfo.minRowBytes(). <a class="el" href="struct_pixel.html">Pixel</a> memory is deleted when <a class="el" href="class_sk_surface.html">SkSurface</a> is deleted.</p>
<p><a class="el" href="class_sk_surface.html">SkSurface</a> is returned if all parameters are valid. Valid parameters include: info dimensions are greater than zero; info contains SkColorType and SkAlphaType supported by raster surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageInfo</td><td>width, height, SkColorType, SkAlphaType, <a class="el" href="class_sk_color_space.html">SkColorSpace</a>, of raster surface; width and height must be greater than zero </td></tr>
    <tr><td class="paramname">props</td><td>LCD striping orientation and setting for device independent fonts; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_surface.html">SkSurface</a> if all parameters are valid; otherwise, nullptr </dd></dl>

</div>
</div>
<a id="ae4ed88112b3622f7a7474e9e2b771004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4ed88112b3622f7a7474e9e2b771004">&#9670;&nbsp;</a></span>MakeRaster() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_surface.html">SkSurface</a>&gt; SkSurface::MakeRaster </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>imageInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *&#160;</td>
          <td class="paramname"><em>surfaceProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates raster <a class="el" href="class_sk_surface.html">SkSurface</a>. <a class="el" href="class_sk_canvas.html">SkCanvas</a> returned by <a class="el" href="class_sk_surface.html">SkSurface</a> draws directly into pixels. Allocates and zeroes pixel memory. <a class="el" href="struct_pixel.html">Pixel</a> memory size is imageInfo.height() times rowBytes, or times imageInfo.minRowBytes() if rowBytes is zero. <a class="el" href="struct_pixel.html">Pixel</a> memory is deleted when <a class="el" href="class_sk_surface.html">SkSurface</a> is deleted.</p>
<p><a class="el" href="class_sk_surface.html">SkSurface</a> is returned if all parameters are valid. Valid parameters include: info dimensions are greater than zero; info contains SkColorType and SkAlphaType supported by raster surface; rowBytes is large enough to contain info width pixels of SkColorType, or is zero.</p>
<p>If rowBytes is zero, a suitable value will be chosen internally.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageInfo</td><td>width, height, SkColorType, SkAlphaType, <a class="el" href="class_sk_color_space.html">SkColorSpace</a>, of raster surface; width and height must be greater than zero </td></tr>
    <tr><td class="paramname">rowBytes</td><td>interval from one <a class="el" href="class_sk_surface.html">SkSurface</a> row to the next; may be zero </td></tr>
    <tr><td class="paramname">surfaceProps</td><td>LCD striping orientation and setting for device independent fonts; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_surface.html">SkSurface</a> if all parameters are valid; otherwise, nullptr </dd></dl>

</div>
</div>
<a id="af025ece3e61fea154e5bc303f76e78b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af025ece3e61fea154e5bc303f76e78b1">&#9670;&nbsp;</a></span>MakeRasterDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_surface.html">SkSurface</a>&gt; SkSurface::MakeRasterDirect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>imageInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *&#160;</td>
          <td class="paramname"><em>surfaceProps</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates raster <a class="el" href="class_sk_surface.html">SkSurface</a>. <a class="el" href="class_sk_canvas.html">SkCanvas</a> returned by <a class="el" href="class_sk_surface.html">SkSurface</a> draws directly into pixels.</p>
<p><a class="el" href="class_sk_surface.html">SkSurface</a> is returned if all parameters are valid. Valid parameters include: info dimensions are greater than zero; info contains SkColorType and SkAlphaType supported by raster surface; pixels is not nullptr; rowBytes is large enough to contain info width pixels of SkColorType.</p>
<p><a class="el" href="struct_pixel.html">Pixel</a> buffer size should be info height times computed rowBytes. Pixels are not initialized. To access pixels after drawing, <a class="el" href="class_sk_surface.html#a8de5913a3bca21fccd77e92755b26432">peekPixels()</a> or <a class="el" href="class_sk_surface.html#af3fe3696a898f644c0b3136d94771588">readPixels()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageInfo</td><td>width, height, SkColorType, SkAlphaType, <a class="el" href="class_sk_color_space.html">SkColorSpace</a>, of raster surface; width and height must be greater than zero </td></tr>
    <tr><td class="paramname">pixels</td><td>pointer to destination pixels buffer </td></tr>
    <tr><td class="paramname">rowBytes</td><td>interval from one <a class="el" href="class_sk_surface.html">SkSurface</a> row to the next </td></tr>
    <tr><td class="paramname">surfaceProps</td><td>LCD striping orientation and setting for device independent fonts; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_surface.html">SkSurface</a> if all parameters are valid; otherwise, nullptr </dd></dl>

</div>
</div>
<a id="aa000cb9fdcb3b5ec5bf92408fd0df3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa000cb9fdcb3b5ec5bf92408fd0df3a0">&#9670;&nbsp;</a></span>MakeRasterDirectReleaseProc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_surface.html">SkSurface</a>&gt; SkSurface::MakeRasterDirectReleaseProc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>imageInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *pixels, void *context)&#160;</td>
          <td class="paramname"><em>releaseProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *&#160;</td>
          <td class="paramname"><em>surfaceProps</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates raster <a class="el" href="class_sk_surface.html">SkSurface</a>. <a class="el" href="class_sk_canvas.html">SkCanvas</a> returned by <a class="el" href="class_sk_surface.html">SkSurface</a> draws directly into pixels. releaseProc is called with pixels and context when <a class="el" href="class_sk_surface.html">SkSurface</a> is deleted.</p>
<p><a class="el" href="class_sk_surface.html">SkSurface</a> is returned if all parameters are valid. Valid parameters include: info dimensions are greater than zero; info contains SkColorType and SkAlphaType supported by raster surface; pixels is not nullptr; rowBytes is large enough to contain info width pixels of SkColorType.</p>
<p><a class="el" href="struct_pixel.html">Pixel</a> buffer size should be info height times computed rowBytes. Pixels are not initialized. To access pixels after drawing, call flush() or <a class="el" href="class_sk_surface.html#a8de5913a3bca21fccd77e92755b26432">peekPixels()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageInfo</td><td>width, height, SkColorType, SkAlphaType, <a class="el" href="class_sk_color_space.html">SkColorSpace</a>, of raster surface; width and height must be greater than zero </td></tr>
    <tr><td class="paramname">pixels</td><td>pointer to destination pixels buffer </td></tr>
    <tr><td class="paramname">rowBytes</td><td>interval from one <a class="el" href="class_sk_surface.html">SkSurface</a> row to the next </td></tr>
    <tr><td class="paramname">releaseProc</td><td>called when <a class="el" href="class_sk_surface.html">SkSurface</a> is deleted; may be nullptr </td></tr>
    <tr><td class="paramname">context</td><td>passed to releaseProc; may be nullptr </td></tr>
    <tr><td class="paramname">surfaceProps</td><td>LCD striping orientation and setting for device independent fonts; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_surface.html">SkSurface</a> if all parameters are valid; otherwise, nullptr </dd></dl>

</div>
</div>
<a id="a8ac34d6cf6f05d76db8d27b3e811e01c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ac34d6cf6f05d76db8d27b3e811e01c">&#9670;&nbsp;</a></span>MakeRasterN32Premul()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_surface.html">SkSurface</a>&gt; SkSurface::MakeRasterN32Premul </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *&#160;</td>
          <td class="paramname"><em>surfaceProps</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates raster <a class="el" href="class_sk_surface.html">SkSurface</a>. <a class="el" href="class_sk_canvas.html">SkCanvas</a> returned by <a class="el" href="class_sk_surface.html">SkSurface</a> draws directly into pixels. Allocates and zeroes pixel memory. <a class="el" href="struct_pixel.html">Pixel</a> memory size is height times width times four. <a class="el" href="struct_pixel.html">Pixel</a> memory is deleted when <a class="el" href="class_sk_surface.html">SkSurface</a> is deleted.</p>
<p>Internally, sets <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> to width, height, native color type, and kPremul_SkAlphaType.</p>
<p><a class="el" href="class_sk_surface.html">SkSurface</a> is returned if width and height are greater than zero.</p>
<p>Use to create <a class="el" href="class_sk_surface.html">SkSurface</a> that matches SkPMColor, the native pixel arrangement on the platform. <a class="el" href="class_sk_surface.html">SkSurface</a> drawn to output device skips converting its pixel format.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>pixel column count; must be greater than zero </td></tr>
    <tr><td class="paramname">height</td><td>pixel row count; must be greater than zero </td></tr>
    <tr><td class="paramname">surfaceProps</td><td>LCD striping orientation and setting for device independent fonts; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_surface.html">SkSurface</a> if all parameters are valid; otherwise, nullptr </dd></dl>

</div>
</div>
<a id="a13494920609f783f66d3246a6ea26236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13494920609f783f66d3246a6ea26236">&#9670;&nbsp;</a></span>MakeRenderTarget() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_surface.html">SkSurface</a>&gt; SkSurface::MakeRenderTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_surface_characterization.html">SkSurfaceCharacterization</a> &amp;&#160;</td>
          <td class="paramname"><em>characterization</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_types_8h.html#a66f73362220ea988583a7980b6634374">SkBudgeted</a>&#160;</td>
          <td class="paramname"><em>budgeted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="class_sk_surface.html">SkSurface</a> on GPU indicated by context that is compatible with the provided characterization. budgeted selects whether allocation for pixels is tracked by context.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>GPU context </td></tr>
    <tr><td class="paramname">characterization</td><td>description of the desired <a class="el" href="class_sk_surface.html">SkSurface</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_surface.html">SkSurface</a> if all parameters are valid; otherwise, nullptr </dd></dl>

</div>
</div>
<a id="ad836deaf72354a6eebe21565e9906f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad836deaf72354a6eebe21565e9906f67">&#9670;&nbsp;</a></span>MakeRenderTarget() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_surface.html">SkSurface</a>&gt; SkSurface::MakeRenderTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_types_8h.html#a66f73362220ea988583a7980b6634374">SkBudgeted</a>&#160;</td>
          <td class="paramname"><em>budgeted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>imageInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="class_sk_surface.html">SkSurface</a> on GPU indicated by context. Allocates memory for pixels, based on the width, height, and SkColorType in <a class="el" href="struct_sk_image_info.html">SkImageInfo</a>. budgeted selects whether allocation for pixels is tracked by context. imageInfo describes the pixel format in SkColorType, and transparency in SkAlphaType, and color matching in <a class="el" href="class_sk_color_space.html">SkColorSpace</a>.</p>
<p><a class="el" href="class_sk_surface.html">SkSurface</a> bottom-left corner is pinned to the origin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>GPU context </td></tr>
    <tr><td class="paramname">imageInfo</td><td>width, height, SkColorType, SkAlphaType, <a class="el" href="class_sk_color_space.html">SkColorSpace</a>, of raster surface; width, or height, or both, may be zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_surface.html">SkSurface</a> if all parameters are valid; otherwise, nullptr </dd></dl>

</div>
</div>
<a id="a71929ad95b166b7b98df684056724e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71929ad95b166b7b98df684056724e1e">&#9670;&nbsp;</a></span>MakeRenderTarget() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_surface.html">SkSurface</a>&gt; SkSurface::MakeRenderTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_types_8h.html#a66f73362220ea988583a7980b6634374">SkBudgeted</a>&#160;</td>
          <td class="paramname"><em>budgeted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>imageInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *&#160;</td>
          <td class="paramname"><em>surfaceProps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="class_sk_surface.html">SkSurface</a> on GPU indicated by context. Allocates memory for pixels, based on the width, height, and SkColorType in <a class="el" href="struct_sk_image_info.html">SkImageInfo</a>. budgeted selects whether allocation for pixels is tracked by context. imageInfo describes the pixel format in SkColorType, and transparency in SkAlphaType, and color matching in <a class="el" href="class_sk_color_space.html">SkColorSpace</a>.</p>
<p>sampleCount requests the number of samples per pixel. Pass zero to disable multi-sample anti-aliasing. The request is rounded up to the next supported count, or rounded down if it is larger than the maximum supported count.</p>
<p><a class="el" href="class_sk_surface.html">SkSurface</a> bottom-left corner is pinned to the origin.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>GPU context </td></tr>
    <tr><td class="paramname">imageInfo</td><td>width, height, SkColorType, SkAlphaType, <a class="el" href="class_sk_color_space.html">SkColorSpace</a>, of raster surface; width, or height, or both, may be zero </td></tr>
    <tr><td class="paramname">sampleCount</td><td>samples per pixel, or 0 to disable multi-sample anti-aliasing </td></tr>
    <tr><td class="paramname">surfaceProps</td><td>LCD striping orientation and setting for device independent fonts; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_surface.html">SkSurface</a> if all parameters are valid; otherwise, nullptr </dd></dl>

</div>
</div>
<a id="aa32278bea58b9f229190c45b59f01548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32278bea58b9f229190c45b59f01548">&#9670;&nbsp;</a></span>MakeRenderTarget() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_surface.html">SkSurface</a>&gt; SkSurface::MakeRenderTarget </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_types_8h.html#a66f73362220ea988583a7980b6634374">SkBudgeted</a>&#160;</td>
          <td class="paramname"><em>budgeted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>imageInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sampleCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrSurfaceOrigin&#160;</td>
          <td class="paramname"><em>surfaceOrigin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *&#160;</td>
          <td class="paramname"><em>surfaceProps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>shouldCreateWithMips</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="class_sk_surface.html">SkSurface</a> on GPU indicated by context. Allocates memory for pixels, based on the width, height, and SkColorType in <a class="el" href="struct_sk_image_info.html">SkImageInfo</a>. budgeted selects whether allocation for pixels is tracked by context. imageInfo describes the pixel format in SkColorType, and transparency in SkAlphaType, and color matching in <a class="el" href="class_sk_color_space.html">SkColorSpace</a>.</p>
<p>sampleCount requests the number of samples per pixel. Pass zero to disable multi-sample anti-aliasing. The request is rounded up to the next supported count, or rounded down if it is larger than the maximum supported count.</p>
<p>surfaceOrigin pins either the top-left or the bottom-left corner to the origin.</p>
<p>shouldCreateWithMips hints that <a class="el" href="class_sk_image.html">SkImage</a> returned by <a class="el" href="class_sk_surface.html#a9e0831e582fff299df12786801fbd2bf">makeImageSnapshot()</a> is mip map.</p>
<p>If SK_SUPPORT_GPU is defined as zero, has no effect and returns nullptr.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>GPU context </td></tr>
    <tr><td class="paramname">imageInfo</td><td>width, height, SkColorType, SkAlphaType, <a class="el" href="class_sk_color_space.html">SkColorSpace</a>; width, or height, or both, may be zero </td></tr>
    <tr><td class="paramname">sampleCount</td><td>samples per pixel, or 0 to disable full scene anti-aliasing </td></tr>
    <tr><td class="paramname">surfaceProps</td><td>LCD striping orientation and setting for device independent fonts; may be nullptr </td></tr>
    <tr><td class="paramname">shouldCreateWithMips</td><td>hint that <a class="el" href="class_sk_surface.html">SkSurface</a> will host mip map images </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_surface.html">SkSurface</a> if all parameters are valid; otherwise, nullptr </dd></dl>

</div>
</div>
<a id="a56ed11229ed16cbb2b9d377deac2ca08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ed11229ed16cbb2b9d377deac2ca08">&#9670;&nbsp;</a></span>makeSurface() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_surface.html">SkSurface</a>&gt; SkSurface::makeSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>imageInfo</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a compatible <a class="el" href="class_sk_surface.html">SkSurface</a>, or nullptr. Returned <a class="el" href="class_sk_surface.html">SkSurface</a> contains the same raster, GPU, or null properties as the original. Returned <a class="el" href="class_sk_surface.html">SkSurface</a> does not share the same pixels.</p>
<p>Returns nullptr if imageInfo width or height are zero, or if imageInfo is incompatible with <a class="el" href="class_sk_surface.html">SkSurface</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">imageInfo</td><td>width, height, SkColorType, SkAlphaType, <a class="el" href="class_sk_color_space.html">SkColorSpace</a>, of <a class="el" href="class_sk_surface.html">SkSurface</a>; width and height must be greater than zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>compatible <a class="el" href="class_sk_surface.html">SkSurface</a> or nullptr</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_makeSurface">https://fiddle.skia.org/c/@Surface_makeSurface</a> </p>

</div>
</div>
<a id="a925f99aeda52481cdedc9bc5e24ea57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925f99aeda52481cdedc9bc5e24ea57a">&#9670;&nbsp;</a></span>makeSurface() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt;<a class="el" href="class_sk_surface.html">SkSurface</a>&gt; SkSurface::makeSurface </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls makeSurface(ImageInfo) with the same ImageInfo as this surface, but with the specified width and height. </p>

</div>
</div>
<a id="ae577c5cac83c670f87c51eddab87aa9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae577c5cac83c670f87c51eddab87aa9f">&#9670;&nbsp;</a></span>notifyContentWillChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkSurface::notifyContentWillChange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#a09e73a19d8d3d1ea85c38a515fc48538">ContentChangeMode</a>&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notifies that <a class="el" href="class_sk_surface.html">SkSurface</a> contents will be changed by code outside of Skia. Subsequent calls to <a class="el" href="class_sk_surface.html#af977ef6c5da6bc9b95747e5961672433">generationID()</a> return a different value.</p>
<p>TODO: Can kRetain_ContentChangeMode be deprecated?</p>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_notifyContentWillChange">https://fiddle.skia.org/c/@Surface_notifyContentWillChange</a> </p>

</div>
</div>
<a id="a8de5913a3bca21fccd77e92755b26432"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8de5913a3bca21fccd77e92755b26432">&#9670;&nbsp;</a></span>peekPixels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkSurface::peekPixels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_pixmap.html">SkPixmap</a> *&#160;</td>
          <td class="paramname"><em>pixmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="class_sk_surface.html">SkSurface</a> pixel address, row bytes, and <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> to <a class="el" href="class_sk_pixmap.html">SkPixmap</a>, if address is available, and returns true. If pixel address is not available, return false and leave <a class="el" href="class_sk_pixmap.html">SkPixmap</a> unchanged.</p>
<p>pixmap contents become invalid on any future change to <a class="el" href="class_sk_surface.html">SkSurface</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixmap</td><td>storage for pixel state if pixels are readable; otherwise, ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_surface.html">SkSurface</a> has direct access to pixels</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_peekPixels">https://fiddle.skia.org/c/@Surface_peekPixels</a> </p>

</div>
</div>
<a id="a0a3c4c19cc65a7eb602cb196b1c40556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3c4c19cc65a7eb602cb196b1c40556">&#9670;&nbsp;</a></span>props()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a>&amp; SkSurface::props </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> for surface.</p>
<dl class="section return"><dt>Returns</dt><dd>LCD striping orientation and setting for device independent fonts </dd></dl>

</div>
</div>
<a id="abf11d4d743be6d2d94007e8d923c987c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf11d4d743be6d2d94007e8d923c987c">&#9670;&nbsp;</a></span>readPixels() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkSurface::readPixels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="struct_sk_rect.html">SkRect</a> of pixels from <a class="el" href="class_sk_surface.html">SkSurface</a> into bitmap.</p>
<p>Source <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (srcX, srcY) and <a class="el" href="class_sk_surface.html">SkSurface</a> (<a class="el" href="class_sk_surface.html#a351ef72e03fba91865a321e8e081a842">width()</a>, <a class="el" href="class_sk_surface.html#aa30771352bbeb37532669127fa16494e">height()</a>). Destination <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (0, 0) and (bitmap.width(), bitmap.height()). Copies each readable pixel intersecting both rectangles, without scaling, converting to bitmap.colorType() and bitmap.alphaType() if required.</p>
<p>Pixels are readable when <a class="el" href="class_sk_surface.html">SkSurface</a> is raster, or backed by a GPU.</p>
<p>The destination pixel storage must be allocated by the caller.</p>
<p><a class="el" href="struct_pixel.html">Pixel</a> values are converted only if SkColorType and SkAlphaType do not match. Only pixels within both source and destination rectangles are copied. dst contents outside <a class="el" href="struct_sk_rect.html">SkRect</a> intersection are unchanged.</p>
<p>Pass negative values for srcX or srcY to offset pixels across or down destination.</p>
<p>Does not copy, and returns false if:</p><ul>
<li>Source and destination rectangles do not intersect.</li>
<li><a class="el" href="class_sk_surface.html">SkSurface</a> pixels could not be converted to dst.colorType() or dst.alphaType().</li>
<li>dst pixels could not be allocated.</li>
<li>dst.rowBytes() is too small to contain one row of pixels.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>storage for pixels copied from <a class="el" href="class_sk_surface.html">SkSurface</a> </td></tr>
    <tr><td class="paramname">srcX</td><td>offset into readable pixels on x-axis; may be negative </td></tr>
    <tr><td class="paramname">srcY</td><td>offset into readable pixels on y-axis; may be negative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if pixels were copied</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_readPixels_3">https://fiddle.skia.org/c/@Surface_readPixels_3</a> </p>

</div>
</div>
<a id="a1fbe87fec06fb10cc5f2ea34b6bff55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbe87fec06fb10cc5f2ea34b6bff55e">&#9670;&nbsp;</a></span>readPixels() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkSurface::readPixels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>dstInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dstPixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstRowBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="struct_sk_rect.html">SkRect</a> of pixels from <a class="el" href="class_sk_canvas.html">SkCanvas</a> into dstPixels.</p>
<p>Source <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (srcX, srcY) and <a class="el" href="class_sk_surface.html">SkSurface</a> (<a class="el" href="class_sk_surface.html#a351ef72e03fba91865a321e8e081a842">width()</a>, <a class="el" href="class_sk_surface.html#aa30771352bbeb37532669127fa16494e">height()</a>). Destination <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (0, 0) and (dstInfo.width(), dstInfo.height()). Copies each readable pixel intersecting both rectangles, without scaling, converting to dstInfo.colorType() and dstInfo.alphaType() if required.</p>
<p>Pixels are readable when <a class="el" href="class_sk_surface.html">SkSurface</a> is raster, or backed by a GPU.</p>
<p>The destination pixel storage must be allocated by the caller.</p>
<p><a class="el" href="struct_pixel.html">Pixel</a> values are converted only if SkColorType and SkAlphaType do not match. Only pixels within both source and destination rectangles are copied. dstPixels contents outside <a class="el" href="struct_sk_rect.html">SkRect</a> intersection are unchanged.</p>
<p>Pass negative values for srcX or srcY to offset pixels across or down destination.</p>
<p>Does not copy, and returns false if:</p><ul>
<li>Source and destination rectangles do not intersect.</li>
<li><a class="el" href="class_sk_surface.html">SkSurface</a> pixels could not be converted to dstInfo.colorType() or dstInfo.alphaType().</li>
<li>dstRowBytes is too small to contain one row of pixels.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstInfo</td><td>width, height, SkColorType, and SkAlphaType of dstPixels </td></tr>
    <tr><td class="paramname">dstPixels</td><td>storage for pixels; dstInfo.height() times dstRowBytes, or larger </td></tr>
    <tr><td class="paramname">dstRowBytes</td><td>size of one destination row; dstInfo.width() times pixel size, or larger </td></tr>
    <tr><td class="paramname">srcX</td><td>offset into readable pixels on x-axis; may be negative </td></tr>
    <tr><td class="paramname">srcY</td><td>offset into readable pixels on y-axis; may be negative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if pixels were copied </dd></dl>

</div>
</div>
<a id="af3fe3696a898f644c0b3136d94771588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fe3696a898f644c0b3136d94771588">&#9670;&nbsp;</a></span>readPixels() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkSurface::readPixels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="struct_sk_rect.html">SkRect</a> of pixels to dst.</p>
<p>Source <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (srcX, srcY) and <a class="el" href="class_sk_surface.html">SkSurface</a> (<a class="el" href="class_sk_surface.html#a351ef72e03fba91865a321e8e081a842">width()</a>, <a class="el" href="class_sk_surface.html#aa30771352bbeb37532669127fa16494e">height()</a>). Destination <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (0, 0) and (dst.width(), dst.height()). Copies each readable pixel intersecting both rectangles, without scaling, converting to dst.colorType() and dst.alphaType() if required.</p>
<p>Pixels are readable when <a class="el" href="class_sk_surface.html">SkSurface</a> is raster, or backed by a GPU.</p>
<p>The destination pixel storage must be allocated by the caller.</p>
<p><a class="el" href="struct_pixel.html">Pixel</a> values are converted only if SkColorType and SkAlphaType do not match. Only pixels within both source and destination rectangles are copied. dst contents outside <a class="el" href="struct_sk_rect.html">SkRect</a> intersection are unchanged.</p>
<p>Pass negative values for srcX or srcY to offset pixels across or down destination.</p>
<p>Does not copy, and returns false if:</p><ul>
<li>Source and destination rectangles do not intersect.</li>
<li><a class="el" href="class_sk_pixmap.html">SkPixmap</a> pixels could not be allocated.</li>
<li>dst.rowBytes() is too small to contain one row of pixels.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>storage for pixels copied from <a class="el" href="class_sk_surface.html">SkSurface</a> </td></tr>
    <tr><td class="paramname">srcX</td><td>offset into readable pixels on x-axis; may be negative </td></tr>
    <tr><td class="paramname">srcY</td><td>offset into readable pixels on y-axis; may be negative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if pixels were copied</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_readPixels">https://fiddle.skia.org/c/@Surface_readPixels</a> </p>

</div>
</div>
<a id="a7e10b31a98c0b93e6d6fb23b32b8519f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e10b31a98c0b93e6d6fb23b32b8519f">&#9670;&nbsp;</a></span>recordingContext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_gr_recording_context.html">GrRecordingContext</a>* SkSurface::recordingContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the recording context being used by the <a class="el" href="class_sk_surface.html">SkSurface</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>the recording context, if available; nullptr otherwise </dd></dl>

</div>
</div>
<a id="a6335b4e9e654c197aa9802bf74facc5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6335b4e9e654c197aa9802bf74facc5b">&#9670;&nbsp;</a></span>replaceBackendTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkSurface::replaceBackendTexture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_texture.html">GrBackendTexture</a> &amp;&#160;</td>
          <td class="paramname"><em>backendTexture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GrSurfaceOrigin&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#a09e73a19d8d3d1ea85c38a515fc48538">ContentChangeMode</a>&#160;</td>
          <td class="paramname"><em>mode</em> = <code><a class="el" href="class_sk_surface.html#a09e73a19d8d3d1ea85c38a515fc48538a61df574700828a9f039c6cd8ec4c39df">kRetain_ContentChangeMode</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#a0e552eaf3124ef4e6fbb3490b321ea60">TextureReleaseProc</a>&#160;</td>
          <td class="paramname"><em>textureReleaseProc</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_surface.html#ae91b4f130cbb53ecde3a1d9261eadc54">ReleaseContext</a>&#160;</td>
          <td class="paramname"><em>releaseContext</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the surface was made via MakeFromBackendTexture then it's backing texture may be substituted with a different texture. The contents of the previous backing texture are copied into the new texture. <a class="el" href="class_sk_canvas.html">SkCanvas</a> state is preserved. The original sample count is used. The <a class="el" href="class_gr_backend_format.html">GrBackendFormat</a> and dimensions of replacement texture must match that of the original.</p>
<p>Upon success textureReleaseProc is called when it is safe to delete the texture in the backend API (accounting only for use of the texture by this surface). If <a class="el" href="class_sk_surface.html">SkSurface</a> creation fails textureReleaseProc is called before this function returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">backendTexture</td><td>the new backing texture for the surface </td></tr>
    <tr><td class="paramname">mode</td><td>Retain or discard current Content </td></tr>
    <tr><td class="paramname">textureReleaseProc</td><td>function called when texture can be released </td></tr>
    <tr><td class="paramname">releaseContext</td><td>state passed to textureReleaseProc </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aebf60b11a45f03386aecc5f673d36bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf60b11a45f03386aecc5f673d36bac">&#9670;&nbsp;</a></span>wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkSurface::wait </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numSemaphores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_gr_backend_semaphore.html">GrBackendSemaphore</a> *&#160;</td>
          <td class="paramname"><em>waitSemaphores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deleteSemaphoresAfterWait</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a list of GPU semaphores that the current GPU-backed API must wait on before executing any more commands on the GPU for this surface. If this call returns false, then the GPU back-end will not wait on any passed in semaphores, and the client will still own the semaphores, regardless of the value of deleteSemaphoresAfterWait.</p>
<p>If deleteSemaphoresAfterWait is false then Skia will not delete the semaphores. In this case it is the client's responsibility to not destroy or attempt to reuse the semaphores until it knows that Skia has finished waiting on them. This can be done by using finishedProcs on flush calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numSemaphores</td><td>size of waitSemaphores array </td></tr>
    <tr><td class="paramname">waitSemaphores</td><td>array of semaphore containers @paramm deleteSemaphoresAfterWait who owns and should delete the semaphores </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if GPU is waiting on semaphores </dd></dl>

</div>
</div>
<a id="a351ef72e03fba91865a321e8e081a842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351ef72e03fba91865a321e8e081a842">&#9670;&nbsp;</a></span>width()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SkSurface::width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns pixel count in each row; may be zero or greater.</p>
<dl class="section return"><dt>Returns</dt><dd>number of pixel columns </dd></dl>

</div>
</div>
<a id="a59a898652100042350bce30cb348c781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a898652100042350bce30cb348c781">&#9670;&nbsp;</a></span>writePixels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkSurface::writePixels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="struct_sk_rect.html">SkRect</a> of pixels from the src <a class="el" href="class_sk_bitmap.html">SkBitmap</a> to the <a class="el" href="class_sk_surface.html">SkSurface</a>.</p>
<p>Source <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (0, 0) and (src.width(), src.height()). Destination <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (dstX, dstY) and (dstX + Surface <a class="el" href="class_sk_surface.html#a351ef72e03fba91865a321e8e081a842">width()</a>, dstY + Surface <a class="el" href="class_sk_surface.html#aa30771352bbeb37532669127fa16494e">height()</a>).</p>
<p>Copies each readable pixel intersecting both rectangles, without scaling, converting to <a class="el" href="class_sk_surface.html">SkSurface</a> colorType() and <a class="el" href="class_sk_surface.html">SkSurface</a> alphaType() if required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>storage for pixels to copy to <a class="el" href="class_sk_surface.html">SkSurface</a> </td></tr>
    <tr><td class="paramname">dstX</td><td>x-axis position relative to <a class="el" href="class_sk_surface.html">SkSurface</a> to begin copy; may be negative </td></tr>
    <tr><td class="paramname">dstY</td><td>y-axis position relative to <a class="el" href="class_sk_surface.html">SkSurface</a> to begin copy; may be negative</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_writePixels_2">https://fiddle.skia.org/c/@Surface_writePixels_2</a> </p>

</div>
</div>
<a id="ae22a0f49d435f78820918fbf06c0dd61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22a0f49d435f78820918fbf06c0dd61">&#9670;&nbsp;</a></span>writePixels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkSurface::writePixels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dstY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="struct_sk_rect.html">SkRect</a> of pixels from the src <a class="el" href="class_sk_pixmap.html">SkPixmap</a> to the <a class="el" href="class_sk_surface.html">SkSurface</a>.</p>
<p>Source <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (0, 0) and (src.width(), src.height()). Destination <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (dstX, dstY) and (dstX + Surface <a class="el" href="class_sk_surface.html#a351ef72e03fba91865a321e8e081a842">width()</a>, dstY + Surface <a class="el" href="class_sk_surface.html#aa30771352bbeb37532669127fa16494e">height()</a>).</p>
<p>Copies each readable pixel intersecting both rectangles, without scaling, converting to <a class="el" href="class_sk_surface.html">SkSurface</a> colorType() and <a class="el" href="class_sk_surface.html">SkSurface</a> alphaType() if required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>storage for pixels to copy to <a class="el" href="class_sk_surface.html">SkSurface</a> </td></tr>
    <tr><td class="paramname">dstX</td><td>x-axis position relative to <a class="el" href="class_sk_surface.html">SkSurface</a> to begin copy; may be negative </td></tr>
    <tr><td class="paramname">dstY</td><td>y-axis position relative to <a class="el" href="class_sk_surface.html">SkSurface</a> to begin copy; may be negative</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_writePixels">https://fiddle.skia.org/c/@Surface_writePixels</a> </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1ff636605c412060f5ffe6bc0a5039e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff636605c412060f5ffe6bc0a5039e1">&#9670;&nbsp;</a></span>kDiscardWrite_TextureHandleAccess</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209">BackendHandleAccess</a> SkSurface::kDiscardWrite_TextureHandleAccess</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">            <a class="code" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209a265463cfb4ba17bb7948556f12c73b95">kDiscardWrite_BackendHandleAccess</a></div>
</div><!-- fragment --><p>Deprecated. </p>

</div>
</div>
<a id="a87371ae0497a248a1f9567950670b709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87371ae0497a248a1f9567950670b709">&#9670;&nbsp;</a></span>kFlushRead_TextureHandleAccess</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209">BackendHandleAccess</a> SkSurface::kFlushRead_TextureHandleAccess</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">            <a class="code" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209a2061b9bbc92672b5168fbd018b47ec7a">kFlushRead_BackendHandleAccess</a></div>
</div><!-- fragment --><p>Deprecated. </p>

</div>
</div>
<a id="a13c51fc4193e7e91806b109af59d242f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c51fc4193e7e91806b109af59d242f">&#9670;&nbsp;</a></span>kFlushWrite_TextureHandleAccess</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209">BackendHandleAccess</a> SkSurface::kFlushWrite_TextureHandleAccess</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">            <a class="code" href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209a2c2b35a88238afbf7e7b79ff52048db4">kFlushWrite_BackendHandleAccess</a></div>
</div><!-- fragment --><p>Deprecated. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/include/core/<a class="el" href="_sk_surface_8h_source.html">SkSurface.h</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclass_sk_surface_html_ae68c874f3e621291d54c5b62f3165209a265463cfb4ba17bb7948556f12c73b95"><div class="ttname"><a href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209a265463cfb4ba17bb7948556f12c73b95">SkSurface::kDiscardWrite_BackendHandleAccess</a></div><div class="ttdeci">@ kDiscardWrite_BackendHandleAccess</div><div class="ttdoc">back-end object must be overwritten</div><div class="ttdef"><b>Definition:</b> SkSurface.h:503</div></div>
<div class="ttc" id="aclass_sk_surface_html_ae68c874f3e621291d54c5b62f3165209a2061b9bbc92672b5168fbd018b47ec7a"><div class="ttname"><a href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209a2061b9bbc92672b5168fbd018b47ec7a">SkSurface::kFlushRead_BackendHandleAccess</a></div><div class="ttdeci">@ kFlushRead_BackendHandleAccess</div><div class="ttdoc">back-end object is readable</div><div class="ttdef"><b>Definition:</b> SkSurface.h:501</div></div>
<div class="ttc" id="aclass_sk_surface_html_ae68c874f3e621291d54c5b62f3165209a2c2b35a88238afbf7e7b79ff52048db4"><div class="ttname"><a href="class_sk_surface.html#ae68c874f3e621291d54c5b62f3165209a2c2b35a88238afbf7e7b79ff52048db4">SkSurface::kFlushWrite_BackendHandleAccess</a></div><div class="ttdeci">@ kFlushWrite_BackendHandleAccess</div><div class="ttdoc">back-end object is writable</div><div class="ttdef"><b>Definition:</b> SkSurface.h:502</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
