<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Eigen Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Eigen Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace containing all symbols from the Eigen library.  
<a href="namespace_eigen.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_eigen_1_1indexing"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1indexing.html">indexing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_eigen_1_1symbolic"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen_1_1symbolic.html">symbolic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_accelerate_impl.html">AccelerateImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1aligned__allocator.html">aligned_allocator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">STL compatible allocator to use with types requiring a non-standard alignment.  <a href="class_eigen_1_1aligned__allocator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1aligned__allocator__indirection.html">aligned_allocator_indirection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_aligned_box.html">AlignedBox</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An axis aligned box.  <a href="class_eigen_1_1_aligned_box.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_a_m_d_ordering.html">AMDOrdering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_angle_axis.html">AngleAxis</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 3D rotation as a rotation angle around an arbitrary 3D axis.  <a href="class_eigen_1_1_angle_axis.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_anti_hermiticity.html">AntiHermiticity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_anti_symmetry.html">AntiSymmetry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_arithmetic_sequence.html">ArithmeticSequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_arpack_generalized_self_adjoint_eigen_solver.html">ArpackGeneralizedSelfAdjointEigenSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_array.html">Array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">General-purpose arrays with easy API for coefficient-wise operations.  <a href="class_eigen_1_1_array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_array_base.html">ArrayBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all 1D and 2D array, and related expressions.  <a href="class_eigen_1_1_array_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_array_wrapper.html">ArrayWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a mathematical vector or matrix as an array object.  <a href="class_eigen_1_1_array_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_array_xpr.html">ArrayXpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_auto_diff_jacobian.html">AutoDiffJacobian</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar type replacement with automatic differentiation capability.  <a href="class_eigen_1_1_auto_diff_scalar.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_auto_diff_vector.html">AutoDiffVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_band_shape.html">BandShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_barrier.html">Barrier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_b_d_c_s_v_d.html">BDCSVD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">class Bidiagonal Divide and Conquer SVD  <a href="class_eigen_1_1_b_d_c_s_v_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_bench_timer.html">BenchTimer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1bfloat16.html">bfloat16</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_bi_c_g_s_t_a_b.html">BiCGSTAB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A bi conjugate gradient stabilized solver for sparse square problems.  <a href="class_eigen_1_1_bi_c_g_s_t_a_b.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_bi_c_g_s_t_a_b_l.html">BiCGSTABL</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a fixed-size or dynamic-size block.  <a href="class_eigen_1_1_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_block_impl.html">BlockImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_block_impl_3_01const_01_sparse_matrix_3_01_scalar___00_01_options___00_01_storagbd4839db938a8ffb41f4ef7f8f762da8.html">BlockImpl&lt; const SparseMatrix&lt; Scalar_, Options_, StorageIndex_ &gt;, BlockRows, BlockCols, true, Sparse &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_block_impl_3_01_sparse_matrix_3_01_scalar___00_01_options___00_01_storage_index_608917b0d993f2f5b50f076e8dd175c8.html">BlockImpl&lt; SparseMatrix&lt; Scalar_, Options_, StorageIndex_ &gt;, BlockRows, BlockCols, true, Sparse &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_block_impl_3_01_xpr_type_00_01_block_rows_00_01_block_cols_00_01_inner_panel_00_01_dense_01_4.html">BlockImpl&lt; XprType, BlockRows, BlockCols, InnerPanel, Dense &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_block_impl_3_01_xpr_type_00_01_block_rows_00_01_block_cols_00_01_inner_panel_00_01_sparse_01_4.html">BlockImpl&lt; XprType, BlockRows, BlockCols, InnerPanel, Sparse &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_block_impl_3_01_xpr_type_00_01_block_rows_00_01_block_cols_00_01true_00_01_sparse_01_4.html">BlockImpl&lt; XprType, BlockRows, BlockCols, true, Sparse &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_block_sparse_matrix.html">BlockSparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A versatile sparse matrix representation where each element is a block.  <a href="class_eigen_1_1_block_sparse_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_block_sparse_matrix_view.html">BlockSparseMatrixView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_block_sparse_time_dense_product.html">BlockSparseTimeDenseProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_block_vector_return.html">BlockVectorReturn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_block_vector_view.html">BlockVectorView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cholmod_base.html">CholmodBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for the direct Cholesky factorization of Cholmod.  <a href="class_eigen_1_1_cholmod_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cholmod_decomposition.html">CholmodDecomposition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A general Cholesky factorization and solver based on Cholmod.  <a href="class_eigen_1_1_cholmod_decomposition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cholmod_simplicial_l_d_l_t.html">CholmodSimplicialLDLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simplicial direct Cholesky (<a class="el" href="class_eigen_1_1_l_d_l_t.html" title="Robust Cholesky decomposition of a matrix with pivoting.">LDLT</a>) factorization and solver based on Cholmod.  <a href="class_eigen_1_1_cholmod_simplicial_l_d_l_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cholmod_simplicial_l_l_t.html">CholmodSimplicialLLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simplicial direct Cholesky (<a class="el" href="class_eigen_1_1_l_l_t.html" title="Standard Cholesky decomposition (LL^T) of a matrix and associated features.">LLT</a>) factorization and solver based on Cholmod.  <a href="class_eigen_1_1_cholmod_simplicial_l_l_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cholmod_supernodal_l_l_t.html">CholmodSupernodalLLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A supernodal Cholesky (<a class="el" href="class_eigen_1_1_l_l_t.html" title="Standard Cholesky decomposition (LL^T) of a matrix and associated features.">LLT</a>) factorization and solver based on Cholmod.  <a href="class_eigen_1_1_cholmod_supernodal_l_l_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_cleaned_up_der_type.html">CleanedUpDerType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_c_o_l_a_m_d_ordering.html">COLAMDOrdering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_col_piv_householder_q_r.html">ColPivHouseholderQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Householder rank-revealing QR decomposition of a matrix with column-pivoting.  <a href="class_eigen_1_1_col_piv_householder_q_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_comma_initializer.html">CommaInitializer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper class used by the comma initializer operator.  <a href="struct_eigen_1_1_comma_initializer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_complete_orthogonal_decomposition.html">CompleteOrthogonalDecomposition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Complete orthogonal decomposition (COD) of a matrix.  <a href="class_eigen_1_1_complete_orthogonal_decomposition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_complex_eigen_solver.html">ComplexEigenSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes eigenvalues and eigenvectors of general complex matrices.  <a href="class_eigen_1_1_complex_eigen_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_complex_schur.html">ComplexSchur</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a complex Schur decomposition of a real or complex square matrix.  <a href="class_eigen_1_1_complex_schur.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_cond.html">Cond</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_conjugate.html">Conjugate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_conjugate_gradient.html">ConjugateGradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A conjugate gradient solver for sparse (or dense) self-adjoint problems.  <a href="class_eigen_1_1_conjugate_gradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_conversion_sub_expr_eval.html">ConversionSubExprEval</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_conversion_sub_expr_eval_3_01true_00_01_eval_00_01_eval_pointer_type_01_4.html">ConversionSubExprEval&lt; true, Eval, EvalPointerType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cross.html">Cross</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic expression where a coefficient-wise binary operator is applied to two expressions.  <a href="class_eigen_1_1_cwise_binary_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cwise_binary_op_impl.html">CwiseBinaryOpImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cwise_binary_op_impl_3_01_binary_op_00_01_lhs_00_01_rhs_00_01_sparse_01_4.html">CwiseBinaryOpImpl&lt; BinaryOp, Lhs, Rhs, Sparse &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cwise_nullary_op.html">CwiseNullaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic expression of a matrix where all coefficients are defined by a functor.  <a href="class_eigen_1_1_cwise_nullary_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cwise_ternary_op.html">CwiseTernaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic expression where a coefficient-wise ternary operator is applied to two expressions.  <a href="class_eigen_1_1_cwise_ternary_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cwise_ternary_op_impl.html">CwiseTernaryOpImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic expression where a coefficient-wise unary operator is applied to an expression.  <a href="class_eigen_1_1_cwise_unary_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cwise_unary_op_impl.html">CwiseUnaryOpImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cwise_unary_view.html">CwiseUnaryView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic lvalue expression of a coefficient-wise unary operator of a matrix or a vector.  <a href="class_eigen_1_1_cwise_unary_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cwise_unary_view_impl.html">CwiseUnaryViewImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_cwise_unary_view_impl_3_01_view_op_00_01_matrix_type_00_01_stride_type_00_01_dense_01_4.html">CwiseUnaryViewImpl&lt; ViewOp, MatrixType, StrideType, Dense &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_default_device.html">DefaultDevice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_dense.html">Dense</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all dense matrices, vectors, and arrays.  <a href="class_eigen_1_1_dense_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_coeffs_base.html">DenseCoeffsBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_coeffs_base_3_01_derived_00_01_direct_accessors_01_4.html">DenseCoeffsBase&lt; Derived, DirectAccessors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class providing direct read-only coefficient access to matrices and arrays.  <a href="class_eigen_1_1_dense_coeffs_base_3_01_derived_00_01_direct_accessors_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_coeffs_base_3_01_derived_00_01_direct_write_accessors_01_4.html">DenseCoeffsBase&lt; Derived, DirectWriteAccessors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class providing direct read/write coefficient access to matrices and arrays.  <a href="class_eigen_1_1_dense_coeffs_base_3_01_derived_00_01_direct_write_accessors_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_coeffs_base_3_01_derived_00_01_read_only_accessors_01_4.html">DenseCoeffsBase&lt; Derived, ReadOnlyAccessors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class providing read-only coefficient access to matrices and arrays.  <a href="class_eigen_1_1_dense_coeffs_base_3_01_derived_00_01_read_only_accessors_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_coeffs_base_3_01_derived_00_01_write_accessors_01_4.html">DenseCoeffsBase&lt; Derived, WriteAccessors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class providing read/write coefficient access to matrices and arrays.  <a href="class_eigen_1_1_dense_coeffs_base_3_01_derived_00_01_write_accessors_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_dense_functor.html">DenseFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_dense_shape.html">DenseShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_dense_sparse_product_return_type.html">DenseSparseProductReturnType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_storage.html">DenseStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_storage_3_01_t_00_010_00_01_dynamic_00_01_cols___00_01_options___01_4.html">DenseStorage&lt; T, 0, Dynamic, Cols_, Options_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_storage_3_01_t_00_010_00_01_dynamic_00_01_dynamic_00_01_options___01_4.html">DenseStorage&lt; T, 0, Dynamic, Dynamic, Options_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_storage_3_01_t_00_010_00_01_rows___00_01_cols___00_01_options___01_4.html">DenseStorage&lt; T, 0, Rows_, Cols_, Options_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_storage_3_01_t_00_010_00_01_rows___00_01_dynamic_00_01_options___01_4.html">DenseStorage&lt; T, 0, Rows_, Dynamic, Options_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_storage_3_01_t_00_01_dynamic_00_01_dynamic_00_01_cols___00_01_options___01_4.html">DenseStorage&lt; T, Dynamic, Dynamic, Cols_, Options_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_storage_3_01_t_00_01_dynamic_00_01_dynamic_00_01_dynamic_00_01_options___01_4.html">DenseStorage&lt; T, Dynamic, Dynamic, Dynamic, Options_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_storage_3_01_t_00_01_dynamic_00_01_rows___00_01_dynamic_00_01_options___01_4.html">DenseStorage&lt; T, Dynamic, Rows_, Dynamic, Options_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_storage_3_01_t_00_01_size_00_01_dynamic_00_01_cols___00_01_options___01_4.html">DenseStorage&lt; T, Size, Dynamic, Cols_, Options_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_storage_3_01_t_00_01_size_00_01_dynamic_00_01_dynamic_00_01_options___01_4.html">DenseStorage&lt; T, Size, Dynamic, Dynamic, Options_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_storage_3_01_t_00_01_size_00_01_rows___00_01_dynamic_00_01_options___01_4.html">DenseStorage&lt; T, Size, Rows_, Dynamic, Options_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dense_time_sparse_product.html">DenseTimeSparseProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_d_g_m_r_e_s.html">DGMRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Restarted <a class="el" href="class_eigen_1_1_g_m_r_e_s.html" title="A GMRES solver for sparse square problems.">GMRES</a> with deflation. This class implements a modification of the <a class="el" href="class_eigen_1_1_g_m_r_e_s.html" title="A GMRES solver for sparse square problems.">GMRES</a> solver for sparse linear systems. The basis is built with modified Gram-Schmidt. At each restart, a few approximated eigenvectors corresponding to the smallest eigenvalues are used to build a preconditioner for the next cycle. This preconditioner for deflation can be combined with any other preconditioner, the <a class="el" href="class_eigen_1_1_incomplete_l_u_t.html" title="Incomplete LU factorization with dual-threshold strategy.">IncompleteLUT</a> for instance. The preconditioner is applied at right of the matrix and the combination is multiplicative.  <a href="class_eigen_1_1_d_g_m_r_e_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_diagonal.html">Diagonal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a diagonal/subdiagonal/superdiagonal in a matrix.  <a href="class_eigen_1_1_diagonal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_diagonal_base.html">DiagonalBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for diagonal matrices and expressions.  <a href="class_eigen_1_1_diagonal_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_diagonal_matrix.html">DiagonalMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a diagonal matrix with its storage.  <a href="class_eigen_1_1_diagonal_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_diagonal_preconditioner.html">DiagonalPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A preconditioner based on the digonal entries.  <a href="class_eigen_1_1_diagonal_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_diagonal_product.html">DiagonalProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_diagonal_shape.html">DiagonalShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_diagonal_wrapper.html">DiagonalWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a diagonal matrix.  <a href="class_eigen_1_1_diagonal_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_dimension_list.html">DimensionList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_d_sizes.html">DSizes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dynamic_s_group.html">DynamicSGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dynamic symmetry group.  <a href="class_eigen_1_1_dynamic_s_group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dynamic_s_group_from_template_args.html">DynamicSGroupFromTemplateArgs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_dynamic_skyline_matrix.html">DynamicSkylineMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1eigen__assert__exception.html">eigen_assert_exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1eigen__static__assert__exception.html">eigen_static_assert_exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_eigen_convolution_kernel.html">EigenConvolutionKernel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_eigen_convolution_kernel_3_01_evaluator_00_01_coeff_return_type_00_01_kernel_ty2e9d028eb7cd2ec2b9a3482ce2831510.html">EigenConvolutionKernel&lt; Evaluator, CoeffReturnType, KernelType, Index, InputDims, Kernel_accessor, Buffer_accessor, convolution_type::CONV1D &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_eigen_convolution_kernel_3_01_evaluator_00_01_coeff_return_type_00_01_kernel_tye5471715b4fc6eb1318397127ce3d99b.html">EigenConvolutionKernel&lt; Evaluator, CoeffReturnType, KernelType, Index, InputDims, Kernel_accessor, Buffer_accessor, convolution_type::CONV2D &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_eigen_convolution_kernel_3_01_evaluator_00_01_coeff_return_type_00_01_kernel_tyb95df839c566e99fa66a1ab62d922efe.html">EigenConvolutionKernel&lt; Evaluator, CoeffReturnType, KernelType, Index, InputDims, Kernel_accessor, Buffer_accessor, convolution_type::CONV3D &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_eigen_solver.html">EigenSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes eigenvalues and eigenvectors of general matrices.  <a href="class_eigen_1_1_eigen_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_eigen_test.html">EigenTest</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_euler_angles.html">EulerAngles</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a rotation in a 3 dimensional space as three Euler angles.  <a href="class_eigen_1_1_euler_angles.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_euler_system.html">EulerSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a fixed Euler rotation system.  <a href="class_eigen_1_1_euler_system.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_event_count.html">EventCount</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_f_a_b_sum.html">FABSum</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_flagged.html">Flagged</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_force_aligned_access.html">ForceAlignedAccess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enforce aligned packet loads and stores regardless of what is requested.  <a href="class_eigen_1_1_force_aligned_access.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_full_piv_householder_q_r.html">FullPivHouseholderQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Householder rank-revealing QR decomposition of a matrix with full pivoting.  <a href="class_eigen_1_1_full_piv_householder_q_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_full_piv_l_u.html">FullPivLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LU decomposition of a matrix with complete pivoting, and related features.  <a href="class_eigen_1_1_full_piv_l_u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1general__product__to__triangular__selector.html">general_product_to_triangular_selector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1general__product__to__triangular__selector_3_01_matrix_type_00_01_product_type_00_01_up_lo_00_01false_01_4.html">general_product_to_triangular_selector&lt; MatrixType, ProductType, UpLo, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1general__product__to__triangular__selector_3_01_matrix_type_00_01_product_type_00_01_up_lo_00_01true_01_4.html">general_product_to_triangular_selector&lt; MatrixType, ProductType, UpLo, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_generalized_eigen_solver.html">GeneralizedEigenSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the generalized eigenvalues and eigenvectors of a pair of general matrices.  <a href="class_eigen_1_1_generalized_eigen_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_generalized_self_adjoint_eigen_solver.html">GeneralizedSelfAdjointEigenSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes eigenvalues and eigenvectors of the generalized selfadjoint eigen problem.  <a href="class_eigen_1_1_generalized_self_adjoint_eigen_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_generic_num_traits.html">GenericNumTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_g_m_r_e_s.html">GMRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="class_eigen_1_1_g_m_r_e_s.html" title="A GMRES solver for sparse square problems.">GMRES</a> solver for sparse square problems.  <a href="class_eigen_1_1_g_m_r_e_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1half.html">half</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_hermiticity.html">Hermiticity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_hessenberg_decomposition.html">HessenbergDecomposition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduces a square matrix to Hessenberg form by an orthogonal similarity transformation.  <a href="class_eigen_1_1_hessenberg_decomposition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_homogeneous.html">Homogeneous</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of one (or a set of) homogeneous vector(s)  <a href="class_eigen_1_1_homogeneous.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_homogeneous_shape.html">HomogeneousShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_householder_q_r.html">HouseholderQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Householder QR decomposition of a matrix.  <a href="class_eigen_1_1_householder_q_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_householder_sequence.html">HouseholderSequence</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequence of Householder reflections acting on subspaces with decreasing size.  <a href="class_eigen_1_1_householder_sequence.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_hybrid_non_linear_solver.html">HybridNonLinearSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds a zero of a system of n nonlinear functions in n variables by a modification of the Powell hybrid method ("dogleg").  <a href="class_eigen_1_1_hybrid_non_linear_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_hyperplane.html">Hyperplane</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A hyperplane.  <a href="class_eigen_1_1_hyperplane.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_identity_preconditioner.html">IdentityPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A naive preconditioner which approximates any matrix as the identity matrix.  <a href="class_eigen_1_1_identity_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_i_d_r_s.html">IDRS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Induced Dimension Reduction method (IDR(s)) is a short-recurrences Krylov method for sparse square problems.  <a href="class_eigen_1_1_i_d_r_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_i_d_r_s_t_a_b_l.html">IDRSTABL</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The IDR(s)STAB(l) is a combination of IDR(s) and BiCGSTAB(l). It is a short-recurrences Krylov method for sparse square problems. It can outperform both IDR(s) and BiCGSTAB(l). IDR(s)STAB(l) generally closely follows the optimal <a class="el" href="class_eigen_1_1_g_m_r_e_s.html" title="A GMRES solver for sparse square problems.">GMRES</a> convergence in terms of the number of Matrix-Vector products. However, without the increasing cost per iteration of <a class="el" href="class_eigen_1_1_g_m_r_e_s.html" title="A GMRES solver for sparse square problems.">GMRES</a>. IDR(s)STAB(l) is suitable for both indefinite systems and systems with complex eigenvalues.  <a href="class_eigen_1_1_i_d_r_s_t_a_b_l.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_incomplete_cholesky.html">IncompleteCholesky</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modified Incomplete Cholesky with dual threshold.  <a href="class_eigen_1_1_incomplete_cholesky.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_incomplete_l_u.html">IncompleteLU</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_incomplete_l_u_t.html">IncompleteLUT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Incomplete LU factorization with dual-threshold strategy.  <a href="class_eigen_1_1_incomplete_l_u_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_indexed_view.html">IndexedView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a non-sequential sub-matrix defined by arbitrary sequences of row and column indices.  <a href="class_eigen_1_1_indexed_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_indexed_view_impl.html">IndexedViewImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_index_list.html">IndexList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_index_pair.html">IndexPair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_index_pair_list.html">IndexPairList</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_inner_iterator.html">InnerIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <a class="el" href="class_eigen_1_1_inner_iterator.html" title="An InnerIterator allows to loop over the element of any matrix expression.">InnerIterator</a> allows to loop over the element of any matrix expression.  <a href="class_eigen_1_1_inner_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_inner_stride.html">InnerStride</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience specialization of <a class="el" href="class_eigen_1_1_stride.html" title="Holds strides information for Map.">Stride</a> to specify only an inner stride See class <a class="el" href="class_eigen_1_1_map.html" title="A matrix or vector expression mapping an existing array of data.">Map</a> for some examples.  <a href="class_eigen_1_1_inner_stride.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_inverse.html">Inverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of the inverse of another expression.  <a href="class_eigen_1_1_inverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_inverse_impl.html">InverseImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_inverse_impl_3_01_permutation_type_00_01_permutation_storage_01_4.html">InverseImpl&lt; PermutationType, PermutationStorage &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_i_o_format.html">IOFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a set of parameters controlling the way matrices are printed.  <a href="struct_eigen_1_1_i_o_format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_iteration_controller.html">IterationController</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls the iterations of the iterative solvers.  <a href="class_eigen_1_1_iteration_controller.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_iterative_solver_base.html">IterativeSolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for linear iterative solvers.  <a href="class_eigen_1_1_iterative_solver_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_iter_scaling.html">IterScaling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">iterative scaling algorithm to equilibrate rows and column norms in matrices  <a href="class_eigen_1_1_iter_scaling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_jacobi_rotation.html">JacobiRotation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rotation given by a cosine-sine pair.  <a href="class_eigen_1_1_jacobi_rotation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_jacobi_s_v_d.html">JacobiSVD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two-sided Jacobi SVD decomposition of a rectangular matrix.  <a href="class_eigen_1_1_jacobi_s_v_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_kahan_sum.html">KahanSum</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kahan algorithm based accumulator.  <a href="class_eigen_1_1_kahan_sum.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_kd_b_v_h.html">KdBVH</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple bounding volume hierarchy based on <a class="el" href="class_eigen_1_1_aligned_box.html" title="An axis aligned box.">AlignedBox</a>.  <a href="class_eigen_1_1_kd_b_v_h.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_k_l_u.html">KLU</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_kronecker_product.html">KroneckerProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker tensor product helper class for dense matrices.  <a href="class_eigen_1_1_kronecker_product.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_kronecker_product_base.html">KroneckerProductBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class of dense and sparse Kronecker product.  <a href="class_eigen_1_1_kronecker_product_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_kronecker_product_sparse.html">KroneckerProductSparse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Kronecker tensor product helper class for sparse matrices.  <a href="class_eigen_1_1_kronecker_product_sparse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_lazy_product_return_type.html">LazyProductReturnType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_l_d_l_t.html">LDLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Robust Cholesky decomposition of a matrix with pivoting.  <a href="class_eigen_1_1_l_d_l_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_least_square_diagonal_preconditioner.html">LeastSquareDiagonalPreconditioner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Jacobi preconditioner for <a class="el" href="class_eigen_1_1_least_squares_conjugate_gradient.html" title="A conjugate gradient solver for sparse (or dense) least-square problems.">LeastSquaresConjugateGradient</a>.  <a href="class_eigen_1_1_least_square_diagonal_preconditioner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_least_squares_conjugate_gradient.html">LeastSquaresConjugateGradient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A conjugate gradient solver for sparse (or dense) least-square problems.  <a href="class_eigen_1_1_least_squares_conjugate_gradient.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_levenberg_marquardt.html">LevenbergMarquardt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs non linear optimization over a non-linear function, using a variant of the Levenberg Marquardt algorithm.  <a href="class_eigen_1_1_levenberg_marquardt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_l_l_t.html">LLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard Cholesky decomposition (LL^T) of a matrix and associated features.  <a href="class_eigen_1_1_l_l_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_make_complex.html">MakeComplex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_make_complex_3_01false_01_4.html">MakeComplex&lt; false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_make_complex_3_01true_01_4.html">MakeComplex&lt; true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_make_pointer.html">MakePointer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_map.html">Map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix or vector expression mapping an existing array of data.  <a href="class_eigen_1_1_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_map_3_01const_01_quaternion_3_01_scalar___01_4_00_01_options___01_4.html">Map&lt; const Quaternion&lt; Scalar_ &gt;, Options_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_eigen_1_1_quaternion.html" title="The quaternion class used to represent 3D orientations and rotations.">Quaternion</a> expression mapping a constant memory buffer.  <a href="class_eigen_1_1_map_3_01const_01_quaternion_3_01_scalar___01_4_00_01_options___01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_map_3_01const_01_sparse_matrix_3_01_mat_scalar_00_01_mat_options_00_01_mat_index4032bba20cf92aab8bcf07e926e15a4f.html">Map&lt; const SparseMatrix&lt; MatScalar, MatOptions, MatIndex &gt;, Options, StrideType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_map_3_01_permutation_matrix_3_01_size_at_compile_time_00_01_max_size_at_compile_66a1e10ae4db42d6363fa8f6f7a7be45.html">Map&lt; PermutationMatrix&lt; SizeAtCompileTime, MaxSizeAtCompileTime, StorageIndex_ &gt;, PacketAccess_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_map_3_01_quaternion_3_01_scalar___01_4_00_01_options___01_4.html">Map&lt; Quaternion&lt; Scalar_ &gt;, Options_ &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a quaternion from a memory buffer.  <a href="class_eigen_1_1_map_3_01_quaternion_3_01_scalar___01_4_00_01_options___01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_map_3_01_sparse_matrix_3_01_mat_scalar_00_01_mat_options_00_01_mat_index_01_4_002c859b470cc9e43a031929bd752a93e6.html">Map&lt; SparseMatrix&lt; MatScalar, MatOptions, MatIndex &gt;, Options, StrideType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of class <a class="el" href="class_eigen_1_1_map.html" title="A matrix or vector expression mapping an existing array of data.">Map</a> for SparseMatrix-like storage.  <a href="class_eigen_1_1_map_3_01_sparse_matrix_3_01_mat_scalar_00_01_mat_options_00_01_mat_index_01_4_002c859b470cc9e43a031929bd752a93e6.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_map_3_01_transpositions_3_01_size_at_compile_time_00_01_max_size_at_compile_time6b48bb88d22d4b22c4bc1d2ca31538c4.html">Map&lt; Transpositions&lt; SizeAtCompileTime, MaxSizeAtCompileTime, StorageIndex_ &gt;, PacketAccess &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_map_base.html">MapBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_map_base_3_01_derived_00_01_read_only_accessors_01_4.html">MapBase&lt; Derived, ReadOnlyAccessors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for dense <a class="el" href="class_eigen_1_1_map.html" title="A matrix or vector expression mapping an existing array of data.">Map</a> and <a class="el" href="class_eigen_1_1_block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> expression with direct access.  <a href="class_eigen_1_1_map_base_3_01_derived_00_01_read_only_accessors_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_map_base_3_01_derived_00_01_write_accessors_01_4.html">MapBase&lt; Derived, WriteAccessors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for non-const dense <a class="el" href="class_eigen_1_1_map.html" title="A matrix or vector expression mapping an existing array of data.">Map</a> and <a class="el" href="class_eigen_1_1_block.html" title="Expression of a fixed-size or dynamic-size block.">Block</a> expression with direct access.  <a href="class_eigen_1_1_map_base_3_01_derived_00_01_write_accessors_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_mapped_skyline_matrix.html">MappedSkylineMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix.html">Matrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The matrix class, also used for vectors and row-vectors.  <a href="class_eigen_1_1_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all dense matrices, vectors, and expressions.  <a href="class_eigen_1_1_matrix_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_complex_power_return_value.html">MatrixComplexPowerReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix (expression).  <a href="class_eigen_1_1_matrix_complex_power_return_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_matrix_exponential_return_value.html">MatrixExponentialReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix exponential of some matrix (expression).  <a href="struct_eigen_1_1_matrix_exponential_return_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_function_return_value.html">MatrixFunctionReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix function of some matrix (expression).  <a href="class_eigen_1_1_matrix_function_return_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_logarithm_return_value.html">MatrixLogarithmReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix logarithm of some matrix (expression).  <a href="class_eigen_1_1_matrix_logarithm_return_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_market_iterator.html">MatrixMarketIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator to browse matrices from a specified folder.  <a href="class_eigen_1_1_matrix_market_iterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_power.html">MatrixPower</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix powers.  <a href="class_eigen_1_1_matrix_power.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_power_atomic.html">MatrixPowerAtomic</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for computing matrix powers.  <a href="class_eigen_1_1_matrix_power_atomic.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_power_parentheses_return_value.html">MatrixPowerParenthesesReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix.  <a href="class_eigen_1_1_matrix_power_parentheses_return_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_power_return_value.html">MatrixPowerReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix power of some matrix (expression).  <a href="class_eigen_1_1_matrix_power_return_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_square_root_return_value.html">MatrixSquareRootReturnValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proxy for the matrix square root of some matrix (expression).  <a href="class_eigen_1_1_matrix_square_root_return_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_matrix_wrapper.html">MatrixWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of an array as a mathematical vector or matrix.  <a href="class_eigen_1_1_matrix_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_matrix_xpr.html">MatrixXpr</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1max__n__1.html">max_n_1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1max__n__1_3_010_01_4.html">max_n_1&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_max_size_vector.html">MaxSizeVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_eigen_1_1_max_size_vector.html" title="The MaxSizeVector class.">MaxSizeVector</a> class.  <a href="class_eigen_1_1_max_size_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_metis_ordering.html">MetisOrdering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_m_i_n_r_e_s.html">MINRES</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A minimal residual solver for sparse symmetric problems.  <a href="class_eigen_1_1_m_i_n_r_e_s.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_movable_scalar.html">MovableScalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_natural_ordering.html">NaturalOrdering</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_nest_by_value.html">NestByValue</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression which must be nested by value.  <a href="class_eigen_1_1_nest_by_value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_no_alias.html">NoAlias</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo expression providing an operator = assuming no aliasing.  <a href="class_eigen_1_1_no_alias.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_no_op_output_kernel.html">NoOpOutputKernel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_notification.html">Notification</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_numerical_diff.html">NumericalDiff</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds information about the various numeric (i.e. scalar) types allowed by <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a>.  <a href="struct_eigen_1_1_num_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01_annoying_scalar_01_4.html">NumTraits&lt; AnnoyingScalar &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01_array_3_01_scalar_00_01_rows_00_01_cols_00_01_options_00_01_max_rows_00_01_max_cols_01_4_01_4.html">NumTraits&lt; Array&lt; Scalar, Rows, Cols, Options, MaxRows, MaxCols &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01_auto_diff_scalar_3_01_der_type_01_4_01_4.html">NumTraits&lt; AutoDiffScalar&lt; DerType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01bool_01_4.html">NumTraits&lt; bool &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01boost_1_1multiprecision_1_1detail_1_1expression_3_01_t1_00_01_t2de536fef90a65f9e6892d34a2e1ed34d.html">NumTraits&lt; boost::multiprecision::detail::expression&lt; T1, T2, T3, T4, T5 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01double_01_4.html">NumTraits&lt; double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01_eigen_1_1bfloat16_01_4.html">NumTraits&lt; Eigen::bfloat16 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01_eigen_1_1half_01_4.html">NumTraits&lt; Eigen::half &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01float_01_4.html">NumTraits&lt; float &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01long_01double_01_4.html">NumTraits&lt; long double &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01_movable_scalar_3_01float_01_4_01_4.html">NumTraits&lt; MovableScalar&lt; float &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01_real_01_4.html">NumTraits&lt; Real &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01std_1_1complex_3_01_real___01_4_01_4.html">NumTraits&lt; std::complex&lt; Real_ &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01std_1_1string_01_4.html">NumTraits&lt; std::string &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01type2index_3_01n_01_4_01_4.html">NumTraits&lt; type2index&lt; n &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_num_traits_3_01void_01_4.html">NumTraits&lt; void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_outer_stride.html">OuterStride</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience specialization of <a class="el" href="class_eigen_1_1_stride.html" title="Holds strides information for Map.">Stride</a> to specify only an outer stride See class <a class="el" href="class_eigen_1_1_map.html" title="A matrix or vector expression mapping an existing array of data.">Map</a> for some examples.  <a href="class_eigen_1_1_outer_stride.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_packet_converter.html">PacketConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_packet_converter_3_01_tensor_evaluator_00_01_src_packet_00_01_tgt_packet_00_011_00_011_01_4.html">PacketConverter&lt; TensorEvaluator, SrcPacket, TgtPacket, 1, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_packet_converter_3_01_tensor_evaluator_00_01_src_packet_00_01_tgt_packet_00_011_00_01_tgt_coeff_ratio_01_4.html">PacketConverter&lt; TensorEvaluator, SrcPacket, TgtPacket, 1, TgtCoeffRatio &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_packet_converter_3_01_tensor_evaluator_00_01_src_packet_00_01_tgt_packet_00_012_00_011_01_4.html">PacketConverter&lt; TensorEvaluator, SrcPacket, TgtPacket, 2, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_packet_converter_3_01_tensor_evaluator_00_01_src_packet_00_01_tgt_packet_00_014_00_011_01_4.html">PacketConverter&lt; TensorEvaluator, SrcPacket, TgtPacket, 4, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_packet_converter_3_01_tensor_evaluator_00_01_src_packet_00_01_tgt_packet_00_018_00_011_01_4.html">PacketConverter&lt; TensorEvaluator, SrcPacket, TgtPacket, 8, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_packet_type.html">PacketType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_pair.html">Pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_parametrized_line.html">ParametrizedLine</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A parametrized line.  <a href="class_eigen_1_1_parametrized_line.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_pardiso_impl.html">PardisoImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_pardiso_l_d_l_t.html">PardisoLDLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse direct Cholesky (<a class="el" href="class_eigen_1_1_l_d_l_t.html" title="Robust Cholesky decomposition of a matrix with pivoting.">LDLT</a>) factorization and solver based on the PARDISO library.  <a href="class_eigen_1_1_pardiso_l_d_l_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_pardiso_l_l_t.html">PardisoLLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse direct Cholesky (<a class="el" href="class_eigen_1_1_l_l_t.html" title="Standard Cholesky decomposition (LL^T) of a matrix and associated features.">LLT</a>) factorization and solver based on the PARDISO library.  <a href="class_eigen_1_1_pardiso_l_l_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_pardiso_l_u.html">PardisoLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse direct LU factorization and solver based on the PARDISO library.  <a href="class_eigen_1_1_pardiso_l_u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1partial__redux__dummy__func.html">partial_redux_dummy_func</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_partial_piv_l_u.html">PartialPivLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LU decomposition of a matrix with partial pivoting, and related features.  <a href="class_eigen_1_1_partial_piv_l_u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_partial_redux_expr.html">PartialReduxExpr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic expression of a partially reduxed matrix.  <a href="class_eigen_1_1_partial_redux_expr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_part_of.html">PartOf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_part_of_3_01_imag_part_01_4.html">PartOf&lt; ImagPart &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_part_of_3_01_real_part_01_4.html">PartOf&lt; RealPart &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_pastix_base.html">PastixBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_pastix_l_d_l_t.html">PastixLDLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse direct supernodal Cholesky (<a class="el" href="class_eigen_1_1_l_l_t.html" title="Standard Cholesky decomposition (LL^T) of a matrix and associated features.">LLT</a>) factorization and solver based on the PaStiX library.  <a href="class_eigen_1_1_pastix_l_d_l_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_pastix_l_l_t.html">PastixLLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse direct supernodal Cholesky (<a class="el" href="class_eigen_1_1_l_l_t.html" title="Standard Cholesky decomposition (LL^T) of a matrix and associated features.">LLT</a>) factorization and solver based on the PaStiX library.  <a href="class_eigen_1_1_pastix_l_l_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_pastix_l_u.html">PastixLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to the PaStix solver.  <a href="class_eigen_1_1_pastix_l_u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_permutation_base.html">PermutationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for permutations.  <a href="class_eigen_1_1_permutation_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_permutation_matrix.html">PermutationMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutation matrix.  <a href="class_eigen_1_1_permutation_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_permutation_shape.html">PermutationShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_permutation_storage.html">PermutationStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_permutation_wrapper.html">PermutationWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to view a vector of integers as a permutation matrix.  <a href="class_eigen_1_1_permutation_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_plain_object_base.html">PlainObjectBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_polynomial_solver.html">PolynomialSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A polynomial solver.  <a href="class_eigen_1_1_polynomial_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_polynomial_solver_3_01_scalar___00_011_01_4.html">PolynomialSolver&lt; Scalar_, 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_polynomial_solver_base.html">PolynomialSolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defined to be inherited by polynomial solvers: it provides convenient methods such as.  <a href="class_eigen_1_1_polynomial_solver_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_product.html">Product</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of the product of two arbitrary matrices or vectors.  <a href="class_eigen_1_1_product.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_product_impl.html">ProductImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_product_impl_3_01_lhs_00_01_rhs_00_01_option_00_01_dense_01_4.html">ProductImpl&lt; Lhs, Rhs, Option, Dense &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_product_return_type.html">ProductReturnType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_quaternion.html">Quaternion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The quaternion class used to represent 3D orientations and rotations.  <a href="class_eigen_1_1_quaternion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_quaternion_base.html">QuaternionBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for quaternion expressions.  <a href="class_eigen_1_1_quaternion_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_random_setter.html">RandomSetter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="class_eigen_1_1_random_setter.html" title="The RandomSetter is a wrapper object allowing to set/update a sparse matrix with random access.">RandomSetter</a> is a wrapper object allowing to set/update a sparse matrix with random access.  <a href="class_eigen_1_1_random_setter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_real_q_z.html">RealQZ</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a real QZ decomposition of a pair of square matrices.  <a href="class_eigen_1_1_real_q_z.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_real_schur.html">RealSchur</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs a real Schur decomposition of a square matrix.  <a href="class_eigen_1_1_real_schur.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_ref.html">Ref</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A matrix or vector expression mapping an existing expression.  <a href="class_eigen_1_1_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_ref_3_01const_01_sparse_matrix_3_01_mat_scalar_00_01_mat_options_00_01_mat_index1bbfd78857ba9c14d54178cb3009ac38.html">Ref&lt; const SparseMatrix&lt; MatScalar, MatOptions, MatIndex &gt;, Options, StrideType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_ref_3_01const_01_sparse_vector_3_01_mat_scalar_00_01_mat_options_00_01_mat_index673660e6a13ed7a7b712b0f75a25d720.html">Ref&lt; const SparseVector&lt; MatScalar, MatOptions, MatIndex &gt;, Options, StrideType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_ref_3_01const_01_t_plain_object_type_00_01_options_00_01_stride_type_01_4.html">Ref&lt; const TPlainObjectType, Options, StrideType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_ref_3_01_sparse_matrix_3_01_mat_scalar_00_01_mat_options_00_01_mat_index_01_4_0024ec28acf7b4e76d8ff99a0bdc39c296.html">Ref&lt; SparseMatrix&lt; MatScalar, MatOptions, MatIndex &gt;, Options, StrideType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse matrix expression referencing an existing sparse expression.  <a href="class_eigen_1_1_ref_3_01_sparse_matrix_3_01_mat_scalar_00_01_mat_options_00_01_mat_index_01_4_0024ec28acf7b4e76d8ff99a0bdc39c296.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_ref_3_01_sparse_vector_3_01_mat_scalar_00_01_mat_options_00_01_mat_index_01_4_00357b3c2eca55b7ce618d0a2b2447510f.html">Ref&lt; SparseVector&lt; MatScalar, MatOptions, MatIndex &gt;, Options, StrideType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse vector expression referencing an existing sparse vector expression.  <a href="class_eigen_1_1_ref_3_01_sparse_vector_3_01_mat_scalar_00_01_mat_options_00_01_mat_index_01_4_00357b3c2eca55b7ce618d0a2b2447510f.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_ref_base.html">RefBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_replicate.html">Replicate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of the multiple replication of a matrix or vector.  <a href="class_eigen_1_1_replicate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_reshaped.html">Reshaped</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a fixed-size or dynamic-size reshape.  <a href="class_eigen_1_1_reshaped.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_reshaped_impl.html">ReshapedImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_reshaped_impl_3_01_xpr_type_00_01_rows_00_01_cols_00_01_order_00_01_dense_01_4.html">ReshapedImpl&lt; XprType, Rows, Cols, Order, Dense &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_return_by_value.html">ReturnByValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_reverse.html">Reverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of the reverse of a vector or matrix.  <a href="class_eigen_1_1_reverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_rotation2_d.html">Rotation2D</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a rotation/orientation in a 2 dimensional space.  <a href="class_eigen_1_1_rotation2_d.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_rotation_base.html">RotationBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for compact rotation representations.  <a href="class_eigen_1_1_rotation_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_run_queue.html">RunQueue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_scalar_binary_op_traits.html">ScalarBinaryOpTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the given binary operation of two numeric types is allowed and what the scalar return type is.  <a href="struct_eigen_1_1_scalar_binary_op_traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_scalar_binary_op_traits_3_01_auto_diff_scalar_3_01_der_type_01_4_00_01typename_8029eb4becd448e88ba5e4cb75a4dd2b.html">ScalarBinaryOpTraits&lt; AutoDiffScalar&lt; DerType &gt;, typename DerType::Scalar, BinOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_scalar_binary_op_traits_3_01_t_00_01_t_00_01_binary_op_01_4.html">ScalarBinaryOpTraits&lt; T, T, BinaryOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_scalar_binary_op_traits_3_01_t_00_01typename_01_num_traits_3_01std_1_1enable__ifbe530695f4f3dc01aaaf6d5e7c67af1.html">ScalarBinaryOpTraits&lt; T, typename NumTraits&lt; std::enable_if_t&lt; NumTraits&lt; T &gt;::IsComplex, T &gt; &gt;::Real, BinaryOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_scalar_binary_op_traits_3_01_t_00_01void_00_01_binary_op_01_4.html">ScalarBinaryOpTraits&lt; T, void, BinaryOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_scalar_binary_op_traits_3_01typename_01_der_type_1_1_scalar_00_01_auto_diff_sca5c26207d328bbaa3069a04f38248d36b.html">ScalarBinaryOpTraits&lt; typename DerType::Scalar, AutoDiffScalar&lt; DerType &gt;, BinOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_scalar_binary_op_traits_3_01typename_01_num_traits_3_01std_1_1enable__if__t_3_091d7ef6159baf6224bdde1715a358c19.html">ScalarBinaryOpTraits&lt; typename NumTraits&lt; std::enable_if_t&lt; NumTraits&lt; T &gt;::IsComplex, T &gt; &gt;::Real, T, BinaryOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_scalar_binary_op_traits_3_01void_00_01_t_00_01_binary_op_01_4.html">ScalarBinaryOpTraits&lt; void, T, BinaryOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_scalar_binary_op_traits_3_01void_00_01void_00_01_binary_op_01_4.html">ScalarBinaryOpTraits&lt; void, void, BinaryOp &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_select.html">Select</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a coefficient wise version of the C++ ternary operator ?:  <a href="class_eigen_1_1_select.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1selfadjoint__product__selector.html">selfadjoint_product_selector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1selfadjoint__product__selector_3_01_matrix_type_00_01_other_type_00_01_up_lo_00_01false_01_4.html">selfadjoint_product_selector&lt; MatrixType, OtherType, UpLo, false &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1selfadjoint__product__selector_3_01_matrix_type_00_01_other_type_00_01_up_lo_00_01true_01_4.html">selfadjoint_product_selector&lt; MatrixType, OtherType, UpLo, true &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1selfadjoint__rank1__update.html">selfadjoint_rank1_update</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1selfadjoint__rank1__update_3_01_scalar_00_01_index_00_01_col_major_00_01_up_lo_0985162e7429113fdcd7a3950b8d00f1e.html">selfadjoint_rank1_update&lt; Scalar, Index, ColMajor, UpLo, ConjLhs, ConjRhs &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1selfadjoint__rank1__update_3_01_scalar_00_01_index_00_01_row_major_00_01_up_lo_03a9dcf0deae11b1da493e4caae5cd21a.html">selfadjoint_rank1_update&lt; Scalar, Index, RowMajor, UpLo, ConjLhs, ConjRhs &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_self_adjoint_eigen_solver.html">SelfAdjointEigenSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes eigenvalues and eigenvectors of selfadjoint matrices.  <a href="class_eigen_1_1_self_adjoint_eigen_solver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_self_adjoint_shape.html">SelfAdjointShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_self_adjoint_view.html">SelfAdjointView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a selfadjoint matrix from a triangular part of a dense matrix.  <a href="class_eigen_1_1_self_adjoint_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_serializer.html">Serializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_serializer_3_01_array_3_01_scalar_00_01_rows_00_01_cols_00_01_options_00_01_max_rows_00_01_max_cols_01_4_01_4.html">Serializer&lt; Array&lt; Scalar, Rows, Cols, Options, MaxRows, MaxCols &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_serializer_3_01_dense_base_3_01_derived_01_4_00_01void_01_4.html">Serializer&lt; DenseBase&lt; Derived &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_serializer_3_01_matrix_3_01_scalar_00_01_rows_00_01_cols_00_01_options_00_01_max_rows_00_01_max_cols_01_4_01_4.html">Serializer&lt; Matrix&lt; Scalar, Rows, Cols, Options, MaxRows, MaxCols &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_serializer_3_01_sparse_matrix_3_01_scalar_00_01_options_00_01_storage_index_01_4_00_01void_01_4.html">Serializer&lt; SparseMatrix&lt; Scalar, Options, StorageIndex &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_serializer_3_01_sparse_vector_3_01_scalar_00_01_options_00_01_storage_index_01_4_00_01void_01_4.html">Serializer&lt; SparseVector&lt; Scalar, Options, StorageIndex &gt;, void &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_serializer_3_01_t_00_01typename_01std_1_1enable__if__t_3_01std_1_1is__trivial_3_f4fa08d609a76d842dd2f7bc74d0667a.html">Serializer&lt; T, typename std::enable_if_t&lt; std::is_trivial&lt; T &gt;::value &amp;&amp;std::is_standard_layout&lt; T &gt;::value &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_s_group.html">SGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_eigen_1_1_symmetry.html">Symmetry</a> group, initialized from template arguments.  <a href="class_eigen_1_1_s_group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_simplicial_cholesky.html">SimplicialCholesky</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_simplicial_cholesky_base.html">SimplicialCholeskyBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for direct sparse Cholesky factorizations.  <a href="class_eigen_1_1_simplicial_cholesky_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_simplicial_l_d_l_t.html">SimplicialLDLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A direct sparse <a class="el" href="class_eigen_1_1_l_d_l_t.html" title="Robust Cholesky decomposition of a matrix with pivoting.">LDLT</a> Cholesky factorizations without square root.  <a href="class_eigen_1_1_simplicial_l_d_l_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_simplicial_l_l_t.html">SimplicialLLT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A direct sparse <a class="el" href="class_eigen_1_1_l_l_t.html" title="Standard Cholesky decomposition (LL^T) of a matrix and associated features.">LLT</a> Cholesky factorizations.  <a href="class_eigen_1_1_simplicial_l_l_t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_sizes.html">Sizes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_skew_symmetric_base.html">SkewSymmetricBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for skew symmetric matrices and expressions.  <a href="class_eigen_1_1_skew_symmetric_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_skew_symmetric_matrix3.html">SkewSymmetricMatrix3</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a 3x3 skew symmetric matrix with its storage.  <a href="class_eigen_1_1_skew_symmetric_matrix3.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_skew_symmetric_shape.html">SkewSymmetricShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_skew_symmetric_wrapper.html">SkewSymmetricWrapper</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a skew symmetric matrix.  <a href="class_eigen_1_1_skew_symmetric_wrapper.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_skyline_inplace_l_u.html">SkylineInplaceLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inplace LU decomposition of a skyline matrix and associated features.  <a href="class_eigen_1_1_skyline_inplace_l_u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_skyline_matrix.html">SkylineMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The main skyline matrix class.  <a href="class_eigen_1_1_skyline_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_skyline_matrix_base.html">SkylineMatrixBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of any skyline matrices or skyline expressions.  <a href="class_eigen_1_1_skyline_matrix_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_skyline_product.html">SkylineProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_skyline_product_return_type.html">SkylineProductReturnType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_skyline_storage.html">SkylineStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_skyline_vector.html">SkylineVector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_slu_matrix.html">SluMatrix</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_slu_matrix_map_helper.html">SluMatrixMapHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_slu_matrix_map_helper_3_01_matrix_3_01_scalar_00_01_rows_00_01_cols_00_01_optioce31c400c0dc6b34c9e9bbf922bc7aae.html">SluMatrixMapHelper&lt; Matrix&lt; Scalar, Rows, Cols, Options, MRows, MCols &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_slu_matrix_map_helper_3_01_sparse_matrix_base_3_01_derived_01_4_01_4.html">SluMatrixMapHelper&lt; SparseMatrixBase&lt; Derived &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_solve.html">Solve</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo expression representing a solving operation.  <a href="class_eigen_1_1_solve.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_solve_impl.html">SolveImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_solve_impl_3_01_decomposition_00_01_rhs_type_00_01_dense_01_4.html">SolveImpl&lt; Decomposition, RhsType, Dense &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_solver_base.html">SolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for matrix decomposition and solvers.  <a href="class_eigen_1_1_solver_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_solver_shape.html">SolverShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_solver_storage.html">SolverStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_solve_with_guess.html">SolveWithGuess</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo expression representing a solving operation.  <a href="class_eigen_1_1_solve_with_guess.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_sparse.html">Sparse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_compressed_base.html">SparseCompressedBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for sparse [compressed]-{row|column}-storage format.  <a href="class_eigen_1_1_sparse_compressed_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_dense_outer_product.html">SparseDenseOuterProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_sparse_dense_product_return_type.html">SparseDenseProductReturnType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_diagonal_product.html">SparseDiagonalProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_sparse_functor.html">SparseFunctor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_inverse.html">SparseInverse</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate sparse subset of inverse of sparse matrix  <a href="class_eigen_1_1_sparse_inverse.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u.html">SparseLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_eigen_1_1_sparse.html">Sparse</a> supernodal LU factorization for general matrices.  <a href="class_eigen_1_1_sparse_l_u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_sparse_l_u_matrix_l_return_type.html">SparseLUMatrixLReturnType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_sparse_l_u_matrix_u_return_type.html">SparseLUMatrixUReturnType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_l_u_transpose_view.html">SparseLUTransposeView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_map_base.html">SparseMapBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_map_base_3_01_derived_00_01_read_only_accessors_01_4.html">SparseMapBase&lt; Derived, ReadOnlyAccessors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for <a class="el" href="class_eigen_1_1_map.html" title="A matrix or vector expression mapping an existing array of data.">Map</a> and <a class="el" href="class_eigen_1_1_ref.html" title="A matrix or vector expression mapping an existing expression.">Ref</a> instance of sparse matrix and vector.  <a href="class_eigen_1_1_sparse_map_base_3_01_derived_00_01_read_only_accessors_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_map_base_3_01_derived_00_01_write_accessors_01_4.html">SparseMapBase&lt; Derived, WriteAccessors &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Common base class for writable <a class="el" href="class_eigen_1_1_map.html" title="A matrix or vector expression mapping an existing array of data.">Map</a> and <a class="el" href="class_eigen_1_1_ref.html" title="A matrix or vector expression mapping an existing expression.">Ref</a> instance of sparse matrix and vector.  <a href="class_eigen_1_1_sparse_map_base_3_01_derived_00_01_write_accessors_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A versatible sparse matrix representation.  <a href="class_eigen_1_1_sparse_matrix.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of any sparse matrices or sparse expressions.  <a href="class_eigen_1_1_sparse_matrix_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_q_r.html">SparseQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_eigen_1_1_sparse.html">Sparse</a> left-looking QR factorization with numerical column pivoting.  <a href="class_eigen_1_1_sparse_q_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_sparse_q_r___q_product.html">SparseQR_QProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_sparse_q_r_matrix_q_return_type.html">SparseQRMatrixQReturnType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_sparse_q_r_matrix_q_transpose_return_type.html">SparseQRMatrixQTransposeReturnType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_self_adjoint_view.html">SparseSelfAdjointView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo expression to manipulate a triangular sparse matrix as a selfadjoint matrix.  <a href="class_eigen_1_1_sparse_self_adjoint_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_sparse_shape.html">SparseShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_solver_base.html">SparseSolverBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A base class for sparse solvers.  <a href="class_eigen_1_1_sparse_solver_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_sparse_product.html">SparseSparseProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_sparse_sparse_product_return_type.html">SparseSparseProductReturnType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_symmetric_permutation_product.html">SparseSymmetricPermutationProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_time_dense_product.html">SparseTimeDenseProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_vector.html">SparseVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a sparse vector class  <a href="class_eigen_1_1_sparse_vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_sparse_view.html">SparseView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a dense or sparse matrix with zero or too small values removed.  <a href="class_eigen_1_1_sparse_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_spline.html">Spline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing multi-dimensional spline curves.  <a href="class_eigen_1_1_spline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_spline_fitting.html">SplineFitting</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_eigen_1_1_spline.html" title="A class representing multi-dimensional spline curves.">Spline</a> fitting methods.  <a href="struct_eigen_1_1_spline_fitting.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_spline_traits.html">SplineTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_spline_traits_3_01_spline_3_01_scalar___00_01_dim___00_01_degree___01_4_00_01___derivative_order_01_4.html">SplineTraits&lt; Spline&lt; Scalar_, Dim_, Degree_ &gt;, _DerivativeOrder &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time attributes of the <a class="el" href="class_eigen_1_1_spline.html" title="A class representing multi-dimensional spline curves.">Spline</a> class for fixed degree.  <a href="struct_eigen_1_1_spline_traits_3_01_spline_3_01_scalar___00_01_dim___00_01_degree___01_4_00_01___derivative_order_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_spline_traits_3_01_spline_3_01_scalar___00_01_dim___00_01_degree___01_4_00_01_dynamic_01_4.html">SplineTraits&lt; Spline&lt; Scalar_, Dim_, Degree_ &gt;, Dynamic &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compile-time attributes of the <a class="el" href="class_eigen_1_1_spline.html" title="A class representing multi-dimensional spline curves.">Spline</a> class for Dynamic degree.  <a href="struct_eigen_1_1_spline_traits_3_01_spline_3_01_scalar___00_01_dim___00_01_degree___01_4_00_01_dynamic_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_s_p_q_r.html">SPQR</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_eigen_1_1_sparse.html">Sparse</a> QR factorization based on SuiteSparseQR library.  <a href="class_eigen_1_1_s_p_q_r.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_s_p_q_r___q_product.html">SPQR_QProduct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_s_p_q_r_matrix_q_return_type.html">SPQRMatrixQReturnType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_s_p_q_r_matrix_q_transpose_return_type.html">SPQRMatrixQTransposeReturnType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_static_s_group.html">StaticSGroup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static symmetry group.  <a href="class_eigen_1_1_static_s_group.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_std_map_traits.html">StdMapTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_std_unordered_map_traits.html">StdUnorderedMapTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_stl_thread_environment.html">StlThreadEnvironment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_storage_memory.html">StorageMemory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_stride.html">Stride</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds strides information for <a class="el" href="class_eigen_1_1_map.html" title="A matrix or vector expression mapping an existing array of data.">Map</a>.  <a href="class_eigen_1_1_stride.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_super_l_u.html">SuperLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse direct LU factorization and solver based on the <a class="el" href="class_eigen_1_1_super_l_u.html" title="A sparse direct LU factorization and solver based on the SuperLU library.">SuperLU</a> library.  <a href="class_eigen_1_1_super_l_u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_super_l_u_base.html">SuperLUBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base class for the direct and incomplete LU factorization of <a class="el" href="class_eigen_1_1_super_l_u.html" title="A sparse direct LU factorization and solver based on the SuperLU library.">SuperLU</a>.  <a href="class_eigen_1_1_super_l_u_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_s_v_d_base.html">SVDBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of SVD algorithms.  <a href="class_eigen_1_1_s_v_d_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_swap_wrapper.html">SwapWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_symmetry.html">Symmetry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor.html">Tensor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tensor class.  <a href="class_eigen_1_1_tensor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_assign_op.html">TensorAssignOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_async_device.html">TensorAsyncDevice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo expression providing an operator = that will evaluate its argument asynchronously on the specified device. Currently only ThreadPoolDevice implements proper asynchronous execution, while the default and GPU devices just run the expression synchronously and call m_done() on completion..  <a href="class_eigen_1_1_tensor_async_device.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_base.html">TensorBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The tensor base class.  <a href="class_eigen_1_1_tensor_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_base_3_01_derived_00_01_read_only_accessors_01_4.html">TensorBase&lt; Derived, ReadOnlyAccessors &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_broadcasting_op.html">TensorBroadcastingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_chipping_op.html">TensorChippingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_concatenation_op.html">TensorConcatenationOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_eigen_1_1_tensor.html" title="The tensor class.">Tensor</a> concatenation class.  <a href="class_eigen_1_1_tensor_concatenation_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_contraction_evaluator_base.html">TensorContractionEvaluatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_contraction_op.html">TensorContractionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_contraction_params.html">TensorContractionParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_conversion_op.html">TensorConversionOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_eigen_1_1_tensor.html" title="The tensor class.">Tensor</a> conversion class. This class makes it possible to vectorize type casting operations when the number of scalars per packet in the source and the destination type differ.  <a href="class_eigen_1_1_tensor_conversion_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_convolution_op.html">TensorConvolutionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_cost_model.html">TensorCostModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_custom_binary_op.html">TensorCustomBinaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_eigen_1_1_tensor.html" title="The tensor class.">Tensor</a> custom class.  <a href="class_eigen_1_1_tensor_custom_binary_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_custom_unary_op.html">TensorCustomUnaryOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_eigen_1_1_tensor.html" title="The tensor class.">Tensor</a> custom class.  <a href="class_eigen_1_1_tensor_custom_unary_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_cwise_binary_op.html">TensorCwiseBinaryOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_cwise_nullary_op.html">TensorCwiseNullaryOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_cwise_ternary_op.html">TensorCwiseTernaryOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_cwise_unary_op.html">TensorCwiseUnaryOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_device.html">TensorDevice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo expression providing an operator = that will evaluate its argument on the specified computing 'device' (GPU, thread pool, ...)  <a href="class_eigen_1_1_tensor_device.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_eval_to_op.html">TensorEvalToOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator.html">TensorEvaluator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A cost model used to limit the number of threads used for evaluating tensor expression.  <a href="struct_eigen_1_1_tensor_evaluator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_derived_00_01_device_01_4.html">TensorEvaluator&lt; const Derived, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_assign_op_3_01_left_arg_type_00_01_right_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorAssignOp&lt; LeftArgType, RightArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_broadcasting_op_3_01_broadcast_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorBroadcastingOp&lt; Broadcast, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_chipping_op_3_01_dim_id_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorChippingOp&lt; DimId, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_concatenation_op_3_01_axis_00_01_left_arg_e37e1b61d31098a96aab7c22793b325c.html">TensorEvaluator&lt; const TensorConcatenationOp&lt; Axis, LeftArgType, RightArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_contraction_op_3_01_indices_00_01_left_arg9c4326f883824ad97f64c3ddefaca362.html">TensorEvaluator&lt; const TensorContractionOp&lt; Indices, LeftArgType, RightArgType, OutputKernelType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_contraction_op_3_01_indices_00_01_left_argde8579947f9ac1c1e76f6f37acd958cc.html">TensorEvaluator&lt; const TensorContractionOp&lt; Indices, LeftArgType, RightArgType, OutputKernelType &gt;, Eigen::SyclDevice &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_conversion_op_3_01_target_type_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorConversionOp&lt; TargetType, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_convolution_op_3_01_indices_00_01_input_ar27ed28dccb4630db304c3ad822c3d857.html">TensorEvaluator&lt; const TensorConvolutionOp&lt; Indices, InputArgType, KernelArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_convolution_op_3_01_indices_00_01_input_ar7770f416750693de4e3ca373ab370675.html">TensorEvaluator&lt; const TensorConvolutionOp&lt; Indices, InputArgType, KernelArgType &gt;, Eigen::SyclDevice &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_custom_binary_op_3_01_custom_binary_func_0fea6836b993af318b6a5ab54d775368f.html">TensorEvaluator&lt; const TensorCustomBinaryOp&lt; CustomBinaryFunc, LhsXprType, RhsXprType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_custom_unary_op_3_01_custom_unary_func_00_c98bd2331846ae9855eae47ba436125b.html">TensorEvaluator&lt; const TensorCustomUnaryOp&lt; CustomUnaryFunc, XprType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_cwise_binary_op_3_01_binary_op_00_01_left_d0674d2fbf9b5f3fd40347d3eda7a38d.html">TensorEvaluator&lt; const TensorCwiseBinaryOp&lt; BinaryOp, LeftArgType, RightArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_cwise_nullary_op_3_01_nullary_op_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorCwiseNullaryOp&lt; NullaryOp, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_cwise_ternary_op_3_01_ternary_op_00_01_arg9fef65261bbea39b0e5e8b56a6f07cfb.html">TensorEvaluator&lt; const TensorCwiseTernaryOp&lt; TernaryOp, Arg1Type, Arg2Type, Arg3Type &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_cwise_unary_op_3_01_unary_op_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorCwiseUnaryOp&lt; UnaryOp, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_eval_to_op_3_01_arg_type_00_01_make_pointer___01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorEvalToOp&lt; ArgType, MakePointer_ &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_f_f_t_op_3_01_f_f_t_00_01_arg_type_00_01_f5465061a41919661aa138e40adeec36d.html">TensorEvaluator&lt; const TensorFFTOp&lt; FFT, ArgType, FFTResultType, FFTDir &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_forced_eval_op_3_01_arg_type___01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorForcedEvalOp&lt; ArgType_ &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_generator_op_3_01_generator_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorGeneratorOp&lt; Generator, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_image_patch_op_3_01_rows_00_01_cols_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorImagePatchOp&lt; Rows, Cols, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_index_pair_op_3_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorIndexPairOp&lt; ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_inflation_op_3_01_strides_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorInflationOp&lt; Strides, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_layout_swap_op_3_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorLayoutSwapOp&lt; ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_padding_op_3_01_padding_dimensions_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorPaddingOp&lt; PaddingDimensions, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_pair_reducer_op_3_01_reduce_op_00_01_dims_68d687aab61d8d8c3d9941c64161567d.html">TensorEvaluator&lt; const TensorPairReducerOp&lt; ReduceOp, Dims, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_patch_op_3_01_patch_dim_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorPatchOp&lt; PatchDim, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_reduction_op_3_01_op_00_01_dims_00_01_arg_4fdf2ec1445de4704eb590bc98040dc6.html">TensorEvaluator&lt; const TensorReductionOp&lt; Op, Dims, ArgType, MakePointer_ &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_reduction_op_3_01_op_00_01_dims_00_01_arg_8526ad21653c64b8cfa89ee710d9dbfa.html">TensorEvaluator&lt; const TensorReductionOp&lt; Op, Dims, ArgType, MakePointer_ &gt;, Eigen::SyclDevice &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_ref_3_01_derived_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorRef&lt; Derived &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_reshaping_op_3_01_new_dimensions_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorReshapingOp&lt; NewDimensions, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_reverse_op_3_01_reverse_dimensions_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorReverseOp&lt; ReverseDimensions, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_scan_op_3_01_op_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorScanOp&lt; Op, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_select_op_3_01_if_arg_type_00_01_then_arg_346b931156fad56ae8aa875afe41cb55.html">TensorEvaluator&lt; const TensorSelectOp&lt; IfArgType, ThenArgType, ElseArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_shuffling_op_3_01_shuffle_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorShufflingOp&lt; Shuffle, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_slicing_op_3_01_start_indices_00_01_sizes_ad061dd92ee73f8ad7fd3bb05ad7286d.html">TensorEvaluator&lt; const TensorSlicingOp&lt; StartIndices, Sizes, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_striding_op_3_01_strides_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorStridingOp&lt; Strides, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_striding_slicing_op_3_01_start_indices_00_cee1ff5835d6d215dedc4ac8d5000be4.html">TensorEvaluator&lt; const TensorStridingSlicingOp&lt; StartIndices, StopIndices, Strides, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_trace_op_3_01_dims_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; const TensorTraceOp&lt; Dims, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01const_01_tensor_volume_patch_op_3_01_planes_00_01_rows_00_7868d50e868058a145e213ecbb5a830e.html">TensorEvaluator&lt; const TensorVolumePatchOp&lt; Planes, Rows, Cols, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01_tensor_chipping_op_3_01_dim_id_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; TensorChippingOp&lt; DimId, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01_tensor_concatenation_op_3_01_axis_00_01_left_arg_type_00_7f27325ca3102a6730769e76427d2ca7.html">TensorEvaluator&lt; TensorConcatenationOp&lt; Axis, LeftArgType, RightArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01_tensor_layout_swap_op_3_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; TensorLayoutSwapOp&lt; ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01_tensor_ref_3_01_derived_01_4_00_01_device_01_4.html">TensorEvaluator&lt; TensorRef&lt; Derived &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01_tensor_reshaping_op_3_01_new_dimensions_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; TensorReshapingOp&lt; NewDimensions, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01_tensor_reverse_op_3_01_reverse_dimensions_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; TensorReverseOp&lt; ReverseDimensions, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01_tensor_shuffling_op_3_01_shuffle_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; TensorShufflingOp&lt; Shuffle, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01_tensor_slicing_op_3_01_start_indices_00_01_sizes_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; TensorSlicingOp&lt; StartIndices, Sizes, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01_tensor_striding_op_3_01_strides_00_01_arg_type_01_4_00_01_device_01_4.html">TensorEvaluator&lt; TensorStridingOp&lt; Strides, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_evaluator_3_01_tensor_striding_slicing_op_3_01_start_indices_00_01_stop_b19fd6c14958f7e749ce3c389a8eda72.html">TensorEvaluator&lt; TensorStridingSlicingOp&lt; StartIndices, StopIndices, Strides, ArgType &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_f_f_t_op.html">TensorFFTOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_fixed_size.html">TensorFixedSize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fixed sized version of the tensor class.  <a href="class_eigen_1_1_tensor_fixed_size.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_forced_eval_op.html">TensorForcedEvalOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_generator_op.html">TensorGeneratorOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_eigen_1_1_tensor.html" title="The tensor class.">Tensor</a> generator class.  <a href="class_eigen_1_1_tensor_generator_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_image_patch_op.html">TensorImagePatchOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_index_pair_op.html">TensorIndexPairOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_inflation_op.html">TensorInflationOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_i_o_format.html">TensorIOFormat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_layout_swap_op.html">TensorLayoutSwapOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_map.html">TensorMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A tensor expression mapping an existing array of data.  <a href="class_eigen_1_1_tensor_map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_op_cost.html">TensorOpCost</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_padding_op.html">TensorPaddingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_pair_reducer_op.html">TensorPairReducerOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_patch_op.html">TensorPatchOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_reduction_evaluator_base.html">TensorReductionEvaluatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_tensor_reduction_evaluator_base_3_01const_01_tensor_reduction_op_3_01_op_00_01_05381c92c64ce608472a315e16b836a8.html">TensorReductionEvaluatorBase&lt; const TensorReductionOp&lt; Op, Dims, ArgType, MakePointer_ &gt;, Device &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_reduction_op.html">TensorReductionOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_ref.html">TensorRef</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A reference to a tensor expression The expression will be evaluated lazily (as much as possible).  <a href="class_eigen_1_1_tensor_ref.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_reshaping_op.html">TensorReshapingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_reverse_op.html">TensorReverseOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_scan_op.html">TensorScanOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_select_op.html">TensorSelectOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_shuffling_op.html">TensorShufflingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_slicing_op.html">TensorSlicingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_storage.html">TensorStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_storage_3_01_t_00_01_d_sizes_3_01_index_type_00_01_num_indices___01_4_00_01_options___01_4.html">TensorStorage&lt; T, DSizes&lt; IndexType, NumIndices_ &gt;, Options_ &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_striding_op.html">TensorStridingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_striding_slicing_op.html">TensorStridingSlicingOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_trace_op.html">TensorTraceOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_volume_patch_op.html">TensorVolumePatchOp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_with_format.html">TensorWithFormat</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_with_format_3_01_t_00_01_col_major_00_010_01_4.html">TensorWithFormat&lt; T, ColMajor, 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_with_format_3_01_t_00_01_col_major_00_01rank_01_4.html">TensorWithFormat&lt; T, ColMajor, rank &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tensor_with_format_3_01_t_00_01_row_major_00_01rank_01_4.html">TensorWithFormat&lt; T, RowMajor, rank &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_thread_local.html">ThreadLocal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_thread_pool_interface.html">ThreadPoolInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_thread_pool_templ.html">ThreadPoolTempl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_transform.html">Transform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an homogeneous transformation in a N dimensional space.  <a href="class_eigen_1_1_transform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_translation.html">Translation</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a translation transformation.  <a href="class_eigen_1_1_translation.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_transpose.html">Transpose</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of the transpose of a matrix.  <a href="class_eigen_1_1_transpose.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_transpose_3_01_transpositions_base_3_01_transpositions_derived_01_4_01_4.html">Transpose&lt; TranspositionsBase&lt; TranspositionsDerived &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_transpose_impl.html">TransposeImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_transpose_impl_3_01_matrix_type_00_01_dense_01_4.html">TransposeImpl&lt; MatrixType, Dense &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_transpose_impl_3_01_matrix_type_00_01_sparse_01_4.html">TransposeImpl&lt; MatrixType, Sparse &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_transpositions.html">Transpositions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a sequence of transpositions (row/column interchange)  <a href="class_eigen_1_1_transpositions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_transpositions_base.html">TranspositionsBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_transpositions_shape.html">TranspositionsShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_transpositions_storage.html">TranspositionsStorage</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_transpositions_wrapper.html">TranspositionsWrapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_triangular_base.html">TriangularBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for triangular part in a matrix.  <a href="class_eigen_1_1_triangular_base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1_triangular_shape.html">TriangularShape</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_triangular_view.html">TriangularView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a triangular part in a matrix.  <a href="class_eigen_1_1_triangular_view.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_triangular_view_impl.html">TriangularViewImpl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_triangular_view_impl_3_01_matrix_type_00_01_mode_00_01_sparse_01_4.html">TriangularViewImpl&lt; MatrixType, Mode, Sparse &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a triangular part in a <b>sparse</b> matrix.  <a href="class_eigen_1_1_triangular_view_impl_3_01_matrix_type_00_01_mode_00_01_sparse_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_triangular_view_impl_3_01_matrix_type___00_01_mode___00_01_dense_01_4.html">TriangularViewImpl&lt; MatrixType_, Mode_, Dense &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for a triangular part in a <b>dense</b> matrix.  <a href="class_eigen_1_1_triangular_view_impl_3_01_matrix_type___00_01_mode___00_01_dense_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_tridiagonalization.html">Tridiagonalization</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tridiagonal decomposition of a selfadjoint matrix.  <a href="class_eigen_1_1_tridiagonalization.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_triplet.html">Triplet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small structure to hold a non zero as a triplet (i,j,value).  <a href="class_eigen_1_1_triplet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1type2index.html">type2index</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_eigen_1_1type2indexpair.html">type2indexpair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_umf_pack_l_u.html">UmfPackLU</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse LU factorization and solver based on UmfPack.  <a href="class_eigen_1_1_umf_pack_l_u.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_uniform_scaling.html">UniformScaling</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a generic uniform scaling transformation.  <a href="class_eigen_1_1_uniform_scaling.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_vector_block.html">VectorBlock</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expression of a fixed-size or dynamic-size sub-vector.  <a href="class_eigen_1_1_vector_block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_vectorwise_op.html">VectorwiseOp</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo expression providing broadcasting and partial reduction operations.  <a href="class_eigen_1_1_vectorwise_op.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_eigen_1_1_with_format.html">WithFormat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pseudo expression providing matrix output with given format.  <a href="class_eigen_1_1_with_format.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1efac32ba0383f43bbd3cae7f55cfcb4"><td class="memTemplParams" colspan="2"><a id="a1efac32ba0383f43bbd3cae7f55cfcb4"></a>
template&lt;typename MatrixType , int UpLo = Lower&gt; </td></tr>
<tr class="memitem:a1efac32ba0383f43bbd3cae7f55cfcb4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AccelerateLLT</b> = <a class="el" href="class_eigen_1_1_accelerate_impl.html">AccelerateImpl</a>&lt; MatrixType, UpLo|<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda7d30fb969ef6b763c098f0015108cef4">Symmetric</a>, SparseFactorizationCholesky, true &gt;</td></tr>
<tr class="separator:a1efac32ba0383f43bbd3cae7f55cfcb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a306fbf7c7da66a787c51f4cbabd1b29e"><td class="memTemplParams" colspan="2"><a id="a306fbf7c7da66a787c51f4cbabd1b29e"></a>
template&lt;typename MatrixType , int UpLo = Lower&gt; </td></tr>
<tr class="memitem:a306fbf7c7da66a787c51f4cbabd1b29e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AccelerateLDLT</b> = <a class="el" href="class_eigen_1_1_accelerate_impl.html">AccelerateImpl</a>&lt; MatrixType, UpLo|<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda7d30fb969ef6b763c098f0015108cef4">Symmetric</a>, SparseFactorizationLDLT, true &gt;</td></tr>
<tr class="separator:a306fbf7c7da66a787c51f4cbabd1b29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d7a33f29f85992e3b80ff1a2ae2f910"><td class="memTemplParams" colspan="2"><a id="a7d7a33f29f85992e3b80ff1a2ae2f910"></a>
template&lt;typename MatrixType , int UpLo = Lower&gt; </td></tr>
<tr class="memitem:a7d7a33f29f85992e3b80ff1a2ae2f910"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AccelerateLDLTUnpivoted</b> = <a class="el" href="class_eigen_1_1_accelerate_impl.html">AccelerateImpl</a>&lt; MatrixType, UpLo|<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda7d30fb969ef6b763c098f0015108cef4">Symmetric</a>, SparseFactorizationLDLTUnpivoted, true &gt;</td></tr>
<tr class="separator:a7d7a33f29f85992e3b80ff1a2ae2f910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c21016724a436e1538f27ee0986e31d"><td class="memTemplParams" colspan="2"><a id="a8c21016724a436e1538f27ee0986e31d"></a>
template&lt;typename MatrixType , int UpLo = Lower&gt; </td></tr>
<tr class="memitem:a8c21016724a436e1538f27ee0986e31d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AccelerateLDLTSBK</b> = <a class="el" href="class_eigen_1_1_accelerate_impl.html">AccelerateImpl</a>&lt; MatrixType, UpLo|<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda7d30fb969ef6b763c098f0015108cef4">Symmetric</a>, SparseFactorizationLDLTSBK, true &gt;</td></tr>
<tr class="separator:a8c21016724a436e1538f27ee0986e31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfdbff45a3cc430a53c22a1e6f2a2f6"><td class="memTemplParams" colspan="2"><a id="a2bfdbff45a3cc430a53c22a1e6f2a2f6"></a>
template&lt;typename MatrixType , int UpLo = Lower&gt; </td></tr>
<tr class="memitem:a2bfdbff45a3cc430a53c22a1e6f2a2f6"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AccelerateLDLTTPP</b> = <a class="el" href="class_eigen_1_1_accelerate_impl.html">AccelerateImpl</a>&lt; MatrixType, UpLo|<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda7d30fb969ef6b763c098f0015108cef4">Symmetric</a>, SparseFactorizationLDLTTPP, true &gt;</td></tr>
<tr class="separator:a2bfdbff45a3cc430a53c22a1e6f2a2f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a48d030076379d2f25230098de43b1"><td class="memTemplParams" colspan="2"><a id="a97a48d030076379d2f25230098de43b1"></a>
template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a97a48d030076379d2f25230098de43b1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AccelerateQR</b> = <a class="el" href="class_eigen_1_1_accelerate_impl.html">AccelerateImpl</a>&lt; MatrixType, 0, SparseFactorizationQR, false &gt;</td></tr>
<tr class="separator:a97a48d030076379d2f25230098de43b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c62533b6aefd2827110a559abf01ce"><td class="memTemplParams" colspan="2"><a id="af5c62533b6aefd2827110a559abf01ce"></a>
template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:af5c62533b6aefd2827110a559abf01ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>AccelerateCholeskyAtA</b> = <a class="el" href="class_eigen_1_1_accelerate_impl.html">AccelerateImpl</a>&lt; MatrixType, 0, SparseFactorizationCholeskyAtA, false &gt;</td></tr>
<tr class="separator:af5c62533b6aefd2827110a559abf01ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836a3a8dafac8a82453d0c09e2171fb1"><td class="memTemplParams" colspan="2"><a id="a836a3a8dafac8a82453d0c09e2171fb1"></a>
template&lt;typename Derived , typename ScalarExponent &gt; </td></tr>
<tr class="memitem:a836a3a8dafac8a82453d0c09e2171fb1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>GlobalUnaryPowReturnType</b> = std::enable_if_t&lt; !<a class="el" href="struct_eigen_1_1internal_1_1is__arithmetic.html">internal::is_arithmetic</a>&lt; typename <a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; Derived &gt;::Real &gt;::value &amp;&amp;<a class="el" href="struct_eigen_1_1internal_1_1is__arithmetic.html">internal::is_arithmetic</a>&lt; typename <a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; ScalarExponent &gt;::Real &gt;::value, <a class="el" href="class_eigen_1_1_cwise_unary_op.html">CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__unary__pow__op.html">internal::scalar_unary_pow_op</a>&lt; typename Derived::Scalar, ScalarExponent &gt;, const Derived &gt; &gt;</td></tr>
<tr class="separator:a836a3a8dafac8a82453d0c09e2171fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2623c0d4641dda067fbdb9a009ef0c91"><td class="memTemplParams" colspan="2">
template&lt;typename Type , int Size&gt; </td></tr>
<tr class="memitem:ga2623c0d4641dda067fbdb9a009ef0c91"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrixtypedefs.html#ga2623c0d4641dda067fbdb9a009ef0c91">Vector</a> = <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; Type, Size, 1 &gt;</td></tr>
<tr class="memdesc:ga2623c0d4641dda067fbdb9a009ef0c91"><td class="mdescLeft">&#160;</td><td class="mdescRight">\cpp11 <code>Size</code>&times;<code>1</code> vector of type <code>Type</code>. <br /></td></tr>
<tr class="separator:ga2623c0d4641dda067fbdb9a009ef0c91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga181118570e7a0bb1cf3366180061f14f"><td class="memTemplParams" colspan="2">
template&lt;typename Type , int Size&gt; </td></tr>
<tr class="memitem:ga181118570e7a0bb1cf3366180061f14f"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__matrixtypedefs.html#ga181118570e7a0bb1cf3366180061f14f">RowVector</a> = <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; Type, 1, Size &gt;</td></tr>
<tr class="memdesc:ga181118570e7a0bb1cf3366180061f14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">\cpp11 <code>1</code>&times;<code>Size</code> vector of type <code>Type</code>. <br /></td></tr>
<tr class="separator:ga181118570e7a0bb1cf3366180061f14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06499c94936a19673e53deb516a1b76"><td class="memItemLeft" align="right" valign="top"><a id="aa06499c94936a19673e53deb516a1b76"></a>
typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE&#160;</td><td class="memItemRight" valign="bottom"><b>DenseIndex</b></td></tr>
<tr class="separator:aa06499c94936a19673e53deb516a1b76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e77e0933482dafde8fe197d9a2cfde"><td class="memItemLeft" align="right" valign="top">typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a></td></tr>
<tr class="memdesc:a62e77e0933482dafde8fe197d9a2cfde"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Index type as used for the API.  <a href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">More...</a><br /></td></tr>
<tr class="separator:a62e77e0933482dafde8fe197d9a2cfde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98d4a3e6a17265ea869019a892c18348"><td class="memItemLeft" align="right" valign="top"><a id="a98d4a3e6a17265ea869019a892c18348"></a>
typedef std::complex&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>dcomplex</b></td></tr>
<tr class="separator:a98d4a3e6a17265ea869019a892c18348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04a60bbffdc89e47eb1ff3adc31fd559"><td class="memItemLeft" align="right" valign="top"><a id="a04a60bbffdc89e47eb1ff3adc31fd559"></a>
typedef std::complex&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>scomplex</b></td></tr>
<tr class="separator:a04a60bbffdc89e47eb1ff3adc31fd559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02236777748981f69ac8703769d03088"><td class="memItemLeft" align="right" valign="top"><a id="a02236777748981f69ac8703769d03088"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>BlasIndex</b></td></tr>
<tr class="separator:a02236777748981f69ac8703769d03088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc7128416da41ca99bb8af814b78599e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_angle_axis.html">AngleAxis</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___geometry___module.html#gadc7128416da41ca99bb8af814b78599e">AngleAxisf</a></td></tr>
<tr class="separator:gadc7128416da41ca99bb8af814b78599e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac218cd8f23b49aa36401d0c843bb6835"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_angle_axis.html">AngleAxis</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___geometry___module.html#gac218cd8f23b49aa36401d0c843bb6835">AngleAxisd</a></td></tr>
<tr class="separator:gac218cd8f23b49aa36401d0c843bb6835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga785b13a5a87f9bf55d4eba51ead2dcf0"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_quaternion.html">Quaternion</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___geometry___module.html#ga785b13a5a87f9bf55d4eba51ead2dcf0">Quaternionf</a></td></tr>
<tr class="separator:ga785b13a5a87f9bf55d4eba51ead2dcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e77eb8b6aae0e04be2db88107dbc642"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_quaternion.html">Quaternion</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___geometry___module.html#ga6e77eb8b6aae0e04be2db88107dbc642">Quaterniond</a></td></tr>
<tr class="separator:ga6e77eb8b6aae0e04be2db88107dbc642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dad770768dc28ad3cee4696841a5dd4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_map.html">Map</a>&lt; <a class="el" href="class_eigen_1_1_quaternion.html">Quaternion</a>&lt; float &gt;, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___geometry___module.html#ga7dad770768dc28ad3cee4696841a5dd4">QuaternionMapf</a></td></tr>
<tr class="separator:ga7dad770768dc28ad3cee4696841a5dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac566b934815fa5293437b5d0c065d4e8"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_map.html">Map</a>&lt; <a class="el" href="class_eigen_1_1_quaternion.html">Quaternion</a>&lt; double &gt;, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___geometry___module.html#gac566b934815fa5293437b5d0c065d4e8">QuaternionMapd</a></td></tr>
<tr class="separator:gac566b934815fa5293437b5d0c065d4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1224c70c2ecdaeb4bffa4887dbf2d04d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_map.html">Map</a>&lt; <a class="el" href="class_eigen_1_1_quaternion.html">Quaternion</a>&lt; float &gt;, <a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf">Aligned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___geometry___module.html#ga1224c70c2ecdaeb4bffa4887dbf2d04d">QuaternionMapAlignedf</a></td></tr>
<tr class="separator:ga1224c70c2ecdaeb4bffa4887dbf2d04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c11d0bbf7602645581380ba3cd6e690"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_map.html">Map</a>&lt; <a class="el" href="class_eigen_1_1_quaternion.html">Quaternion</a>&lt; double &gt;, <a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf">Aligned</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___geometry___module.html#ga4c11d0bbf7602645581380ba3cd6e690">QuaternionMapAlignedd</a></td></tr>
<tr class="separator:ga4c11d0bbf7602645581380ba3cd6e690"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad801876e45910d99ebc3f8425e5e2a9e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_rotation2_d.html">Rotation2D</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___geometry___module.html#gad801876e45910d99ebc3f8425e5e2a9e">Rotation2Df</a></td></tr>
<tr class="separator:gad801876e45910d99ebc3f8425e5e2a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga610359336130abe9a396ca159b3e8258"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_rotation2_d.html">Rotation2D</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___geometry___module.html#ga610359336130abe9a396ca159b3e8258">Rotation2Dd</a></td></tr>
<tr class="separator:ga610359336130abe9a396ca159b3e8258"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5acdf901fca83d0f807538414fe0d29e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_diagonal_matrix.html">DiagonalMatrix</a>&lt; float, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a5acdf901fca83d0f807538414fe0d29e">AlignedScaling2f</a></td></tr>
<tr class="separator:a5acdf901fca83d0f807538414fe0d29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028f6f47e59a156fba3bd984363644bd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_diagonal_matrix.html">DiagonalMatrix</a>&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a028f6f47e59a156fba3bd984363644bd">AlignedScaling2d</a></td></tr>
<tr class="separator:a028f6f47e59a156fba3bd984363644bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07fc07f3188dad812b24f581985d3d4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_diagonal_matrix.html">DiagonalMatrix</a>&lt; float, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#af07fc07f3188dad812b24f581985d3d4">AlignedScaling3f</a></td></tr>
<tr class="separator:af07fc07f3188dad812b24f581985d3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4362757fc0624ef024a7b56b256bfc86"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_eigen_1_1_diagonal_matrix.html">DiagonalMatrix</a>&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a4362757fc0624ef024a7b56b256bfc86">AlignedScaling3d</a></td></tr>
<tr class="separator:a4362757fc0624ef024a7b56b256bfc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac031bf50068e71eac1a95b338301fc76"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; float, 2, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a080cd5366173608f701cd945c2335568">Isometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Isometry2f</b></td></tr>
<tr class="separator:gac031bf50068e71eac1a95b338301fc76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32fcbd332028977266895dfd6a0a966"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; float, 3, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a080cd5366173608f701cd945c2335568">Isometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Isometry3f</b></td></tr>
<tr class="separator:gaf32fcbd332028977266895dfd6a0a966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85469b5fd842b7add09a12ebd5f6e5f7"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; double, 2, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a080cd5366173608f701cd945c2335568">Isometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Isometry2d</b></td></tr>
<tr class="separator:ga85469b5fd842b7add09a12ebd5f6e5f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2bd16f49442a7c039c2a5a6e6ef6ae10"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; double, 3, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a080cd5366173608f701cd945c2335568">Isometry</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Isometry3d</b></td></tr>
<tr class="separator:ga2bd16f49442a7c039c2a5a6e6ef6ae10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c1ea05a21899654ee3a2e3f91fa30e0"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; float, 2, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a71e768e0581725d919d0b05f4cb83234">Affine</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Affine2f</b></td></tr>
<tr class="separator:ga2c1ea05a21899654ee3a2e3f91fa30e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17e901de8ff882aea7845c5457db6a4f"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; float, 3, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a71e768e0581725d919d0b05f4cb83234">Affine</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Affine3f</b></td></tr>
<tr class="separator:ga17e901de8ff882aea7845c5457db6a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4ffc25cac8d8bf79ce8dee2f257111c"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; double, 2, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a71e768e0581725d919d0b05f4cb83234">Affine</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Affine2d</b></td></tr>
<tr class="separator:gaf4ffc25cac8d8bf79ce8dee2f257111c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaffa69d3143826efeb84e5d6c56a4c78"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; double, 3, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a71e768e0581725d919d0b05f4cb83234">Affine</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Affine3d</b></td></tr>
<tr class="separator:gaaffa69d3143826efeb84e5d6c56a4c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1eacd9947275ae2ede9720865a6cdd12"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; float, 2, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aa30a06b60d218b709020972df47de2b0">AffineCompact</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AffineCompact2f</b></td></tr>
<tr class="separator:ga1eacd9947275ae2ede9720865a6cdd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga367b34099eb022e54ae87a993e4026dc"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; float, 3, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aa30a06b60d218b709020972df47de2b0">AffineCompact</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AffineCompact3f</b></td></tr>
<tr class="separator:ga367b34099eb022e54ae87a993e4026dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63bcd8f0e502bfddd3d4848091a8f0c3"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; double, 2, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aa30a06b60d218b709020972df47de2b0">AffineCompact</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AffineCompact2d</b></td></tr>
<tr class="separator:ga63bcd8f0e502bfddd3d4848091a8f0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabcab8f2099a3d08948548e21874ecfcb"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; double, 3, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aa30a06b60d218b709020972df47de2b0">AffineCompact</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>AffineCompact3d</b></td></tr>
<tr class="separator:gabcab8f2099a3d08948548e21874ecfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c0a922ca75a04ef2f6c310dad0a4ab8"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; float, 2, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aead6a2de12a17aaa4f5c523215dfccad">Projective</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Projective2f</b></td></tr>
<tr class="separator:ga8c0a922ca75a04ef2f6c310dad0a4ab8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab14804071b7486b6666f3d324475a478"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; float, 3, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aead6a2de12a17aaa4f5c523215dfccad">Projective</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Projective3f</b></td></tr>
<tr class="separator:gab14804071b7486b6666f3d324475a478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga461bbe55fc07888761bcda98aea0366d"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; double, 2, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aead6a2de12a17aaa4f5c523215dfccad">Projective</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Projective2d</b></td></tr>
<tr class="separator:ga461bbe55fc07888761bcda98aea0366d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9cec8c457da930391eb73370e07aaae"><td class="memItemLeft" align="right" valign="top">
typedef <a class="el" href="class_eigen_1_1_transform.html">Transform</a>&lt; double, 3, <a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aead6a2de12a17aaa4f5c523215dfccad">Projective</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Projective3d</b></td></tr>
<tr class="separator:gab9cec8c457da930391eb73370e07aaae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69caf4470e90184c0f6d25fb2b0d3d77"><td class="memItemLeft" align="right" valign="top"><a id="a69caf4470e90184c0f6d25fb2b0d3d77"></a>
typedef <a class="el" href="class_eigen_1_1_translation.html">Translation</a>&lt; float, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Translation2f</b></td></tr>
<tr class="separator:a69caf4470e90184c0f6d25fb2b0d3d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982a8a83eaa55aa335772a7513cd71a6"><td class="memItemLeft" align="right" valign="top"><a id="a982a8a83eaa55aa335772a7513cd71a6"></a>
typedef <a class="el" href="class_eigen_1_1_translation.html">Translation</a>&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Translation2d</b></td></tr>
<tr class="separator:a982a8a83eaa55aa335772a7513cd71a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909b4672826ae2cc78a167e49dfe21a5"><td class="memItemLeft" align="right" valign="top"><a id="a909b4672826ae2cc78a167e49dfe21a5"></a>
typedef <a class="el" href="class_eigen_1_1_translation.html">Translation</a>&lt; float, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Translation3f</b></td></tr>
<tr class="separator:a909b4672826ae2cc78a167e49dfe21a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da881f21d724e3673633450198092d4"><td class="memItemLeft" align="right" valign="top"><a id="a1da881f21d724e3673633450198092d4"></a>
typedef <a class="el" href="class_eigen_1_1_translation.html">Translation</a>&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>Translation3d</b></td></tr>
<tr class="separator:a1da881f21d724e3673633450198092d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e1a4be8f88b43f2054d759a449042c9"><td class="memItemLeft" align="right" valign="top"><a id="a9e1a4be8f88b43f2054d759a449042c9"></a>
typedef <a class="el" href="class_eigen_1_1_thread_pool_templ.html">ThreadPoolTempl</a>&lt; <a class="el" href="struct_eigen_1_1_stl_thread_environment.html">StlThreadEnvironment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ThreadPool</b></td></tr>
<tr class="separator:a9e1a4be8f88b43f2054d759a449042c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f560c77056cdde7d413619127e0923"><td class="memTemplParams" colspan="2"><a id="a22f560c77056cdde7d413619127e0923"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:a22f560c77056cdde7d413619127e0923"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>array</b> = std::array&lt; <a class="el" href="class_eigen_1_1_triplet.html">T</a>, N &gt;</td></tr>
<tr class="separator:a22f560c77056cdde7d413619127e0923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3267f52cedb0db97b9e2900f27193db"><td class="memItemLeft" align="right" valign="top"><a id="ab3267f52cedb0db97b9e2900f27193db"></a>
typedef <a class="el" href="class_eigen_1_1_spline.html">Spline</a>&lt; float, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ab3267f52cedb0db97b9e2900f27193db">Spline2f</a></td></tr>
<tr class="memdesc:ab3267f52cedb0db97b9e2900f27193db"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D float B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:ab3267f52cedb0db97b9e2900f27193db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df1e9c9ea06a0bcd26626f1b64d785e"><td class="memItemLeft" align="right" valign="top"><a id="a8df1e9c9ea06a0bcd26626f1b64d785e"></a>
typedef <a class="el" href="class_eigen_1_1_spline.html">Spline</a>&lt; float, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a8df1e9c9ea06a0bcd26626f1b64d785e">Spline3f</a></td></tr>
<tr class="memdesc:a8df1e9c9ea06a0bcd26626f1b64d785e"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D float B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:a8df1e9c9ea06a0bcd26626f1b64d785e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3d357fe2fef560e7d8e592fb215fbf"><td class="memItemLeft" align="right" valign="top"><a id="aad3d357fe2fef560e7d8e592fb215fbf"></a>
typedef <a class="el" href="class_eigen_1_1_spline.html">Spline</a>&lt; double, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#aad3d357fe2fef560e7d8e592fb215fbf">Spline2d</a></td></tr>
<tr class="memdesc:aad3d357fe2fef560e7d8e592fb215fbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">2D double B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:aad3d357fe2fef560e7d8e592fb215fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652b0c454d2123a13f04922404bed782"><td class="memItemLeft" align="right" valign="top"><a id="a652b0c454d2123a13f04922404bed782"></a>
typedef <a class="el" href="class_eigen_1_1_spline.html">Spline</a>&lt; double, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a652b0c454d2123a13f04922404bed782">Spline3d</a></td></tr>
<tr class="memdesc:a652b0c454d2123a13f04922404bed782"><td class="mdescLeft">&#160;</td><td class="mdescRight">3D double B-spline with dynamic degree. <br /></td></tr>
<tr class="separator:a652b0c454d2123a13f04922404bed782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2514a510073cbf9b0375186f86ae517"><td class="memItemLeft" align="right" valign="top"><a id="ae2514a510073cbf9b0375186f86ae517"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>DefaultPermutationIndex</b></td></tr>
<tr class="separator:ae2514a510073cbf9b0375186f86ae517"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac408d3d548ea829ad12c4d298789290a"><td class="memItemLeft" align="right" valign="top"><a id="ac408d3d548ea829ad12c4d298789290a"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>CPU_TIMER</b> = 0, 
<b>REAL_TIMER</b> = 1
 }</td></tr>
<tr class="separator:ac408d3d548ea829ad12c4d298789290a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf3958430069971186dfd7afe6864b3"><td class="memItemLeft" align="right" valign="top"><a id="a8cf3958430069971186dfd7afe6864b3"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>CholmodMode</b> { <br />
&#160;&#160;<b>CholmodAuto</b>, 
<b>CholmodSimplicialLLt</b>, 
<b>CholmodSupernodalLLt</b>, 
<b>CholmodLDLt</b>, 
<br />
&#160;&#160;<b>CholmodAuto</b>, 
<b>CholmodSimplicialLLt</b>, 
<b>CholmodSupernodalLLt</b>, 
<b>CholmodLDLt</b>
<br />
 }</td></tr>
<tr class="separator:a8cf3958430069971186dfd7afe6864b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5cd10e56e38c4aa4d3d143e9ab6d9a"><td class="memItemLeft" align="right" valign="top"><a id="abc5cd10e56e38c4aa4d3d143e9ab6d9a"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>Large</b> = 2, 
<b>Small</b> = 3
 }</td></tr>
<tr class="separator:abc5cd10e56e38c4aa4d3d143e9ab6d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e24a17d5d91c2384e36a1e36ed4b5e"><td class="memItemLeft" align="right" valign="top"><a id="a28e24a17d5d91c2384e36a1e36ed4b5e"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>DontAlignCols</b> = 1
 }</td></tr>
<tr class="separator:a28e24a17d5d91c2384e36a1e36ed4b5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52305b98316605c5aad386828d47e9cb"><td class="memItemLeft" align="right" valign="top"><a id="a52305b98316605c5aad386828d47e9cb"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>StreamPrecision</b> = -1, 
<b>FullPrecision</b> = -2
 }</td></tr>
<tr class="separator:a52305b98316605c5aad386828d47e9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39e3366ff5554d731e7dc8bb642f83cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga39e3366ff5554d731e7dc8bb642f83cd">UpLoType</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6">Lower</a> =0x1, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec">Upper</a> =0x2, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaddb72f888ac85d5a1c52333e54f9374b">UnitDiag</a> =0x4, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda884ff7240392e85aa6e4b3c957e36483">ZeroDiag</a> =0x8, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda8155cfdfde9e75e7144dff0393d17181">UnitLower</a> =UnitDiag|Lower, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda8b0b63ff46dcd7377b59df14e0562fc1">UnitUpper</a> =UnitDiag|Upper, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda00aa79c8865ada1584c4d57bcd93299f">StrictlyLower</a> =ZeroDiag|Lower, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdae38aad7d66fecfb213fce453edff4c7a">StrictlyUpper</a> =ZeroDiag|Upper, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda2491fc6765056421f504eb7e16083e8f">SelfAdjoint</a> =0x10, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda7d30fb969ef6b763c098f0015108cef4">Symmetric</a> =0x20, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6">Lower</a> =0x1, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec">Upper</a> =0x2, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaddb72f888ac85d5a1c52333e54f9374b">UnitDiag</a> =0x4, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda884ff7240392e85aa6e4b3c957e36483">ZeroDiag</a> =0x8, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda8155cfdfde9e75e7144dff0393d17181">UnitLower</a> =UnitDiag|Lower, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda8b0b63ff46dcd7377b59df14e0562fc1">UnitUpper</a> =UnitDiag|Upper, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda00aa79c8865ada1584c4d57bcd93299f">StrictlyLower</a> =ZeroDiag|Lower, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdae38aad7d66fecfb213fce453edff4c7a">StrictlyUpper</a> =ZeroDiag|Upper, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda2491fc6765056421f504eb7e16083e8f">SelfAdjoint</a> =0x10, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda7d30fb969ef6b763c098f0015108cef4">Symmetric</a> =0x20
<br />
 }</td></tr>
<tr class="separator:ga39e3366ff5554d731e7dc8bb642f83cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45fe06e29902b7a2773de05ba27b47a1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga45fe06e29902b7a2773de05ba27b47a1">AlignmentType</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204">Unaligned</a> =0, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ae9267ee4260c25c5b162ae72bf18a7bd">Aligned8</a> =8, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc">Aligned16</a> =16, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a7797d247b86f6e9837cc338beb6060de">Aligned32</a> =32, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a0f4f4451618a2e67cade6b54ca0fc84b">Aligned64</a> =64, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a86400b6f9ebc01d9997b12512f3ea5fc">Aligned128</a> =128, 
<b>AlignedMask</b> =255, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf">Aligned</a> =16, 
<br />
&#160;&#160;<b>AlignedMax</b> = Unaligned, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204">Unaligned</a> =0, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ae9267ee4260c25c5b162ae72bf18a7bd">Aligned8</a> =8, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc">Aligned16</a> =16, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a7797d247b86f6e9837cc338beb6060de">Aligned32</a> =32, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a0f4f4451618a2e67cade6b54ca0fc84b">Aligned64</a> =64, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a86400b6f9ebc01d9997b12512f3ea5fc">Aligned128</a> =128, 
<b>AlignedMask</b> =255, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf">Aligned</a> =16, 
<b>AlignedMax</b> = Unaligned
<br />
 }</td></tr>
<tr class="separator:ga45fe06e29902b7a2773de05ba27b47a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49a7b3738e273eb00932271b36127f7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#gad49a7b3738e273eb00932271b36127f7">DirectionType</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7addca718e0564723df21d61b94b1198be">Vertical</a>, 
<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7aae8a16b3b9272683c1162915f6d892be">Horizontal</a>, 
<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7aa01e40fce022901560ce6d9fdee2fde3">BothDirections</a>, 
<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7addca718e0564723df21d61b94b1198be">Vertical</a>, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7aae8a16b3b9272683c1162915f6d892be">Horizontal</a>, 
<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7aa01e40fce022901560ce6d9fdee2fde3">BothDirections</a>
<br />
 }</td></tr>
<tr class="separator:gad49a7b3738e273eb00932271b36127f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2409f30bc18e288e66de7ac53f71e5"><td class="memItemLeft" align="right" valign="top"><a id="a3d2409f30bc18e288e66de7ac53f71e5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>TraversalType</b> { <br />
&#160;&#160;<b>DefaultTraversal</b>, 
<b>LinearTraversal</b>, 
<b>InnerVectorizedTraversal</b>, 
<b>LinearVectorizedTraversal</b>, 
<br />
&#160;&#160;<b>SliceVectorizedTraversal</b>, 
<b>InvalidTraversal</b>, 
<b>AllAtOnceTraversal</b>, 
<b>DefaultTraversal</b>, 
<br />
&#160;&#160;<b>LinearTraversal</b>, 
<b>InnerVectorizedTraversal</b>, 
<b>LinearVectorizedTraversal</b>, 
<b>SliceVectorizedTraversal</b>, 
<br />
&#160;&#160;<b>InvalidTraversal</b>, 
<b>AllAtOnceTraversal</b>
<br />
 }</td></tr>
<tr class="separator:a3d2409f30bc18e288e66de7ac53f71e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c7299b77156ae8c7827ba61787669d"><td class="memItemLeft" align="right" valign="top"><a id="ab8c7299b77156ae8c7827ba61787669d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>UnrollingType</b> { <br />
&#160;&#160;<b>NoUnrolling</b>, 
<b>InnerUnrolling</b>, 
<b>CompleteUnrolling</b>, 
<b>NoUnrolling</b>, 
<br />
&#160;&#160;<b>InnerUnrolling</b>, 
<b>CompleteUnrolling</b>
<br />
 }</td></tr>
<tr class="separator:ab8c7299b77156ae8c7827ba61787669d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4ff3ed63ee9637dda3fedea4bba1ea"><td class="memItemLeft" align="right" valign="top"><a id="a8f4ff3ed63ee9637dda3fedea4bba1ea"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SpecializedType</b> { <b>Specialized</b>, 
<b>BuiltIn</b>, 
<b>Specialized</b>, 
<b>BuiltIn</b>
 }</td></tr>
<tr class="separator:a8f4ff3ed63ee9637dda3fedea4bba1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacded1a18ae58b0f554751f6cdf9eb13"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#gaacded1a18ae58b0f554751f6cdf9eb13">StorageOptions</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a">ColMajor</a> = 0, 
<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3">RowMajor</a> = 0x1, 
<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a28d63c0dd8560827162decfd898804f4">AutoAlign</a> = 0, 
<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a40a452614141522dd313363dbbd65726">DontAlign</a> = 0x2, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a">ColMajor</a> = 0, 
<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3">RowMajor</a> = 0x1, 
<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a28d63c0dd8560827162decfd898804f4">AutoAlign</a> = 0, 
<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a40a452614141522dd313363dbbd65726">DontAlign</a> = 0x2
<br />
 }</td></tr>
<tr class="separator:gaacded1a18ae58b0f554751f6cdf9eb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac22de43beeac7a78b384f99bed5cee0b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#gac22de43beeac7a78b384f99bed5cee0b">SideType</a> { <a class="el" href="group__enums.html#ggac22de43beeac7a78b384f99bed5cee0ba129609b3bdf23b071f5f86cf2f995ec4">OnTheLeft</a> = 1, 
<a class="el" href="group__enums.html#ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b">OnTheRight</a> = 2, 
<a class="el" href="group__enums.html#ggac22de43beeac7a78b384f99bed5cee0ba129609b3bdf23b071f5f86cf2f995ec4">OnTheLeft</a> = 1, 
<a class="el" href="group__enums.html#ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b">OnTheRight</a> = 2
 }</td></tr>
<tr class="separator:gac22de43beeac7a78b384f99bed5cee0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f4e3f96895bdb325eab1a0b651e211f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga7f4e3f96895bdb325eab1a0b651e211f">NaNPropagationOptions</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#gga7f4e3f96895bdb325eab1a0b651e211fa290e1ae259b1b8c56afecc450c7efe45">PropagateFast</a> = 0, 
<a class="el" href="group__enums.html#gga7f4e3f96895bdb325eab1a0b651e211faf68eba121da16de9af4e4c4318cf438a">PropagateNaN</a>, 
<a class="el" href="group__enums.html#gga7f4e3f96895bdb325eab1a0b651e211fa29d90d93b7e1a8ec888f5b926120e22a">PropagateNumbers</a>, 
<a class="el" href="group__enums.html#gga7f4e3f96895bdb325eab1a0b651e211fa290e1ae259b1b8c56afecc450c7efe45">PropagateFast</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga7f4e3f96895bdb325eab1a0b651e211faf68eba121da16de9af4e4c4318cf438a">PropagateNaN</a>, 
<a class="el" href="group__enums.html#gga7f4e3f96895bdb325eab1a0b651e211fa29d90d93b7e1a8ec888f5b926120e22a">PropagateNumbers</a>
<br />
 }</td></tr>
<tr class="separator:ga7f4e3f96895bdb325eab1a0b651e211f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fe75444f853cd2dd2b6b94e27dcac7"><td class="memItemLeft" align="right" valign="top"><a id="a57fe75444f853cd2dd2b6b94e27dcac7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>NoChange_t</b> { <b>NoChange</b>, 
<b>NoChange</b>
 }</td></tr>
<tr class="separator:a57fe75444f853cd2dd2b6b94e27dcac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44c6508f8e204a03efbfd555a63a21f"><td class="memItemLeft" align="right" valign="top"><a id="ac44c6508f8e204a03efbfd555a63a21f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Sequential_t</b> { <b>Sequential</b>, 
<b>Sequential</b>
 }</td></tr>
<tr class="separator:ac44c6508f8e204a03efbfd555a63a21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644c9489710c76e32bd3a9b15d83ca43"><td class="memItemLeft" align="right" valign="top"><a id="a644c9489710c76e32bd3a9b15d83ca43"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Default_t</b> { <b>Default</b>, 
<b>Default</b>
 }</td></tr>
<tr class="separator:a644c9489710c76e32bd3a9b15d83ca43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b71c21bbdd3b0bb8a7a1dffd92e1bf"><td class="memItemLeft" align="right" valign="top"><a id="a59b71c21bbdd3b0bb8a7a1dffd92e1bf"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>AmbiVectorMode</b> { <b>IsDense</b> = 0, 
<b>IsSparse</b>, 
<b>IsDense</b> = 0, 
<b>IsSparse</b>
 }</td></tr>
<tr class="separator:a59b71c21bbdd3b0bb8a7a1dffd92e1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f93eac38eb83deb0e8dbd42ddf11d5d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga9f93eac38eb83deb0e8dbd42ddf11d5d">AccessorLevels</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5da42865f87356ad7e585a1bfbfd1b81699">ReadOnlyAccessors</a>, 
<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5da2c59ef3697d65866c3a8e16eda7881ab">WriteAccessors</a>, 
<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5da47996b52dd3a8c298a8821675a557c55">DirectAccessors</a>, 
<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5dae218802d4436c6907e60368c28609472">DirectWriteAccessors</a>, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5da42865f87356ad7e585a1bfbfd1b81699">ReadOnlyAccessors</a>, 
<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5da2c59ef3697d65866c3a8e16eda7881ab">WriteAccessors</a>, 
<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5da47996b52dd3a8c298a8821675a557c55">DirectAccessors</a>, 
<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5dae218802d4436c6907e60368c28609472">DirectWriteAccessors</a>
<br />
 }</td></tr>
<tr class="separator:ga9f93eac38eb83deb0e8dbd42ddf11d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e239fb70022eb8747994cf5d68b4a9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#gae3e239fb70022eb8747994cf5d68b4a9">DecompositionOptions</a> { <br />
&#160;&#160;<b>Pivoting</b> = 0x01, 
<b>NoPivoting</b> = 0x02, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a2b4f91ca5859a4159dbfe8090043817f">ComputeFullU</a> = 0x04, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9af8c742a1aa87773e165eae406c9ccaf8">ComputeThinU</a> = 0x08, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a52c6f7e80bbf9a42297c88f700245b51">ComputeFullV</a> = 0x10, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a1055e53fa95c8ae04a07ebb72cfafd95">ComputeThinV</a> = 0x20, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9ad0c82cf0a9daf2a63bb6e2f10d51f69c">EigenvaluesOnly</a> = 0x40, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc">ComputeEigenvectors</a> = 0x80, 
<br />
&#160;&#160;<b>EigVecMask</b> = EigenvaluesOnly | ComputeEigenvectors, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a1a7cefbb22c2c3928d246b753cf53633">Ax_lBx</a> = 0x100, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9afc36646eaa4187858eaad466d32a2096">ABx_lx</a> = 0x200, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a5b64c528c90483f0b716018cad0143f8">BAx_lx</a> = 0x400, 
<br />
&#160;&#160;<b>GenEigMask</b> = Ax_lBx | ABx_lx | BAx_lx, 
<b>Pivoting</b> = 0x01, 
<b>NoPivoting</b> = 0x02, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a2b4f91ca5859a4159dbfe8090043817f">ComputeFullU</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9af8c742a1aa87773e165eae406c9ccaf8">ComputeThinU</a> = 0x08, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a52c6f7e80bbf9a42297c88f700245b51">ComputeFullV</a> = 0x10, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a1055e53fa95c8ae04a07ebb72cfafd95">ComputeThinV</a> = 0x20, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9ad0c82cf0a9daf2a63bb6e2f10d51f69c">EigenvaluesOnly</a> = 0x40, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc">ComputeEigenvectors</a> = 0x80, 
<b>EigVecMask</b> = EigenvaluesOnly | ComputeEigenvectors, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a1a7cefbb22c2c3928d246b753cf53633">Ax_lBx</a> = 0x100, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9afc36646eaa4187858eaad466d32a2096">ABx_lx</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a5b64c528c90483f0b716018cad0143f8">BAx_lx</a> = 0x400, 
<b>GenEigMask</b> = Ax_lBx | ABx_lx | BAx_lx
<br />
 }</td></tr>
<tr class="separator:gae3e239fb70022eb8747994cf5d68b4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46eba0d5c621f590b8cf1b53af31d56e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga46eba0d5c621f590b8cf1b53af31d56e">QRPreconditioners</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56eaebc52a2365eec1df700ea97bd7af2d9a">ColPivHouseholderQRPreconditioner</a> = 0x0, 
<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56ea4d4b44de7ac7f4e623309be035d287d0">NoQRPreconditioner</a> = 0x40, 
<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56ea25d36655046e5910c850f62f84f34e25">HouseholderQRPreconditioner</a> = 0x80, 
<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56ea566c44ba828dea7f5d2fb174d799d5d2">FullPivHouseholderQRPreconditioner</a> = 0xC0, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56eae5c5f7ab41066cf3f9f976c28a0cf918">DisableQRDecomposition</a> = NoQRPreconditioner, 
<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56eaebc52a2365eec1df700ea97bd7af2d9a">ColPivHouseholderQRPreconditioner</a> = 0x0, 
<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56ea4d4b44de7ac7f4e623309be035d287d0">NoQRPreconditioner</a> = 0x40, 
<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56ea25d36655046e5910c850f62f84f34e25">HouseholderQRPreconditioner</a> = 0x80, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56ea566c44ba828dea7f5d2fb174d799d5d2">FullPivHouseholderQRPreconditioner</a> = 0xC0, 
<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56eae5c5f7ab41066cf3f9f976c28a0cf918">DisableQRDecomposition</a> = NoQRPreconditioner
<br />
 }</td></tr>
<tr class="separator:ga46eba0d5c621f590b8cf1b53af31d56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85fad7b87587764e5cf6b513a9e0ee5e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea">Success</a> = 0, 
<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f">NumericalIssue</a> = 1, 
<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8">NoConvergence</a> = 2, 
<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea945604f62795ffc70aedf2bd12ea0434">InvalidInput</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea">Success</a> = 0, 
<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f">NumericalIssue</a> = 1, 
<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8">NoConvergence</a> = 2, 
<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea945604f62795ffc70aedf2bd12ea0434">InvalidInput</a> = 3
<br />
 }</td></tr>
<tr class="separator:ga85fad7b87587764e5cf6b513a9e0ee5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee59a86102f150923b0cac6d4ff05107"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#gaee59a86102f150923b0cac6d4ff05107">TransformTraits</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a080cd5366173608f701cd945c2335568">Isometry</a> = 0x1, 
<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a71e768e0581725d919d0b05f4cb83234">Affine</a> = 0x2, 
<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aa30a06b60d218b709020972df47de2b0">AffineCompact</a> = 0x10 | Affine, 
<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aead6a2de12a17aaa4f5c523215dfccad">Projective</a> = 0x20, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a080cd5366173608f701cd945c2335568">Isometry</a> = 0x1, 
<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a71e768e0581725d919d0b05f4cb83234">Affine</a> = 0x2, 
<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aa30a06b60d218b709020972df47de2b0">AffineCompact</a> = 0x10 | Affine, 
<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aead6a2de12a17aaa4f5c523215dfccad">Projective</a> = 0x20
<br />
 }</td></tr>
<tr class="separator:gaee59a86102f150923b0cac6d4ff05107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a3e26ba06f3c60d2f2e46f56045f27"><td class="memItemLeft" align="right" valign="top"><a id="a15a3e26ba06f3c60d2f2e46f56045f27"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ProductImplType</b> { <br />
&#160;&#160;<b>DefaultProduct</b> =0, 
<b>LazyProduct</b>, 
<b>AliasFreeProduct</b>, 
<b>CoeffBasedProductMode</b>, 
<br />
&#160;&#160;<b>LazyCoeffBasedProductMode</b>, 
<b>OuterProduct</b>, 
<b>InnerProduct</b>, 
<b>GemvProduct</b>, 
<br />
&#160;&#160;<b>GemmProduct</b>, 
<b>DefaultProduct</b> =0, 
<b>LazyProduct</b>, 
<b>AliasFreeProduct</b>, 
<br />
&#160;&#160;<b>CoeffBasedProductMode</b>, 
<b>LazyCoeffBasedProductMode</b>, 
<b>OuterProduct</b>, 
<b>InnerProduct</b>, 
<br />
&#160;&#160;<b>GemvProduct</b>, 
<b>GemmProduct</b>
<br />
 }</td></tr>
<tr class="separator:a15a3e26ba06f3c60d2f2e46f56045f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbc3ee52075935e7854d9f65c5a8e03"><td class="memItemLeft" align="right" valign="top"><a id="a3cbc3ee52075935e7854d9f65c5a8e03"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Action</b> { <b>GetAction</b>, 
<b>SetAction</b>, 
<b>GetAction</b>, 
<b>SetAction</b>
 }</td></tr>
<tr class="separator:a3cbc3ee52075935e7854d9f65c5a8e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6641573852afb7812d40effdb102dc0"><td class="memItemLeft" align="right" valign="top"><a id="aa6641573852afb7812d40effdb102dc0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>AutoSize_t</b> { <b>AutoSize</b>, 
<b>AutoSize</b>
 }</td></tr>
<tr class="separator:aa6641573852afb7812d40effdb102dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9763111c1564d759c6b8abbf3c9f231b"><td class="memItemLeft" align="right" valign="top"><a id="a9763111c1564d759c6b8abbf3c9f231b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SimplicialCholeskyMode</b> { <b>SimplicialCholeskyLLT</b>, 
<b>SimplicialCholeskyLDLT</b>, 
<b>SimplicialCholeskyLLT</b>, 
<b>SimplicialCholeskyLDLT</b>
 }</td></tr>
<tr class="separator:a9763111c1564d759c6b8abbf3c9f231b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5e710ea0d2f7f1ad5c6fc45ae9f6cf"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespace_eigen.html#a85f09e8f95d9c58d05522608c72feaf8af81fc519ed9cc0ebc6aac69a366086a5">StandardCompressedFormat</a> = 2
 }</td></tr>
<tr class="separator:ada5e710ea0d2f7f1ad5c6fc45ae9f6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae138f89644546cf3e6952820a4b85b"><td class="memItemLeft" align="right" valign="top"><a id="aeae138f89644546cf3e6952820a4b85b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>convolution_type</b> { <br />
&#160;&#160;<b>CONV1D</b>, 
<b>CONV2D</b>, 
<b>CONV3D</b>, 
<b>CONV1D</b>, 
<br />
&#160;&#160;<b>CONV2D</b>, 
<b>CONV3D</b>
<br />
 }</td></tr>
<tr class="separator:aeae138f89644546cf3e6952820a4b85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c51628ff1971f45d37282fedc8cdafe"><td class="memItemLeft" align="right" valign="top"><a id="a5c51628ff1971f45d37282fedc8cdafe"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>FFTResultType</b> { <br />
&#160;&#160;<b>RealPart</b> = 0, 
<b>ImagPart</b> = 1, 
<b>BothParts</b> = 2, 
<b>RealPart</b> = 0, 
<br />
&#160;&#160;<b>ImagPart</b> = 1, 
<b>BothParts</b> = 2
<br />
 }</td></tr>
<tr class="separator:a5c51628ff1971f45d37282fedc8cdafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21243f618445aca2fd04fd6a0f0f6bf6"><td class="memItemLeft" align="right" valign="top"><a id="a21243f618445aca2fd04fd6a0f0f6bf6"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>FFTDirection</b> { <b>FFT_FORWARD</b> = 0, 
<b>FFT_REVERSE</b> = 1, 
<b>FFT_FORWARD</b> = 0, 
<b>FFT_REVERSE</b> = 1
 }</td></tr>
<tr class="separator:a21243f618445aca2fd04fd6a0f0f6bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622216a61db7cda3a723ffd639e2e046"><td class="memItemLeft" align="right" valign="top"><a id="a622216a61db7cda3a723ffd639e2e046"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PaddingType</b> { <b>PADDING_VALID</b> = 1, 
<b>PADDING_SAME</b> = 2, 
<b>PADDING_VALID</b> = 1, 
<b>PADDING_SAME</b> = 2
 }</td></tr>
<tr class="separator:a622216a61db7cda3a723ffd639e2e046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0279513beccf1beb56bff096df3b124"><td class="memItemLeft" align="right" valign="top"><a id="aa0279513beccf1beb56bff096df3b124"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>NegationFlag</b> = 0x01, 
<b>ConjugationFlag</b> = 0x02
 }</td></tr>
<tr class="separator:aa0279513beccf1beb56bff096df3b124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19e0f5f1ad7b3a13565d9e99e4deb9c8"><td class="memItemLeft" align="right" valign="top"><a id="a19e0f5f1ad7b3a13565d9e99e4deb9c8"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>GlobalRealFlag</b> = 0x01, 
<b>GlobalImagFlag</b> = 0x02, 
<b>GlobalZeroFlag</b> = 0x03
 }</td></tr>
<tr class="separator:a19e0f5f1ad7b3a13565d9e99e4deb9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae614aa7cdd687fb5c421a54f2ce5c361"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361">EulerAxis</a> { <br />
&#160;&#160;<a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361ae8110af93d433bfcf247d6bac5e1d387">EULER_X</a> = 1, 
<a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361a7309edb53a9d9cdb77fac7c1e9200263">EULER_Y</a> = 2, 
<a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361a0c641fd5050b5219d6c172ac83fb379d">EULER_Z</a> = 3, 
<a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361ae8110af93d433bfcf247d6bac5e1d387">EULER_X</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361a7309edb53a9d9cdb77fac7c1e9200263">EULER_Y</a> = 2, 
<a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361a0c641fd5050b5219d6c172ac83fb379d">EULER_Z</a> = 3
<br />
 }</td></tr>
<tr class="memdesc:ae614aa7cdd687fb5c421a54f2ce5c361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a fixed signed rotation axis for EulerSystem.  <a href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361">More...</a><br /></td></tr>
<tr class="separator:ae614aa7cdd687fb5c421a54f2ce5c361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f19342e6b4ecd38ae002d470299add"><td class="memItemLeft" align="right" valign="top"><a id="a53f19342e6b4ecd38ae002d470299add"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>NumericalDiffMode</b> { <b>Forward</b>, 
<b>Central</b>, 
<b>Forward</b>, 
<b>Central</b>
 }</td></tr>
<tr class="separator:a53f19342e6b4ecd38ae002d470299add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b8fa1446cf8ebdf8901a0644e8dd42"><td class="memItemLeft" align="right" valign="top"><a id="a23b8fa1446cf8ebdf8901a0644e8dd42"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>AdditionalProductEvaluationMode</b> { <br />
&#160;&#160;<b>SkylineTimeDenseProduct</b>, 
<b>SkylineTimeSkylineProduct</b>, 
<b>DenseTimeSkylineProduct</b>, 
<b>SkylineTimeDenseProduct</b>, 
<br />
&#160;&#160;<b>SkylineTimeSkylineProduct</b>, 
<b>DenseTimeSkylineProduct</b>
<br />
 }</td></tr>
<tr class="separator:a23b8fa1446cf8ebdf8901a0644e8dd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab59d833f31f15c4f669098e359e8edd7"><td class="memItemLeft" align="right" valign="top"><a id="ab59d833f31f15c4f669098e359e8edd7"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>IsSkyline</b> = SkylineBit
 }</td></tr>
<tr class="separator:ab59d833f31f15c4f669098e359e8edd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079ffbb10416126b7b45c9f13e4911b1"><td class="memItemLeft" align="right" valign="top"><a id="a079ffbb10416126b7b45c9f13e4911b1"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>SPD</b> = 0x100, 
<b>NonSymmetric</b> = 0x0
 }</td></tr>
<tr class="separator:a079ffbb10416126b7b45c9f13e4911b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2774cc6614722832f1c7db0885b0e3af"><td class="memItemLeft" align="right" valign="top"><a id="a2774cc6614722832f1c7db0885b0e3af"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>CPU_TIMER</b> = 0, 
<b>REAL_TIMER</b> = 1
 }</td></tr>
<tr class="separator:a2774cc6614722832f1c7db0885b0e3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf3958430069971186dfd7afe6864b3"><td class="memItemLeft" align="right" valign="top"><a id="a8cf3958430069971186dfd7afe6864b3"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>CholmodMode</b> { <br />
&#160;&#160;<b>CholmodAuto</b>, 
<b>CholmodSimplicialLLt</b>, 
<b>CholmodSupernodalLLt</b>, 
<b>CholmodLDLt</b>, 
<br />
&#160;&#160;<b>CholmodAuto</b>, 
<b>CholmodSimplicialLLt</b>, 
<b>CholmodSupernodalLLt</b>, 
<b>CholmodLDLt</b>
<br />
 }</td></tr>
<tr class="separator:a8cf3958430069971186dfd7afe6864b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d31280e63d7217571314bd43f937d2"><td class="memItemLeft" align="right" valign="top"><a id="ab6d31280e63d7217571314bd43f937d2"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>Large</b> = 2, 
<b>Small</b> = 3
 }</td></tr>
<tr class="separator:ab6d31280e63d7217571314bd43f937d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae48ab103766656372697c8ebc829da45"><td class="memItemLeft" align="right" valign="top"><a id="ae48ab103766656372697c8ebc829da45"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>DontAlignCols</b> = 1
 }</td></tr>
<tr class="separator:ae48ab103766656372697c8ebc829da45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4adac323cc6ede138fe4b5c51cd4fa1c"><td class="memItemLeft" align="right" valign="top"><a id="a4adac323cc6ede138fe4b5c51cd4fa1c"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>StreamPrecision</b> = -1, 
<b>FullPrecision</b> = -2
 }</td></tr>
<tr class="separator:a4adac323cc6ede138fe4b5c51cd4fa1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39e3366ff5554d731e7dc8bb642f83cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga39e3366ff5554d731e7dc8bb642f83cd">UpLoType</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6">Lower</a> =0x1, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec">Upper</a> =0x2, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaddb72f888ac85d5a1c52333e54f9374b">UnitDiag</a> =0x4, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda884ff7240392e85aa6e4b3c957e36483">ZeroDiag</a> =0x8, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda8155cfdfde9e75e7144dff0393d17181">UnitLower</a> =UnitDiag|Lower, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda8b0b63ff46dcd7377b59df14e0562fc1">UnitUpper</a> =UnitDiag|Upper, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda00aa79c8865ada1584c4d57bcd93299f">StrictlyLower</a> =ZeroDiag|Lower, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdae38aad7d66fecfb213fce453edff4c7a">StrictlyUpper</a> =ZeroDiag|Upper, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda2491fc6765056421f504eb7e16083e8f">SelfAdjoint</a> =0x10, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda7d30fb969ef6b763c098f0015108cef4">Symmetric</a> =0x20, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6">Lower</a> =0x1, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec">Upper</a> =0x2, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdaddb72f888ac85d5a1c52333e54f9374b">UnitDiag</a> =0x4, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda884ff7240392e85aa6e4b3c957e36483">ZeroDiag</a> =0x8, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda8155cfdfde9e75e7144dff0393d17181">UnitLower</a> =UnitDiag|Lower, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda8b0b63ff46dcd7377b59df14e0562fc1">UnitUpper</a> =UnitDiag|Upper, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda00aa79c8865ada1584c4d57bcd93299f">StrictlyLower</a> =ZeroDiag|Lower, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cdae38aad7d66fecfb213fce453edff4c7a">StrictlyUpper</a> =ZeroDiag|Upper, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda2491fc6765056421f504eb7e16083e8f">SelfAdjoint</a> =0x10, 
<a class="el" href="group__enums.html#gga39e3366ff5554d731e7dc8bb642f83cda7d30fb969ef6b763c098f0015108cef4">Symmetric</a> =0x20
<br />
 }</td></tr>
<tr class="separator:ga39e3366ff5554d731e7dc8bb642f83cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45fe06e29902b7a2773de05ba27b47a1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga45fe06e29902b7a2773de05ba27b47a1">AlignmentType</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204">Unaligned</a> =0, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ae9267ee4260c25c5b162ae72bf18a7bd">Aligned8</a> =8, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc">Aligned16</a> =16, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a7797d247b86f6e9837cc338beb6060de">Aligned32</a> =32, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a0f4f4451618a2e67cade6b54ca0fc84b">Aligned64</a> =64, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a86400b6f9ebc01d9997b12512f3ea5fc">Aligned128</a> =128, 
<b>AlignedMask</b> =255, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf">Aligned</a> =16, 
<br />
&#160;&#160;<b>AlignedMax</b> = Unaligned, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ac935220b4c844108e183ebe30a4d5204">Unaligned</a> =0, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ae9267ee4260c25c5b162ae72bf18a7bd">Aligned8</a> =8, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1af8e2bf74b04c02199f62c5e3c06dbfcc">Aligned16</a> =16, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a7797d247b86f6e9837cc338beb6060de">Aligned32</a> =32, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a0f4f4451618a2e67cade6b54ca0fc84b">Aligned64</a> =64, 
<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1a86400b6f9ebc01d9997b12512f3ea5fc">Aligned128</a> =128, 
<b>AlignedMask</b> =255, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf">Aligned</a> =16, 
<b>AlignedMax</b> = Unaligned
<br />
 }</td></tr>
<tr class="separator:ga45fe06e29902b7a2773de05ba27b47a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad49a7b3738e273eb00932271b36127f7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#gad49a7b3738e273eb00932271b36127f7">DirectionType</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7addca718e0564723df21d61b94b1198be">Vertical</a>, 
<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7aae8a16b3b9272683c1162915f6d892be">Horizontal</a>, 
<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7aa01e40fce022901560ce6d9fdee2fde3">BothDirections</a>, 
<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7addca718e0564723df21d61b94b1198be">Vertical</a>, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7aae8a16b3b9272683c1162915f6d892be">Horizontal</a>, 
<a class="el" href="group__enums.html#ggad49a7b3738e273eb00932271b36127f7aa01e40fce022901560ce6d9fdee2fde3">BothDirections</a>
<br />
 }</td></tr>
<tr class="separator:gad49a7b3738e273eb00932271b36127f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2409f30bc18e288e66de7ac53f71e5"><td class="memItemLeft" align="right" valign="top"><a id="a3d2409f30bc18e288e66de7ac53f71e5"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>TraversalType</b> { <br />
&#160;&#160;<b>DefaultTraversal</b>, 
<b>LinearTraversal</b>, 
<b>InnerVectorizedTraversal</b>, 
<b>LinearVectorizedTraversal</b>, 
<br />
&#160;&#160;<b>SliceVectorizedTraversal</b>, 
<b>InvalidTraversal</b>, 
<b>AllAtOnceTraversal</b>, 
<b>DefaultTraversal</b>, 
<br />
&#160;&#160;<b>LinearTraversal</b>, 
<b>InnerVectorizedTraversal</b>, 
<b>LinearVectorizedTraversal</b>, 
<b>SliceVectorizedTraversal</b>, 
<br />
&#160;&#160;<b>InvalidTraversal</b>, 
<b>AllAtOnceTraversal</b>
<br />
 }</td></tr>
<tr class="separator:a3d2409f30bc18e288e66de7ac53f71e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c7299b77156ae8c7827ba61787669d"><td class="memItemLeft" align="right" valign="top"><a id="ab8c7299b77156ae8c7827ba61787669d"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>UnrollingType</b> { <br />
&#160;&#160;<b>NoUnrolling</b>, 
<b>InnerUnrolling</b>, 
<b>CompleteUnrolling</b>, 
<b>NoUnrolling</b>, 
<br />
&#160;&#160;<b>InnerUnrolling</b>, 
<b>CompleteUnrolling</b>
<br />
 }</td></tr>
<tr class="separator:ab8c7299b77156ae8c7827ba61787669d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4ff3ed63ee9637dda3fedea4bba1ea"><td class="memItemLeft" align="right" valign="top"><a id="a8f4ff3ed63ee9637dda3fedea4bba1ea"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SpecializedType</b> { <b>Specialized</b>, 
<b>BuiltIn</b>, 
<b>Specialized</b>, 
<b>BuiltIn</b>
 }</td></tr>
<tr class="separator:a8f4ff3ed63ee9637dda3fedea4bba1ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaacded1a18ae58b0f554751f6cdf9eb13"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#gaacded1a18ae58b0f554751f6cdf9eb13">StorageOptions</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a">ColMajor</a> = 0, 
<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3">RowMajor</a> = 0x1, 
<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a28d63c0dd8560827162decfd898804f4">AutoAlign</a> = 0, 
<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a40a452614141522dd313363dbbd65726">DontAlign</a> = 0x2, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a">ColMajor</a> = 0, 
<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3">RowMajor</a> = 0x1, 
<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a28d63c0dd8560827162decfd898804f4">AutoAlign</a> = 0, 
<a class="el" href="group__enums.html#ggaacded1a18ae58b0f554751f6cdf9eb13a40a452614141522dd313363dbbd65726">DontAlign</a> = 0x2
<br />
 }</td></tr>
<tr class="separator:gaacded1a18ae58b0f554751f6cdf9eb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac22de43beeac7a78b384f99bed5cee0b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#gac22de43beeac7a78b384f99bed5cee0b">SideType</a> { <a class="el" href="group__enums.html#ggac22de43beeac7a78b384f99bed5cee0ba129609b3bdf23b071f5f86cf2f995ec4">OnTheLeft</a> = 1, 
<a class="el" href="group__enums.html#ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b">OnTheRight</a> = 2, 
<a class="el" href="group__enums.html#ggac22de43beeac7a78b384f99bed5cee0ba129609b3bdf23b071f5f86cf2f995ec4">OnTheLeft</a> = 1, 
<a class="el" href="group__enums.html#ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b">OnTheRight</a> = 2
 }</td></tr>
<tr class="separator:gac22de43beeac7a78b384f99bed5cee0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f4e3f96895bdb325eab1a0b651e211f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga7f4e3f96895bdb325eab1a0b651e211f">NaNPropagationOptions</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#gga7f4e3f96895bdb325eab1a0b651e211fa290e1ae259b1b8c56afecc450c7efe45">PropagateFast</a> = 0, 
<a class="el" href="group__enums.html#gga7f4e3f96895bdb325eab1a0b651e211faf68eba121da16de9af4e4c4318cf438a">PropagateNaN</a>, 
<a class="el" href="group__enums.html#gga7f4e3f96895bdb325eab1a0b651e211fa29d90d93b7e1a8ec888f5b926120e22a">PropagateNumbers</a>, 
<a class="el" href="group__enums.html#gga7f4e3f96895bdb325eab1a0b651e211fa290e1ae259b1b8c56afecc450c7efe45">PropagateFast</a> = 0, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga7f4e3f96895bdb325eab1a0b651e211faf68eba121da16de9af4e4c4318cf438a">PropagateNaN</a>, 
<a class="el" href="group__enums.html#gga7f4e3f96895bdb325eab1a0b651e211fa29d90d93b7e1a8ec888f5b926120e22a">PropagateNumbers</a>
<br />
 }</td></tr>
<tr class="separator:ga7f4e3f96895bdb325eab1a0b651e211f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57fe75444f853cd2dd2b6b94e27dcac7"><td class="memItemLeft" align="right" valign="top"><a id="a57fe75444f853cd2dd2b6b94e27dcac7"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>NoChange_t</b> { <b>NoChange</b>, 
<b>NoChange</b>
 }</td></tr>
<tr class="separator:a57fe75444f853cd2dd2b6b94e27dcac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44c6508f8e204a03efbfd555a63a21f"><td class="memItemLeft" align="right" valign="top"><a id="ac44c6508f8e204a03efbfd555a63a21f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Sequential_t</b> { <b>Sequential</b>, 
<b>Sequential</b>
 }</td></tr>
<tr class="separator:ac44c6508f8e204a03efbfd555a63a21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644c9489710c76e32bd3a9b15d83ca43"><td class="memItemLeft" align="right" valign="top"><a id="a644c9489710c76e32bd3a9b15d83ca43"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Default_t</b> { <b>Default</b>, 
<b>Default</b>
 }</td></tr>
<tr class="separator:a644c9489710c76e32bd3a9b15d83ca43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b71c21bbdd3b0bb8a7a1dffd92e1bf"><td class="memItemLeft" align="right" valign="top"><a id="a59b71c21bbdd3b0bb8a7a1dffd92e1bf"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>AmbiVectorMode</b> { <b>IsDense</b> = 0, 
<b>IsSparse</b>, 
<b>IsDense</b> = 0, 
<b>IsSparse</b>
 }</td></tr>
<tr class="separator:a59b71c21bbdd3b0bb8a7a1dffd92e1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f93eac38eb83deb0e8dbd42ddf11d5d"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga9f93eac38eb83deb0e8dbd42ddf11d5d">AccessorLevels</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5da42865f87356ad7e585a1bfbfd1b81699">ReadOnlyAccessors</a>, 
<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5da2c59ef3697d65866c3a8e16eda7881ab">WriteAccessors</a>, 
<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5da47996b52dd3a8c298a8821675a557c55">DirectAccessors</a>, 
<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5dae218802d4436c6907e60368c28609472">DirectWriteAccessors</a>, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5da42865f87356ad7e585a1bfbfd1b81699">ReadOnlyAccessors</a>, 
<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5da2c59ef3697d65866c3a8e16eda7881ab">WriteAccessors</a>, 
<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5da47996b52dd3a8c298a8821675a557c55">DirectAccessors</a>, 
<a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5dae218802d4436c6907e60368c28609472">DirectWriteAccessors</a>
<br />
 }</td></tr>
<tr class="separator:ga9f93eac38eb83deb0e8dbd42ddf11d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae3e239fb70022eb8747994cf5d68b4a9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#gae3e239fb70022eb8747994cf5d68b4a9">DecompositionOptions</a> { <br />
&#160;&#160;<b>Pivoting</b> = 0x01, 
<b>NoPivoting</b> = 0x02, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a2b4f91ca5859a4159dbfe8090043817f">ComputeFullU</a> = 0x04, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9af8c742a1aa87773e165eae406c9ccaf8">ComputeThinU</a> = 0x08, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a52c6f7e80bbf9a42297c88f700245b51">ComputeFullV</a> = 0x10, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a1055e53fa95c8ae04a07ebb72cfafd95">ComputeThinV</a> = 0x20, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9ad0c82cf0a9daf2a63bb6e2f10d51f69c">EigenvaluesOnly</a> = 0x40, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc">ComputeEigenvectors</a> = 0x80, 
<br />
&#160;&#160;<b>EigVecMask</b> = EigenvaluesOnly | ComputeEigenvectors, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a1a7cefbb22c2c3928d246b753cf53633">Ax_lBx</a> = 0x100, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9afc36646eaa4187858eaad466d32a2096">ABx_lx</a> = 0x200, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a5b64c528c90483f0b716018cad0143f8">BAx_lx</a> = 0x400, 
<br />
&#160;&#160;<b>GenEigMask</b> = Ax_lBx | ABx_lx | BAx_lx, 
<b>Pivoting</b> = 0x01, 
<b>NoPivoting</b> = 0x02, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a2b4f91ca5859a4159dbfe8090043817f">ComputeFullU</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9af8c742a1aa87773e165eae406c9ccaf8">ComputeThinU</a> = 0x08, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a52c6f7e80bbf9a42297c88f700245b51">ComputeFullV</a> = 0x10, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a1055e53fa95c8ae04a07ebb72cfafd95">ComputeThinV</a> = 0x20, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9ad0c82cf0a9daf2a63bb6e2f10d51f69c">EigenvaluesOnly</a> = 0x40, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9ada93d8885bde32b876ba4af01d3292cc">ComputeEigenvectors</a> = 0x80, 
<b>EigVecMask</b> = EigenvaluesOnly | ComputeEigenvectors, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a1a7cefbb22c2c3928d246b753cf53633">Ax_lBx</a> = 0x100, 
<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9afc36646eaa4187858eaad466d32a2096">ABx_lx</a> = 0x200, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#ggae3e239fb70022eb8747994cf5d68b4a9a5b64c528c90483f0b716018cad0143f8">BAx_lx</a> = 0x400, 
<b>GenEigMask</b> = Ax_lBx | ABx_lx | BAx_lx
<br />
 }</td></tr>
<tr class="separator:gae3e239fb70022eb8747994cf5d68b4a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46eba0d5c621f590b8cf1b53af31d56e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga46eba0d5c621f590b8cf1b53af31d56e">QRPreconditioners</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56eaebc52a2365eec1df700ea97bd7af2d9a">ColPivHouseholderQRPreconditioner</a> = 0x0, 
<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56ea4d4b44de7ac7f4e623309be035d287d0">NoQRPreconditioner</a> = 0x40, 
<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56ea25d36655046e5910c850f62f84f34e25">HouseholderQRPreconditioner</a> = 0x80, 
<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56ea566c44ba828dea7f5d2fb174d799d5d2">FullPivHouseholderQRPreconditioner</a> = 0xC0, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56eae5c5f7ab41066cf3f9f976c28a0cf918">DisableQRDecomposition</a> = NoQRPreconditioner, 
<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56eaebc52a2365eec1df700ea97bd7af2d9a">ColPivHouseholderQRPreconditioner</a> = 0x0, 
<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56ea4d4b44de7ac7f4e623309be035d287d0">NoQRPreconditioner</a> = 0x40, 
<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56ea25d36655046e5910c850f62f84f34e25">HouseholderQRPreconditioner</a> = 0x80, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56ea566c44ba828dea7f5d2fb174d799d5d2">FullPivHouseholderQRPreconditioner</a> = 0xC0, 
<a class="el" href="group__enums.html#gga46eba0d5c621f590b8cf1b53af31d56eae5c5f7ab41066cf3f9f976c28a0cf918">DisableQRDecomposition</a> = NoQRPreconditioner
<br />
 }</td></tr>
<tr class="separator:ga46eba0d5c621f590b8cf1b53af31d56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga85fad7b87587764e5cf6b513a9e0ee5e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#ga85fad7b87587764e5cf6b513a9e0ee5e">ComputationInfo</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea">Success</a> = 0, 
<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f">NumericalIssue</a> = 1, 
<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8">NoConvergence</a> = 2, 
<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea945604f62795ffc70aedf2bd12ea0434">InvalidInput</a> = 3, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea52581b035f4b59c203b8ff999ef5fcea">Success</a> = 0, 
<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5eaaf9b736d310a664e7729d163a035cc5f">NumericalIssue</a> = 1, 
<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5eaba1c8763d1179778070f365ecc4157a8">NoConvergence</a> = 2, 
<a class="el" href="group__enums.html#gga85fad7b87587764e5cf6b513a9e0ee5ea945604f62795ffc70aedf2bd12ea0434">InvalidInput</a> = 3
<br />
 }</td></tr>
<tr class="separator:ga85fad7b87587764e5cf6b513a9e0ee5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee59a86102f150923b0cac6d4ff05107"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__enums.html#gaee59a86102f150923b0cac6d4ff05107">TransformTraits</a> { <br />
&#160;&#160;<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a080cd5366173608f701cd945c2335568">Isometry</a> = 0x1, 
<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a71e768e0581725d919d0b05f4cb83234">Affine</a> = 0x2, 
<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aa30a06b60d218b709020972df47de2b0">AffineCompact</a> = 0x10 | Affine, 
<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aead6a2de12a17aaa4f5c523215dfccad">Projective</a> = 0x20, 
<br />
&#160;&#160;<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a080cd5366173608f701cd945c2335568">Isometry</a> = 0x1, 
<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107a71e768e0581725d919d0b05f4cb83234">Affine</a> = 0x2, 
<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aa30a06b60d218b709020972df47de2b0">AffineCompact</a> = 0x10 | Affine, 
<a class="el" href="group__enums.html#ggaee59a86102f150923b0cac6d4ff05107aead6a2de12a17aaa4f5c523215dfccad">Projective</a> = 0x20
<br />
 }</td></tr>
<tr class="separator:gaee59a86102f150923b0cac6d4ff05107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a3e26ba06f3c60d2f2e46f56045f27"><td class="memItemLeft" align="right" valign="top"><a id="a15a3e26ba06f3c60d2f2e46f56045f27"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ProductImplType</b> { <br />
&#160;&#160;<b>DefaultProduct</b> =0, 
<b>LazyProduct</b>, 
<b>AliasFreeProduct</b>, 
<b>CoeffBasedProductMode</b>, 
<br />
&#160;&#160;<b>LazyCoeffBasedProductMode</b>, 
<b>OuterProduct</b>, 
<b>InnerProduct</b>, 
<b>GemvProduct</b>, 
<br />
&#160;&#160;<b>GemmProduct</b>, 
<b>DefaultProduct</b> =0, 
<b>LazyProduct</b>, 
<b>AliasFreeProduct</b>, 
<br />
&#160;&#160;<b>CoeffBasedProductMode</b>, 
<b>LazyCoeffBasedProductMode</b>, 
<b>OuterProduct</b>, 
<b>InnerProduct</b>, 
<br />
&#160;&#160;<b>GemvProduct</b>, 
<b>GemmProduct</b>
<br />
 }</td></tr>
<tr class="separator:a15a3e26ba06f3c60d2f2e46f56045f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cbc3ee52075935e7854d9f65c5a8e03"><td class="memItemLeft" align="right" valign="top"><a id="a3cbc3ee52075935e7854d9f65c5a8e03"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>Action</b> { <b>GetAction</b>, 
<b>SetAction</b>, 
<b>GetAction</b>, 
<b>SetAction</b>
 }</td></tr>
<tr class="separator:a3cbc3ee52075935e7854d9f65c5a8e03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6641573852afb7812d40effdb102dc0"><td class="memItemLeft" align="right" valign="top"><a id="aa6641573852afb7812d40effdb102dc0"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>AutoSize_t</b> { <b>AutoSize</b>, 
<b>AutoSize</b>
 }</td></tr>
<tr class="separator:aa6641573852afb7812d40effdb102dc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9763111c1564d759c6b8abbf3c9f231b"><td class="memItemLeft" align="right" valign="top"><a id="a9763111c1564d759c6b8abbf3c9f231b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SimplicialCholeskyMode</b> { <b>SimplicialCholeskyLLT</b>, 
<b>SimplicialCholeskyLDLT</b>, 
<b>SimplicialCholeskyLLT</b>, 
<b>SimplicialCholeskyLDLT</b>
 }</td></tr>
<tr class="separator:a9763111c1564d759c6b8abbf3c9f231b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f09e8f95d9c58d05522608c72feaf8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="namespace_eigen.html#a85f09e8f95d9c58d05522608c72feaf8af81fc519ed9cc0ebc6aac69a366086a5">StandardCompressedFormat</a> = 2
 }</td></tr>
<tr class="separator:a85f09e8f95d9c58d05522608c72feaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeae138f89644546cf3e6952820a4b85b"><td class="memItemLeft" align="right" valign="top"><a id="aeae138f89644546cf3e6952820a4b85b"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>convolution_type</b> { <br />
&#160;&#160;<b>CONV1D</b>, 
<b>CONV2D</b>, 
<b>CONV3D</b>, 
<b>CONV1D</b>, 
<br />
&#160;&#160;<b>CONV2D</b>, 
<b>CONV3D</b>
<br />
 }</td></tr>
<tr class="separator:aeae138f89644546cf3e6952820a4b85b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c51628ff1971f45d37282fedc8cdafe"><td class="memItemLeft" align="right" valign="top"><a id="a5c51628ff1971f45d37282fedc8cdafe"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>FFTResultType</b> { <br />
&#160;&#160;<b>RealPart</b> = 0, 
<b>ImagPart</b> = 1, 
<b>BothParts</b> = 2, 
<b>RealPart</b> = 0, 
<br />
&#160;&#160;<b>ImagPart</b> = 1, 
<b>BothParts</b> = 2
<br />
 }</td></tr>
<tr class="separator:a5c51628ff1971f45d37282fedc8cdafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21243f618445aca2fd04fd6a0f0f6bf6"><td class="memItemLeft" align="right" valign="top"><a id="a21243f618445aca2fd04fd6a0f0f6bf6"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>FFTDirection</b> { <b>FFT_FORWARD</b> = 0, 
<b>FFT_REVERSE</b> = 1, 
<b>FFT_FORWARD</b> = 0, 
<b>FFT_REVERSE</b> = 1
 }</td></tr>
<tr class="separator:a21243f618445aca2fd04fd6a0f0f6bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622216a61db7cda3a723ffd639e2e046"><td class="memItemLeft" align="right" valign="top"><a id="a622216a61db7cda3a723ffd639e2e046"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>PaddingType</b> { <b>PADDING_VALID</b> = 1, 
<b>PADDING_SAME</b> = 2, 
<b>PADDING_VALID</b> = 1, 
<b>PADDING_SAME</b> = 2
 }</td></tr>
<tr class="separator:a622216a61db7cda3a723ffd639e2e046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3764e5fe754c1756e59f9a2e4f7ca010"><td class="memItemLeft" align="right" valign="top"><a id="a3764e5fe754c1756e59f9a2e4f7ca010"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>NegationFlag</b> = 0x01, 
<b>ConjugationFlag</b> = 0x02
 }</td></tr>
<tr class="separator:a3764e5fe754c1756e59f9a2e4f7ca010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ee30590df885ebf5a53fcb005dd81b7"><td class="memItemLeft" align="right" valign="top"><a id="a4ee30590df885ebf5a53fcb005dd81b7"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>GlobalRealFlag</b> = 0x01, 
<b>GlobalImagFlag</b> = 0x02, 
<b>GlobalZeroFlag</b> = 0x03
 }</td></tr>
<tr class="separator:a4ee30590df885ebf5a53fcb005dd81b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae614aa7cdd687fb5c421a54f2ce5c361"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361">EulerAxis</a> { <br />
&#160;&#160;<a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361ae8110af93d433bfcf247d6bac5e1d387">EULER_X</a> = 1, 
<a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361a7309edb53a9d9cdb77fac7c1e9200263">EULER_Y</a> = 2, 
<a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361a0c641fd5050b5219d6c172ac83fb379d">EULER_Z</a> = 3, 
<a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361ae8110af93d433bfcf247d6bac5e1d387">EULER_X</a> = 1, 
<br />
&#160;&#160;<a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361a7309edb53a9d9cdb77fac7c1e9200263">EULER_Y</a> = 2, 
<a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361a0c641fd5050b5219d6c172ac83fb379d">EULER_Z</a> = 3
<br />
 }</td></tr>
<tr class="memdesc:ae614aa7cdd687fb5c421a54f2ce5c361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representation of a fixed signed rotation axis for EulerSystem.  <a href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361">More...</a><br /></td></tr>
<tr class="separator:ae614aa7cdd687fb5c421a54f2ce5c361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f19342e6b4ecd38ae002d470299add"><td class="memItemLeft" align="right" valign="top"><a id="a53f19342e6b4ecd38ae002d470299add"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>NumericalDiffMode</b> { <b>Forward</b>, 
<b>Central</b>, 
<b>Forward</b>, 
<b>Central</b>
 }</td></tr>
<tr class="separator:a53f19342e6b4ecd38ae002d470299add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b8fa1446cf8ebdf8901a0644e8dd42"><td class="memItemLeft" align="right" valign="top"><a id="a23b8fa1446cf8ebdf8901a0644e8dd42"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>AdditionalProductEvaluationMode</b> { <br />
&#160;&#160;<b>SkylineTimeDenseProduct</b>, 
<b>SkylineTimeSkylineProduct</b>, 
<b>DenseTimeSkylineProduct</b>, 
<b>SkylineTimeDenseProduct</b>, 
<br />
&#160;&#160;<b>SkylineTimeSkylineProduct</b>, 
<b>DenseTimeSkylineProduct</b>
<br />
 }</td></tr>
<tr class="separator:a23b8fa1446cf8ebdf8901a0644e8dd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2beca575f145b46e68ea5158dc6de2"><td class="memItemLeft" align="right" valign="top"><a id="a0c2beca575f145b46e68ea5158dc6de2"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>IsSkyline</b> = SkylineBit
 }</td></tr>
<tr class="separator:a0c2beca575f145b46e68ea5158dc6de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e47aea8feff95ae4c94608d30a476bf"><td class="memItemLeft" align="right" valign="top"><a id="a9e47aea8feff95ae4c94608d30a476bf"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>SPD</b> = 0x100, 
<b>NonSymmetric</b> = 0x0
 }</td></tr>
<tr class="separator:a9e47aea8feff95ae4c94608d30a476bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7794e77d4be556d1c965842e227bd572"><td class="memTemplParams" colspan="2">template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </td></tr>
<tr class="memitem:a7794e77d4be556d1c965842e227bd572"><td class="memTemplItemLeft" align="right" valign="top">cholmod_sparse&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a7794e77d4be556d1c965842e227bd572">viewAsCholmod</a> (<a class="el" href="class_eigen_1_1_ref.html">Ref</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt; &gt; mat)</td></tr>
<tr class="separator:a7794e77d4be556d1c965842e227bd572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fca420db40e6fc768704addd9d999d5"><td class="memTemplParams" colspan="2"><a id="a4fca420db40e6fc768704addd9d999d5"></a>
template&lt;typename Scalar_ , int Options_, typename Index_ &gt; </td></tr>
<tr class="memitem:a4fca420db40e6fc768704addd9d999d5"><td class="memTemplItemLeft" align="right" valign="top">const cholmod_sparse&#160;</td><td class="memTemplItemRight" valign="bottom"><b>viewAsCholmod</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar_, Options_, Index_ &gt; &amp;mat)</td></tr>
<tr class="separator:a4fca420db40e6fc768704addd9d999d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb92c8841d8657e8d0b17de64fe1e98a"><td class="memTemplParams" colspan="2"><a id="acb92c8841d8657e8d0b17de64fe1e98a"></a>
template&lt;typename Scalar_ , int Options_, typename Index_ &gt; </td></tr>
<tr class="memitem:acb92c8841d8657e8d0b17de64fe1e98a"><td class="memTemplItemLeft" align="right" valign="top">const cholmod_sparse&#160;</td><td class="memTemplItemRight" valign="bottom"><b>viewAsCholmod</b> (const <a class="el" href="class_eigen_1_1_sparse_vector.html">SparseVector</a>&lt; Scalar_, Options_, Index_ &gt; &amp;mat)</td></tr>
<tr class="separator:acb92c8841d8657e8d0b17de64fe1e98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a1848d39c84d0b57c1e7cb2f9b370e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar_ , int Options_, typename Index_ , unsigned int UpLo&gt; </td></tr>
<tr class="memitem:af0a1848d39c84d0b57c1e7cb2f9b370e"><td class="memTemplItemLeft" align="right" valign="top">cholmod_sparse&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#af0a1848d39c84d0b57c1e7cb2f9b370e">viewAsCholmod</a> (const <a class="el" href="class_eigen_1_1_sparse_self_adjoint_view.html">SparseSelfAdjointView</a>&lt; const <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar_, Options_, Index_ &gt;, UpLo &gt; &amp;mat)</td></tr>
<tr class="separator:af0a1848d39c84d0b57c1e7cb2f9b370e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92fe7b595099051fa1d1c443641a6de3"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a92fe7b595099051fa1d1c443641a6de3"><td class="memTemplItemLeft" align="right" valign="top">cholmod_dense&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a92fe7b595099051fa1d1c443641a6de3">viewAsCholmod</a> (<a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt; &amp;mat)</td></tr>
<tr class="separator:a92fe7b595099051fa1d1c443641a6de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d422271b7edea7b672998eeb3260521"><td class="memTemplParams" colspan="2">template&lt;typename Scalar , int Flags, typename StorageIndex &gt; </td></tr>
<tr class="memitem:a2d422271b7edea7b672998eeb3260521"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_map.html">Map</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar, Flags, StorageIndex &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a2d422271b7edea7b672998eeb3260521">viewAsEigen</a> (cholmod_sparse &amp;cm)</td></tr>
<tr class="separator:a2d422271b7edea7b672998eeb3260521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3c346d2a61d1e8e86e6fb4cf57fbda"><td class="memTemplParams" colspan="2">template&lt;typename FirstType , typename SizeType , typename IncrType &gt; </td></tr>
<tr class="memitem:a3a3c346d2a61d1e8e86e6fb4cf57fbda"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_arithmetic_sequence.html">ArithmeticSequence</a>&lt; typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; FirstType &gt;::type, typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; SizeType &gt;::type, typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__seq__incr.html">internal::cleanup_seq_incr</a>&lt; IncrType &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a3a3c346d2a61d1e8e86e6fb4cf57fbda">seqN</a> (FirstType first, SizeType size, IncrType incr)</td></tr>
<tr class="separator:a3a3c346d2a61d1e8e86e6fb4cf57fbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2b47604fbd83f8e88849a371eb0a8f"><td class="memTemplParams" colspan="2">template&lt;typename FirstType , typename SizeType &gt; </td></tr>
<tr class="memitem:a5e2b47604fbd83f8e88849a371eb0a8f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_arithmetic_sequence.html">ArithmeticSequence</a>&lt; typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; FirstType &gt;::type, typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; SizeType &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a5e2b47604fbd83f8e88849a371eb0a8f">seqN</a> (FirstType first, SizeType size)</td></tr>
<tr class="separator:a5e2b47604fbd83f8e88849a371eb0a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570c5399d7d1a339f2756e529debf7ed"><td class="memTemplParams" colspan="2"><a id="a570c5399d7d1a339f2756e529debf7ed"></a>
template&lt;typename FirstType , typename LastType &gt; </td></tr>
<tr class="memitem:a570c5399d7d1a339f2756e529debf7ed"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>seq</b> (FirstType f, LastType l) -&gt; decltype(<a class="el" href="namespace_eigen.html#a3a3c346d2a61d1e8e86e6fb4cf57fbda">seqN</a>(typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; FirstType &gt;::type(f),(typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; LastType &gt;::type(l) - typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; FirstType &gt;::type(f)+fix&lt; 1 &gt;())))</td></tr>
<tr class="separator:a570c5399d7d1a339f2756e529debf7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d125f2e0ce64e0e63ad3185fe8af067"><td class="memTemplParams" colspan="2"><a id="a9d125f2e0ce64e0e63ad3185fe8af067"></a>
template&lt;typename FirstType , typename LastType , typename IncrType &gt; </td></tr>
<tr class="memitem:a9d125f2e0ce64e0e63ad3185fe8af067"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><b>seq</b> (FirstType f, LastType l, IncrType incr) -&gt; decltype(<a class="el" href="namespace_eigen.html#a3a3c346d2a61d1e8e86e6fb4cf57fbda">seqN</a>(typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; FirstType &gt;::type(f),(typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; LastType &gt;::type(l) - typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; FirstType &gt;::type(f)+typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__seq__incr.html">internal::cleanup_seq_incr</a>&lt; IncrType &gt;::type(incr))/typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__seq__incr.html">internal::cleanup_seq_incr</a>&lt; IncrType &gt;::type(incr), typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__seq__incr.html">internal::cleanup_seq_incr</a>&lt; IncrType &gt;::type(incr)))</td></tr>
<tr class="separator:a9d125f2e0ce64e0e63ad3185fe8af067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c54c4d59b5fd9ce61d8bf70018b8b1"><td class="memTemplParams" colspan="2">template&lt;typename MatrixDerived , typename PermutationDerived &gt; </td></tr>
<tr class="memitem:aa6c54c4d59b5fd9ce61d8bf70018b8b1"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_DEVICE_FUNC <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; MatrixDerived, PermutationDerived, AliasFreeProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#aa6c54c4d59b5fd9ce61d8bf70018b8b1">operator*</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;matrix, const <a class="el" href="class_eigen_1_1_permutation_base.html">PermutationBase</a>&lt; PermutationDerived &gt; &amp;permutation)</td></tr>
<tr class="separator:aa6c54c4d59b5fd9ce61d8bf70018b8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5e3648914dc76efaeec71a7093601d"><td class="memTemplParams" colspan="2">template&lt;typename PermutationDerived , typename MatrixDerived &gt; </td></tr>
<tr class="memitem:a5a5e3648914dc76efaeec71a7093601d"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_DEVICE_FUNC <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; PermutationDerived, MatrixDerived, AliasFreeProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a5a5e3648914dc76efaeec71a7093601d">operator*</a> (const <a class="el" href="class_eigen_1_1_permutation_base.html">PermutationBase</a>&lt; PermutationDerived &gt; &amp;permutation, const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;matrix)</td></tr>
<tr class="separator:a5a5e3648914dc76efaeec71a7093601d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2669f89ff38296a38e6d973552eb4e33"><td class="memItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a2669f89ff38296a38e6d973552eb4e33">l1CacheSize</a> ()</td></tr>
<tr class="separator:a2669f89ff38296a38e6d973552eb4e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfc0330ba567d63a496be1cac8427ae"><td class="memItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a2cfc0330ba567d63a496be1cac8427ae">l2CacheSize</a> ()</td></tr>
<tr class="separator:a2cfc0330ba567d63a496be1cac8427ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2efa4852ea90c2d47b7dcec5b40ba2b"><td class="memItemLeft" align="right" valign="top">std::ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ae2efa4852ea90c2d47b7dcec5b40ba2b">l3CacheSize</a> ()</td></tr>
<tr class="separator:ae2efa4852ea90c2d47b7dcec5b40ba2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64421554aa0a4bf9258bafe3170102b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ae64421554aa0a4bf9258bafe3170102b">setCpuCacheSizes</a> (std::ptrdiff_t l1, std::ptrdiff_t l2, std::ptrdiff_t l3)</td></tr>
<tr class="separator:ae64421554aa0a4bf9258bafe3170102b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820c0e0460934cc17eb6dacbad54a9f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a820c0e0460934cc17eb6dacbad54a9f5">initParallel</a> ()</td></tr>
<tr class="separator:a820c0e0460934cc17eb6dacbad54a9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aca97d83e21b91a04ec079360dfffeb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a9aca97d83e21b91a04ec079360dfffeb">nbThreads</a> ()</td></tr>
<tr class="separator:a9aca97d83e21b91a04ec079360dfffeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9cd17c2fe18204239cd11c88c120b50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#af9cd17c2fe18204239cd11c88c120b50">setNbThreads</a> (int v)</td></tr>
<tr class="separator:af9cd17c2fe18204239cd11c88c120b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d0768057509b40f5a64327dbf97ffb8"><td class="memTemplParams" colspan="2">template&lt;typename MatrixDerived , typename TranspositionsDerived &gt; </td></tr>
<tr class="memitem:a6d0768057509b40f5a64327dbf97ffb8"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_DEVICE_FUNC <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; MatrixDerived, TranspositionsDerived, AliasFreeProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a6d0768057509b40f5a64327dbf97ffb8">operator*</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;matrix, const <a class="el" href="class_eigen_1_1_transpositions_base.html">TranspositionsBase</a>&lt; TranspositionsDerived &gt; &amp;transpositions)</td></tr>
<tr class="separator:a6d0768057509b40f5a64327dbf97ffb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10fac68e0747d8acfb7c102ff5bab3c6"><td class="memTemplParams" colspan="2">template&lt;typename TranspositionsDerived , typename MatrixDerived &gt; </td></tr>
<tr class="memitem:a10fac68e0747d8acfb7c102ff5bab3c6"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_DEVICE_FUNC <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; TranspositionsDerived, MatrixDerived, AliasFreeProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a10fac68e0747d8acfb7c102ff5bab3c6">operator*</a> (const <a class="el" href="class_eigen_1_1_transpositions_base.html">TranspositionsBase</a>&lt; TranspositionsDerived &gt; &amp;transpositions, const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;matrix)</td></tr>
<tr class="separator:a10fac68e0747d8acfb7c102ff5bab3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8ad90d69bf6d7d3fa04fd5ac69938b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:abe8ad90d69bf6d7d3fa04fd5ac69938b"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#abe8ad90d69bf6d7d3fa04fd5ac69938b">serialize_size</a> (const Args &amp;... args)</td></tr>
<tr class="separator:abe8ad90d69bf6d7d3fa04fd5ac69938b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7b2bfe22ad05393d50a81c13f7352a"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7f7b2bfe22ad05393d50a81c13f7352a"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE uint8_t *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a7f7b2bfe22ad05393d50a81c13f7352a">serialize</a> (uint8_t *dest, uint8_t *end, const Args &amp;... args)</td></tr>
<tr class="separator:a7f7b2bfe22ad05393d50a81c13f7352a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9010e675b04cc99696726dc48b11c91b"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a9010e675b04cc99696726dc48b11c91b"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const EIGEN_STRONG_INLINE uint8_t *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a9010e675b04cc99696726dc48b11c91b">deserialize</a> (const uint8_t *src, const uint8_t *end, Args &amp;... args)</td></tr>
<tr class="separator:a9010e675b04cc99696726dc48b11c91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a8ed57e3f2973526026765ae697761"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_uniform_scaling.html">UniformScaling</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a23a8ed57e3f2973526026765ae697761">Scaling</a> (float s)</td></tr>
<tr class="separator:a23a8ed57e3f2973526026765ae697761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86bf75d7fd4a67bf9c2c7354d8e5e2af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_uniform_scaling.html">UniformScaling</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a86bf75d7fd4a67bf9c2c7354d8e5e2af">Scaling</a> (double s)</td></tr>
<tr class="separator:a86bf75d7fd4a67bf9c2c7354d8e5e2af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97769767c20f843fc8c60421dcf0fd45"><td class="memTemplParams" colspan="2">template&lt;typename RealScalar &gt; </td></tr>
<tr class="memitem:a97769767c20f843fc8c60421dcf0fd45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_uniform_scaling.html">UniformScaling</a>&lt; std::complex&lt; RealScalar &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a97769767c20f843fc8c60421dcf0fd45">Scaling</a> (const std::complex&lt; RealScalar &gt; &amp;s)</td></tr>
<tr class="separator:a97769767c20f843fc8c60421dcf0fd45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76ae94fe10ce570fbd130bd6c7ab06d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:ab76ae94fe10ce570fbd130bd6c7ab06d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_diagonal_matrix.html">DiagonalMatrix</a>&lt; Scalar, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ab76ae94fe10ce570fbd130bd6c7ab06d">Scaling</a> (const Scalar &amp;sx, const Scalar &amp;sy)</td></tr>
<tr class="separator:ab76ae94fe10ce570fbd130bd6c7ab06d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acaf9cb32919d0a51876e0d204d2af475"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:acaf9cb32919d0a51876e0d204d2af475"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_diagonal_matrix.html">DiagonalMatrix</a>&lt; Scalar, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#acaf9cb32919d0a51876e0d204d2af475">Scaling</a> (const Scalar &amp;sx, const Scalar &amp;sy, const Scalar &amp;sz)</td></tr>
<tr class="separator:acaf9cb32919d0a51876e0d204d2af475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f5797ba6804cc1d4b0c8c62da3e3d7"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ac8f5797ba6804cc1d4b0c8c62da3e3d7"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_diagonal_wrapper.html">DiagonalWrapper</a>&lt; const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ac8f5797ba6804cc1d4b0c8c62da3e3d7">Scaling</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt; &amp;coeffs)</td></tr>
<tr class="separator:ac8f5797ba6804cc1d4b0c8c62da3e3d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8945614275f33d8679c0f6f648073986"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a8945614275f33d8679c0f6f648073986"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_diagonal_wrapper.html">DiagonalWrapper</a>&lt; const Derived &gt;::PlainObject&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a8945614275f33d8679c0f6f648073986">Scaling</a> (<a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt; &amp;&amp;coeffs)</td></tr>
<tr class="separator:a8945614275f33d8679c0f6f648073986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga033d6550c1fc82e232f2b4c380c19a54"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename OtherDerived &gt; </td></tr>
<tr class="memitem:ga033d6550c1fc82e232f2b4c380c19a54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1internal_1_1umeyama__transform__matrix__type.html">internal::umeyama_transform_matrix_type</a>&lt; Derived, OtherDerived &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___geometry___module.html#ga033d6550c1fc82e232f2b4c380c19a54">umeyama</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt; &amp;src, const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;dst, bool with_scaling=true)</td></tr>
<tr class="memdesc:ga033d6550c1fc82e232f2b4c380c19a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the transformation between two point sets.  <a href="group___geometry___module.html#ga033d6550c1fc82e232f2b4c380c19a54">More...</a><br /></td></tr>
<tr class="separator:ga033d6550c1fc82e232f2b4c380c19a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6632b4f607fd51ab4560100fed76180f"><td class="memTemplParams" colspan="2">template&lt;typename OtherDerived , typename VectorsType , typename CoeffsType , int Side&gt; </td></tr>
<tr class="memitem:a6632b4f607fd51ab4560100fed76180f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1internal_1_1matrix__type__times__scalar__type.html">internal::matrix_type_times_scalar_type</a>&lt; typename VectorsType::Scalar, OtherDerived &gt;::Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a6632b4f607fd51ab4560100fed76180f">operator*</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;other, const <a class="el" href="class_eigen_1_1_householder_sequence.html">HouseholderSequence</a>&lt; VectorsType, CoeffsType, Side &gt; &amp;h)</td></tr>
<tr class="memdesc:a6632b4f607fd51ab4560100fed76180f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the product of a matrix with a Householder sequence.  <a href="namespace_eigen.html#a6632b4f607fd51ab4560100fed76180f">More...</a><br /></td></tr>
<tr class="separator:a6632b4f607fd51ab4560100fed76180f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bd4b85120e014cf1125a054b02d4d92"><td class="memTemplParams" colspan="2">template&lt;typename VectorsType , typename CoeffsType &gt; </td></tr>
<tr class="memitem:ga4bd4b85120e014cf1125a054b02d4d92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_householder_sequence.html">HouseholderSequence</a>&lt; VectorsType, CoeffsType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___householder___module.html#ga4bd4b85120e014cf1125a054b02d4d92">householderSequence</a> (const VectorsType &amp;v, const CoeffsType &amp;h)</td></tr>
<tr class="memdesc:ga4bd4b85120e014cf1125a054b02d4d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for constructing a Householder sequence.  <a href="group___householder___module.html#ga4bd4b85120e014cf1125a054b02d4d92">More...</a><br /></td></tr>
<tr class="separator:ga4bd4b85120e014cf1125a054b02d4d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59f16274f9e66f902f1a4b3f23e8b002"><td class="memTemplParams" colspan="2">template&lt;typename VectorsType , typename CoeffsType &gt; </td></tr>
<tr class="memitem:ga59f16274f9e66f902f1a4b3f23e8b002"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_householder_sequence.html">HouseholderSequence</a>&lt; VectorsType, CoeffsType, <a class="el" href="group__enums.html#ggac22de43beeac7a78b384f99bed5cee0ba99dc75d8e00b6c3a5bdc31940f47492b">OnTheRight</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___householder___module.html#ga59f16274f9e66f902f1a4b3f23e8b002">rightHouseholderSequence</a> (const VectorsType &amp;v, const CoeffsType &amp;h)</td></tr>
<tr class="memdesc:ga59f16274f9e66f902f1a4b3f23e8b002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience function for constructing a Householder sequence.  <a href="group___householder___module.html#ga59f16274f9e66f902f1a4b3f23e8b002">More...</a><br /></td></tr>
<tr class="separator:ga59f16274f9e66f902f1a4b3f23e8b002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d0ed07a6ee97fcef4fe3bce6a674d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ad6d0ed07a6ee97fcef4fe3bce6a674d4">klu_solve</a> (klu_symbolic *Symbolic, klu_numeric *Numeric, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> ldim, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> nrhs, double <a class="el" href="class_eigen_1_1_matrix.html">B</a>[], klu_common *Common, double)</td></tr>
<tr class="memdesc:ad6d0ed07a6ee97fcef4fe3bce6a674d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A sparse LU factorization and solver based on <a class="el" href="class_eigen_1_1_k_l_u.html">KLU</a>.  <a href="namespace_eigen.html#ad6d0ed07a6ee97fcef4fe3bce6a674d4">More...</a><br /></td></tr>
<tr class="separator:ad6d0ed07a6ee97fcef4fe3bce6a674d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39109b96d932655b77d17f49aaffa847"><td class="memItemLeft" align="right" valign="top"><a id="a39109b96d932655b77d17f49aaffa847"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>klu_solve</b> (klu_symbolic *Symbolic, klu_numeric *Numeric, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> ldim, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> nrhs, std::complex&lt; double &gt;<a class="el" href="class_eigen_1_1_matrix.html">B</a>[], klu_common *Common, std::complex&lt; double &gt;)</td></tr>
<tr class="separator:a39109b96d932655b77d17f49aaffa847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9876fa8f6fcfffb18804eb15a257f56"><td class="memItemLeft" align="right" valign="top"><a id="ae9876fa8f6fcfffb18804eb15a257f56"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>klu_tsolve</b> (klu_symbolic *Symbolic, klu_numeric *Numeric, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> ldim, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> nrhs, double <a class="el" href="class_eigen_1_1_matrix.html">B</a>[], klu_common *Common, double)</td></tr>
<tr class="separator:ae9876fa8f6fcfffb18804eb15a257f56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af374e4dd80db15037f7f0d584b9000ee"><td class="memItemLeft" align="right" valign="top"><a id="af374e4dd80db15037f7f0d584b9000ee"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>klu_tsolve</b> (klu_symbolic *Symbolic, klu_numeric *Numeric, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> ldim, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> nrhs, std::complex&lt; double &gt;<a class="el" href="class_eigen_1_1_matrix.html">B</a>[], klu_common *Common, std::complex&lt; double &gt;)</td></tr>
<tr class="separator:af374e4dd80db15037f7f0d584b9000ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c00b8ccc084877b6438e9e7bf7b3f9"><td class="memItemLeft" align="right" valign="top"><a id="a52c00b8ccc084877b6438e9e7bf7b3f9"></a>
klu_numeric *&#160;</td><td class="memItemRight" valign="bottom"><b>klu_factor</b> (int Ap[], int Ai[], double Ax[], klu_symbolic *Symbolic, klu_common *Common, double)</td></tr>
<tr class="separator:a52c00b8ccc084877b6438e9e7bf7b3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d9a26ec88366c1c23bf0341b707edc"><td class="memItemLeft" align="right" valign="top"><a id="a62d9a26ec88366c1c23bf0341b707edc"></a>
klu_numeric *&#160;</td><td class="memItemRight" valign="bottom"><b>klu_factor</b> (int Ap[], int Ai[], std::complex&lt; double &gt; Ax[], klu_symbolic *Symbolic, klu_common *Common, std::complex&lt; double &gt;)</td></tr>
<tr class="separator:a62d9a26ec88366c1c23bf0341b707edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80397b64f798f52a50eff26c45f52fa"><td class="memTemplParams" colspan="2"><a id="af80397b64f798f52a50eff26c45f52fa"></a>
template&lt;typename DenseDerived , typename SparseDerived &gt; </td></tr>
<tr class="memitem:af80397b64f798f52a50eff26c45f52fa"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__sum__op.html">internal::scalar_sum_op</a>&lt; typename DenseDerived::Scalar, typename SparseDerived::Scalar &gt;, const DenseDerived, const SparseDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; DenseDerived &gt; &amp;a, const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; SparseDerived &gt; &amp;b)</td></tr>
<tr class="separator:af80397b64f798f52a50eff26c45f52fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a17be391505c2f1ae4ae1e98a72f3ba"><td class="memTemplParams" colspan="2"><a id="a7a17be391505c2f1ae4ae1e98a72f3ba"></a>
template&lt;typename SparseDerived , typename DenseDerived &gt; </td></tr>
<tr class="memitem:a7a17be391505c2f1ae4ae1e98a72f3ba"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__sum__op.html">internal::scalar_sum_op</a>&lt; typename SparseDerived::Scalar, typename DenseDerived::Scalar &gt;, const SparseDerived, const DenseDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator+</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; SparseDerived &gt; &amp;a, const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; DenseDerived &gt; &amp;b)</td></tr>
<tr class="separator:a7a17be391505c2f1ae4ae1e98a72f3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f05fe1c0e6b9db67cabb57fc54a366"><td class="memTemplParams" colspan="2"><a id="af5f05fe1c0e6b9db67cabb57fc54a366"></a>
template&lt;typename DenseDerived , typename SparseDerived &gt; </td></tr>
<tr class="memitem:af5f05fe1c0e6b9db67cabb57fc54a366"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__difference__op.html">internal::scalar_difference_op</a>&lt; typename DenseDerived::Scalar, typename SparseDerived::Scalar &gt;, const DenseDerived, const SparseDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; DenseDerived &gt; &amp;a, const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; SparseDerived &gt; &amp;b)</td></tr>
<tr class="separator:af5f05fe1c0e6b9db67cabb57fc54a366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2837d44f3b24abe890cbc6673bde7d11"><td class="memTemplParams" colspan="2"><a id="a2837d44f3b24abe890cbc6673bde7d11"></a>
template&lt;typename SparseDerived , typename DenseDerived &gt; </td></tr>
<tr class="memitem:a2837d44f3b24abe890cbc6673bde7d11"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__difference__op.html">internal::scalar_difference_op</a>&lt; typename SparseDerived::Scalar, typename DenseDerived::Scalar &gt;, const SparseDerived, const DenseDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator-</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; SparseDerived &gt; &amp;a, const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; DenseDerived &gt; &amp;b)</td></tr>
<tr class="separator:a2837d44f3b24abe890cbc6673bde7d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad798a8be8b0c5f94a29b119898d8d83d"><td class="memTemplParams" colspan="2">template&lt;typename SparseDerived , typename PermDerived &gt; </td></tr>
<tr class="memitem:ad798a8be8b0c5f94a29b119898d8d83d"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; SparseDerived, PermDerived, AliasFreeProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ad798a8be8b0c5f94a29b119898d8d83d">operator*</a> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; SparseDerived &gt; &amp;matrix, const <a class="el" href="class_eigen_1_1_permutation_base.html">PermutationBase</a>&lt; PermDerived &gt; &amp;perm)</td></tr>
<tr class="separator:ad798a8be8b0c5f94a29b119898d8d83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2c1af8da495ae3cbe7be12cecfe294"><td class="memTemplParams" colspan="2">template&lt;typename SparseDerived , typename PermDerived &gt; </td></tr>
<tr class="memitem:a9c2c1af8da495ae3cbe7be12cecfe294"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; PermDerived, SparseDerived, AliasFreeProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a9c2c1af8da495ae3cbe7be12cecfe294">operator*</a> (const <a class="el" href="class_eigen_1_1_permutation_base.html">PermutationBase</a>&lt; PermDerived &gt; &amp;perm, const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; SparseDerived &gt; &amp;matrix)</td></tr>
<tr class="separator:a9c2c1af8da495ae3cbe7be12cecfe294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d3d00588ad602b9d64755ab14ac2f0"><td class="memTemplParams" colspan="2">template&lt;typename SparseDerived , typename PermutationType &gt; </td></tr>
<tr class="memitem:ad6d3d00588ad602b9d64755ab14ac2f0"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; SparseDerived, <a class="el" href="class_eigen_1_1_inverse.html">Inverse</a>&lt; PermutationType &gt;, AliasFreeProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ad6d3d00588ad602b9d64755ab14ac2f0">operator*</a> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; SparseDerived &gt; &amp;matrix, const <a class="el" href="class_eigen_1_1_inverse_impl.html">InverseImpl</a>&lt; PermutationType, <a class="el" href="struct_eigen_1_1_permutation_storage.html">PermutationStorage</a> &gt; &amp;tperm)</td></tr>
<tr class="separator:ad6d3d00588ad602b9d64755ab14ac2f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8908bda30ef10657db0653d96ad5800e"><td class="memTemplParams" colspan="2">template&lt;typename SparseDerived , typename PermutationType &gt; </td></tr>
<tr class="memitem:a8908bda30ef10657db0653d96ad5800e"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; <a class="el" href="class_eigen_1_1_inverse.html">Inverse</a>&lt; PermutationType &gt;, SparseDerived, AliasFreeProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a8908bda30ef10657db0653d96ad5800e">operator*</a> (const <a class="el" href="class_eigen_1_1_inverse_impl.html">InverseImpl</a>&lt; PermutationType, <a class="el" href="struct_eigen_1_1_permutation_storage.html">PermutationStorage</a> &gt; &amp;tperm, const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; SparseDerived &gt; &amp;matrix)</td></tr>
<tr class="separator:a8908bda30ef10657db0653d96ad5800e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3aa11404d37f5081c70138a206eb5a"><td class="memItemLeft" align="right" valign="top"><a id="a7d3aa11404d37f5081c70138a206eb5a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_defaults</b> (double control[UMFPACK_CONTROL], double, int)</td></tr>
<tr class="separator:a7d3aa11404d37f5081c70138a206eb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e91e95cf5869e21067c585ca322c83"><td class="memItemLeft" align="right" valign="top"><a id="a23e91e95cf5869e21067c585ca322c83"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_defaults</b> (double control[UMFPACK_CONTROL], std::complex&lt; double &gt;, int)</td></tr>
<tr class="separator:a23e91e95cf5869e21067c585ca322c83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d827b82a1253cda0185a04e80f9c4f"><td class="memItemLeft" align="right" valign="top"><a id="a84d827b82a1253cda0185a04e80f9c4f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_defaults</b> (double control[UMFPACK_CONTROL], double, SuiteSparse_long)</td></tr>
<tr class="separator:a84d827b82a1253cda0185a04e80f9c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bf09ece1c017c2f6d976f46f777be3"><td class="memItemLeft" align="right" valign="top"><a id="a87bf09ece1c017c2f6d976f46f777be3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_defaults</b> (double control[UMFPACK_CONTROL], std::complex&lt; double &gt;, SuiteSparse_long)</td></tr>
<tr class="separator:a87bf09ece1c017c2f6d976f46f777be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61e30548835bfa39be923617170f434"><td class="memItemLeft" align="right" valign="top"><a id="ac61e30548835bfa39be923617170f434"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_report_info</b> (double control[UMFPACK_CONTROL], double info[UMFPACK_INFO], double, int)</td></tr>
<tr class="separator:ac61e30548835bfa39be923617170f434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e88affdb1b3f4175a9b5450d104586"><td class="memItemLeft" align="right" valign="top"><a id="aa6e88affdb1b3f4175a9b5450d104586"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_report_info</b> (double control[UMFPACK_CONTROL], double info[UMFPACK_INFO], std::complex&lt; double &gt;, int)</td></tr>
<tr class="separator:aa6e88affdb1b3f4175a9b5450d104586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235323767b372116a07b87670ed8a66c"><td class="memItemLeft" align="right" valign="top"><a id="a235323767b372116a07b87670ed8a66c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_report_info</b> (double control[UMFPACK_CONTROL], double info[UMFPACK_INFO], double, SuiteSparse_long)</td></tr>
<tr class="separator:a235323767b372116a07b87670ed8a66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc444b00c8d0957e837150031503cf2"><td class="memItemLeft" align="right" valign="top"><a id="abfc444b00c8d0957e837150031503cf2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_report_info</b> (double control[UMFPACK_CONTROL], double info[UMFPACK_INFO], std::complex&lt; double &gt;, SuiteSparse_long)</td></tr>
<tr class="separator:abfc444b00c8d0957e837150031503cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1757bed1f7fb48cd25e04a8cd511f5c"><td class="memItemLeft" align="right" valign="top"><a id="ac1757bed1f7fb48cd25e04a8cd511f5c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_report_status</b> (double control[UMFPACK_CONTROL], int status, double, int)</td></tr>
<tr class="separator:ac1757bed1f7fb48cd25e04a8cd511f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7f3bb4b05bceced976dd8c84ccc6a6"><td class="memItemLeft" align="right" valign="top"><a id="a9e7f3bb4b05bceced976dd8c84ccc6a6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_report_status</b> (double control[UMFPACK_CONTROL], int status, std::complex&lt; double &gt;, int)</td></tr>
<tr class="separator:a9e7f3bb4b05bceced976dd8c84ccc6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c58ec6a004da2c14b63df19f9bbdb5"><td class="memItemLeft" align="right" valign="top"><a id="a86c58ec6a004da2c14b63df19f9bbdb5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_report_status</b> (double control[UMFPACK_CONTROL], int status, double, SuiteSparse_long)</td></tr>
<tr class="separator:a86c58ec6a004da2c14b63df19f9bbdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf65f79a78e76a883d0e0fb24efc73a"><td class="memItemLeft" align="right" valign="top"><a id="aaaf65f79a78e76a883d0e0fb24efc73a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_report_status</b> (double control[UMFPACK_CONTROL], int status, std::complex&lt; double &gt;, SuiteSparse_long)</td></tr>
<tr class="separator:aaaf65f79a78e76a883d0e0fb24efc73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ecb59cfa10f6220cffc967e2dff28a1"><td class="memItemLeft" align="right" valign="top"><a id="a6ecb59cfa10f6220cffc967e2dff28a1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_report_control</b> (double control[UMFPACK_CONTROL], double, int)</td></tr>
<tr class="separator:a6ecb59cfa10f6220cffc967e2dff28a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53faa4cbd47f6d79c870157e00150e00"><td class="memItemLeft" align="right" valign="top"><a id="a53faa4cbd47f6d79c870157e00150e00"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_report_control</b> (double control[UMFPACK_CONTROL], std::complex&lt; double &gt;, int)</td></tr>
<tr class="separator:a53faa4cbd47f6d79c870157e00150e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b6993ed3c8d7c19c6267fbd75b932a"><td class="memItemLeft" align="right" valign="top"><a id="a54b6993ed3c8d7c19c6267fbd75b932a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_report_control</b> (double control[UMFPACK_CONTROL], double, SuiteSparse_long)</td></tr>
<tr class="separator:a54b6993ed3c8d7c19c6267fbd75b932a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9acc968b67bc96ce10f9c12be9572b19"><td class="memItemLeft" align="right" valign="top"><a id="a9acc968b67bc96ce10f9c12be9572b19"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_report_control</b> (double control[UMFPACK_CONTROL], std::complex&lt; double &gt;, SuiteSparse_long)</td></tr>
<tr class="separator:a9acc968b67bc96ce10f9c12be9572b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7581ef58c3ae1a61f2f1cfd5e8684c98"><td class="memItemLeft" align="right" valign="top"><a id="a7581ef58c3ae1a61f2f1cfd5e8684c98"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_free_numeric</b> (void **Numeric, double, int)</td></tr>
<tr class="separator:a7581ef58c3ae1a61f2f1cfd5e8684c98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c662046532c662fd3e656e61ab8df92"><td class="memItemLeft" align="right" valign="top"><a id="a4c662046532c662fd3e656e61ab8df92"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_free_numeric</b> (void **Numeric, std::complex&lt; double &gt;, int)</td></tr>
<tr class="separator:a4c662046532c662fd3e656e61ab8df92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad89a156f4297b8581ca83f92dd04ec2e"><td class="memItemLeft" align="right" valign="top"><a id="ad89a156f4297b8581ca83f92dd04ec2e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_free_numeric</b> (void **Numeric, double, SuiteSparse_long)</td></tr>
<tr class="separator:ad89a156f4297b8581ca83f92dd04ec2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab3db4bc437cd33ba8e5218c9c02ebc"><td class="memItemLeft" align="right" valign="top"><a id="a2ab3db4bc437cd33ba8e5218c9c02ebc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_free_numeric</b> (void **Numeric, std::complex&lt; double &gt;, SuiteSparse_long)</td></tr>
<tr class="separator:a2ab3db4bc437cd33ba8e5218c9c02ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac68cc45ac3b56299748d4440facc0666"><td class="memItemLeft" align="right" valign="top"><a id="ac68cc45ac3b56299748d4440facc0666"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_free_symbolic</b> (void **Symbolic, double, int)</td></tr>
<tr class="separator:ac68cc45ac3b56299748d4440facc0666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15515dc2ac24ac94ed4ad40bd714906e"><td class="memItemLeft" align="right" valign="top"><a id="a15515dc2ac24ac94ed4ad40bd714906e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_free_symbolic</b> (void **Symbolic, std::complex&lt; double &gt;, int)</td></tr>
<tr class="separator:a15515dc2ac24ac94ed4ad40bd714906e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3904bf7910eb2c949c92d85ea2d5c7e"><td class="memItemLeft" align="right" valign="top"><a id="ae3904bf7910eb2c949c92d85ea2d5c7e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_free_symbolic</b> (void **Symbolic, double, SuiteSparse_long)</td></tr>
<tr class="separator:ae3904bf7910eb2c949c92d85ea2d5c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe781cca68322ef63ef6184184c5b8b4"><td class="memItemLeft" align="right" valign="top"><a id="abe781cca68322ef63ef6184184c5b8b4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_free_symbolic</b> (void **Symbolic, std::complex&lt; double &gt;, SuiteSparse_long)</td></tr>
<tr class="separator:abe781cca68322ef63ef6184184c5b8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847c096504418ca04136196572cd7eda"><td class="memItemLeft" align="right" valign="top"><a id="a847c096504418ca04136196572cd7eda"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_symbolic</b> (int n_row, int n_col, const int Ap[], const int Ai[], const double Ax[], void **Symbolic, const double <a class="el" href="struct_control.html">Control</a>[UMFPACK_CONTROL], double Info[UMFPACK_INFO])</td></tr>
<tr class="separator:a847c096504418ca04136196572cd7eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454630cf278a251ef1052f2864561bb6"><td class="memItemLeft" align="right" valign="top"><a id="a454630cf278a251ef1052f2864561bb6"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_symbolic</b> (int n_row, int n_col, const int Ap[], const int Ai[], const std::complex&lt; double &gt; Ax[], void **Symbolic, const double <a class="el" href="struct_control.html">Control</a>[UMFPACK_CONTROL], double Info[UMFPACK_INFO])</td></tr>
<tr class="separator:a454630cf278a251ef1052f2864561bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf48d3678d1c900cf68e262a50b8ef1c"><td class="memItemLeft" align="right" valign="top"><a id="abf48d3678d1c900cf68e262a50b8ef1c"></a>
SuiteSparse_long&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_symbolic</b> (SuiteSparse_long n_row, SuiteSparse_long n_col, const SuiteSparse_long Ap[], const SuiteSparse_long Ai[], const double Ax[], void **Symbolic, const double <a class="el" href="struct_control.html">Control</a>[UMFPACK_CONTROL], double Info[UMFPACK_INFO])</td></tr>
<tr class="separator:abf48d3678d1c900cf68e262a50b8ef1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24db314ca0b5f66deb32ebbf376d3a6"><td class="memItemLeft" align="right" valign="top"><a id="ac24db314ca0b5f66deb32ebbf376d3a6"></a>
SuiteSparse_long&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_symbolic</b> (SuiteSparse_long n_row, SuiteSparse_long n_col, const SuiteSparse_long Ap[], const SuiteSparse_long Ai[], const std::complex&lt; double &gt; Ax[], void **Symbolic, const double <a class="el" href="struct_control.html">Control</a>[UMFPACK_CONTROL], double Info[UMFPACK_INFO])</td></tr>
<tr class="separator:ac24db314ca0b5f66deb32ebbf376d3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24c67bcc4bd138fea3102bfc3144c82"><td class="memItemLeft" align="right" valign="top"><a id="ae24c67bcc4bd138fea3102bfc3144c82"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_numeric</b> (const int Ap[], const int Ai[], const double Ax[], void *Symbolic, void **Numeric, const double <a class="el" href="struct_control.html">Control</a>[UMFPACK_CONTROL], double Info[UMFPACK_INFO])</td></tr>
<tr class="separator:ae24c67bcc4bd138fea3102bfc3144c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a5f3d62574d58c788ffb4e22e8e409"><td class="memItemLeft" align="right" valign="top"><a id="a79a5f3d62574d58c788ffb4e22e8e409"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_numeric</b> (const int Ap[], const int Ai[], const std::complex&lt; double &gt; Ax[], void *Symbolic, void **Numeric, const double <a class="el" href="struct_control.html">Control</a>[UMFPACK_CONTROL], double Info[UMFPACK_INFO])</td></tr>
<tr class="separator:a79a5f3d62574d58c788ffb4e22e8e409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ee73e6e0070c1316fc3ebec131bdf7"><td class="memItemLeft" align="right" valign="top"><a id="a28ee73e6e0070c1316fc3ebec131bdf7"></a>
SuiteSparse_long&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_numeric</b> (const SuiteSparse_long Ap[], const SuiteSparse_long Ai[], const double Ax[], void *Symbolic, void **Numeric, const double <a class="el" href="struct_control.html">Control</a>[UMFPACK_CONTROL], double Info[UMFPACK_INFO])</td></tr>
<tr class="separator:a28ee73e6e0070c1316fc3ebec131bdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a2fbc2b24c067ca0a6c34900af06a1"><td class="memItemLeft" align="right" valign="top"><a id="a88a2fbc2b24c067ca0a6c34900af06a1"></a>
SuiteSparse_long&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_numeric</b> (const SuiteSparse_long Ap[], const SuiteSparse_long Ai[], const std::complex&lt; double &gt; Ax[], void *Symbolic, void **Numeric, const double <a class="el" href="struct_control.html">Control</a>[UMFPACK_CONTROL], double Info[UMFPACK_INFO])</td></tr>
<tr class="separator:a88a2fbc2b24c067ca0a6c34900af06a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4b67e7827ef63894888bb9475512dc"><td class="memItemLeft" align="right" valign="top"><a id="a4f4b67e7827ef63894888bb9475512dc"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_solve</b> (int sys, const int Ap[], const int Ai[], const double Ax[], double X[], const double <a class="el" href="class_eigen_1_1_matrix.html">B</a>[], void *Numeric, const double <a class="el" href="struct_control.html">Control</a>[UMFPACK_CONTROL], double Info[UMFPACK_INFO])</td></tr>
<tr class="separator:a4f4b67e7827ef63894888bb9475512dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccc7c4e4af80e69a83dafe8df474372"><td class="memItemLeft" align="right" valign="top"><a id="acccc7c4e4af80e69a83dafe8df474372"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_solve</b> (int sys, const int Ap[], const int Ai[], const std::complex&lt; double &gt; Ax[], std::complex&lt; double &gt; X[], const std::complex&lt; double &gt; <a class="el" href="class_eigen_1_1_matrix.html">B</a>[], void *Numeric, const double <a class="el" href="struct_control.html">Control</a>[UMFPACK_CONTROL], double Info[UMFPACK_INFO])</td></tr>
<tr class="separator:acccc7c4e4af80e69a83dafe8df474372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b7db24314d53492377bd89eb513814"><td class="memItemLeft" align="right" valign="top"><a id="a88b7db24314d53492377bd89eb513814"></a>
SuiteSparse_long&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_solve</b> (int sys, const SuiteSparse_long Ap[], const SuiteSparse_long Ai[], const double Ax[], double X[], const double <a class="el" href="class_eigen_1_1_matrix.html">B</a>[], void *Numeric, const double <a class="el" href="struct_control.html">Control</a>[UMFPACK_CONTROL], double Info[UMFPACK_INFO])</td></tr>
<tr class="separator:a88b7db24314d53492377bd89eb513814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd9f4aba42f973b292b2e6ebb6c4d29"><td class="memItemLeft" align="right" valign="top"><a id="abbd9f4aba42f973b292b2e6ebb6c4d29"></a>
SuiteSparse_long&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_solve</b> (int sys, const SuiteSparse_long Ap[], const SuiteSparse_long Ai[], const std::complex&lt; double &gt; Ax[], std::complex&lt; double &gt; X[], const std::complex&lt; double &gt; <a class="el" href="class_eigen_1_1_matrix.html">B</a>[], void *Numeric, const double <a class="el" href="struct_control.html">Control</a>[UMFPACK_CONTROL], double Info[UMFPACK_INFO])</td></tr>
<tr class="separator:abbd9f4aba42f973b292b2e6ebb6c4d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2916b9529f0938350692d56d527a047"><td class="memItemLeft" align="right" valign="top"><a id="af2916b9529f0938350692d56d527a047"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_get_lunz</b> (int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, double)</td></tr>
<tr class="separator:af2916b9529f0938350692d56d527a047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8aae2a0d71f002142ebaf0dcb96f097"><td class="memItemLeft" align="right" valign="top"><a id="ae8aae2a0d71f002142ebaf0dcb96f097"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_get_lunz</b> (int *lnz, int *unz, int *n_row, int *n_col, int *nz_udiag, void *Numeric, std::complex&lt; double &gt;)</td></tr>
<tr class="separator:ae8aae2a0d71f002142ebaf0dcb96f097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a3a113755ed330cd508e47b2ed90a1"><td class="memItemLeft" align="right" valign="top"><a id="ad5a3a113755ed330cd508e47b2ed90a1"></a>
SuiteSparse_long&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_get_lunz</b> (SuiteSparse_long *lnz, SuiteSparse_long *unz, SuiteSparse_long *n_row, SuiteSparse_long *n_col, SuiteSparse_long *nz_udiag, void *Numeric, double)</td></tr>
<tr class="separator:ad5a3a113755ed330cd508e47b2ed90a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cf19fd7f53f3443bced942c31d5af7a"><td class="memItemLeft" align="right" valign="top"><a id="a4cf19fd7f53f3443bced942c31d5af7a"></a>
SuiteSparse_long&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_get_lunz</b> (SuiteSparse_long *lnz, SuiteSparse_long *unz, SuiteSparse_long *n_row, SuiteSparse_long *n_col, SuiteSparse_long *nz_udiag, void *Numeric, std::complex&lt; double &gt;)</td></tr>
<tr class="separator:a4cf19fd7f53f3443bced942c31d5af7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435266948cde73ddd933b5c9aa3948f0"><td class="memItemLeft" align="right" valign="top"><a id="a435266948cde73ddd933b5c9aa3948f0"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_get_numeric</b> (int Lp[], int Lj[], double Lx[], int Up[], int Ui[], double Ux[], int P[], int Q[], double Dx[], int *do_recip, double Rs[], void *Numeric)</td></tr>
<tr class="separator:a435266948cde73ddd933b5c9aa3948f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab180284eb73eef50710704885570e29"><td class="memItemLeft" align="right" valign="top"><a id="aab180284eb73eef50710704885570e29"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_get_numeric</b> (int Lp[], int Lj[], std::complex&lt; double &gt; Lx[], int Up[], int Ui[], std::complex&lt; double &gt; Ux[], int P[], int Q[], std::complex&lt; double &gt; Dx[], int *do_recip, double Rs[], void *Numeric)</td></tr>
<tr class="separator:aab180284eb73eef50710704885570e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7749ddd5ffb0b4e4be8221a2a81200fe"><td class="memItemLeft" align="right" valign="top"><a id="a7749ddd5ffb0b4e4be8221a2a81200fe"></a>
SuiteSparse_long&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_get_numeric</b> (SuiteSparse_long Lp[], SuiteSparse_long Lj[], double Lx[], SuiteSparse_long Up[], SuiteSparse_long Ui[], double Ux[], SuiteSparse_long P[], SuiteSparse_long Q[], double Dx[], SuiteSparse_long *do_recip, double Rs[], void *Numeric)</td></tr>
<tr class="separator:a7749ddd5ffb0b4e4be8221a2a81200fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a6a7bdb5f39b6bb83c7891730f2ceda"><td class="memItemLeft" align="right" valign="top"><a id="a7a6a7bdb5f39b6bb83c7891730f2ceda"></a>
SuiteSparse_long&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_get_numeric</b> (SuiteSparse_long Lp[], SuiteSparse_long Lj[], std::complex&lt; double &gt; Lx[], SuiteSparse_long Up[], SuiteSparse_long Ui[], std::complex&lt; double &gt; Ux[], SuiteSparse_long P[], SuiteSparse_long Q[], std::complex&lt; double &gt; Dx[], SuiteSparse_long *do_recip, double Rs[], void *Numeric)</td></tr>
<tr class="separator:a7a6a7bdb5f39b6bb83c7891730f2ceda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab4e33fe43d2eb42a4b804343760ece"><td class="memItemLeft" align="right" valign="top"><a id="a4ab4e33fe43d2eb42a4b804343760ece"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_get_determinant</b> (double *Mx, double *Ex, void *NumericHandle, double User_Info[UMFPACK_INFO], int)</td></tr>
<tr class="separator:a4ab4e33fe43d2eb42a4b804343760ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f0b4b7f0f357e2c3d66216fd805830"><td class="memItemLeft" align="right" valign="top"><a id="aa7f0b4b7f0f357e2c3d66216fd805830"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_get_determinant</b> (std::complex&lt; double &gt; *Mx, double *Ex, void *NumericHandle, double User_Info[UMFPACK_INFO], int)</td></tr>
<tr class="separator:aa7f0b4b7f0f357e2c3d66216fd805830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9dd7fe319aa7d311913462d90de9360"><td class="memItemLeft" align="right" valign="top"><a id="af9dd7fe319aa7d311913462d90de9360"></a>
SuiteSparse_long&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_get_determinant</b> (double *Mx, double *Ex, void *NumericHandle, double User_Info[UMFPACK_INFO], SuiteSparse_long)</td></tr>
<tr class="separator:af9dd7fe319aa7d311913462d90de9360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2e5b91b068e26a5c523ab546d79079"><td class="memItemLeft" align="right" valign="top"><a id="aec2e5b91b068e26a5c523ab546d79079"></a>
SuiteSparse_long&#160;</td><td class="memItemRight" valign="bottom"><b>umfpack_get_determinant</b> (std::complex&lt; double &gt; *Mx, double *Ex, void *NumericHandle, double User_Info[UMFPACK_INFO], SuiteSparse_long)</td></tr>
<tr class="separator:aec2e5b91b068e26a5c523ab546d79079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb48cb308801c92008761a7400ac4196"><td class="memItemLeft" align="right" valign="top"><a id="acb48cb308801c92008761a7400ac4196"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:acb48cb308801c92008761a7400ac4196"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_annoying_scalar.html">AnnoyingScalar</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_precision&lt; AnnoyingScalar &gt;</b> ()</td></tr>
<tr class="separator:acb48cb308801c92008761a7400ac4196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b3c5cef3b8c53fa6c69aa2f608a5888"><td class="memItemLeft" align="right" valign="top"><a id="a8b3c5cef3b8c53fa6c69aa2f608a5888"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8b3c5cef3b8c53fa6c69aa2f608a5888"><td class="memTemplItemLeft" align="right" valign="top">Real&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_precision&lt; Real &gt;</b> ()</td></tr>
<tr class="separator:a8b3c5cef3b8c53fa6c69aa2f608a5888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd0fb5de9a0e3196003928a28bb151b"><td class="memTemplParams" colspan="2"><a id="a6dd0fb5de9a0e3196003928a28bb151b"></a>
template&lt;typename Lhs , typename Rhs &gt; </td></tr>
<tr class="memitem:a6dd0fb5de9a0e3196003928a28bb151b"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; Lhs, Rhs &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>prod</b> (const Lhs &amp;lhs, const Rhs &amp;rhs)</td></tr>
<tr class="separator:a6dd0fb5de9a0e3196003928a28bb151b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7aeb3f2ecc6d518b24ee50c423519ca"><td class="memTemplParams" colspan="2"><a id="ad7aeb3f2ecc6d518b24ee50c423519ca"></a>
template&lt;typename Lhs , typename Rhs &gt; </td></tr>
<tr class="memitem:ad7aeb3f2ecc6d518b24ee50c423519ca"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; Lhs, Rhs, LazyProduct &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>lazyprod</b> (const Lhs &amp;lhs, const Rhs &amp;rhs)</td></tr>
<tr class="separator:ad7aeb3f2ecc6d518b24ee50c423519ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e2fa753412fadca68692dab53afa7b"><td class="memTemplParams" colspan="2"><a id="a87e2fa753412fadca68692dab53afa7b"></a>
template&lt;typename DstXprType , typename SrcXprType &gt; </td></tr>
<tr class="memitem:a87e2fa753412fadca68692dab53afa7b"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE DstXprType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_using_evaluator</b> (const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; DstXprType &gt; &amp;dst, const SrcXprType &amp;src)</td></tr>
<tr class="separator:a87e2fa753412fadca68692dab53afa7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a760d48942c6fc5fbab1cd642195a1878"><td class="memTemplParams" colspan="2"><a id="a760d48942c6fc5fbab1cd642195a1878"></a>
template&lt;typename DstXprType , template&lt; typename &gt; class StorageBase, typename SrcXprType &gt; </td></tr>
<tr class="memitem:a760d48942c6fc5fbab1cd642195a1878"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE DstXprType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_using_evaluator</b> (const <a class="el" href="class_eigen_1_1_no_alias.html">NoAlias</a>&lt; DstXprType, StorageBase &gt; &amp;dst, const SrcXprType &amp;src)</td></tr>
<tr class="separator:a760d48942c6fc5fbab1cd642195a1878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61562a02f90df062ee87a6afd6bdd0af"><td class="memTemplParams" colspan="2"><a id="a61562a02f90df062ee87a6afd6bdd0af"></a>
template&lt;typename DstXprType , typename SrcXprType &gt; </td></tr>
<tr class="memitem:a61562a02f90df062ee87a6afd6bdd0af"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_STRONG_INLINE DstXprType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_using_evaluator</b> (const <a class="el" href="class_eigen_1_1_plain_object_base.html">PlainObjectBase</a>&lt; DstXprType &gt; &amp;dst, const SrcXprType &amp;src)</td></tr>
<tr class="separator:a61562a02f90df062ee87a6afd6bdd0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38f2d7c7e914818e584561f5888123a"><td class="memTemplParams" colspan="2"><a id="ae38f2d7c7e914818e584561f5888123a"></a>
template&lt;typename DstXprType , typename SrcXprType &gt; </td></tr>
<tr class="memitem:ae38f2d7c7e914818e584561f5888123a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_assign_using_evaluator</b> (const DstXprType &amp;dst, const SrcXprType &amp;src)</td></tr>
<tr class="separator:ae38f2d7c7e914818e584561f5888123a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e181f2c102982e79cd3f58f7b013cd8"><td class="memTemplParams" colspan="2"><a id="a5e181f2c102982e79cd3f58f7b013cd8"></a>
template&lt;typename DstXprType , typename SrcXprType &gt; </td></tr>
<tr class="memitem:a5e181f2c102982e79cd3f58f7b013cd8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>subtract_assign_using_evaluator</b> (const DstXprType &amp;dst, const SrcXprType &amp;src)</td></tr>
<tr class="separator:a5e181f2c102982e79cd3f58f7b013cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ef6eff082c409d877105430d7837ec"><td class="memTemplParams" colspan="2"><a id="a94ef6eff082c409d877105430d7837ec"></a>
template&lt;typename DstXprType , typename SrcXprType &gt; </td></tr>
<tr class="memitem:a94ef6eff082c409d877105430d7837ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multiply_assign_using_evaluator</b> (const DstXprType &amp;dst, const SrcXprType &amp;src)</td></tr>
<tr class="separator:a94ef6eff082c409d877105430d7837ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07a8b514d9e4239d18f822ae16512bc"><td class="memTemplParams" colspan="2"><a id="ab07a8b514d9e4239d18f822ae16512bc"></a>
template&lt;typename DstXprType , typename SrcXprType &gt; </td></tr>
<tr class="memitem:ab07a8b514d9e4239d18f822ae16512bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divide_assign_using_evaluator</b> (const DstXprType &amp;dst, const SrcXprType &amp;src)</td></tr>
<tr class="separator:ab07a8b514d9e4239d18f822ae16512bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6579967d42a614cebe40909ec8a4054f"><td class="memTemplParams" colspan="2"><a id="a6579967d42a614cebe40909ec8a4054f"></a>
template&lt;typename DstXprType , typename SrcXprType &gt; </td></tr>
<tr class="memitem:a6579967d42a614cebe40909ec8a4054f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>swap_using_evaluator</b> (const DstXprType &amp;dst, const SrcXprType &amp;src)</td></tr>
<tr class="separator:a6579967d42a614cebe40909ec8a4054f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363009311edea9cf1cb642b946518cbc"><td class="memTemplParams" colspan="2">template&lt;typename Kernel , typename... Args&gt; </td></tr>
<tr class="memitem:a363009311edea9cf1cb642b946518cbc"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a363009311edea9cf1cb642b946518cbc">run_on_cpu</a> (Kernel kernel, Args &amp;&amp;... args) -&gt; decltype(kernel(args...))</td></tr>
<tr class="separator:a363009311edea9cf1cb642b946518cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb05f2dfd1e1974dc016cff6f349f98"><td class="memTemplParams" colspan="2">template&lt;typename Kernel , typename... Args&gt; </td></tr>
<tr class="memitem:a1fb05f2dfd1e1974dc016cff6f349f98"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a1fb05f2dfd1e1974dc016cff6f349f98">run</a> (Kernel kernel, Args &amp;&amp;... args) -&gt; decltype(kernel(args...))</td></tr>
<tr class="separator:a1fb05f2dfd1e1974dc016cff6f349f98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda1bc37ca9b370036cce59a96be00c1"><td class="memTemplParams" colspan="2">template&lt;typename Kernel , typename... Args&gt; </td></tr>
<tr class="memitem:aeda1bc37ca9b370036cce59a96be00c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#aeda1bc37ca9b370036cce59a96be00c1">run_with_hint</a> (size_t buffer_capacity_hint, Kernel kernel, Args &amp;&amp;... args) -&gt; decltype(kernel(args...))</td></tr>
<tr class="separator:aeda1bc37ca9b370036cce59a96be00c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e77c847d2ba96d85ba1316e5ea3ea67"><td class="memTemplParams" colspan="2"><a id="a8e77c847d2ba96d85ba1316e5ea3ea67"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a8e77c847d2ba96d85ba1316e5ea3ea67"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; <a class="el" href="struct_eigen_1_1internal_1_1is__same.html">internal::is_same</a>&lt; T1, T2 &gt;::value, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>is_same_type</b> (const T1 &amp;, const T2 &amp;)</td></tr>
<tr class="separator:a8e77c847d2ba96d85ba1316e5ea3ea67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59fa1c0c2d234197bce8d461a4776793"><td class="memTemplParams" colspan="2"><a id="a59fa1c0c2d234197bce8d461a4776793"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59fa1c0c2d234197bce8d461a4776793"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; <a class="el" href="class_eigen_1_1_triplet.html">T</a> &gt;::Real&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_precision</b> ()</td></tr>
<tr class="separator:a59fa1c0c2d234197bce8d461a4776793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6881d7a18f97c01df6c1252fc5bac126"><td class="memItemLeft" align="right" valign="top"><a id="a6881d7a18f97c01df6c1252fc5bac126"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a6881d7a18f97c01df6c1252fc5bac126"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_precision&lt; float &gt;</b> ()</td></tr>
<tr class="separator:a6881d7a18f97c01df6c1252fc5bac126"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80318b650b1e0ff8ff96b9efad266ba1"><td class="memItemLeft" align="right" valign="top"><a id="a80318b650b1e0ff8ff96b9efad266ba1"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a80318b650b1e0ff8ff96b9efad266ba1"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_precision&lt; double &gt;</b> ()</td></tr>
<tr class="separator:a80318b650b1e0ff8ff96b9efad266ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7683c2a014c5259e16ad4ab9e0170232"><td class="memItemLeft" align="right" valign="top"><a id="a7683c2a014c5259e16ad4ab9e0170232"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a7683c2a014c5259e16ad4ab9e0170232"><td class="memTemplItemLeft" align="right" valign="top">long double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_precision&lt; long double &gt;</b> ()</td></tr>
<tr class="separator:a7683c2a014c5259e16ad4ab9e0170232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b3936f38700642414b511b0492b60d4"><td class="memItemLeft" align="right" valign="top"><a id="a9b3936f38700642414b511b0492b60d4"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a9b3936f38700642414b511b0492b60d4"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_precision&lt; std::complex&lt; float &gt; &gt;</b> ()</td></tr>
<tr class="separator:a9b3936f38700642414b511b0492b60d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77ec7cb379d51354254b797f722983c"><td class="memItemLeft" align="right" valign="top"><a id="ab77ec7cb379d51354254b797f722983c"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:ab77ec7cb379d51354254b797f722983c"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_precision&lt; std::complex&lt; double &gt; &gt;</b> ()</td></tr>
<tr class="separator:ab77ec7cb379d51354254b797f722983c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecaff596bd9f5e6d98a49edc6cfd34f"><td class="memItemLeft" align="right" valign="top"><a id="a8ecaff596bd9f5e6d98a49edc6cfd34f"></a>
template&lt;&gt; </td></tr>
<tr class="memitem:a8ecaff596bd9f5e6d98a49edc6cfd34f"><td class="memTemplItemLeft" align="right" valign="top">long double&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_precision&lt; std::complex&lt; long double &gt; &gt;</b> ()</td></tr>
<tr class="separator:a8ecaff596bd9f5e6d98a49edc6cfd34f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866914d9c95461cc21d9d5a42c9fcdf8"><td class="memItemLeft" align="right" valign="top"><a id="a866914d9c95461cc21d9d5a42c9fcdf8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>test_isApprox</b> (const std::complex&lt; float &gt; &amp;a, const std::complex&lt; float &gt; &amp;b)</td></tr>
<tr class="separator:a866914d9c95461cc21d9d5a42c9fcdf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a539da498bda2dcfc0edcf0bda2c2be73"><td class="memItemLeft" align="right" valign="top"><a id="a539da498bda2dcfc0edcf0bda2c2be73"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>test_isMuchSmallerThan</b> (const std::complex&lt; float &gt; &amp;a, const std::complex&lt; float &gt; &amp;b)</td></tr>
<tr class="separator:a539da498bda2dcfc0edcf0bda2c2be73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b782390e9d798029c2e24529766e457"><td class="memItemLeft" align="right" valign="top"><a id="a7b782390e9d798029c2e24529766e457"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>test_isApprox</b> (const std::complex&lt; double &gt; &amp;a, const std::complex&lt; double &gt; &amp;b)</td></tr>
<tr class="separator:a7b782390e9d798029c2e24529766e457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a5ea7d4707d277d788b8ff80ccf127"><td class="memItemLeft" align="right" valign="top"><a id="ab9a5ea7d4707d277d788b8ff80ccf127"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>test_isMuchSmallerThan</b> (const std::complex&lt; double &gt; &amp;a, const std::complex&lt; double &gt; &amp;b)</td></tr>
<tr class="separator:ab9a5ea7d4707d277d788b8ff80ccf127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0abfedf97e2323b090f249243986ba"><td class="memItemLeft" align="right" valign="top"><a id="a4b0abfedf97e2323b090f249243986ba"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>test_isApprox</b> (const std::complex&lt; long double &gt; &amp;a, const std::complex&lt; long double &gt; &amp;b)</td></tr>
<tr class="separator:a4b0abfedf97e2323b090f249243986ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad493ae50921288fb3f62f4732aeb2876"><td class="memItemLeft" align="right" valign="top"><a id="ad493ae50921288fb3f62f4732aeb2876"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>test_isMuchSmallerThan</b> (const std::complex&lt; long double &gt; &amp;a, const std::complex&lt; long double &gt; &amp;b)</td></tr>
<tr class="separator:ad493ae50921288fb3f62f4732aeb2876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcac98601217024dc7ceef2e8f74c5c6"><td class="memItemLeft" align="right" valign="top"><a id="adcac98601217024dc7ceef2e8f74c5c6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>test_isApprox</b> (const long double &amp;a, const long double &amp;b)</td></tr>
<tr class="separator:adcac98601217024dc7ceef2e8f74c5c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9835dfcb4613af3cceb32c7eb9e3cd"><td class="memItemLeft" align="right" valign="top"><a id="a5a9835dfcb4613af3cceb32c7eb9e3cd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>test_isMuchSmallerThan</b> (const long double &amp;a, const long double &amp;b)</td></tr>
<tr class="separator:a5a9835dfcb4613af3cceb32c7eb9e3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37038e95456c17b19dc69180583444bb"><td class="memItemLeft" align="right" valign="top"><a id="a37038e95456c17b19dc69180583444bb"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>test_isApproxOrLessThan</b> (const long double &amp;a, const long double &amp;b)</td></tr>
<tr class="separator:a37038e95456c17b19dc69180583444bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420a78795b09cd2a7cc1a5bc4e3f30b7"><td class="memTemplParams" colspan="2"><a id="a420a78795b09cd2a7cc1a5bc4e3f30b7"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a420a78795b09cd2a7cc1a5bc4e3f30b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; typename T1::RealScalar &gt;::NonInteger&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_relative_error</b> (const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; T1 &gt; &amp;a, const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; T2 &gt; &amp;b)</td></tr>
<tr class="separator:a420a78795b09cd2a7cc1a5bc4e3f30b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6c439203185801630c2857b44ef276"><td class="memTemplParams" colspan="2"><a id="a5b6c439203185801630c2857b44ef276"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a5b6c439203185801630c2857b44ef276"><td class="memTemplItemLeft" align="right" valign="top">T1::RealScalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_relative_error</b> (const T1 &amp;a, const T2 &amp;b, const typename T1::Coefficients *=0)</td></tr>
<tr class="separator:a5b6c439203185801630c2857b44ef276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9a46db32498d15a7ea8d09574bbf39"><td class="memTemplParams" colspan="2"><a id="a6d9a46db32498d15a7ea8d09574bbf39"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a6d9a46db32498d15a7ea8d09574bbf39"><td class="memTemplItemLeft" align="right" valign="top">T1::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_relative_error</b> (const T1 &amp;a, const T2 &amp;b, const typename T1::MatrixType *=0)</td></tr>
<tr class="separator:a6d9a46db32498d15a7ea8d09574bbf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f0a7266e0f6a0079eb31cfcf06afcc"><td class="memTemplParams" colspan="2"><a id="ac2f0a7266e0f6a0079eb31cfcf06afcc"></a>
template&lt;typename S , int D&gt; </td></tr>
<tr class="memitem:ac2f0a7266e0f6a0079eb31cfcf06afcc"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_relative_error</b> (const <a class="el" href="class_eigen_1_1_translation.html">Translation</a>&lt; S, D &gt; &amp;a, const <a class="el" href="class_eigen_1_1_translation.html">Translation</a>&lt; S, D &gt; &amp;b)</td></tr>
<tr class="separator:ac2f0a7266e0f6a0079eb31cfcf06afcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e5fc6174700be721bb9c27ce3f8815e"><td class="memTemplParams" colspan="2"><a id="a0e5fc6174700be721bb9c27ce3f8815e"></a>
template&lt;typename S , int D, int O&gt; </td></tr>
<tr class="memitem:a0e5fc6174700be721bb9c27ce3f8815e"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_relative_error</b> (const <a class="el" href="class_eigen_1_1_parametrized_line.html">ParametrizedLine</a>&lt; S, D, O &gt; &amp;a, const <a class="el" href="class_eigen_1_1_parametrized_line.html">ParametrizedLine</a>&lt; S, D, O &gt; &amp;b)</td></tr>
<tr class="separator:a0e5fc6174700be721bb9c27ce3f8815e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6722d6113e8f684b5f69b222510b1173"><td class="memTemplParams" colspan="2"><a id="a6722d6113e8f684b5f69b222510b1173"></a>
template&lt;typename S , int D&gt; </td></tr>
<tr class="memitem:a6722d6113e8f684b5f69b222510b1173"><td class="memTemplItemLeft" align="right" valign="top">S&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_relative_error</b> (const <a class="el" href="class_eigen_1_1_aligned_box.html">AlignedBox</a>&lt; S, D &gt; &amp;a, const <a class="el" href="class_eigen_1_1_aligned_box.html">AlignedBox</a>&lt; S, D &gt; &amp;b)</td></tr>
<tr class="separator:a6722d6113e8f684b5f69b222510b1173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa667ebc4e9a54db43dabaa8235a2c3b9"><td class="memTemplParams" colspan="2"><a id="aa667ebc4e9a54db43dabaa8235a2c3b9"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:aa667ebc4e9a54db43dabaa8235a2c3b9"><td class="memTemplItemLeft" align="right" valign="top">T1::RealScalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_relative_error</b> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; T1 &gt; &amp;a, const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; T2 &gt; &amp;b)</td></tr>
<tr class="separator:aa667ebc4e9a54db43dabaa8235a2c3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae510fbb3f20a0114cb8428471ff902ed"><td class="memTemplParams" colspan="2"><a id="ae510fbb3f20a0114cb8428471ff902ed"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ae510fbb3f20a0114cb8428471ff902ed"><td class="memTemplItemLeft" align="right" valign="top">T1::RealScalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_relative_error</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; T1 &gt; &amp;a, const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; T2 &gt; &amp;b)</td></tr>
<tr class="separator:ae510fbb3f20a0114cb8428471ff902ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d9111c3a8c3efb7e8754d43543d67f"><td class="memTemplParams" colspan="2"><a id="ac7d9111c3a8c3efb7e8754d43543d67f"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ac7d9111c3a8c3efb7e8754d43543d67f"><td class="memTemplItemLeft" align="right" valign="top">T1::RealScalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_relative_error</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; T1 &gt; &amp;a, const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; T2 &gt; &amp;b)</td></tr>
<tr class="separator:ac7d9111c3a8c3efb7e8754d43543d67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fccc4ca6b0e6834dae33ada1f17e74"><td class="memTemplParams" colspan="2"><a id="a09fccc4ca6b0e6834dae33ada1f17e74"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a09fccc4ca6b0e6834dae33ada1f17e74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; typename <a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; T1 &gt;::Real &gt;::NonInteger&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_relative_error</b> (const T1 &amp;a, const T2 &amp;b, std::enable_if_t&lt; <a class="el" href="struct_eigen_1_1internal_1_1is__arithmetic.html">internal::is_arithmetic</a>&lt; typename <a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; T1 &gt;::Real &gt;::value, T1 &gt; *=0)</td></tr>
<tr class="separator:a09fccc4ca6b0e6834dae33ada1f17e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b119ece58adbb33db1f2670e988423"><td class="memTemplParams" colspan="2"><a id="ae7b119ece58adbb33db1f2670e988423"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae7b119ece58adbb33db1f2670e988423"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_triplet.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_relative_error</b> (const <a class="el" href="class_eigen_1_1_rotation2_d.html">Rotation2D</a>&lt; <a class="el" href="class_eigen_1_1_triplet.html">T</a> &gt; &amp;a, const <a class="el" href="class_eigen_1_1_rotation2_d.html">Rotation2D</a>&lt; <a class="el" href="class_eigen_1_1_triplet.html">T</a> &gt; &amp;b)</td></tr>
<tr class="separator:ae7b119ece58adbb33db1f2670e988423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c97575f6fba46c2982b464c9cde90c"><td class="memTemplParams" colspan="2"><a id="ac9c97575f6fba46c2982b464c9cde90c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac9c97575f6fba46c2982b464c9cde90c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_triplet.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_relative_error</b> (const <a class="el" href="class_eigen_1_1_angle_axis.html">AngleAxis</a>&lt; <a class="el" href="class_eigen_1_1_triplet.html">T</a> &gt; &amp;a, const <a class="el" href="class_eigen_1_1_angle_axis.html">AngleAxis</a>&lt; <a class="el" href="class_eigen_1_1_triplet.html">T</a> &gt; &amp;b)</td></tr>
<tr class="separator:ac9c97575f6fba46c2982b464c9cde90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621499e5e36df27ae4c11bef1bbac48d"><td class="memTemplParams" colspan="2"><a id="a621499e5e36df27ae4c11bef1bbac48d"></a>
template&lt;typename Type1 , typename Type2 &gt; </td></tr>
<tr class="memitem:a621499e5e36df27ae4c11bef1bbac48d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_isApprox</b> (const Type1 &amp;a, const Type2 &amp;b, typename Type1::Scalar *=0)</td></tr>
<tr class="separator:a621499e5e36df27ae4c11bef1bbac48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b967cdd6248237b53191013ecb8e4e6"><td class="memTemplParams" colspan="2"><a id="a5b967cdd6248237b53191013ecb8e4e6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5b967cdd6248237b53191013ecb8e4e6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; typename T::Scalar &gt;::Real&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_test_precision</b> (const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;, const typename T::Scalar *=0)</td></tr>
<tr class="separator:a5b967cdd6248237b53191013ecb8e4e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd4ee8e1eb826df18fe617b32d768a2"><td class="memTemplParams" colspan="2"><a id="a7cd4ee8e1eb826df18fe617b32d768a2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7cd4ee8e1eb826df18fe617b32d768a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; <a class="el" href="class_eigen_1_1_triplet.html">T</a> &gt;::Real&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_test_precision</b> (const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;, std::enable_if_t&lt; <a class="el" href="struct_eigen_1_1internal_1_1is__arithmetic.html">internal::is_arithmetic</a>&lt; typename <a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; <a class="el" href="class_eigen_1_1_triplet.html">T</a> &gt;::Real &gt;::value, <a class="el" href="class_eigen_1_1_triplet.html">T</a> &gt; *=0)</td></tr>
<tr class="separator:a7cd4ee8e1eb826df18fe617b32d768a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1a0a2e015838382b95725487e0ef7e"><td class="memTemplParams" colspan="2"><a id="a7a1a0a2e015838382b95725487e0ef7e"></a>
template&lt;typename Type1 , typename Type2 &gt; </td></tr>
<tr class="memitem:a7a1a0a2e015838382b95725487e0ef7e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>verifyIsApprox</b> (const Type1 &amp;a, const Type2 &amp;b)</td></tr>
<tr class="separator:a7a1a0a2e015838382b95725487e0ef7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a459e7d2c160f1ba553ade1d06dc8facc"><td class="memTemplParams" colspan="2"><a id="a459e7d2c160f1ba553ade1d06dc8facc"></a>
template&lt;typename Type1 , typename Type2 &gt; </td></tr>
<tr class="memitem:a459e7d2c160f1ba553ade1d06dc8facc"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>verifyIsCwiseApprox</b> (const Type1 &amp;a, const Type2 &amp;b, bool exact)</td></tr>
<tr class="separator:a459e7d2c160f1ba553ade1d06dc8facc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac629f5f03405251bde5776a443935e32"><td class="memTemplParams" colspan="2"><a id="ac629f5f03405251bde5776a443935e32"></a>
template&lt;typename Scalar , typename ScalarRef &gt; </td></tr>
<tr class="memitem:ac629f5f03405251bde5776a443935e32"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_isApproxWithRef</b> (const Scalar &amp;a, const Scalar &amp;b, const ScalarRef &amp;ref)</td></tr>
<tr class="separator:ac629f5f03405251bde5776a443935e32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6d71953497863f9720bbb91c61ef03b"><td class="memTemplParams" colspan="2"><a id="ab6d71953497863f9720bbb91c61ef03b"></a>
template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:ab6d71953497863f9720bbb91c61ef03b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_isMuchSmallerThan</b> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived1 &gt; &amp;m1, const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived2 &gt; &amp;m2)</td></tr>
<tr class="separator:ab6d71953497863f9720bbb91c61ef03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d42d823149b099e71f0d23f49bfe32f"><td class="memTemplParams" colspan="2"><a id="a4d42d823149b099e71f0d23f49bfe32f"></a>
template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4d42d823149b099e71f0d23f49bfe32f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_isMuchSmallerThan</b> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt; &amp;m, const typename <a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; typename <a class="el" href="struct_eigen_1_1internal_1_1traits.html">internal::traits</a>&lt; Derived &gt;::Scalar &gt;::Real &amp;s)</td></tr>
<tr class="separator:a4d42d823149b099e71f0d23f49bfe32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ba6c19dbe321546997e690a9778406"><td class="memTemplParams" colspan="2"><a id="aa1ba6c19dbe321546997e690a9778406"></a>
template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:aa1ba6c19dbe321546997e690a9778406"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_isUnitary</b> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt; &amp;m)</td></tr>
<tr class="separator:aa1ba6c19dbe321546997e690a9778406"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3ee412d2ee35b4ac9720db33c0a884"><td class="memTemplParams" colspan="2"><a id="a7a3ee412d2ee35b4ac9720db33c0a884"></a>
template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a7a3ee412d2ee35b4ac9720db33c0a884"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_isCwiseApprox</b> (const <a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a>&lt; Derived1 &gt; &amp;m1, const <a class="el" href="class_eigen_1_1_dense_base.html">DenseBase</a>&lt; Derived2 &gt; &amp;m2, bool exact)</td></tr>
<tr class="separator:a7a3ee412d2ee35b4ac9720db33c0a884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2100a88968278367e26c4eb2099b4f8"><td class="memTemplParams" colspan="2"><a id="ac2100a88968278367e26c4eb2099b4f8"></a>
template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:ac2100a88968278367e26c4eb2099b4f8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_is_equal</b> (const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;actual, const U &amp;expected, bool expect_equal)</td></tr>
<tr class="separator:ac2100a88968278367e26c4eb2099b4f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d79d82f1c6e55567791cd5c5304bc0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a10d79d82f1c6e55567791cd5c5304bc0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a10d79d82f1c6e55567791cd5c5304bc0">isNotNaN</a> (const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;x)</td></tr>
<tr class="separator:a10d79d82f1c6e55567791cd5c5304bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d65958858e32e62aeba1e4455a5737"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab8d65958858e32e62aeba1e4455a5737"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ab8d65958858e32e62aeba1e4455a5737">isPlusInf</a> (const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;x)</td></tr>
<tr class="separator:ab8d65958858e32e62aeba1e4455a5737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e4b5699212c361ff6818d5badb9e71"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a73e4b5699212c361ff6818d5badb9e71"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a73e4b5699212c361ff6818d5badb9e71">isMinusInf</a> (const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;x)</td></tr>
<tr class="separator:a73e4b5699212c361ff6818d5badb9e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d9a7ddcee5c7c8defaba3628455efb2"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a0d9a7ddcee5c7c8defaba3628455efb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a0d9a7ddcee5c7c8defaba3628455efb2">createRandomPIMatrixOfRank</a> (<a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> desired_rank, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> rows, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cols, MatrixType &amp;m)</td></tr>
<tr class="separator:a0d9a7ddcee5c7c8defaba3628455efb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9489ae63302dfd33d4560c5377ead43f"><td class="memTemplParams" colspan="2">template&lt;typename PermutationVectorType &gt; </td></tr>
<tr class="memitem:a9489ae63302dfd33d4560c5377ead43f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a9489ae63302dfd33d4560c5377ead43f">randomPermutationVector</a> (PermutationVectorType &amp;v, <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> size)</td></tr>
<tr class="separator:a9489ae63302dfd33d4560c5377ead43f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33a0d76d99d352dd36cf73987d8eca7"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:ac33a0d76d99d352dd36cf73987d8eca7"><td class="memTemplItemLeft" align="right" valign="top">MatrixType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ac33a0d76d99d352dd36cf73987d8eca7">generateRandomUnitaryMatrix</a> (const <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> dim)</td></tr>
<tr class="separator:ac33a0d76d99d352dd36cf73987d8eca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9581b8fef58e77009b9c07137d8fa4d"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename RealScalarVectorType &gt; </td></tr>
<tr class="memitem:af9581b8fef58e77009b9c07137d8fa4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#af9581b8fef58e77009b9c07137d8fa4d">generateRandomMatrixSvs</a> (const RealScalarVectorType &amp;svs, const <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> rows, const <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> cols, MatrixType &amp;<a class="el" href="class_eigen_1_1_matrix.html">M</a>)</td></tr>
<tr class="separator:af9581b8fef58e77009b9c07137d8fa4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e897919aefe17f42d3e08a3670d6e7d"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename RealScalar &gt; </td></tr>
<tr class="memitem:a9e897919aefe17f42d3e08a3670d6e7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_vector_type.html">VectorType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a9e897919aefe17f42d3e08a3670d6e7d">setupRandomSvs</a> (const <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> dim, const RealScalar max)</td></tr>
<tr class="separator:a9e897919aefe17f42d3e08a3670d6e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6d3938c26e96ae1837bfcacda0cd77"><td class="memTemplParams" colspan="2">template&lt;typename VectorType , typename RealScalar &gt; </td></tr>
<tr class="memitem:aeb6d3938c26e96ae1837bfcacda0cd77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_vector_type.html">VectorType</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#aeb6d3938c26e96ae1837bfcacda0cd77">setupRangeSvs</a> (const <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a> dim, const RealScalar min, const RealScalar max)</td></tr>
<tr class="separator:aeb6d3938c26e96ae1837bfcacda0cd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f0b9ea6097dc2e17a5aec9b02e63a5"><td class="memItemLeft" align="right" valign="top"><a id="a23f0b9ea6097dc2e17a5aec9b02e63a5"></a>
<a class="el" href="class_eigen_1_1_aligned_box.html">Box2d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>bounding_box</b> (const Vector2d &amp;v)</td></tr>
<tr class="separator:a23f0b9ea6097dc2e17a5aec9b02e63a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78030c0b948de8279c1cbc0b62cc202"><td class="memTemplParams" colspan="2"><a id="ac78030c0b948de8279c1cbc0b62cc202"></a>
template&lt;typename IndexType , int NumDims&gt; </td></tr>
<tr class="memitem:ac78030c0b948de8279c1cbc0b62cc202"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="struct_eigen_1_1_d_sizes.html">DSizes</a>&lt; IndexType, NumDims &gt; &amp;dims)</td></tr>
<tr class="separator:ac78030c0b948de8279c1cbc0b62cc202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcc94ba428bad798d2087b2bde597f7"><td class="memTemplParams" colspan="2"><a id="a0dcc94ba428bad798d2087b2bde597f7"></a>
template&lt;typename Dims1 , typename Dims2 &gt; </td></tr>
<tr class="memitem:a0dcc94ba428bad798d2087b2bde597f7"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dimensions_match</b> (Dims1 dims1, Dims2 dims2)</td></tr>
<tr class="separator:a0dcc94ba428bad798d2087b2bde597f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd92b19390d0ec188412026668b6fb7"><td class="memTemplParams" colspan="2"><a id="a3bd92b19390d0ec188412026668b6fb7"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3bd92b19390d0ec188412026668b6fb7"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_triplet.html">T</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>constCast</b> (const <a class="el" href="class_eigen_1_1_triplet.html">T</a> *data)</td></tr>
<tr class="separator:a3bd92b19390d0ec188412026668b6fb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c9e316b709db929d87c9bc305492f0d"><td class="memTemplParams" colspan="2">template&lt;typename ADerived , typename BDerived , typename XDerived &gt; </td></tr>
<tr class="memitem:a4c9e316b709db929d87c9bc305492f0d"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_tensor_cwise_ternary_op.html">TensorCwiseTernaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__betainc__op.html">internal::scalar_betainc_op</a>&lt; typename XDerived::Scalar &gt;, const ADerived, const BDerived, const XDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a4c9e316b709db929d87c9bc305492f0d">betainc</a> (const ADerived &amp;a, const BDerived &amp;b, const XDerived &amp;x)</td></tr>
<tr class="separator:a4c9e316b709db929d87c9bc305492f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70d21d52e299cb0de9a71bb6c5f2905"><td class="memTemplParams" colspan="2"><a id="ad70d21d52e299cb0de9a71bb6c5f2905"></a>
template&lt;typename FirstType , typename... OtherTypes&gt; </td></tr>
<tr class="memitem:ad70d21d52e299cb0de9a71bb6c5f2905"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;os, const <a class="el" href="struct_eigen_1_1_index_list.html">IndexList</a>&lt; FirstType, OtherTypes... &gt; &amp;dims)</td></tr>
<tr class="separator:ad70d21d52e299cb0de9a71bb6c5f2905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bc015da71e13bbc09fee58a53728668"><td class="memTemplParams" colspan="2"><a id="a6bc015da71e13bbc09fee58a53728668"></a>
template&lt;typename FirstType , typename... OtherTypes&gt; </td></tr>
<tr class="memitem:a6bc015da71e13bbc09fee58a53728668"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_eigen_1_1_index_list.html">IndexList</a>&lt; FirstType, OtherTypes... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_index_list</b> (FirstType val1, OtherTypes... other_vals)</td></tr>
<tr class="separator:a6bc015da71e13bbc09fee58a53728668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8c32ea213b16f60b9763d28bba6c20"><td class="memTemplParams" colspan="2"><a id="a8e8c32ea213b16f60b9763d28bba6c20"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8e8c32ea213b16f60b9763d28bba6c20"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const <a class="el" href="class_eigen_1_1_tensor_base.html">TensorBase</a>&lt; <a class="el" href="class_eigen_1_1_triplet.html">T</a>, <a class="el" href="group__enums.html#gga9f93eac38eb83deb0e8dbd42ddf11d5da42865f87356ad7e585a1bfbfd1b81699">ReadOnlyAccessors</a> &gt; &amp;t)</td></tr>
<tr class="separator:a8e8c32ea213b16f60b9763d28bba6c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e435ff027b847c3eca6481acfe6089"><td class="memTemplParams" colspan="2"><a id="a76e435ff027b847c3eca6481acfe6089"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a76e435ff027b847c3eca6481acfe6089"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const EIGEN_ALWAYS_INLINE T1 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>choose</b> (<a class="el" href="struct_eigen_1_1_cond.html">Cond</a>&lt; true &gt;, const T1 &amp;first, const T2 &amp;)</td></tr>
<tr class="separator:a76e435ff027b847c3eca6481acfe6089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aa08da5ed1827089a547c3c50a8fb9d"><td class="memTemplParams" colspan="2"><a id="a4aa08da5ed1827089a547c3c50a8fb9d"></a>
template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a4aa08da5ed1827089a547c3c50a8fb9d"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC const EIGEN_ALWAYS_INLINE T2 &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>choose</b> (<a class="el" href="struct_eigen_1_1_cond.html">Cond</a>&lt; false &gt;, const T1 &amp;, const T2 &amp;second)</td></tr>
<tr class="separator:a4aa08da5ed1827089a547c3c50a8fb9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ec9832931270b80961236d30f6d2e3"><td class="memTemplParams" colspan="2"><a id="a13ec9832931270b80961236d30f6d2e3"></a>
template&lt;typename T , typename X , typename Y &gt; </td></tr>
<tr class="memitem:a13ec9832931270b80961236d30f6d2e3"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE <a class="el" href="class_eigen_1_1_triplet.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divup</b> (const X x, const Y y)</td></tr>
<tr class="separator:a13ec9832931270b80961236d30f6d2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa764c140980c11b0aa3b16f4fa5392f6"><td class="memTemplParams" colspan="2"><a id="aa764c140980c11b0aa3b16f4fa5392f6"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa764c140980c11b0aa3b16f4fa5392f6"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_DEVICE_FUNC EIGEN_ALWAYS_INLINE <a class="el" href="class_eigen_1_1_triplet.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>divup</b> (const <a class="el" href="class_eigen_1_1_triplet.html">T</a> x, const <a class="el" href="class_eigen_1_1_triplet.html">T</a> y)</td></tr>
<tr class="separator:aa764c140980c11b0aa3b16f4fa5392f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc5da1997ce23784fbd794f9eff7a181"><td class="memTemplParams" colspan="2"><a id="adc5da1997ce23784fbd794f9eff7a181"></a>
template&lt;typename U , typename V &gt; </td></tr>
<tr class="memitem:adc5da1997ce23784fbd794f9eff7a181"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_CONSTEXPR EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="struct_eigen_1_1_pair.html">Pair</a>&lt; U, V &gt; &amp;x, const <a class="el" href="struct_eigen_1_1_pair.html">Pair</a>&lt; U, V &gt; &amp;y)</td></tr>
<tr class="separator:adc5da1997ce23784fbd794f9eff7a181"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac777262ef7ee246cc13550d6b06200dc"><td class="memTemplParams" colspan="2"><a id="ac777262ef7ee246cc13550d6b06200dc"></a>
template&lt;typename U , typename V &gt; </td></tr>
<tr class="memitem:ac777262ef7ee246cc13550d6b06200dc"><td class="memTemplItemLeft" align="right" valign="top">EIGEN_CONSTEXPR EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator!=</b> (const <a class="el" href="struct_eigen_1_1_pair.html">Pair</a>&lt; U, V &gt; &amp;x, const <a class="el" href="struct_eigen_1_1_pair.html">Pair</a>&lt; U, V &gt; &amp;y)</td></tr>
<tr class="separator:ac777262ef7ee246cc13550d6b06200dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0955f67302586c01ba67c4fa11ec3f4"><td class="memTemplParams" colspan="2"><a id="aa0955f67302586c01ba67c4fa11ec3f4"></a>
template&lt;typename NewDerType &gt; </td></tr>
<tr class="memitem:aa0955f67302586c01ba67c4fa11ec3f4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; NewDerType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>MakeAutoDiffScalar</b> (const typename NewDerType::Scalar &amp;value, const NewDerType &amp;der)</td></tr>
<tr class="separator:aa0955f67302586c01ba67c4fa11ec3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a065d353fcbff30a8e902d2900a784d45"><td class="memTemplParams" colspan="2"><a id="a065d353fcbff30a8e902d2900a784d45"></a>
template&lt;typename DerType &gt; </td></tr>
<tr class="memitem:a065d353fcbff30a8e902d2900a784d45"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>conj</b> (const <a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;x)</td></tr>
<tr class="separator:a065d353fcbff30a8e902d2900a784d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71b5974e117d989a4e79f54ba65f460"><td class="memTemplParams" colspan="2"><a id="aa71b5974e117d989a4e79f54ba65f460"></a>
template&lt;typename DerType &gt; </td></tr>
<tr class="memitem:aa71b5974e117d989a4e79f54ba65f460"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>real</b> (const <a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;x)</td></tr>
<tr class="separator:aa71b5974e117d989a4e79f54ba65f460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524f2d0ae40cbbb4f55ea073c98a1c43"><td class="memTemplParams" colspan="2"><a id="a524f2d0ae40cbbb4f55ea073c98a1c43"></a>
template&lt;typename DerType &gt; </td></tr>
<tr class="memitem:a524f2d0ae40cbbb4f55ea073c98a1c43"><td class="memTemplItemLeft" align="right" valign="top">DerType::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><b>imag</b> (const <a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;)</td></tr>
<tr class="separator:a524f2d0ae40cbbb4f55ea073c98a1c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f0b53a2a0242270bc40539a2155e9d"><td class="memTemplParams" colspan="2"><a id="a63f0b53a2a0242270bc40539a2155e9d"></a>
template&lt;typename DerType , typename T &gt; </td></tr>
<tr class="memitem:a63f0b53a2a0242270bc40539a2155e9d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_cleaned_up_der_type.html">CleanedUpDerType</a>&lt; DerType &gt;::type()&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;x, const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;y)</td></tr>
<tr class="separator:a63f0b53a2a0242270bc40539a2155e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6505ea5284366809c5807fbac8ba104a"><td class="memTemplParams" colspan="2"><a id="a6505ea5284366809c5807fbac8ba104a"></a>
template&lt;typename DerType , typename T &gt; </td></tr>
<tr class="memitem:a6505ea5284366809c5807fbac8ba104a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_cleaned_up_der_type.html">CleanedUpDerType</a>&lt; DerType &gt;::type()&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;x, const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;y)</td></tr>
<tr class="separator:a6505ea5284366809c5807fbac8ba104a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6123699edc0fb07af5ff53982024080"><td class="memTemplParams" colspan="2"><a id="ac6123699edc0fb07af5ff53982024080"></a>
template&lt;typename DerType , typename T &gt; </td></tr>
<tr class="memitem:ac6123699edc0fb07af5ff53982024080"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_cleaned_up_der_type.html">CleanedUpDerType</a>&lt; DerType &gt;::type()&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;x, const <a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;y)</td></tr>
<tr class="separator:ac6123699edc0fb07af5ff53982024080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4c1761cdd094562e58a37b0e6ec8bf8"><td class="memTemplParams" colspan="2"><a id="af4c1761cdd094562e58a37b0e6ec8bf8"></a>
template&lt;typename DerType , typename T &gt; </td></tr>
<tr class="memitem:af4c1761cdd094562e58a37b0e6ec8bf8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_cleaned_up_der_type.html">CleanedUpDerType</a>&lt; DerType &gt;::type()&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;x, const <a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;y)</td></tr>
<tr class="separator:af4c1761cdd094562e58a37b0e6ec8bf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0e37099bfc46c33aa928944f0a7803"><td class="memTemplParams" colspan="2"><a id="afc0e37099bfc46c33aa928944f0a7803"></a>
template&lt;typename DerType &gt; </td></tr>
<tr class="memitem:afc0e37099bfc46c33aa928944f0a7803"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_cleaned_up_der_type.html">CleanedUpDerType</a>&lt; DerType &gt;::type()&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min</b> (const <a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;x, const <a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;y)</td></tr>
<tr class="separator:afc0e37099bfc46c33aa928944f0a7803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac545ec4079d79006468d5f0dc42de0b8"><td class="memTemplParams" colspan="2"><a id="ac545ec4079d79006468d5f0dc42de0b8"></a>
template&lt;typename DerType &gt; </td></tr>
<tr class="memitem:ac545ec4079d79006468d5f0dc42de0b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_cleaned_up_der_type.html">CleanedUpDerType</a>&lt; DerType &gt;::type()&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max</b> (const <a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;x, const <a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; DerType &gt; &amp;y)</td></tr>
<tr class="separator:ac545ec4079d79006468d5f0dc42de0b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade972f79dcb91f919a4a9939178e1024"><td class="memItemLeft" align="right" valign="top"><a id="ade972f79dcb91f919a4a9939178e1024"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY</b> (abs, using std::abs;return Eigen::MakeAutoDiffScalar(abs(x.value()), x.derivatives() *(x.value()&lt; 0 ? -1 :1));) EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY(abs2</td></tr>
<tr class="separator:ade972f79dcb91f919a4a9939178e1024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14347a3d067977f2be8b1c258706ecb"><td class="memItemLeft" align="right" valign="top"><a id="ac14347a3d067977f2be8b1c258706ecb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY</b> (sqrt, using std::sqrt;Scalar sqrtx=sqrt(x.value());return Eigen::MakeAutoDiffScalar(sqrtx, x.derivatives() *(Scalar(0.5)/sqrtx));) EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY(cos</td></tr>
<tr class="separator:ac14347a3d067977f2be8b1c258706ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fe7d2b9e95853eb56a075380661309"><td class="memItemLeft" align="right" valign="top"><a id="a76fe7d2b9e95853eb56a075380661309"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY</b> (sin, using std::sin;using std::cos;return Eigen::MakeAutoDiffScalar(sin(x.value()), x.derivatives() *cos(x.value()));) EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY(exp</td></tr>
<tr class="separator:a76fe7d2b9e95853eb56a075380661309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b46115e280b27e7f5ed4c933d89553"><td class="memItemLeft" align="right" valign="top"><a id="a22b46115e280b27e7f5ed4c933d89553"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY</b> (<a class="el" href="structlog.html">log</a>, using std::log;return Eigen::MakeAutoDiffScalar(<a class="el" href="structlog.html">log</a>(x.value()), x.derivatives() *(Scalar(1)/x.value()));) template&lt; typename DerType &gt; inline Eigen</td></tr>
<tr class="separator:a22b46115e280b27e7f5ed4c933d89553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae280aca1e1da255751995a2e655e6ac4"><td class="memTemplParams" colspan="2"><a id="ae280aca1e1da255751995a2e655e6ac4"></a>
template&lt;typename DerTypeA , typename DerTypeB &gt; </td></tr>
<tr class="memitem:ae280aca1e1da255751995a2e655e6ac4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; typename <a class="el" href="struct_eigen_1_1internal_1_1traits.html">internal::traits</a>&lt; internal::remove_all_t&lt; DerTypeA &gt; &gt;::Scalar, <a class="el" href="namespace_eigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a>, 1 &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>atan2</b> (const <a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; DerTypeA &gt; &amp;a, const <a class="el" href="class_eigen_1_1_auto_diff_scalar.html">AutoDiffScalar</a>&lt; DerTypeB &gt; &amp;b)</td></tr>
<tr class="separator:ae280aca1e1da255751995a2e655e6ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212ff33d56ffe0384059b78e7e8a8142"><td class="memItemLeft" align="right" valign="top"><a id="a212ff33d56ffe0384059b78e7e8a8142"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY</b> (tan, using std::tan;using std::cos;return Eigen::MakeAutoDiffScalar(tan(x.value()), x.derivatives() *(Scalar(1)/numext::abs2(cos(x.value()))));) EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY(asin</td></tr>
<tr class="separator:a212ff33d56ffe0384059b78e7e8a8142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af291629130d7e1494b0c17b7413f86"><td class="memItemLeft" align="right" valign="top"><a id="a3af291629130d7e1494b0c17b7413f86"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY</b> (acos, using std::sqrt;using std::acos;return Eigen::MakeAutoDiffScalar(acos(x.value()), x.derivatives() *(Scalar(-1)/sqrt(1-numext::abs2(x.value()))));) EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY(tanh</td></tr>
<tr class="separator:a3af291629130d7e1494b0c17b7413f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e5dd85fa549b012df73af4865f9b93"><td class="memItemLeft" align="right" valign="top"><a id="a77e5dd85fa549b012df73af4865f9b93"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY</b> (sinh, using std::sinh;using std::cosh;return Eigen::MakeAutoDiffScalar(sinh(x.value()), x.derivatives() *cosh(x.value()));) EIGEN_AUTODIFF_DECLARE_GLOBAL_UNARY(cosh</td></tr>
<tr class="separator:a77e5dd85fa549b012df73af4865f9b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d8e283f082c972338f3fc4f644b2a9"><td class="memTemplParams" colspan="2">template&lt;typename BVH , typename Intersector &gt; </td></tr>
<tr class="memitem:a07d8e283f082c972338f3fc4f644b2a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a07d8e283f082c972338f3fc4f644b2a9">BVIntersect</a> (const BVH &amp;tree, Intersector &amp;intersector)</td></tr>
<tr class="separator:a07d8e283f082c972338f3fc4f644b2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b8047a3ee05b5e6fec4668197a9a43"><td class="memTemplParams" colspan="2">template&lt;typename BVH1 , typename BVH2 , typename Intersector &gt; </td></tr>
<tr class="memitem:ac3b8047a3ee05b5e6fec4668197a9a43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ac3b8047a3ee05b5e6fec4668197a9a43">BVIntersect</a> (const BVH1 &amp;tree1, const BVH2 &amp;tree2, Intersector &amp;intersector)</td></tr>
<tr class="separator:ac3b8047a3ee05b5e6fec4668197a9a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcbe73ac1482eacab0e18ee32c25508e"><td class="memTemplParams" colspan="2">template&lt;typename BVH , typename Minimizer &gt; </td></tr>
<tr class="memitem:adcbe73ac1482eacab0e18ee32c25508e"><td class="memTemplItemLeft" align="right" valign="top">Minimizer::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#adcbe73ac1482eacab0e18ee32c25508e">BVMinimize</a> (const BVH &amp;tree, Minimizer &amp;minimizer)</td></tr>
<tr class="separator:adcbe73ac1482eacab0e18ee32c25508e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915f6adc8b195c94a83c35de6a842556"><td class="memTemplParams" colspan="2">template&lt;typename BVH1 , typename BVH2 , typename Minimizer &gt; </td></tr>
<tr class="memitem:a915f6adc8b195c94a83c35de6a842556"><td class="memTemplItemLeft" align="right" valign="top">Minimizer::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a915f6adc8b195c94a83c35de6a842556">BVMinimize</a> (const BVH1 &amp;tree1, const BVH2 &amp;tree2, Minimizer &amp;minimizer)</td></tr>
<tr class="separator:a915f6adc8b195c94a83c35de6a842556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d064ade25b61d1a15aafd2b0804451"><td class="memItemLeft" align="right" valign="top"><a id="ac5d064ade25b61d1a15aafd2b0804451"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>ssaupd_</b> (int *ido, char *bmat, int *n, char *which, int *nev, float *tol, float *resid, int *ncv, float *v, int *ldv, int *iparam, int *ipntr, float *workd, float *workl, int *lworkl, int *info)</td></tr>
<tr class="separator:ac5d064ade25b61d1a15aafd2b0804451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6ec6afef01b98490d99ba2c9d1227a"><td class="memItemLeft" align="right" valign="top"><a id="a7b6ec6afef01b98490d99ba2c9d1227a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>sseupd_</b> (int *rvec, char *All, int *select, float *d, float *z, int *ldz, float *sigma, char *bmat, int *n, char *which, int *nev, float *tol, float *resid, int *ncv, float *v, int *ldv, int *iparam, int *ipntr, float *workd, float *workl, int *lworkl, int *ierr)</td></tr>
<tr class="separator:a7b6ec6afef01b98490d99ba2c9d1227a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4bd56e53bf25dde37e3bc96708cd6c1"><td class="memItemLeft" align="right" valign="top"><a id="af4bd56e53bf25dde37e3bc96708cd6c1"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dsaupd_</b> (int *ido, char *bmat, int *n, char *which, int *nev, double *tol, double *resid, int *ncv, double *v, int *ldv, int *iparam, int *ipntr, double *workd, double *workl, int *lworkl, int *info)</td></tr>
<tr class="separator:af4bd56e53bf25dde37e3bc96708cd6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105b4c128a890804f76ed956b9d5bed3"><td class="memItemLeft" align="right" valign="top"><a id="a105b4c128a890804f76ed956b9d5bed3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>dseupd_</b> (int *rvec, char *All, int *select, double *d, double *z, int *ldz, double *sigma, char *bmat, int *n, char *which, int *nev, double *tol, double *resid, int *ncv, double *v, int *ldv, int *iparam, int *ipntr, double *workd, double *workl, int *lworkl, int *ierr)</td></tr>
<tr class="separator:a105b4c128a890804f76ed956b9d5bed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd4b7cd1e324ed0769cac2701f4d050"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:aedd4b7cd1e324ed0769cac2701f4d050"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_kronecker_product.html">KroneckerProduct</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">A</a>, <a class="el" href="class_eigen_1_1_matrix.html">B</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#aedd4b7cd1e324ed0769cac2701f4d050">kroneckerProduct</a> (const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">A</a> &gt; &amp;a, const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">B</a> &gt; &amp;b)</td></tr>
<tr class="separator:aedd4b7cd1e324ed0769cac2701f4d050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6cd3acfea39bcff3fa38e0de1226f5"><td class="memTemplParams" colspan="2">template&lt;typename A , typename B &gt; </td></tr>
<tr class="memitem:a4e6cd3acfea39bcff3fa38e0de1226f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_kronecker_product_sparse.html">KroneckerProductSparse</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">A</a>, <a class="el" href="class_eigen_1_1_matrix.html">B</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a4e6cd3acfea39bcff3fa38e0de1226f5">kroneckerProduct</a> (const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">A</a> &gt; &amp;a, const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">B</a> &gt; &amp;b)</td></tr>
<tr class="separator:a4e6cd3acfea39bcff3fa38e0de1226f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f490197e16df831683018e383e29346"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:a2f490197e16df831683018e383e29346"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a2f490197e16df831683018e383e29346">matrix_sqrt_quasi_triangular</a> (const MatrixType &amp;arg, ResultType &amp;result)</td></tr>
<tr class="memdesc:a2f490197e16df831683018e383e29346"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix square root of quasi-triangular matrix.  <a href="namespace_eigen.html#a2f490197e16df831683018e383e29346">More...</a><br /></td></tr>
<tr class="separator:a2f490197e16df831683018e383e29346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51c91f920f6ea4a7f6f72caa1e8249f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename ResultType &gt; </td></tr>
<tr class="memitem:ae51c91f920f6ea4a7f6f72caa1e8249f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ae51c91f920f6ea4a7f6f72caa1e8249f">matrix_sqrt_triangular</a> (const MatrixType &amp;arg, ResultType &amp;result)</td></tr>
<tr class="memdesc:ae51c91f920f6ea4a7f6f72caa1e8249f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute matrix square root of triangular matrix.  <a href="namespace_eigen.html#ae51c91f920f6ea4a7f6f72caa1e8249f">More...</a><br /></td></tr>
<tr class="separator:ae51c91f920f6ea4a7f6f72caa1e8249f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadbf059bc28ce1cf94c57c1454633d40"><td class="memTemplParams" colspan="2">template&lt;typename Polynomials , typename T &gt; </td></tr>
<tr class="memitem:aadbf059bc28ce1cf94c57c1454633d40"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_triplet.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#aadbf059bc28ce1cf94c57c1454633d40">poly_eval_horner</a> (const Polynomials &amp;poly, const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;x)</td></tr>
<tr class="separator:aadbf059bc28ce1cf94c57c1454633d40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb64ffddaa9e83634e3ab0e3fd3664f5"><td class="memTemplParams" colspan="2">template&lt;typename Polynomials , typename T &gt; </td></tr>
<tr class="memitem:adb64ffddaa9e83634e3ab0e3fd3664f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_triplet.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#adb64ffddaa9e83634e3ab0e3fd3664f5">poly_eval</a> (const Polynomials &amp;poly, const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;x)</td></tr>
<tr class="separator:adb64ffddaa9e83634e3ab0e3fd3664f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90ec4513aa09bb8ad54daa209322d03"><td class="memTemplParams" colspan="2">template&lt;typename Polynomial &gt; </td></tr>
<tr class="memitem:ac90ec4513aa09bb8ad54daa209322d03"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; typename Polynomial::Scalar &gt;::Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ac90ec4513aa09bb8ad54daa209322d03">cauchy_max_bound</a> (const Polynomial &amp;poly)</td></tr>
<tr class="separator:ac90ec4513aa09bb8ad54daa209322d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f0af310d5cc131eb5e806f241af951"><td class="memTemplParams" colspan="2">template&lt;typename Polynomial &gt; </td></tr>
<tr class="memitem:a43f0af310d5cc131eb5e806f241af951"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; typename Polynomial::Scalar &gt;::Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a43f0af310d5cc131eb5e806f241af951">cauchy_min_bound</a> (const Polynomial &amp;poly)</td></tr>
<tr class="separator:a43f0af310d5cc131eb5e806f241af951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc3648f7ef67db3d5d04454fc1257fd"><td class="memTemplParams" colspan="2">template&lt;typename RootVector , typename Polynomial &gt; </td></tr>
<tr class="memitem:afbc3648f7ef67db3d5d04454fc1257fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#afbc3648f7ef67db3d5d04454fc1257fd">roots_to_monicPolynomial</a> (const RootVector &amp;rv, Polynomial &amp;poly)</td></tr>
<tr class="separator:afbc3648f7ef67db3d5d04454fc1257fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b82b077ca4d3780012b2f837bb23ee0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a5b82b077ca4d3780012b2f837bb23ee0">getMarketHeader</a> (const std::string &amp;filename, int &amp;sym, bool &amp;iscomplex, bool &amp;isdense)</td></tr>
<tr class="memdesc:a5b82b077ca4d3780012b2f837bb23ee0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the header of a matrixmarket file and determines the properties of a matrix.  <a href="namespace_eigen.html#a5b82b077ca4d3780012b2f837bb23ee0">More...</a><br /></td></tr>
<tr class="separator:a5b82b077ca4d3780012b2f837bb23ee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35610696b22ae58bdd51d96468956455"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType &gt; </td></tr>
<tr class="memitem:a35610696b22ae58bdd51d96468956455"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a35610696b22ae58bdd51d96468956455">loadMarket</a> (SparseMatrixType &amp;mat, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a35610696b22ae58bdd51d96468956455"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a sparse matrix from a matrixmarket format file.  <a href="namespace_eigen.html#a35610696b22ae58bdd51d96468956455">More...</a><br /></td></tr>
<tr class="separator:a35610696b22ae58bdd51d96468956455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3d7dbb905149f63fa179898018ca57"><td class="memTemplParams" colspan="2">template&lt;typename DenseType &gt; </td></tr>
<tr class="memitem:abe3d7dbb905149f63fa179898018ca57"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#abe3d7dbb905149f63fa179898018ca57">loadMarketDense</a> (DenseType &amp;mat, const std::string &amp;filename)</td></tr>
<tr class="memdesc:abe3d7dbb905149f63fa179898018ca57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads a dense <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> or Vector from a matrixmarket file. If a statically sized matrix has to be parsed and the file contains the wrong dimensions it is undefined behaviour.  <a href="namespace_eigen.html#abe3d7dbb905149f63fa179898018ca57">More...</a><br /></td></tr>
<tr class="separator:abe3d7dbb905149f63fa179898018ca57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b97a7af6c8af0fa0455723203b24853"><td class="memTemplParams" colspan="2"><a id="a0b97a7af6c8af0fa0455723203b24853"></a>
template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a0b97a7af6c8af0fa0455723203b24853"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a0b97a7af6c8af0fa0455723203b24853">loadMarketVector</a> (<a class="el" href="struct_vector_type.html">VectorType</a> &amp;vec, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a0b97a7af6c8af0fa0455723203b24853"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same functionality as loadMarketDense, deprecated. <br /></td></tr>
<tr class="separator:a0b97a7af6c8af0fa0455723203b24853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d673f7e2dfee413dec4395a6a40f46"><td class="memTemplParams" colspan="2">template&lt;typename SparseMatrixType &gt; </td></tr>
<tr class="memitem:a33d673f7e2dfee413dec4395a6a40f46"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a33d673f7e2dfee413dec4395a6a40f46">saveMarket</a> (const SparseMatrixType &amp;mat, const std::string &amp;filename, int sym=0)</td></tr>
<tr class="memdesc:a33d673f7e2dfee413dec4395a6a40f46"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes a sparse <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> to a marketmarket format file  <a href="namespace_eigen.html#a33d673f7e2dfee413dec4395a6a40f46">More...</a><br /></td></tr>
<tr class="separator:a33d673f7e2dfee413dec4395a6a40f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbbd2f4dd378bd63e67163e907e5861"><td class="memTemplParams" colspan="2">template&lt;typename DenseType &gt; </td></tr>
<tr class="memitem:acdbbd2f4dd378bd63e67163e907e5861"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#acdbbd2f4dd378bd63e67163e907e5861">saveMarketDense</a> (const DenseType &amp;mat, const std::string &amp;filename)</td></tr>
<tr class="memdesc:acdbbd2f4dd378bd63e67163e907e5861"><td class="mdescLeft">&#160;</td><td class="mdescRight">writes a dense <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> or vector to a marketmarket format file  <a href="namespace_eigen.html#acdbbd2f4dd378bd63e67163e907e5861">More...</a><br /></td></tr>
<tr class="separator:acdbbd2f4dd378bd63e67163e907e5861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43fb1aaef616814a2c030a7986ed0afd"><td class="memTemplParams" colspan="2"><a id="a43fb1aaef616814a2c030a7986ed0afd"></a>
template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a43fb1aaef616814a2c030a7986ed0afd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a43fb1aaef616814a2c030a7986ed0afd">saveMarketVector</a> (const <a class="el" href="struct_vector_type.html">VectorType</a> &amp;vec, const std::string &amp;filename)</td></tr>
<tr class="memdesc:a43fb1aaef616814a2c030a7986ed0afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same functionality as saveMarketDense, deprecated. <br /></td></tr>
<tr class="separator:a43fb1aaef616814a2c030a7986ed0afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae29347f850e265d2d33164b3387ba360"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename OtherDerived &gt; </td></tr>
<tr class="memitem:ae29347f850e265d2d33164b3387ba360"><td class="memTemplItemLeft" align="right" valign="top">Derived::Scalar&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ae29347f850e265d2d33164b3387ba360">accurateDot</a> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; Derived &gt; &amp;<a class="el" href="class_eigen_1_1_matrix.html">A</a>, const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;other)</td></tr>
<tr class="memdesc:ae29347f850e265d2d33164b3387ba360"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes an accurate dot product on two sparse vectors  <a href="namespace_eigen.html#ae29347f850e265d2d33164b3387ba360">More...</a><br /></td></tr>
<tr class="separator:ae29347f850e265d2d33164b3387ba360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf5abdb29bfceb4625e62e35c830ce4"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:afdf5abdb29bfceb4625e62e35c830ce4"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__i0__op.html">Eigen::internal::scalar_bessel_i0_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#afdf5abdb29bfceb4625e62e35c830ce4">bessel_i0</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:afdf5abdb29bfceb4625e62e35c830ce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e6995d520140092109482a34c21cac"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ae5e6995d520140092109482a34c21cac"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__i0e__op.html">Eigen::internal::scalar_bessel_i0e_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ae5e6995d520140092109482a34c21cac">bessel_i0e</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:ae5e6995d520140092109482a34c21cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739801b7e406af9db51b7524292d87bd"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a739801b7e406af9db51b7524292d87bd"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__i1__op.html">Eigen::internal::scalar_bessel_i1_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a739801b7e406af9db51b7524292d87bd">bessel_i1</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:a739801b7e406af9db51b7524292d87bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f089b726e804a9fe0a9b07604aa44b"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a99f089b726e804a9fe0a9b07604aa44b"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__i1e__op.html">Eigen::internal::scalar_bessel_i1e_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a99f089b726e804a9fe0a9b07604aa44b">bessel_i1e</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:a99f089b726e804a9fe0a9b07604aa44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d807b7d6e0e137d91e42683bdc32ffe"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a6d807b7d6e0e137d91e42683bdc32ffe"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__k0__op.html">Eigen::internal::scalar_bessel_k0_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a6d807b7d6e0e137d91e42683bdc32ffe">bessel_k0</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:a6d807b7d6e0e137d91e42683bdc32ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd9ad1d608e8e6804428a26294cd3e5"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a1bd9ad1d608e8e6804428a26294cd3e5"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__k0e__op.html">Eigen::internal::scalar_bessel_k0e_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a1bd9ad1d608e8e6804428a26294cd3e5">bessel_k0e</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:a1bd9ad1d608e8e6804428a26294cd3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98c1366128b96bfd9229cbcebbfbf79"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ab98c1366128b96bfd9229cbcebbfbf79"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__k1__op.html">Eigen::internal::scalar_bessel_k1_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ab98c1366128b96bfd9229cbcebbfbf79">bessel_k1</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:ab98c1366128b96bfd9229cbcebbfbf79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4966f237f5f8d96749f5bf654cac93a3"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a4966f237f5f8d96749f5bf654cac93a3"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__k1e__op.html">Eigen::internal::scalar_bessel_k1e_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a4966f237f5f8d96749f5bf654cac93a3">bessel_k1e</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:a4966f237f5f8d96749f5bf654cac93a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45c6fd1eec3bd5c189d769691ecb725"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:ad45c6fd1eec3bd5c189d769691ecb725"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__j0__op.html">Eigen::internal::scalar_bessel_j0_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ad45c6fd1eec3bd5c189d769691ecb725">bessel_j0</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:ad45c6fd1eec3bd5c189d769691ecb725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89585d60cbc04388a01342c9a36aca37"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a89585d60cbc04388a01342c9a36aca37"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__y0__op.html">Eigen::internal::scalar_bessel_y0_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a89585d60cbc04388a01342c9a36aca37">bessel_y0</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:a89585d60cbc04388a01342c9a36aca37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0419635e1e0bfb31db3b219fc2a03c9f"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a0419635e1e0bfb31db3b219fc2a03c9f"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__j1__op.html">Eigen::internal::scalar_bessel_j1_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a0419635e1e0bfb31db3b219fc2a03c9f">bessel_j1</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:a0419635e1e0bfb31db3b219fc2a03c9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c2c4efe0449c569a8b382febe4d1917"><td class="memTemplParams" colspan="2">template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a8c2c4efe0449c569a8b382febe4d1917"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__y1__op.html">Eigen::internal::scalar_bessel_y1_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a8c2c4efe0449c569a8b382febe4d1917">bessel_y1</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;x)</td></tr>
<tr class="separator:a8c2c4efe0449c569a8b382febe4d1917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3212ea95bc2fc39a6d1187c3fdf1b1f"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ExponentDerived &gt; </td></tr>
<tr class="memitem:af3212ea95bc2fc39a6d1187c3fdf1b1f"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">Eigen::CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__igamma__op.html">Eigen::internal::scalar_igamma_op</a>&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#af3212ea95bc2fc39a6d1187c3fdf1b1f">igamma</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;a, const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;x)</td></tr>
<tr class="separator:af3212ea95bc2fc39a6d1187c3fdf1b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae727e78322e10905ef1a4a01d8e43c8a"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ExponentDerived &gt; </td></tr>
<tr class="memitem:ae727e78322e10905ef1a4a01d8e43c8a"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">Eigen::CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__igamma__der__a__op.html">Eigen::internal::scalar_igamma_der_a_op</a>&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ae727e78322e10905ef1a4a01d8e43c8a">igamma_der_a</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;a, const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;x)</td></tr>
<tr class="separator:ae727e78322e10905ef1a4a01d8e43c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dc86a879904499f4f34a471b569f286"><td class="memTemplParams" colspan="2">template&lt;typename AlphaDerived , typename SampleDerived &gt; </td></tr>
<tr class="memitem:a7dc86a879904499f4f34a471b569f286"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">Eigen::CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__gamma__sample__der__alpha__op.html">Eigen::internal::scalar_gamma_sample_der_alpha_op</a>&lt; typename AlphaDerived::Scalar &gt;, const AlphaDerived, const SampleDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a7dc86a879904499f4f34a471b569f286">gamma_sample_der_alpha</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; AlphaDerived &gt; &amp;alpha, const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; SampleDerived &gt; &amp;sample)</td></tr>
<tr class="separator:a7dc86a879904499f4f34a471b569f286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4edbf3cd0946ca34f217fb6c9b8d47cf"><td class="memTemplParams" colspan="2">template&lt;typename Derived , typename ExponentDerived &gt; </td></tr>
<tr class="memitem:a4edbf3cd0946ca34f217fb6c9b8d47cf"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">Eigen::CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__igammac__op.html">Eigen::internal::scalar_igammac_op</a>&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a4edbf3cd0946ca34f217fb6c9b8d47cf">igammac</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;a, const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;x)</td></tr>
<tr class="separator:a4edbf3cd0946ca34f217fb6c9b8d47cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d90365829589b236773f3dffd2b9e7"><td class="memTemplParams" colspan="2">template&lt;typename DerivedN , typename DerivedX &gt; </td></tr>
<tr class="memitem:a14d90365829589b236773f3dffd2b9e7"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">Eigen::CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__polygamma__op.html">Eigen::internal::scalar_polygamma_op</a>&lt; typename DerivedX::Scalar &gt;, const DerivedN, const DerivedX &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a14d90365829589b236773f3dffd2b9e7">polygamma</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; DerivedN &gt; &amp;n, const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp;x)</td></tr>
<tr class="separator:a14d90365829589b236773f3dffd2b9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a251a5c15e1eebb3f03633f4945c74"><td class="memTemplParams" colspan="2">template&lt;typename ArgADerived , typename ArgBDerived , typename ArgXDerived &gt; </td></tr>
<tr class="memitem:a21a251a5c15e1eebb3f03633f4945c74"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_ternary_op.html">Eigen::CwiseTernaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__betainc__op.html">Eigen::internal::scalar_betainc_op</a>&lt; typename ArgXDerived::Scalar &gt;, const ArgADerived, const ArgBDerived, const ArgXDerived &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a21a251a5c15e1eebb3f03633f4945c74">betainc</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; ArgADerived &gt; &amp;a, const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; ArgBDerived &gt; &amp;b, const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; ArgXDerived &gt; &amp;x)</td></tr>
<tr class="separator:a21a251a5c15e1eebb3f03633f4945c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2072d7b2bb8a3d5fa972dc364d973426"><td class="memTemplParams" colspan="2">template&lt;typename DerivedX , typename DerivedQ &gt; </td></tr>
<tr class="memitem:a2072d7b2bb8a3d5fa972dc364d973426"><td class="memTemplItemLeft" align="right" valign="top">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">Eigen::CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__zeta__op.html">Eigen::internal::scalar_zeta_op</a>&lt; typename DerivedX::Scalar &gt;, const DerivedX, const DerivedQ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a2072d7b2bb8a3d5fa972dc364d973426">zeta</a> (const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp;x, const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; DerivedQ &gt; &amp;q)</td></tr>
<tr class="separator:a2072d7b2bb8a3d5fa972dc364d973426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ed4b8aebde67ffb90eafe2d29dd969"><td class="memTemplParams" colspan="2"><a id="ae8ed4b8aebde67ffb90eafe2d29dd969"></a>
template&lt;typename SplineType , typename DerivativeType &gt; </td></tr>
<tr class="memitem:ae8ed4b8aebde67ffb90eafe2d29dd969"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>derivativesImpl</b> (const SplineType &amp;spline, typename SplineType::Scalar u, DenseIndex order, DerivativeType &amp;der)</td></tr>
<tr class="separator:ae8ed4b8aebde67ffb90eafe2d29dd969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9474da5ed68bbd9a6788a999330416d6"><td class="memTemplParams" colspan="2">template&lt;typename KnotVectorType &gt; </td></tr>
<tr class="memitem:ga9474da5ed68bbd9a6788a999330416d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___splines___module.html#ga9474da5ed68bbd9a6788a999330416d6">KnotAveraging</a> (const KnotVectorType &amp;parameters, DenseIndex degree, KnotVectorType &amp;knots)</td></tr>
<tr class="memdesc:ga9474da5ed68bbd9a6788a999330416d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes knot averages.  <a href="group___splines___module.html#ga9474da5ed68bbd9a6788a999330416d6">More...</a><br /></td></tr>
<tr class="separator:ga9474da5ed68bbd9a6788a999330416d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae10a6f9b6ab7fb400a2526b6382c533b"><td class="memTemplParams" colspan="2">template&lt;typename KnotVectorType , typename ParameterVectorType , typename IndexArray &gt; </td></tr>
<tr class="memitem:gae10a6f9b6ab7fb400a2526b6382c533b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___splines___module.html#gae10a6f9b6ab7fb400a2526b6382c533b">KnotAveragingWithDerivatives</a> (const ParameterVectorType &amp;parameters, const unsigned int degree, const IndexArray &amp;derivativeIndices, KnotVectorType &amp;knots)</td></tr>
<tr class="memdesc:gae10a6f9b6ab7fb400a2526b6382c533b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes knot averages when derivative constraints are present. Note that this is a technical interpretation of the referenced article since the algorithm contained therein is incorrect as written.  <a href="group___splines___module.html#gae10a6f9b6ab7fb400a2526b6382c533b">More...</a><br /></td></tr>
<tr class="separator:gae10a6f9b6ab7fb400a2526b6382c533b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b4cbde5d98411405871accf877552d2"><td class="memTemplParams" colspan="2">template&lt;typename PointArrayType , typename KnotVectorType &gt; </td></tr>
<tr class="memitem:ga1b4cbde5d98411405871accf877552d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___splines___module.html#ga1b4cbde5d98411405871accf877552d2">ChordLengths</a> (const PointArrayType &amp;pts, KnotVectorType &amp;chord_lengths)</td></tr>
<tr class="memdesc:ga1b4cbde5d98411405871accf877552d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes chord length parameters which are required for spline interpolation.  <a href="group___splines___module.html#ga1b4cbde5d98411405871accf877552d2">More...</a><br /></td></tr>
<tr class="separator:ga1b4cbde5d98411405871accf877552d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e2db3496afe9750491c1f712e28dbc"><td class="memTemplParams" colspan="2"><a id="a32e2db3496afe9750491c1f712e28dbc"></a>
template&lt;typename T , typename Derived &gt; </td></tr>
<tr class="memitem:a32e2db3496afe9750491c1f712e28dbc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_triplet.html">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_relative_error</b> (const AlignedVector3&lt; <a class="el" href="class_eigen_1_1_triplet.html">T</a> &gt; &amp;a, const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt; &amp;b)</td></tr>
<tr class="separator:a32e2db3496afe9750491c1f712e28dbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e65cf6a0f2ac4f27b798ccd3f74adf"><td class="memTemplParams" colspan="2"><a id="af3e65cf6a0f2ac4f27b798ccd3f74adf"></a>
template&lt;typename Scalar , int Dim&gt; </td></tr>
<tr class="memitem:af3e65cf6a0f2ac4f27b798ccd3f74adf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_eigen_1_1_aligned_box.html">AlignedBox</a>&lt; Scalar, Dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>bounding_box</b> (const <a class="el" href="class_eigen_1_1_matrix.html">Matrix</a>&lt; Scalar, Dim, 1 &gt; &amp;v)</td></tr>
<tr class="separator:af3e65cf6a0f2ac4f27b798ccd3f74adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f70fbd13394695ead989ec3b659479"><td class="memTemplParams" colspan="2"><a id="a29f70fbd13394695ead989ec3b659479"></a>
template&lt;typename Derived &gt; </td></tr>
<tr class="memitem:a29f70fbd13394695ead989ec3b659479"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>operator&lt;&lt;</b> (std::ostream &amp;s, const <a class="el" href="class_eigen_1_1_diagonal_base.html">DiagonalBase</a>&lt; Derived &gt; &amp;m)</td></tr>
<tr class="separator:a29f70fbd13394695ead989ec3b659479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260fa9ebaf5eb2d6cbfc9f0bdb02386f"><td class="memTemplParams" colspan="2"><a id="a260fa9ebaf5eb2d6cbfc9f0bdb02386f"></a>
template&lt;typename Derived1 , typename Derived2 &gt; </td></tr>
<tr class="memitem:a260fa9ebaf5eb2d6cbfc9f0bdb02386f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>test_isCwiseApprox</b> (const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; Derived1 &gt; &amp;m1, const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; Derived2 &gt; &amp;m2, bool exact)</td></tr>
<tr class="separator:a260fa9ebaf5eb2d6cbfc9f0bdb02386f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aad94bff6c8d08a5edaf5a39694e5345e"><td class="memItemLeft" align="right" valign="top">const EIGEN_DEVICE_FUNC const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>exponents</b></td></tr>
<tr class="separator:aad94bff6c8d08a5edaf5a39694e5345e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81fa7195215a0ce30017dfac309f0b2"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#ad81fa7195215a0ce30017dfac309f0b2">Dynamic</a> = -1</td></tr>
<tr class="separator:ad81fa7195215a0ce30017dfac309f0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c597189a4a99127175e8167c456fff"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a73c597189a4a99127175e8167c456fff">DynamicIndex</a> = 0xffffff</td></tr>
<tr class="separator:a73c597189a4a99127175e8167c456fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06808a853a9baa38b23a5368e7491abd"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a06808a853a9baa38b23a5368e7491abd">UndefinedIncr</a> = 0xfffffe</td></tr>
<tr class="separator:a06808a853a9baa38b23a5368e7491abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7951593b031e13d90223c83d022ce99e"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a7951593b031e13d90223c83d022ce99e">Infinity</a> = -1</td></tr>
<tr class="separator:a7951593b031e13d90223c83d022ce99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3163430a1c13173faffde69016b48aaf"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_eigen.html#a3163430a1c13173faffde69016b48aaf">HugeCost</a> = 10000</td></tr>
<tr class="separator:a3163430a1c13173faffde69016b48aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4f56c2a60bbe4bd2e44c5b19cbe8762"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a> = 0x1</td></tr>
<tr class="separator:gae4f56c2a60bbe4bd2e44c5b19cbe8762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa34e83bae46a8eeae4e69ebe3aaecbed"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#gaa34e83bae46a8eeae4e69ebe3aaecbed">EvalBeforeNestingBit</a> = 0x2</td></tr>
<tr class="separator:gaa34e83bae46a8eeae4e69ebe3aaecbed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae4b8ae7db0d83f9bbed26b261e60e139"><td class="memItemLeft" align="right" valign="top">const EIGEN_DEPRECATED unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#gae4b8ae7db0d83f9bbed26b261e60e139">EvalBeforeAssigningBit</a> = 0x4</td></tr>
<tr class="separator:gae4b8ae7db0d83f9bbed26b261e60e139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a306a438e1ab074e8be59512e887b9f"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#ga1a306a438e1ab074e8be59512e887b9f">PacketAccessBit</a> = 0x8</td></tr>
<tr class="separator:ga1a306a438e1ab074e8be59512e887b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020f88dc24a123b9afbd756c4b220db2"><td class="memItemLeft" align="right" valign="top"><a id="a020f88dc24a123b9afbd756c4b220db2"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>ActualPacketAccessBit</b> = 0x0</td></tr>
<tr class="separator:a020f88dc24a123b9afbd756c4b220db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b983a15d57cd55806df618ac544d09e"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#ga4b983a15d57cd55806df618ac544d09e">LinearAccessBit</a> = 0x10</td></tr>
<tr class="separator:ga4b983a15d57cd55806df618ac544d09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2c323957f20dfdc6cb8f44428eaec1a"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#gae2c323957f20dfdc6cb8f44428eaec1a">LvalueBit</a> = 0x20</td></tr>
<tr class="separator:gae2c323957f20dfdc6cb8f44428eaec1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf1e9d0516a933445a4c307ad8f14915"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#gabf1e9d0516a933445a4c307ad8f14915">DirectAccessBit</a> = 0x40</td></tr>
<tr class="separator:gabf1e9d0516a933445a4c307ad8f14915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1088154b1bb147229211e4f3b56d401"><td class="memItemLeft" align="right" valign="top">const EIGEN_DEPRECATED unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#gab1088154b1bb147229211e4f3b56d401">AlignedBit</a> = 0x80</td></tr>
<tr class="separator:gab1088154b1bb147229211e4f3b56d401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314e8c179d85f480cbaa25558e2a649f"><td class="memItemLeft" align="right" valign="top"><a id="a314e8c179d85f480cbaa25558e2a649f"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>NestByRefBit</b> = 0x100</td></tr>
<tr class="separator:a314e8c179d85f480cbaa25558e2a649f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c186ad80ddcf5e2ed3d7ee31cca1860"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#ga3c186ad80ddcf5e2ed3d7ee31cca1860">NoPreferredStorageOrderBit</a> = 0x200</td></tr>
<tr class="separator:ga3c186ad80ddcf5e2ed3d7ee31cca1860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed0244284da47a2b8661261431173caf"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__flags.html#gaed0244284da47a2b8661261431173caf">CompressedAccessBit</a> = 0x400</td></tr>
<tr class="separator:gaed0244284da47a2b8661261431173caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297729d26fa056b10e9d8d5d088b12e6"><td class="memItemLeft" align="right" valign="top">const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>HereditaryBits</b></td></tr>
<tr class="separator:a297729d26fa056b10e9d8d5d088b12e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2407957f44e0e0b671f1dc6ae56a9df7"><td class="memTemplParams" colspan="2"><a id="a2407957f44e0e0b671f1dc6ae56a9df7"></a>
template&lt;int N&gt; </td></tr>
<tr class="memitem:a2407957f44e0e0b671f1dc6ae56a9df7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="class_eigen_1_1internal_1_1_fixed_int.html">internal::FixedInt</a>&lt; N &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fix</b> {}</td></tr>
<tr class="separator:a2407957f44e0e0b671f1dc6ae56a9df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cbdfe304a8319af94184bc781f583be"><td class="memItemLeft" align="right" valign="top"><a id="a7cbdfe304a8319af94184bc781f583be"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>AutoOrder</b> = 2</td></tr>
<tr class="separator:a7cbdfe304a8319af94184bc781f583be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77c267db06bfa11212bc13dfe8f90a6"><td class="memItemLeft" align="right" valign="top"><a id="ae77c267db06bfa11212bc13dfe8f90a6"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>CoherentAccessPattern</b> = 0x1</td></tr>
<tr class="separator:ae77c267db06bfa11212bc13dfe8f90a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a7fa97adf0db7055c92f466cecc271"><td class="memItemLeft" align="right" valign="top"><a id="ad3a7fa97adf0db7055c92f466cecc271"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>InnerRandomAccessPattern</b> = 0x2 | CoherentAccessPattern</td></tr>
<tr class="separator:ad3a7fa97adf0db7055c92f466cecc271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eea27a4bf0e3e88d0025ee77628e129"><td class="memItemLeft" align="right" valign="top"><a id="a4eea27a4bf0e3e88d0025ee77628e129"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>OuterRandomAccessPattern</b> = 0x4 | CoherentAccessPattern</td></tr>
<tr class="separator:a4eea27a4bf0e3e88d0025ee77628e129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9beed61de5b6f473461b053a43ae793"><td class="memItemLeft" align="right" valign="top"><a id="ad9beed61de5b6f473461b053a43ae793"></a>
const int&#160;</td><td class="memItemRight" valign="bottom"><b>RandomAccessPattern</b> = 0x8 | OuterRandomAccessPattern | InnerRandomAccessPattern</td></tr>
<tr class="separator:ad9beed61de5b6f473461b053a43ae793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63002a89341ef7158fe60fa7570e88c"><td class="memItemLeft" align="right" valign="top"><a id="ab63002a89341ef7158fe60fa7570e88c"></a>
Scalar&#160;</td><td class="memItemRight" valign="bottom"><b>expx</b> = exp(x.value())</td></tr>
<tr class="separator:ab63002a89341ef7158fe60fa7570e88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad496e8c77742ade2de35220f8f0469a8"><td class="memItemLeft" align="right" valign="top"><a id="ad496e8c77742ade2de35220f8f0469a8"></a>
const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><b>SkylineBit</b> = 0x1200</td></tr>
<tr class="separator:ad496e8c77742ade2de35220f8f0469a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace containing all symbols from the Eigen library. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a028f6f47e59a156fba3bd984363644bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028f6f47e59a156fba3bd984363644bd">&#9670;&nbsp;</a></span>AlignedScaling2d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_diagonal_matrix.html">DiagonalMatrix</a>&lt; double, 2 &gt; <a class="el" href="namespace_eigen.html#a028f6f47e59a156fba3bd984363644bd">Eigen::AlignedScaling2d</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000360">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000402">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a5acdf901fca83d0f807538414fe0d29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5acdf901fca83d0f807538414fe0d29e">&#9670;&nbsp;</a></span>AlignedScaling2f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_diagonal_matrix.html">DiagonalMatrix</a>&lt; float, 2 &gt; <a class="el" href="namespace_eigen.html#a5acdf901fca83d0f807538414fe0d29e">Eigen::AlignedScaling2f</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000359">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000401">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a4362757fc0624ef024a7b56b256bfc86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4362757fc0624ef024a7b56b256bfc86">&#9670;&nbsp;</a></span>AlignedScaling3d</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_diagonal_matrix.html">DiagonalMatrix</a>&lt; double, 3 &gt; <a class="el" href="namespace_eigen.html#a4362757fc0624ef024a7b56b256bfc86">Eigen::AlignedScaling3d</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000362">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000404">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="af07fc07f3188dad812b24f581985d3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07fc07f3188dad812b24f581985d3d4">&#9670;&nbsp;</a></span>AlignedScaling3f</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_eigen_1_1_diagonal_matrix.html">DiagonalMatrix</a>&lt; float, 3 &gt; <a class="el" href="namespace_eigen.html#af07fc07f3188dad812b24f581985d3d4">Eigen::AlignedScaling3f</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000361">Deprecated:</a></b></dt><dd></dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000403">Deprecated:</a></b></dt><dd></dd></dl>

</div>
</div>
<a id="a62e77e0933482dafde8fe197d9a2cfde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62e77e0933482dafde8fe197d9a2cfde">&#9670;&nbsp;</a></span>Index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef EIGEN_DEFAULT_DENSE_INDEX_TYPE <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Eigen::Index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The Index type as used for the API. </p>
<p>To change this, <code>#define</code> the preprocessor symbol <code>EIGEN_DEFAULT_DENSE_INDEX_TYPE</code>. </p><dl class="section see"><dt>See also</dt><dd>\blank <a class="el" href="_topic_preprocessor_directives.html">Preprocessor directives</a>, StorageIndex. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="_c_1_2_users_2fab_2src_2_github_2branches_2_neural_amp_modeler_plugin_2eigen_2unsupported_2_eige9876efe7b0468006aaf88af70545e61f.html#a0">C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h</a>, and <a class="el" href="_c_1_2_users_2fab_2src_2_github_2branches_2_neural_amp_modeler_plugin_2_neural_amp_modeler_2_neudcfface7fee2564e924a31cba3aa701c.html#a0">C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/NeuralAmpModeler/NeuralAmpModelerCore/Dependencies/eigen/unsupported/Eigen/CXX11/src/Tensor/TensorLayoutSwap.h</a>.</dd>
</dl>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ada5e710ea0d2f7f1ad5c6fc45ae9f6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5e710ea0d2f7f1ad5c6fc45ae9f6cf">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a85f09e8f95d9c58d05522608c72feaf8af81fc519ed9cc0ebc6aac69a366086a5"></a>StandardCompressedFormat&#160;</td><td class="fielddoc"><p>used by Ref&lt;SparseMatrix&gt; to specify whether the input storage must be in standard compressed form </p>
</td></tr>
</table>

</div>
</div>
<a id="a85f09e8f95d9c58d05522608c72feaf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85f09e8f95d9c58d05522608c72feaf8">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a85f09e8f95d9c58d05522608c72feaf8af81fc519ed9cc0ebc6aac69a366086a5"></a>StandardCompressedFormat&#160;</td><td class="fielddoc"><p>used by Ref&lt;SparseMatrix&gt; to specify whether the input storage must be in standard compressed form </p>
</td></tr>
</table>

</div>
</div>
<a id="ae614aa7cdd687fb5c421a54f2ce5c361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae614aa7cdd687fb5c421a54f2ce5c361">&#9670;&nbsp;</a></span>EulerAxis <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361">Eigen::EulerAxis</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Representation of a fixed signed rotation axis for <a class="el" href="class_eigen_1_1_euler_system.html" title="Represents a fixed Euler rotation system.">EulerSystem</a>. </p>
<p>Values here represent:</p><ul>
<li>The axis of the rotation: X, Y or Z.</li>
<li>The sign (i.e. direction of the rotation along the axis): positive(+) or negative(-)</li>
</ul>
<p>Therefore, this could express all the axes {+X,+Y,+Z,-X,-Y,-Z}</p>
<p>For positive axis, use +EULER_{axis}, and for negative axis use -EULER_{axis}. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae614aa7cdd687fb5c421a54f2ce5c361ae8110af93d433bfcf247d6bac5e1d387"></a>EULER_X&#160;</td><td class="fielddoc"><p>the X axis </p>
</td></tr>
<tr><td class="fieldname"><a id="ae614aa7cdd687fb5c421a54f2ce5c361a7309edb53a9d9cdb77fac7c1e9200263"></a>EULER_Y&#160;</td><td class="fielddoc"><p>the Y axis </p>
</td></tr>
<tr><td class="fieldname"><a id="ae614aa7cdd687fb5c421a54f2ce5c361a0c641fd5050b5219d6c172ac83fb379d"></a>EULER_Z&#160;</td><td class="fielddoc"><p>the Z axis </p>
</td></tr>
<tr><td class="fieldname"><a id="ae614aa7cdd687fb5c421a54f2ce5c361ae8110af93d433bfcf247d6bac5e1d387"></a>EULER_X&#160;</td><td class="fielddoc"><p>the X axis </p>
</td></tr>
<tr><td class="fieldname"><a id="ae614aa7cdd687fb5c421a54f2ce5c361a7309edb53a9d9cdb77fac7c1e9200263"></a>EULER_Y&#160;</td><td class="fielddoc"><p>the Y axis </p>
</td></tr>
<tr><td class="fieldname"><a id="ae614aa7cdd687fb5c421a54f2ce5c361a0c641fd5050b5219d6c172ac83fb379d"></a>EULER_Z&#160;</td><td class="fielddoc"><p>the Z axis </p>
</td></tr>
</table>

</div>
</div>
<a id="ae614aa7cdd687fb5c421a54f2ce5c361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae614aa7cdd687fb5c421a54f2ce5c361">&#9670;&nbsp;</a></span>EulerAxis <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespace_eigen.html#ae614aa7cdd687fb5c421a54f2ce5c361">Eigen::EulerAxis</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Representation of a fixed signed rotation axis for <a class="el" href="class_eigen_1_1_euler_system.html" title="Represents a fixed Euler rotation system.">EulerSystem</a>. </p>
<p>Values here represent:</p><ul>
<li>The axis of the rotation: X, Y or Z.</li>
<li>The sign (i.e. direction of the rotation along the axis): positive(+) or negative(-)</li>
</ul>
<p>Therefore, this could express all the axes {+X,+Y,+Z,-X,-Y,-Z}</p>
<p>For positive axis, use +EULER_{axis}, and for negative axis use -EULER_{axis}. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae614aa7cdd687fb5c421a54f2ce5c361ae8110af93d433bfcf247d6bac5e1d387"></a>EULER_X&#160;</td><td class="fielddoc"><p>the X axis </p>
</td></tr>
<tr><td class="fieldname"><a id="ae614aa7cdd687fb5c421a54f2ce5c361a7309edb53a9d9cdb77fac7c1e9200263"></a>EULER_Y&#160;</td><td class="fielddoc"><p>the Y axis </p>
</td></tr>
<tr><td class="fieldname"><a id="ae614aa7cdd687fb5c421a54f2ce5c361a0c641fd5050b5219d6c172ac83fb379d"></a>EULER_Z&#160;</td><td class="fielddoc"><p>the Z axis </p>
</td></tr>
<tr><td class="fieldname"><a id="ae614aa7cdd687fb5c421a54f2ce5c361ae8110af93d433bfcf247d6bac5e1d387"></a>EULER_X&#160;</td><td class="fielddoc"><p>the X axis </p>
</td></tr>
<tr><td class="fieldname"><a id="ae614aa7cdd687fb5c421a54f2ce5c361a7309edb53a9d9cdb77fac7c1e9200263"></a>EULER_Y&#160;</td><td class="fielddoc"><p>the Y axis </p>
</td></tr>
<tr><td class="fieldname"><a id="ae614aa7cdd687fb5c421a54f2ce5c361a0c641fd5050b5219d6c172ac83fb379d"></a>EULER_Z&#160;</td><td class="fielddoc"><p>the Z axis </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae29347f850e265d2d33164b3387ba360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae29347f850e265d2d33164b3387ba360">&#9670;&nbsp;</a></span>accurateDot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename OtherDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Derived::Scalar Eigen::accurateDot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes an accurate dot product on two sparse vectors </p>
<p>Uses an accurate summation algorithm for the accumulator in order to compute an accurate dot product for two sparse vectors. </p>

</div>
</div>
<a id="afdf5abdb29bfceb4625e62e35c830ce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf5abdb29bfceb4625e62e35c830ce4">&#9670;&nbsp;</a></span>bessel_i0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__i0__op.html">Eigen::internal::scalar_bessel_i0_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt; Eigen::bessel_i0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise i0(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the modified Bessel function of the first kind of order zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i0(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_i0() </dd></dl>

</div>
</div>
<a id="ae5e6995d520140092109482a34c21cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5e6995d520140092109482a34c21cac">&#9670;&nbsp;</a></span>bessel_i0e()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__i0e__op.html">Eigen::internal::scalar_bessel_i0e_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt; Eigen::bessel_i0e </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise i0e(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the exponentially scaled modified Bessel function of the first kind of order zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i0e(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_i0e() </dd></dl>

</div>
</div>
<a id="a739801b7e406af9db51b7524292d87bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739801b7e406af9db51b7524292d87bd">&#9670;&nbsp;</a></span>bessel_i1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__i1__op.html">Eigen::internal::scalar_bessel_i1_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt; Eigen::bessel_i1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise i1(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the modified Bessel function of the first kind of order one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i1(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_i1() </dd></dl>

</div>
</div>
<a id="a99f089b726e804a9fe0a9b07604aa44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f089b726e804a9fe0a9b07604aa44b">&#9670;&nbsp;</a></span>bessel_i1e()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__i1e__op.html">Eigen::internal::scalar_bessel_i1e_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt; Eigen::bessel_i1e </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise i1e(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the exponentially scaled modified Bessel function of the first kind of order one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of i1e(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_i1e() </dd></dl>

</div>
</div>
<a id="ad45c6fd1eec3bd5c189d769691ecb725"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45c6fd1eec3bd5c189d769691ecb725">&#9670;&nbsp;</a></span>bessel_j0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__j0__op.html">Eigen::internal::scalar_bessel_j0_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt; Eigen::bessel_j0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise j0(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the Bessel function of the first kind of order zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of j0(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_j0() </dd></dl>

</div>
</div>
<a id="a0419635e1e0bfb31db3b219fc2a03c9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0419635e1e0bfb31db3b219fc2a03c9f">&#9670;&nbsp;</a></span>bessel_j1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__j1__op.html">Eigen::internal::scalar_bessel_j1_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt; Eigen::bessel_j1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise j1(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the modified Bessel function of the first kind of order one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of j1(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_j1() </dd></dl>

</div>
</div>
<a id="a6d807b7d6e0e137d91e42683bdc32ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d807b7d6e0e137d91e42683bdc32ffe">&#9670;&nbsp;</a></span>bessel_k0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__k0__op.html">Eigen::internal::scalar_bessel_k0_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt; Eigen::bessel_k0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise k0(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the modified Bessel function of the second kind of order zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k0(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_k0() </dd></dl>

</div>
</div>
<a id="a1bd9ad1d608e8e6804428a26294cd3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd9ad1d608e8e6804428a26294cd3e5">&#9670;&nbsp;</a></span>bessel_k0e()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__k0e__op.html">Eigen::internal::scalar_bessel_k0e_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt; Eigen::bessel_k0e </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise k0e(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the exponentially scaled modified Bessel function of the second kind of order zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k0e(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_k0e() </dd></dl>

</div>
</div>
<a id="ab98c1366128b96bfd9229cbcebbfbf79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98c1366128b96bfd9229cbcebbfbf79">&#9670;&nbsp;</a></span>bessel_k1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__k1__op.html">Eigen::internal::scalar_bessel_k1_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt; Eigen::bessel_k1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise k1(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the modified Bessel function of the second kind of order one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k1(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_k1() </dd></dl>

</div>
</div>
<a id="a4966f237f5f8d96749f5bf654cac93a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4966f237f5f8d96749f5bf654cac93a3">&#9670;&nbsp;</a></span>bessel_k1e()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__k1e__op.html">Eigen::internal::scalar_bessel_k1e_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt; Eigen::bessel_k1e </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise k1e(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the exponentially scaled modified Bessel function of the second kind of order one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of k1e(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_k1e() </dd></dl>

</div>
</div>
<a id="a89585d60cbc04388a01342c9a36aca37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89585d60cbc04388a01342c9a36aca37">&#9670;&nbsp;</a></span>bessel_y0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__y0__op.html">Eigen::internal::scalar_bessel_y0_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt; Eigen::bessel_y0 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise y0(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the Bessel function of the second kind of order zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of y0(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_y0() </dd></dl>

</div>
</div>
<a id="a8c2c4efe0449c569a8b382febe4d1917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c2c4efe0449c569a8b382febe4d1917">&#9670;&nbsp;</a></span>bessel_y1()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_unary_op.html">Eigen::CwiseUnaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__bessel__y1__op.html">Eigen::internal::scalar_bessel_y1_op</a>&lt; typename Derived::Scalar &gt;, const Derived &gt; Eigen::bessel_y1 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise y1(<em>x</em>) to the given arrays.</dd></dl>
<p>It returns the Bessel function of the second kind of order one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the argument</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of y1(T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::bessel_y1() </dd></dl>

</div>
</div>
<a id="a4c9e316b709db929d87c9bc305492f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c9e316b709db929d87c9bc305492f0d">&#9670;&nbsp;</a></span>betainc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ADerived , typename BDerived , typename XDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_tensor_cwise_ternary_op.html">TensorCwiseTernaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__betainc__op.html">internal::scalar_betainc_op</a>&lt; typename XDerived::Scalar &gt;, const ADerived, const BDerived, const XDerived &gt; Eigen::betainc </td>
          <td>(</td>
          <td class="paramtype">const ADerived &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BDerived &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const XDerived &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\cpp11 </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise betainc(<em>x</em>, <em>a</em>, <em>b</em>) to the given tensors.</dd></dl>
<p>This function computes the regularized incomplete beta function (integral). </p>

</div>
</div>
<a id="a21a251a5c15e1eebb3f03633f4945c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a251a5c15e1eebb3f03633f4945c74">&#9670;&nbsp;</a></span>betainc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ArgADerived , typename ArgBDerived , typename ArgXDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_ternary_op.html">Eigen::CwiseTernaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__betainc__op.html">Eigen::internal::scalar_betainc_op</a>&lt; typename ArgXDerived::Scalar &gt;, const ArgADerived, const ArgBDerived, const ArgXDerived &gt; Eigen::betainc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; ArgADerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; ArgBDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; ArgXDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\cpp11 </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise betainc(<em>x</em>, <em>a</em>, <em>b</em>) to the given arrays.</dd></dl>
<p>This function computes the regularized incomplete beta function (integral).</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of betainc(T,T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_eigen.html#a4c9e316b709db929d87c9bc305492f0d">Eigen::betainc()</a>, Eigen::lgamma() </dd></dl>

</div>
</div>
<a id="a07d8e283f082c972338f3fc4f644b2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d8e283f082c972338f3fc4f644b2a9">&#9670;&nbsp;</a></span>BVIntersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BVH , typename Intersector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::BVIntersect </td>
          <td>(</td>
          <td class="paramtype">const BVH &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Intersector &amp;&#160;</td>
          <td class="paramname"><em>intersector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a BVH, runs the query encapsulated by <em>intersector</em>. The Intersector type must provide the following members:</p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> intersectVolume(<span class="keyword">const</span> BVH::Volume &amp;volume) <span class="comment">//returns true if volume intersects the query</span></div>
<div class="line"><span class="keywordtype">bool</span> intersectObject(<span class="keyword">const</span> BVH::Object &amp;<span class="keywordtype">object</span>) <span class="comment">//returns true if the search should terminate immediately</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac3b8047a3ee05b5e6fec4668197a9a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b8047a3ee05b5e6fec4668197a9a43">&#9670;&nbsp;</a></span>BVIntersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BVH1 , typename BVH2 , typename Intersector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::BVIntersect </td>
          <td>(</td>
          <td class="paramtype">const BVH1 &amp;&#160;</td>
          <td class="paramname"><em>tree1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BVH2 &amp;&#160;</td>
          <td class="paramname"><em>tree2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Intersector &amp;&#160;</td>
          <td class="paramname"><em>intersector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two BVH's, runs the query on their Cartesian product encapsulated by <em>intersector</em>. The Intersector type must provide the following members:</p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> intersectVolumeVolume(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Volume &amp;v2) <span class="comment">//returns true if product of volumes intersects the query</span></div>
<div class="line"><span class="keywordtype">bool</span> intersectVolumeObject(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Object &amp;o2) <span class="comment">//returns true if the volume-object product intersects the query</span></div>
<div class="line"><span class="keywordtype">bool</span> intersectObjectVolume(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Volume &amp;v2) <span class="comment">//returns true if the volume-object product intersects the query</span></div>
<div class="line"><span class="keywordtype">bool</span> intersectObjectObject(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Object &amp;o2) <span class="comment">//returns true if the search should terminate immediately</span></div>
</div><!-- fragment --> 
</div>
</div>
<a id="adcbe73ac1482eacab0e18ee32c25508e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcbe73ac1482eacab0e18ee32c25508e">&#9670;&nbsp;</a></span>BVMinimize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BVH , typename Minimizer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Minimizer::Scalar Eigen::BVMinimize </td>
          <td>(</td>
          <td class="paramtype">const BVH &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Minimizer &amp;&#160;</td>
          <td class="paramname"><em>minimizer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a BVH, runs the query encapsulated by <em>minimizer</em>. </p><dl class="section return"><dt>Returns</dt><dd>the minimum value. The Minimizer type must provide the following members:<div class="fragment"><div class="line"><span class="keyword">typedef</span> Scalar <span class="comment">//the numeric type of what is being minimized--not necessarily the Scalar type of the BVH (if it has one)</span></div>
<div class="line">Scalar minimumOnVolume(<span class="keyword">const</span> BVH::Volume &amp;volume)</div>
<div class="line">Scalar minimumOnObject(<span class="keyword">const</span> BVH::Object &amp;<span class="keywordtype">object</span>)</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="a915f6adc8b195c94a83c35de6a842556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915f6adc8b195c94a83c35de6a842556">&#9670;&nbsp;</a></span>BVMinimize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BVH1 , typename BVH2 , typename Minimizer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Minimizer::Scalar Eigen::BVMinimize </td>
          <td>(</td>
          <td class="paramtype">const BVH1 &amp;&#160;</td>
          <td class="paramname"><em>tree1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BVH2 &amp;&#160;</td>
          <td class="paramname"><em>tree2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Minimizer &amp;&#160;</td>
          <td class="paramname"><em>minimizer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two BVH's, runs the query on their cartesian product encapsulated by <em>minimizer</em>. </p><dl class="section return"><dt>Returns</dt><dd>the minimum value. The Minimizer type must provide the following members:<div class="fragment"><div class="line"><span class="keyword">typedef</span> Scalar <span class="comment">//the numeric type of what is being minimized--not necessarily the Scalar type of the BVH (if it has one)</span></div>
<div class="line">Scalar minimumOnVolumeVolume(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Volume &amp;v2)</div>
<div class="line">Scalar minimumOnVolumeObject(<span class="keyword">const</span> BVH1::Volume &amp;v1, <span class="keyword">const</span> BVH2::Object &amp;o2)</div>
<div class="line">Scalar minimumOnObjectVolume(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Volume &amp;v2)</div>
<div class="line">Scalar minimumOnObjectObject(<span class="keyword">const</span> BVH1::Object &amp;o1, <span class="keyword">const</span> BVH2::Object &amp;o2)</div>
</div><!-- fragment --> </dd></dl>

</div>
</div>
<a id="ac90ec4513aa09bb8ad54daa209322d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90ec4513aa09bb8ad54daa209322d03">&#9670;&nbsp;</a></span>cauchy_max_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Polynomial &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; typename Polynomial::Scalar &gt;::Real Eigen::cauchy_max_bound </td>
          <td>(</td>
          <td class="paramtype">const Polynomial &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a maximum bound for the absolute value of any root of the polynomial.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>: the vector of coefficients of the polynomial ordered by degrees i.e. poly[i] is the coefficient of degree i of the polynomial e.g. <img class="formulaInl" alt="$ 1 + 3x^2 $" src="form_262.png"/> is stored as a vector <img class="formulaInl" alt="$ [ 1, 0, 3 ] $" src="form_263.png"/>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>the leading coefficient of the input polynomial poly must be non zero </dd></dl>

</div>
</div>
<a id="a43f0af310d5cc131eb5e806f241af951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f0af310d5cc131eb5e806f241af951">&#9670;&nbsp;</a></span>cauchy_min_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Polynomial &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_eigen_1_1_num_traits.html">NumTraits</a>&lt; typename Polynomial::Scalar &gt;::Real Eigen::cauchy_min_bound </td>
          <td>(</td>
          <td class="paramtype">const Polynomial &amp;&#160;</td>
          <td class="paramname"><em>poly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a minimum bound for the absolute value of any non zero root of the polynomial. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>: the vector of coefficients of the polynomial ordered by degrees i.e. poly[i] is the coefficient of degree i of the polynomial e.g. <img class="formulaInl" alt="$ 1 + 3x^2 $" src="form_262.png"/> is stored as a vector <img class="formulaInl" alt="$ [ 1, 0, 3 ] $" src="form_263.png"/>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d9a7ddcee5c7c8defaba3628455efb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d9a7ddcee5c7c8defaba3628455efb2">&#9670;&nbsp;</a></span>createRandomPIMatrixOfRank()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::createRandomPIMatrixOfRank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>desired_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a random partial isometry matrix of given rank.</p>
<p>A partial isometry is a matrix all of whose singular values are either 0 or 1. This is very useful to test rank-revealing algorithms.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>type of random partial isometry matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">desired_rank</td><td>rank requested for the random partial isometry matrix </td></tr>
    <tr><td class="paramname">rows</td><td>row dimension of requested random partial isometry matrix </td></tr>
    <tr><td class="paramname">cols</td><td>column dimension of requested random partial isometry matrix </td></tr>
    <tr><td class="paramname">m</td><td>random partial isometry matrix </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9010e675b04cc99696726dc48b11c91b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9010e675b04cc99696726dc48b11c91b">&#9670;&nbsp;</a></span>deserialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC const EIGEN_STRONG_INLINE uint8_t * Eigen::deserialize </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deserialize a set of values from the byte buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>input byte buffer; if this is nullptr, does nothing. </td></tr>
    <tr><td class="paramname">end</td><td>the end of input byte buffer. </td></tr>
    <tr><td class="paramname">args</td><td>... arguments to deserialize in sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next address after all parsed values; nullptr if parsing errors are detected. </dd></dl>

</div>
</div>
<a id="a7dc86a879904499f4f34a471b569f286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dc86a879904499f4f34a471b569f286">&#9670;&nbsp;</a></span>gamma_sample_der_alpha()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AlphaDerived , typename SampleDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">Eigen::CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__gamma__sample__der__alpha__op.html">Eigen::internal::scalar_gamma_sample_der_alpha_op</a>&lt; typename AlphaDerived::Scalar &gt;, const AlphaDerived, const SampleDerived &gt; Eigen::gamma_sample_der_alpha </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; AlphaDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; SampleDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\cpp11 </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise gamma_sample_der_alpha(<em>alpha</em>, <em>sample</em>) to the given arrays.</dd></dl>
<p>This function computes the coefficient-wise derivative of the sample of a Gamma(alpha, 1) random variable with respect to the parameter alpha.</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of gamma_sample_der_alpha(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_eigen.html#af3212ea95bc2fc39a6d1187c3fdf1b1f">Eigen::igamma()</a>, Eigen::lgamma() </dd></dl>

</div>
</div>
<a id="af9581b8fef58e77009b9c07137d8fa4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9581b8fef58e77009b9c07137d8fa4d">&#9670;&nbsp;</a></span>generateRandomMatrixSvs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename RealScalarVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::generateRandomMatrixSvs </td>
          <td>(</td>
          <td class="paramtype">const RealScalarVectorType &amp;&#160;</td>
          <td class="paramname"><em>svs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>M</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generation of random matrix with prescribed singular values.</p>
<p>We generate random matrices with given singular values by setting up a singular value decomposition. By choosing the number of zeros as singular values we can specify the rank of the matrix. Moreover, we also control its spectral norm, which is the largest singular value, as well as its condition number with respect to the l2-norm, which is the quotient of the largest and smallest singular value.</p>
<p>Reference: For details on the method see e.g. Section 8.1 (pp. 62 f) in</p>
<p>C. C. Paige, M. A. Saunders, LSQR: An algorithm for sparse linear equations and sparse least squares. ACM Transactions on Mathematical Software 8(1), pp. 43-71, 1982. <a href="https://web.stanford.edu/group/SOL/software/lsqr/lsqr-toms82a.pdf">https://web.stanford.edu/group/SOL/software/lsqr/lsqr-toms82a.pdf</a></p>
<p>and also the LSQR webpage <a href="https://web.stanford.edu/group/SOL/software/lsqr/">https://web.stanford.edu/group/SOL/software/lsqr/</a>.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>matrix type to generate </td></tr>
    <tr><td class="paramname">RealScalarVectorType</td><td>vector type with real entries used for singular values </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">svs</td><td>vector of desired singular values </td></tr>
    <tr><td class="paramname">rows</td><td>row dimension of requested random matrix </td></tr>
    <tr><td class="paramname">cols</td><td>column dimension of requested random matrix </td></tr>
    <tr><td class="paramname">M</td><td>generated matrix with prescribed singular values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac33a0d76d99d352dd36cf73987d8eca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33a0d76d99d352dd36cf73987d8eca7">&#9670;&nbsp;</a></span>generateRandomUnitaryMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">MatrixType Eigen::generateRandomUnitaryMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>dim</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a random unitary matrix of prescribed dimension.</p>
<p>The algorithm is using a random Householder sequence to produce a random unitary matrix.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>type of matrix to generate </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>row and column dimension of the requested square matrix </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>random unitary matrix </dd></dl>

</div>
</div>
<a id="a5b82b077ca4d3780012b2f837bb23ee0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b82b077ca4d3780012b2f837bb23ee0">&#9670;&nbsp;</a></span>getMarketHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Eigen::getMarketHeader </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sym</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>iscomplex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isdense</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads the header of a matrixmarket file and determines the properties of a matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>of the file </td></tr>
    <tr><td class="paramname">sym</td><td>if the matrix is hermitian,symmetric or none of the latter (sym=0) </td></tr>
    <tr><td class="paramname">iscomplex</td><td>if the matrix has complex or real coefficients </td></tr>
    <tr><td class="paramname">isdense</td><td>if the matrix is dense or sparse </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file was found </dd></dl>

</div>
</div>
<a id="af3212ea95bc2fc39a6d1187c3fdf1b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3212ea95bc2fc39a6d1187c3fdf1b1f">&#9670;&nbsp;</a></span>igamma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ExponentDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">Eigen::CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__igamma__op.html">Eigen::internal::scalar_igamma_op</a>&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt; Eigen::igamma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\cpp11 </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise igamma(<em>a</em>, <em>x</em>) to the given arrays.</dd></dl>
<p>This function computes the coefficient-wise incomplete gamma function.</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of igammac(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_eigen.html#a4edbf3cd0946ca34f217fb6c9b8d47cf">Eigen::igammac()</a>, Eigen::lgamma() </dd></dl>

</div>
</div>
<a id="ae727e78322e10905ef1a4a01d8e43c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae727e78322e10905ef1a4a01d8e43c8a">&#9670;&nbsp;</a></span>igamma_der_a()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ExponentDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">Eigen::CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__igamma__der__a__op.html">Eigen::internal::scalar_igamma_der_a_op</a>&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt; Eigen::igamma_der_a </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\cpp11 </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise igamma_der_a(<em>a</em>, <em>x</em>) to the given arrays.</dd></dl>
<p>This function computes the coefficient-wise derivative of the incomplete gamma function with respect to the parameter a.</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of igamma_der_a(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_eigen.html#af3212ea95bc2fc39a6d1187c3fdf1b1f">Eigen::igamma()</a>, Eigen::lgamma() </dd></dl>

</div>
</div>
<a id="a4edbf3cd0946ca34f217fb6c9b8d47cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4edbf3cd0946ca34f217fb6c9b8d47cf">&#9670;&nbsp;</a></span>igammac()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived , typename ExponentDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">Eigen::CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__igammac__op.html">Eigen::internal::scalar_igammac_op</a>&lt; typename Derived::Scalar &gt;, const Derived, const ExponentDerived &gt; Eigen::igammac </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; ExponentDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\cpp11 </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise igammac(<em>a</em>, <em>x</em>) to the given arrays.</dd></dl>
<p>This function computes the coefficient-wise complementary incomplete gamma function.</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of igammac(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_eigen.html#af3212ea95bc2fc39a6d1187c3fdf1b1f">Eigen::igamma()</a>, Eigen::lgamma() </dd></dl>

</div>
</div>
<a id="a820c0e0460934cc17eb6dacbad54a9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a820c0e0460934cc17eb6dacbad54a9f5">&#9670;&nbsp;</a></span>initParallel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::initParallel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Must be call first when calling <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> from multiple threads </p>

</div>
</div>
<a id="a73e4b5699212c361ff6818d5badb9e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e4b5699212c361ff6818d5badb9e71">&#9670;&nbsp;</a></span>isMinusInf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Eigen::isMinusInf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if number is minus infinity.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>input type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if input value is minus infinity </dd></dl>

</div>
</div>
<a id="a10d79d82f1c6e55567791cd5c5304bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d79d82f1c6e55567791cd5c5304bc0">&#9670;&nbsp;</a></span>isNotNaN()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Eigen::isNotNaN </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if number is "not a number" (NaN).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>input type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if input value is "not a number" (NaN) </dd></dl>

</div>
</div>
<a id="ab8d65958858e32e62aeba1e4455a5737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d65958858e32e62aeba1e4455a5737">&#9670;&nbsp;</a></span>isPlusInf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Eigen::isPlusInf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if number is plus infinity.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>input type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>input value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true, if input value is plus infinity </dd></dl>

</div>
</div>
<a id="ad6d0ed07a6ee97fcef4fe3bce6a674d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d0ed07a6ee97fcef4fe3bce6a674d4">&#9670;&nbsp;</a></span>klu_solve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Eigen::klu_solve </td>
          <td>(</td>
          <td class="paramtype">klu_symbolic *&#160;</td>
          <td class="paramname"><em>Symbolic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">klu_numeric *&#160;</td>
          <td class="paramname"><em>Numeric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>ldim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>nrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>B</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">klu_common *&#160;</td>
          <td class="paramname"><em>Common</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A sparse LU factorization and solver based on <a class="el" href="class_eigen_1_1_k_l_u.html">KLU</a>. </p>
<p>This class allows to solve for A.X = B sparse linear problems via a LU factorization using the <a class="el" href="class_eigen_1_1_k_l_u.html">KLU</a> library. The sparse matrix A must be squared and full rank. The vectors or matrices X and B can be either dense or sparse.</p>
<dl class="section warning"><dt>Warning</dt><dd>The input matrix A should be in a <b>compressed</b> and <b>column-major</b> form. Otherwise an expensive copy will be made. You can call the inexpensive makeCompressed() to get a compressed matrix. </dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType_</td><td>the type of the sparse matrix A, it must be a SparseMatrix&lt;&gt;</td></tr>
  </table>
  </dd>
</dl>
<p>\implsparsesolverconcept</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/eigen/doc/SparseLinearSystems.dox#TutorialSparseSolverConcept">Sparse solver concept</a>, class <a class="el" href="class_eigen_1_1_umf_pack_l_u.html" title="A sparse LU factorization and solver based on UmfPack.">UmfPackLU</a>, class <a class="el" href="class_eigen_1_1_sparse_l_u.html" title="Sparse supernodal LU factorization for general matrices.">SparseLU</a> </dd></dl>

</div>
</div>
<a id="a4e6cd3acfea39bcff3fa38e0de1226f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e6cd3acfea39bcff3fa38e0de1226f5">&#9670;&nbsp;</a></span>kroneckerProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_kronecker_product_sparse.html">KroneckerProductSparse</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">A</a>, <a class="el" href="class_eigen_1_1_matrix.html">B</a> &gt; Eigen::kroneckerProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">A</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_eigen_1_1_eigen_base.html">EigenBase</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">B</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes Kronecker tensor product of two matrices, at least one of which is sparse</p>
<dl class="section warning"><dt>Warning</dt><dd>If you want to replace a matrix by its Kronecker product with some matrix, do <b>NOT</b> do this: <div class="fragment"><div class="line">A = <a class="code" href="namespace_eigen.html#aedd4b7cd1e324ed0769cac2701f4d050">kroneckerProduct</a>(A,<a class="code" href="class_eigen_1_1_matrix.html">B</a>); <span class="comment">// bug!!! caused by aliasing effect</span></div>
</div><!-- fragment --> instead, use eval() to work around this: <div class="fragment"><div class="line">A = <a class="code" href="namespace_eigen.html#aedd4b7cd1e324ed0769cac2701f4d050">kroneckerProduct</a>(A,<a class="code" href="class_eigen_1_1_matrix.html">B</a>).eval();</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Dense/sparse matrix a </td></tr>
    <tr><td class="paramname">b</td><td>Dense/sparse matrix b </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker tensor product of a and b, stored in a sparse matrix </dd></dl>

</div>
</div>
<a id="aedd4b7cd1e324ed0769cac2701f4d050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd4b7cd1e324ed0769cac2701f4d050">&#9670;&nbsp;</a></span>kroneckerProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename A , typename B &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_kronecker_product.html">KroneckerProduct</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">A</a>, <a class="el" href="class_eigen_1_1_matrix.html">B</a> &gt; Eigen::kroneckerProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">A</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; <a class="el" href="class_eigen_1_1_matrix.html">B</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes Kronecker tensor product of two dense matrices</p>
<dl class="section warning"><dt>Warning</dt><dd>If you want to replace a matrix by its Kronecker product with some matrix, do <b>NOT</b> do this: <div class="fragment"><div class="line">A = <a class="code" href="namespace_eigen.html#aedd4b7cd1e324ed0769cac2701f4d050">kroneckerProduct</a>(A,<a class="code" href="class_eigen_1_1_matrix.html">B</a>); <span class="comment">// bug!!! caused by aliasing effect</span></div>
</div><!-- fragment --> instead, use eval() to work around this: <div class="fragment"><div class="line">A = <a class="code" href="namespace_eigen.html#aedd4b7cd1e324ed0769cac2701f4d050">kroneckerProduct</a>(A,<a class="code" href="class_eigen_1_1_matrix.html">B</a>).eval();</div>
</div><!-- fragment --></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="struct_eigen_1_1_dense.html">Dense</a> matrix a </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="struct_eigen_1_1_dense.html">Dense</a> matrix b </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Kronecker tensor product of a and b </dd></dl>

</div>
</div>
<a id="a2669f89ff38296a38e6d973552eb4e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2669f89ff38296a38e6d973552eb4e33">&#9670;&nbsp;</a></span>l1CacheSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t Eigen::l1CacheSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the currently set level 1 cpu cache size (in bytes) used to estimate the ideal blocking size parameters. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setCpuCacheSize </dd></dl>

</div>
</div>
<a id="a2cfc0330ba567d63a496be1cac8427ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfc0330ba567d63a496be1cac8427ae">&#9670;&nbsp;</a></span>l2CacheSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t Eigen::l2CacheSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the currently set level 2 cpu cache size (in bytes) used to estimate the ideal blocking size parameters. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setCpuCacheSize </dd></dl>

</div>
</div>
<a id="ae2efa4852ea90c2d47b7dcec5b40ba2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2efa4852ea90c2d47b7dcec5b40ba2b">&#9670;&nbsp;</a></span>l3CacheSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ptrdiff_t Eigen::l3CacheSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the currently set level 3 cpu cache size (in bytes) used to estimate the ideal blocking size paramete\ rs. <br  />
 </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setCpuCacheSize</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the currently set level 3 cpu cache size (in bytes) used to estimate the ideal blocking size paramete\ rs. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>setCpuCacheSize </dd></dl>

</div>
</div>
<a id="a35610696b22ae58bdd51d96468956455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35610696b22ae58bdd51d96468956455">&#9670;&nbsp;</a></span>loadMarket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Eigen::loadMarket </td>
          <td>(</td>
          <td class="paramtype">SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a sparse matrix from a matrixmarket format file. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SparseMatrixType</td><td>to read into, symmetries are not supported </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td><a class="el" href="class_eigen_1_1_sparse_matrix.html" title="A versatible sparse matrix representation.">SparseMatrix</a> to read into, current values are overwritten </td></tr>
    <tr><td class="paramname">filename</td><td>to parse matrix from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns true if file exists. Returns false if the parsing did not succeed. </dd></dl>

</div>
</div>
<a id="abe3d7dbb905149f63fa179898018ca57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3d7dbb905149f63fa179898018ca57">&#9670;&nbsp;</a></span>loadMarketDense()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DenseType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Eigen::loadMarketDense </td>
          <td>(</td>
          <td class="paramtype">DenseType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads a dense <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> or Vector from a matrixmarket file. If a statically sized matrix has to be parsed and the file contains the wrong dimensions it is undefined behaviour. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DenseMatrixType</td><td>to read into </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>DenseMatrix to read into, current values are overwritten, symmetries are not supported </td></tr>
    <tr><td class="paramname">filename</td><td>to parse matrix from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if parsing was successful. Returns false if the parsing did not succeed. </dd></dl>

</div>
</div>
<a id="a2f490197e16df831683018e383e29346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f490197e16df831683018e383e29346">&#9670;&nbsp;</a></span>matrix_sqrt_quasi_triangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename ResultType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::matrix_sqrt_quasi_triangular </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute matrix square root of quasi-triangular matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>type of <code>arg</code>, the argument of matrix square root, expected to be an instantiation of the <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> class template. </td></tr>
    <tr><td class="paramname">ResultType</td><td>type of <code>result</code>, where result is to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument of matrix square root. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>matrix square root of upper Hessenberg part of <code>arg</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>This function computes the square root of the upper quasi-triangular matrix stored in the upper Hessenberg part of <code>arg</code>. Only the upper Hessenberg part of <code>result</code> is updated, the rest is not touched. See <a class="el" href="group__core__func__exponential.html#ga5c784ec51a1765be0a623104db2577b6">MatrixBase::sqrt()</a> for details on how this computation is implemented.</p>
<dl class="section see"><dt>See also</dt><dd>MatrixSquareRoot, MatrixSquareRootQuasiTriangular </dd></dl>

</div>
</div>
<a id="ae51c91f920f6ea4a7f6f72caa1e8249f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae51c91f920f6ea4a7f6f72caa1e8249f">&#9670;&nbsp;</a></span>matrix_sqrt_triangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixType , typename ResultType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::matrix_sqrt_triangular </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ResultType &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute matrix square root of triangular matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">MatrixType</td><td>type of <code>arg</code>, the argument of matrix square root, expected to be an instantiation of the <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> class template. </td></tr>
    <tr><td class="paramname">ResultType</td><td>type of <code>result</code>, where result is to be stored. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>argument of matrix square root. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>matrix square root of upper triangular part of <code>arg</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>Only the upper triangular part (including the diagonal) of <code>result</code> is updated, the rest is not touched. See <a class="el" href="group__core__func__exponential.html#ga5c784ec51a1765be0a623104db2577b6">MatrixBase::sqrt()</a> for details on how this computation is implemented.</p>
<dl class="section see"><dt>See also</dt><dd>MatrixSquareRoot, MatrixSquareRootQuasiTriangular </dd></dl>

</div>
</div>
<a id="a9aca97d83e21b91a04ec079360dfffeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aca97d83e21b91a04ec079360dfffeb">&#9670;&nbsp;</a></span>nbThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Eigen::nbThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the max number of threads reserved for <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_eigen.html#af9cd17c2fe18204239cd11c88c120b50">setNbThreads</a> </dd></dl>

</div>
</div>
<a id="a8908bda30ef10657db0653d96ad5800e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8908bda30ef10657db0653d96ad5800e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseDerived , typename PermutationType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; <a class="el" href="class_eigen_1_1_inverse.html">Inverse</a>&lt; PermutationType &gt;, SparseDerived, AliasFreeProduct &gt; Eigen::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_inverse_impl.html">InverseImpl</a>&lt; PermutationType, <a class="el" href="struct_eigen_1_1_permutation_storage.html">PermutationStorage</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tperm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; SparseDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the matrix with the inverse permutation applied to the rows. </dd></dl>

</div>
</div>
<a id="aa6c54c4d59b5fd9ce61d8bf70018b8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c54c4d59b5fd9ce61d8bf70018b8b1">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixDerived , typename PermutationDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_DEVICE_FUNC <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; MatrixDerived, PermutationDerived, AliasFreeProduct &gt; Eigen::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_permutation_base.html">PermutationBase</a>&lt; PermutationDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the matrix with the permutation applied to the columns. </dd></dl>

</div>
</div>
<a id="a6d0768057509b40f5a64327dbf97ffb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d0768057509b40f5a64327dbf97ffb8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatrixDerived , typename TranspositionsDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_DEVICE_FUNC <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; MatrixDerived, TranspositionsDerived, AliasFreeProduct &gt; Eigen::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_transpositions_base.html">TranspositionsBase</a>&lt; TranspositionsDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>transpositions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em>matrix</em> with the <em>transpositions</em> applied to the columns. </dd></dl>

</div>
</div>
<a id="a6632b4f607fd51ab4560100fed76180f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6632b4f607fd51ab4560100fed76180f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OtherDerived , typename VectorsType , typename CoeffsType , int Side&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_eigen_1_1internal_1_1matrix__type__times__scalar__type.html">internal::matrix_type_times_scalar_type</a>&lt; typename VectorsType::Scalar, OtherDerived &gt;::Type Eigen::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; OtherDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_householder_sequence.html">HouseholderSequence</a>&lt; VectorsType, CoeffsType, Side &gt; &amp;&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the product of a matrix with a Householder sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">other</td><td>Matrix being multiplied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>HouseholderSequence being multiplied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Expression object representing the product.</dd></dl>
<p>This function computes <img class="formulaInl" alt="$ MH $" src="form_203.png"/> where <img class="formulaInl" alt="$ M $" src="form_204.png"/> is the matrix <code>other</code> and <img class="formulaInl" alt="$ H $" src="form_137.png"/> is the Householder sequence represented by <code>h</code>. </p>

</div>
</div>
<a id="a9c2c1af8da495ae3cbe7be12cecfe294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c2c1af8da495ae3cbe7be12cecfe294">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseDerived , typename PermDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; PermDerived, SparseDerived, AliasFreeProduct &gt; Eigen::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_permutation_base.html">PermutationBase</a>&lt; PermDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; SparseDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the matrix with the permutation applied to the rows </dd></dl>

</div>
</div>
<a id="a5a5e3648914dc76efaeec71a7093601d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5e3648914dc76efaeec71a7093601d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PermutationDerived , typename MatrixDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_DEVICE_FUNC <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; PermutationDerived, MatrixDerived, AliasFreeProduct &gt; Eigen::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_permutation_base.html">PermutationBase</a>&lt; PermutationDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the matrix with the permutation applied to the rows. </dd></dl>

</div>
</div>
<a id="ad6d3d00588ad602b9d64755ab14ac2f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d3d00588ad602b9d64755ab14ac2f0">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseDerived , typename PermutationType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; SparseDerived, <a class="el" href="class_eigen_1_1_inverse.html">Inverse</a>&lt; PermutationType &gt;, AliasFreeProduct &gt; Eigen::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; SparseDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_inverse_impl.html">InverseImpl</a>&lt; PermutationType, <a class="el" href="struct_eigen_1_1_permutation_storage.html">PermutationStorage</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tperm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the matrix with the inverse permutation applied to the columns. </dd></dl>

</div>
</div>
<a id="ad798a8be8b0c5f94a29b119898d8d83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad798a8be8b0c5f94a29b119898d8d83d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseDerived , typename PermDerived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; SparseDerived, PermDerived, AliasFreeProduct &gt; Eigen::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_matrix_base.html">SparseMatrixBase</a>&lt; SparseDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_permutation_base.html">PermutationBase</a>&lt; PermDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>perm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the matrix with the permutation applied to the columns </dd></dl>

</div>
</div>
<a id="a10fac68e0747d8acfb7c102ff5bab3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10fac68e0747d8acfb7c102ff5bab3c6">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TranspositionsDerived , typename MatrixDerived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_DEVICE_FUNC <a class="el" href="class_eigen_1_1_product.html">Product</a>&lt; TranspositionsDerived, MatrixDerived, AliasFreeProduct &gt; Eigen::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_transpositions_base.html">TranspositionsBase</a>&lt; TranspositionsDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>transpositions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; MatrixDerived &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the <em>matrix</em> with the <em>transpositions</em> applied to the rows. </dd></dl>

</div>
</div>
<a id="adb64ffddaa9e83634e3ab0e3fd3664f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb64ffddaa9e83634e3ab0e3fd3664f5">&#9670;&nbsp;</a></span>poly_eval()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Polynomials , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_triplet.html">T</a> Eigen::poly_eval </td>
          <td>(</td>
          <td class="paramtype">const Polynomials &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the evaluation of the polynomial at x using stabilized Horner algorithm.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>: the vector of coefficients of the polynomial ordered by degrees i.e. poly[i] is the coefficient of degree i of the polynomial e.g. <img class="formulaInl" alt="$ 1 + 3x^2 $" src="form_262.png"/> is stored as a vector <img class="formulaInl" alt="$ [ 1, 0, 3 ] $" src="form_263.png"/>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: the value to evaluate the polynomial at. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aadbf059bc28ce1cf94c57c1454633d40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadbf059bc28ce1cf94c57c1454633d40">&#9670;&nbsp;</a></span>poly_eval_horner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Polynomials , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_triplet.html">T</a> Eigen::poly_eval_horner </td>
          <td>(</td>
          <td class="paramtype">const Polynomials &amp;&#160;</td>
          <td class="paramname"><em>poly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_triplet.html">T</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the evaluation of the polynomial at x using Horner algorithm.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">poly</td><td>: the vector of coefficients of the polynomial ordered by degrees i.e. poly[i] is the coefficient of degree i of the polynomial e.g. <img class="formulaInl" alt="$ 1 + 3x^2 $" src="form_262.png"/> is stored as a vector <img class="formulaInl" alt="$ [ 1, 0, 3 ] $" src="form_263.png"/>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">x</td><td>: the value to evaluate the polynomial at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>for stability: <img class="formulaInl" alt="$ |x| \le 1 $" src="form_264.png"/> </dd></dl>

</div>
</div>
<a id="a14d90365829589b236773f3dffd2b9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d90365829589b236773f3dffd2b9e7">&#9670;&nbsp;</a></span>polygamma()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedN , typename DerivedX &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">Eigen::CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__polygamma__op.html">Eigen::internal::scalar_polygamma_op</a>&lt; typename DerivedX::Scalar &gt;, const DerivedN, const DerivedX &gt; Eigen::polygamma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; DerivedN &gt; &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\cpp11 </p><dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise polygamma(<em>n</em>, <em>x</em>) to the given arrays.</dd></dl>
<p>It returns the <em>n</em> -th derivative of the digamma(psi) evaluated at <code>x</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types in c++11 mode. To support other scalar types, or float/double in non c++11 mode, the user has to provide implementations of polygamma(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>Eigen::digamma() </dd></dl>

</div>
</div>
<a id="a9489ae63302dfd33d4560c5377ead43f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9489ae63302dfd33d4560c5377ead43f">&#9670;&nbsp;</a></span>randomPermutationVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename PermutationVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::randomPermutationVector </td>
          <td>(</td>
          <td class="paramtype">PermutationVectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate random permutation vector.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">PermutationVectorType</td><td>type of vector used to store permutation </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>permutation vector </td></tr>
    <tr><td class="paramname">size</td><td>length of permutation vector </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afbc3648f7ef67db3d5d04454fc1257fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc3648f7ef67db3d5d04454fc1257fd">&#9670;&nbsp;</a></span>roots_to_monicPolynomial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RootVector , typename Polynomial &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::roots_to_monicPolynomial </td>
          <td>(</td>
          <td class="paramtype">const RootVector &amp;&#160;</td>
          <td class="paramname"><em>rv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Polynomial &amp;&#160;</td>
          <td class="paramname"><em>poly</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the roots of a polynomial compute the coefficients in the monomial basis of the monic polynomial with same roots and minimal degree. If RootVector is a vector of complexes, Polynomial should also be a vector of complexes. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rv</td><td>: a vector containing the roots of a polynomial. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">poly</td><td>: the vector of coefficients of the polynomial ordered by degrees i.e. poly[i] is the coefficient of degree i of the polynomial e.g. <img class="formulaInl" alt="$ 3 + x^2 $" src="form_265.png"/> is stored as a vector <img class="formulaInl" alt="$ [ 3, 0, 1 ] $" src="form_266.png"/>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fb05f2dfd1e1974dc016cff6f349f98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb05f2dfd1e1974dc016cff6f349f98">&#9670;&nbsp;</a></span>run()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Eigen::run </td>
          <td>(</td>
          <td class="paramtype">Kernel&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(kernel(args...))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs a kernel on the GPU (if EIGEN_GPUCC), or CPU otherwise.</p>
<p>This is to better support creating generic tests.</p>
<p>The kernel must be able to be passed directly as an input to a global function (i.e. empty or POD). Its inputs must be "Serializable" so we can transfer them to the device, and the output must be a Serializable value type so it can be transferred back from the device.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernel</td><td>kernel to run. </td></tr>
    <tr><td class="paramname">args</td><td>... input arguments, must be "Serializable". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kernel(args...). </dd></dl>

</div>
</div>
<a id="a363009311edea9cf1cb642b946518cbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363009311edea9cf1cb642b946518cbc">&#9670;&nbsp;</a></span>run_on_cpu()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Eigen::run_on_cpu </td>
          <td>(</td>
          <td class="paramtype">Kernel&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(kernel(args...))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs a kernel on the CPU, returning the results. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernel</td><td>kernel to run. </td></tr>
    <tr><td class="paramname">args</td><td>... input arguments. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kernel(args...). </dd></dl>

</div>
</div>
<a id="aeda1bc37ca9b370036cce59a96be00c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda1bc37ca9b370036cce59a96be00c1">&#9670;&nbsp;</a></span>run_with_hint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Kernel , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto Eigen::run_with_hint </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_capacity_hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Kernel&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; decltype(kernel(args...))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Runs a kernel on the GPU (if EIGEN_GPUCC), or CPU otherwise.</p>
<p>This version allows specifying a minimum buffer capacity size required for serializing the puts to transfer results from device to host. Use this when <code>run(...)</code> fails to determine an appropriate capacity by default.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer_capacity_hint</td><td>minimum required buffer size for serializing outputs. </td></tr>
    <tr><td class="paramname">kernel</td><td>kernel to run. </td></tr>
    <tr><td class="paramname">args</td><td>... input arguments, must be "Serializable". </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>kernel(args...). </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_eigen.html#a1fb05f2dfd1e1974dc016cff6f349f98">run</a> </dd></dl>

</div>
</div>
<a id="a33d673f7e2dfee413dec4395a6a40f46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d673f7e2dfee413dec4395a6a40f46">&#9670;&nbsp;</a></span>saveMarket()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparseMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Eigen::saveMarket </td>
          <td>(</td>
          <td class="paramtype">const SparseMatrixType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sym</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>writes a sparse <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> to a marketmarket format file </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">SparseMatrixType</td><td>to write to file </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>matrix to write to file </td></tr>
    <tr><td class="paramname">filename</td><td>filename to write to </td></tr>
    <tr><td class="paramname">sym</td><td>at the moment no symmetry operations are supported </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if writing succeeded </dd></dl>

</div>
</div>
<a id="acdbbd2f4dd378bd63e67163e907e5861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbbd2f4dd378bd63e67163e907e5861">&#9670;&nbsp;</a></span>saveMarketDense()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DenseType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool Eigen::saveMarketDense </td>
          <td>(</td>
          <td class="paramtype">const DenseType &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>writes a dense <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a> or vector to a marketmarket format file </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">DenseMatrixType</td><td>to write to file </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mat</td><td>matrix to write to file </td></tr>
    <tr><td class="paramname">filename</td><td>filename to write to </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if writing succeeded </dd></dl>

</div>
</div>
<a id="ac8f5797ba6804cc1d4b0c8c62da3e3d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f5797ba6804cc1d4b0c8c62da3e3d7">&#9670;&nbsp;</a></span>Scaling() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_eigen_1_1_diagonal_wrapper.html">DiagonalWrapper</a>&lt; const Derived &gt; Eigen::Scaling </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an axis aligned scaling expression from vector expression <em>coeffs</em> This is an alias for coeffs.asDiagonal() </p>

</div>
</div>
<a id="ab76ae94fe10ce570fbd130bd6c7ab06d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76ae94fe10ce570fbd130bd6c7ab06d">&#9670;&nbsp;</a></span>Scaling() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_diagonal_matrix.html">DiagonalMatrix</a>&lt; Scalar, 2 &gt; Eigen::Scaling </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a 2D axis aligned scaling </p>

</div>
</div>
<a id="acaf9cb32919d0a51876e0d204d2af475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaf9cb32919d0a51876e0d204d2af475">&#9670;&nbsp;</a></span>Scaling() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_diagonal_matrix.html">DiagonalMatrix</a>&lt; Scalar, 3 &gt; Eigen::Scaling </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>sy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>sz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a 3D axis aligned scaling </p>

</div>
</div>
<a id="a97769767c20f843fc8c60421dcf0fd45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97769767c20f843fc8c60421dcf0fd45">&#9670;&nbsp;</a></span>Scaling() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_uniform_scaling.html">UniformScaling</a>&lt; std::complex&lt; RealScalar &gt; &gt; Eigen::Scaling </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; RealScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a uniform scaling from scale factor <em>s</em> </p>

</div>
</div>
<a id="a86bf75d7fd4a67bf9c2c7354d8e5e2af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86bf75d7fd4a67bf9c2c7354d8e5e2af">&#9670;&nbsp;</a></span>Scaling() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_uniform_scaling.html">UniformScaling</a>&lt; double &gt; Eigen::Scaling </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a uniform scaling from scale factor <em>s</em> </p>

</div>
</div>
<a id="a23a8ed57e3f2973526026765ae697761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a8ed57e3f2973526026765ae697761">&#9670;&nbsp;</a></span>Scaling() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_uniform_scaling.html">UniformScaling</a>&lt; float &gt; Eigen::Scaling </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a uniform scaling from scale factor <em>s</em> </p>

</div>
</div>
<a id="a8945614275f33d8679c0f6f648073986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8945614275f33d8679c0f6f648073986">&#9670;&nbsp;</a></span>Scaling() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_diagonal_wrapper.html">DiagonalWrapper</a>&lt; const Derived &gt;::PlainObject Eigen::Scaling </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>coeffs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an axis aligned scaling expression from vector <em>coeffs</em> when passed as an rvalue reference </p>

</div>
</div>
<a id="a5e2b47604fbd83f8e88849a371eb0a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2b47604fbd83f8e88849a371eb0a8f">&#9670;&nbsp;</a></span>seqN() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FirstType , typename SizeType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_arithmetic_sequence.html">ArithmeticSequence</a>&lt; typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; FirstType &gt;::type, typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; SizeType &gt;::type &gt; Eigen::seqN </td>
          <td>(</td>
          <td class="paramtype">FirstType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="class_eigen_1_1_arithmetic_sequence.html">ArithmeticSequence</a> starting at <em>first</em>, of length <em>size</em>, and unit increment</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_eigen.html#a3a3c346d2a61d1e8e86e6fb4cf57fbda">seqN(FirstType,SizeType,IncrType)</a>, seq(FirstType,LastType) </dd></dl>

</div>
</div>
<a id="a3a3c346d2a61d1e8e86e6fb4cf57fbda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a3c346d2a61d1e8e86e6fb4cf57fbda">&#9670;&nbsp;</a></span>seqN() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FirstType , typename SizeType , typename IncrType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_arithmetic_sequence.html">ArithmeticSequence</a>&lt; typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; FirstType &gt;::type, typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__index__type.html">internal::cleanup_index_type</a>&lt; SizeType &gt;::type, typename <a class="el" href="struct_eigen_1_1internal_1_1cleanup__seq__incr.html">internal::cleanup_seq_incr</a>&lt; IncrType &gt;::type &gt; Eigen::seqN </td>
          <td>(</td>
          <td class="paramtype">FirstType&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SizeType&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IncrType&#160;</td>
          <td class="paramname"><em>incr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an <a class="el" href="class_eigen_1_1_arithmetic_sequence.html">ArithmeticSequence</a> starting at <em>first</em>, of length <em>size</em>, and increment <em>incr</em> </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_eigen.html#a5e2b47604fbd83f8e88849a371eb0a8f">seqN(FirstType,SizeType)</a>, seq(FirstType,LastType,IncrType) </dd></dl>

</div>
</div>
<a id="a7f7b2bfe22ad05393d50a81c13f7352a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7b2bfe22ad05393d50a81c13f7352a">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE uint8_t * Eigen::serialize </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Serialize a set of values to the byte buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>output byte buffer; if this is nullptr, does nothing. </td></tr>
    <tr><td class="paramname">end</td><td>the end of the output byte buffer. </td></tr>
    <tr><td class="paramname">args</td><td>... arguments to serialize in sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the next address after all serialized values. </dd></dl>

</div>
</div>
<a id="abe8ad90d69bf6d7d3fa04fd5ac69938b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8ad90d69bf6d7d3fa04fd5ac69938b">&#9670;&nbsp;</a></span>serialize_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">EIGEN_DEVICE_FUNC EIGEN_STRONG_INLINE size_t Eigen::serialize_size </td>
          <td>(</td>
          <td class="paramtype">const Args &amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the buffer size required to serialize a set of values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>... arguments to serialize in sequence. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the total size of the required buffer. </dd></dl>

</div>
</div>
<a id="ae64421554aa0a4bf9258bafe3170102b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64421554aa0a4bf9258bafe3170102b">&#9670;&nbsp;</a></span>setCpuCacheSizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::setCpuCacheSizes </td>
          <td>(</td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>l1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>l2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ptrdiff_t&#160;</td>
          <td class="paramname"><em>l3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the cpu L1 and L2 cache sizes (in bytes). These values are use to adjust the size of the blocks for the algorithms working per blocks.</p>
<dl class="section see"><dt>See also</dt><dd>computeProductBlockingSizes </dd></dl>

</div>
</div>
<a id="af9cd17c2fe18204239cd11c88c120b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9cd17c2fe18204239cd11c88c120b50">&#9670;&nbsp;</a></span>setNbThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Eigen::setNbThreads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the max number of threads reserved for <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespace_eigen.html#a9aca97d83e21b91a04ec079360dfffeb">nbThreads</a> </dd></dl>

</div>
</div>
<a id="a9e897919aefe17f42d3e08a3670d6e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e897919aefe17f42d3e08a3670d6e7d">&#9670;&nbsp;</a></span>setupRandomSvs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType , typename RealScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_vector_type.html">VectorType</a> Eigen::setupRandomSvs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setup a vector of random singular values with prescribed upper limit. For use with <a class="el" href="namespace_eigen.html#af9581b8fef58e77009b9c07137d8fa4d">generateRandomMatrixSvs()</a>.</p>
<p>Singular values are non-negative real values. By convention (to be consistent with singular value decomposition) we sort them in decreasing order.</p>
<p>This strategy produces random singular values in the range [0, max], in particular the singular values can be zero or arbitrarily close to zero.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_vector_type.html">VectorType</a></td><td>vector type with real entries used for singular values </td></tr>
    <tr><td class="paramname">RealScalar</td><td>data type used for real entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>number of singular values to generate </td></tr>
    <tr><td class="paramname">max</td><td>upper bound for singular values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of singular values </dd></dl>

</div>
</div>
<a id="aeb6d3938c26e96ae1837bfcacda0cd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6d3938c26e96ae1837bfcacda0cd77">&#9670;&nbsp;</a></span>setupRangeSvs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType , typename RealScalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_vector_type.html">VectorType</a> Eigen::setupRangeSvs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_eigen.html#a62e77e0933482dafde8fe197d9a2cfde">Index</a>&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar&#160;</td>
          <td class="paramname"><em>min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RealScalar&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setup a vector of random singular values with prescribed range. For use with <a class="el" href="namespace_eigen.html#af9581b8fef58e77009b9c07137d8fa4d">generateRandomMatrixSvs()</a>.</p>
<p>Singular values are non-negative real values. By convention (to be consistent with singular value decomposition) we sort them in decreasing order.</p>
<p>For dim &gt; 1 this strategy generates a vector with largest entry max, smallest entry min, and remaining entries in the range [min, max]. For dim == 1 the only entry is min.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname"><a class="el" href="struct_vector_type.html">VectorType</a></td><td>vector type with real entries used for singular values </td></tr>
    <tr><td class="paramname">RealScalar</td><td>data type used for real entry </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dim</td><td>number of singular values to generate </td></tr>
    <tr><td class="paramname">min</td><td>smallest singular value to use </td></tr>
    <tr><td class="paramname">max</td><td>largest singular value to use </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of singular values </dd></dl>

</div>
</div>
<a id="af0a1848d39c84d0b57c1e7cb2f9b370e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a1848d39c84d0b57c1e7cb2f9b370e">&#9670;&nbsp;</a></span>viewAsCholmod() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename Index_ , unsigned int UpLo&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cholmod_sparse Eigen::viewAsCholmod </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_sparse_self_adjoint_view.html">SparseSelfAdjointView</a>&lt; const <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar_, Options_, Index_ &gt;, UpLo &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a view of the <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> sparse matrix <em>mat</em> as Cholmod sparse matrix. The data are not copied but shared. </p>

</div>
</div>
<a id="a92fe7b595099051fa1d1c443641a6de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fe7b595099051fa1d1c443641a6de3">&#9670;&nbsp;</a></span>viewAsCholmod() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Derived &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cholmod_dense Eigen::viewAsCholmod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_matrix_base.html">MatrixBase</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a view of the <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> <b>dense</b> matrix <em>mat</em> as Cholmod dense matrix. The data are not copied but shared. </p>

</div>
</div>
<a id="a7794e77d4be556d1c965842e227bd572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7794e77d4be556d1c965842e227bd572">&#9670;&nbsp;</a></span>viewAsCholmod() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar_ , int Options_, typename StorageIndex_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">cholmod_sparse Eigen::viewAsCholmod </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_eigen_1_1_ref.html">Ref</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar_, Options_, StorageIndex_ &gt; &gt;&#160;</td>
          <td class="paramname"><em>mat</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wraps the <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> sparse matrix <em>mat</em> into a Cholmod sparse matrix object. Note that the data are shared. </p>

</div>
</div>
<a id="a2d422271b7edea7b672998eeb3260521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d422271b7edea7b672998eeb3260521">&#9670;&nbsp;</a></span>viewAsEigen()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar , int Flags, typename StorageIndex &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_eigen_1_1_map.html">Map</a>&lt; <a class="el" href="class_eigen_1_1_sparse_matrix.html">SparseMatrix</a>&lt; Scalar, Flags, StorageIndex &gt; &gt; Eigen::viewAsEigen </td>
          <td>(</td>
          <td class="paramtype">cholmod_sparse &amp;&#160;</td>
          <td class="paramname"><em>cm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a view of the Cholmod sparse matrix <em>cm</em> as an <a class="el" href="namespace_eigen.html" title="Namespace containing all symbols from the Eigen library.">Eigen</a> sparse matrix. The data are not copied but shared. </p>

</div>
</div>
<a id="a2072d7b2bb8a3d5fa972dc364d973426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2072d7b2bb8a3d5fa972dc364d973426">&#9670;&nbsp;</a></span>zeta()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename DerivedX , typename DerivedQ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_STRONG_INLINE <a class="el" href="class_eigen_1_1_cwise_binary_op.html">Eigen::CwiseBinaryOp</a>&lt; <a class="el" href="struct_eigen_1_1internal_1_1scalar__zeta__op.html">Eigen::internal::scalar_zeta_op</a>&lt; typename DerivedX::Scalar &gt;, const DerivedX, const DerivedQ &gt; Eigen::zeta </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; DerivedX &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; DerivedQ &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>an expression of the coefficient-wise zeta(<em>x</em>, <em>q</em>) to the given arrays.</dd></dl>
<p>It returns the Riemann zeta function of two arguments <em>x</em> and <em>q:</em> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>is the exponent, it must be &gt; 1 </td></tr>
    <tr><td class="paramname">q</td><td>is the shift, it must be &gt; 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function supports only float and double scalar types. To support other scalar types, the user has to provide implementations of zeta(T,T) for any scalar type T to be supported.</dd></dl>
<dl class="section see"><dt>See also</dt><dd>ArrayBase::zeta() </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ad81fa7195215a0ce30017dfac309f0b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81fa7195215a0ce30017dfac309f0b2">&#9670;&nbsp;</a></span>Dynamic</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Eigen::Dynamic = -1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This value means that a positive quantity (e.g., a size) is not known at compile-time, and that instead the value is stored in some runtime variable.</p>
<p>Changing the value of Dynamic breaks the ABI, as Dynamic is often used as a template parameter for <a class="el" href="class_eigen_1_1_matrix.html" title="The matrix class, also used for vectors and row-vectors.">Matrix</a>. </p>

</div>
</div>
<a id="a73c597189a4a99127175e8167c456fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c597189a4a99127175e8167c456fff">&#9670;&nbsp;</a></span>DynamicIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Eigen::DynamicIndex = 0xffffff</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This value means that a signed quantity (e.g., a signed index) is not known at compile-time, and that instead its value has to be specified at runtime. </p>

</div>
</div>
<a id="aad94bff6c8d08a5edaf5a39694e5345e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad94bff6c8d08a5edaf5a39694e5345e">&#9670;&nbsp;</a></span>exponents</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const EIGEN_DEVICE_FUNC const <a class="el" href="class_eigen_1_1_array_base.html">Eigen::ArrayBase</a>&lt; Derived &gt; &amp; Eigen::exponents</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::promote_scalar_arg&lt;<span class="keyword">typename</span> Derived::Scalar,Scalar,</div>
<div class="line">                                                  EIGEN_SCALAR_BINARY_SUPPORTED(<a class="code" href="class_eigen_1_1_array_base.html#a4a9e4af07bde9d8cef614976b30aa2bd">pow</a>,Scalar,<span class="keyword">typename</span> Derived::Scalar)&gt;::type PromotedScalar</div>
</div><!-- fragment -->
</div>
</div>
<a id="a297729d26fa056b10e9d8d5d088b12e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a297729d26fa056b10e9d8d5d088b12e6">&#9670;&nbsp;</a></span>HereditaryBits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int Eigen::HereditaryBits</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= <a class="code" href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">RowMajorBit</a></div>
<div class="line">                                  | <a class="code" href="group__flags.html#gaa34e83bae46a8eeae4e69ebe3aaecbed">EvalBeforeNestingBit</a></div>
</div><!-- fragment -->
</div>
</div>
<a id="a3163430a1c13173faffde69016b48aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3163430a1c13173faffde69016b48aaf">&#9670;&nbsp;</a></span>HugeCost</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Eigen::HugeCost = 10000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This value means that the cost to evaluate an expression coefficient is either very expensive or cannot be known at compile time.</p>
<p>This value has to be positive to (1) simplify cost computation, and (2) allow to distinguish between a very expensive and very very expensive expressions. It thus must also be large enough to make sure unrolling won't happen and that sub expressions will be evaluated, but not too large to avoid overflow. </p>

</div>
</div>
<a id="a7951593b031e13d90223c83d022ce99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7951593b031e13d90223c83d022ce99e">&#9670;&nbsp;</a></span>Infinity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Eigen::Infinity = -1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This value means +Infinity; it is currently used only as the p parameter to MatrixBase::lpNorm&lt;int&gt;(). The value Infinity there means the L-infinity norm. </p>

</div>
</div>
<a id="a06808a853a9baa38b23a5368e7491abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06808a853a9baa38b23a5368e7491abd">&#9670;&nbsp;</a></span>UndefinedIncr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int Eigen::UndefinedIncr = 0xfffffe</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This value means that the increment to go from one value to another in a sequence is not constant for each step. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aclass_eigen_1_1_matrix_html"><div class="ttname"><a href="class_eigen_1_1_matrix.html">Eigen::Matrix</a></div><div class="ttdoc">The matrix class, also used for vectors and row-vectors.</div><div class="ttdef"><b>Definition:</b> Matrix.h:180</div></div>
<div class="ttc" id="agroup__flags_html_gae4f56c2a60bbe4bd2e44c5b19cbe8762"><div class="ttname"><a href="group__flags.html#gae4f56c2a60bbe4bd2e44c5b19cbe8762">Eigen::RowMajorBit</a></div><div class="ttdeci">const unsigned int RowMajorBit</div><div class="ttdef"><b>Definition:</b> Constants.h:68</div></div>
<div class="ttc" id="aclass_eigen_1_1_array_base_html_a4a9e4af07bde9d8cef614976b30aa2bd"><div class="ttname"><a href="class_eigen_1_1_array_base.html#a4a9e4af07bde9d8cef614976b30aa2bd">Eigen::ArrayBase::pow</a></div><div class="ttdeci">const EIGEN_DEVICE_FUNC GlobalUnaryPowReturnType&lt; Derived, ScalarExponent &gt; pow(const Eigen::ArrayBase&lt; Derived &gt; &amp;x, const ScalarExponent &amp;exponent)</div><div class="ttdef"><b>Definition:</b> GlobalFunctions.h:125</div></div>
<div class="ttc" id="anamespace_eigen_html_aedd4b7cd1e324ed0769cac2701f4d050"><div class="ttname"><a href="namespace_eigen.html#aedd4b7cd1e324ed0769cac2701f4d050">Eigen::kroneckerProduct</a></div><div class="ttdeci">KroneckerProduct&lt; A, B &gt; kroneckerProduct(const MatrixBase&lt; A &gt; &amp;a, const MatrixBase&lt; B &gt; &amp;b)</div><div class="ttdef"><b>Definition:</b> KroneckerTensorProduct.h:273</div></div>
<div class="ttc" id="agroup__flags_html_gaa34e83bae46a8eeae4e69ebe3aaecbed"><div class="ttname"><a href="group__flags.html#gaa34e83bae46a8eeae4e69ebe3aaecbed">Eigen::EvalBeforeNestingBit</a></div><div class="ttdeci">const unsigned int EvalBeforeNestingBit</div><div class="ttdef"><b>Definition:</b> Constants.h:72</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
