<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: SkCanvas Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_sk_canvas-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SkCanvas Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_sk_canvas_8h_source.html">SkCanvas.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SkCanvas:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_sk_canvas.png" usemap="#SkCanvas_map" alt=""/>
  <map id="SkCanvas_map" name="SkCanvas_map">
<area href="class_sk_canvas_virtual_enforcer.html" alt="SkCanvasVirtualEnforcer&lt; SkCanvas &gt;" shape="rect" coords="439,56,722,80"/>
<area href="class_sk_no_draw_canvas.html" alt="SkNoDrawCanvas" shape="rect" coords="293,112,576,136"/>
<area href="class_sk_picture_record.html" alt="SkPictureRecord" shape="rect" coords="586,112,869,136"/>
<area href="class_sk_canvas_virtual_enforcer.html" alt="SkCanvasVirtualEnforcer&lt; SkNoDrawCanvas &gt;" shape="rect" coords="293,168,576,192"/>
<area href="class_sk_n_way_canvas.html" alt="SkNWayCanvas" shape="rect" coords="146,224,429,248"/>
<area href="class_sk_recorder.html" alt="SkRecorder" shape="rect" coords="439,224,722,248"/>
<area href="class_sk_canvas_stack.html" alt="SkCanvasStack" shape="rect" coords="0,280,283,304"/>
<area href="class_sk_canvas_virtual_enforcer.html" alt="SkCanvasVirtualEnforcer&lt; SkNWayCanvas &gt;" shape="rect" coords="293,280,576,304"/>
<area href="class_sk_overdraw_canvas.html" alt="SkOverdrawCanvas" shape="rect" coords="146,336,429,360"/>
<area href="class_sk_paint_filter_canvas.html" alt="SkPaintFilterCanvas" shape="rect" coords="439,336,722,360"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas_1_1_auto_update_q_r_bounds.html">AutoUpdateQRBounds</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_canvas_1_1_image_set_entry.html">ImageSetEntry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_canvas_1_1_lattice.html">Lattice</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_canvas_1_1_save_layer_rec.html">SaveLayerRec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abe5a2c0555b29ae161ae5d4f102183a5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#abe5a2c0555b29ae161ae5d4f102183a5">SaveLayerFlagsSet</a> { <b>kPreserveLCDText_SaveLayerFlag</b> = 1 &lt;&lt; 1, 
<a class="el" href="class_sk_canvas.html#abe5a2c0555b29ae161ae5d4f102183a5a6b717db5f1a0cffb43d24b994ab47ea2">kInitWithPrevious_SaveLayerFlag</a> = 1 &lt;&lt; 2, 
<a class="el" href="class_sk_canvas.html#abe5a2c0555b29ae161ae5d4f102183a5a5d9a15538ae26733f9239c750128251f">kMaskAgainstCoverage_EXPERIMENTAL_DONT_USE_SaveLayerFlag</a>, 
<b>kF16ColorType</b> = 1 &lt;&lt; 4
 }</td></tr>
<tr class="separator:abe5a2c0555b29ae161ae5d4f102183a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1bcd412326a6886e0f260d4d2dc757b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757b">PointMode</a> { <a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757baf596e2b9e5758fc2e5bc8dbdbc191e01">kPoints_PointMode</a>, 
<a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757ba31b9758602c729b8e0fc9b7fac2ac0df">kLines_PointMode</a>, 
<a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757baa1fb56deddeccfc67fca4a7859d24480">kPolygon_PointMode</a>
 }</td></tr>
<tr class="separator:af1bcd412326a6886e0f260d4d2dc757b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8997239ed4fd8e08bf4b66b3f6eeb40c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a8997239ed4fd8e08bf4b66b3f6eeb40c">SrcRectConstraint</a> { <a class="el" href="class_sk_canvas.html#a8997239ed4fd8e08bf4b66b3f6eeb40ca33a44e18142c9cd28f2b76b7d5f7bc9e">kStrict_SrcRectConstraint</a>, 
<a class="el" href="class_sk_canvas.html#a8997239ed4fd8e08bf4b66b3f6eeb40cacad134f1b0dda4f919f5df87aa0b72bf">kFast_SrcRectConstraint</a>
 }</td></tr>
<tr class="separator:a8997239ed4fd8e08bf4b66b3f6eeb40c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71b7245651dfa4a873a23336fafec48"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#af71b7245651dfa4a873a23336fafec48">QuadAAFlags</a> : unsigned { <br />
&#160;&#160;<b>kLeft_QuadAAFlag</b> = 0b0001, 
<b>kTop_QuadAAFlag</b> = 0b0010, 
<b>kRight_QuadAAFlag</b> = 0b0100, 
<b>kBottom_QuadAAFlag</b> = 0b1000, 
<br />
&#160;&#160;<b>kNone_QuadAAFlags</b> = 0b0000, 
<b>kAll_QuadAAFlags</b> = 0b1111
<br />
 }</td></tr>
<tr class="separator:af71b7245651dfa4a873a23336fafec48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa178674c37b7afc960822390abf1e91c"><td class="memItemLeft" align="right" valign="top"><a id="aa178674c37b7afc960822390abf1e91c"></a>
typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><b>SaveLayerFlags</b></td></tr>
<tr class="separator:aa178674c37b7afc960822390abf1e91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afa6f6d23671e32a48715386609d77385"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#afa6f6d23671e32a48715386609d77385">SkCanvas</a> ()</td></tr>
<tr class="separator:afa6f6d23671e32a48715386609d77385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adec6d012527048422c0bfa76b3e5b13e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#adec6d012527048422c0bfa76b3e5b13e">SkCanvas</a> (int width, int height, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *props=nullptr)</td></tr>
<tr class="separator:adec6d012527048422c0bfa76b3e5b13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac755dcfa14d0af6146cacfab0d6ec2cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ac755dcfa14d0af6146cacfab0d6ec2cf">SkCanvas</a> (<a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_base_device.html">SkBaseDevice</a> &gt; device)</td></tr>
<tr class="separator:ac755dcfa14d0af6146cacfab0d6ec2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6966c7d203c37df6f3c21f27a4da0d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#af6966c7d203c37df6f3c21f27a4da0d6">SkCanvas</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;bitmap)</td></tr>
<tr class="separator:af6966c7d203c37df6f3c21f27a4da0d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4a5fa0689ec0a9157946a0fe5aed86"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a7d4a5fa0689ec0a9157946a0fe5aed86">SkCanvas</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;bitmap, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> &amp;props)</td></tr>
<tr class="separator:a7d4a5fa0689ec0a9157946a0fe5aed86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50760a90eee83469a2a5814fb8be47ec"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a50760a90eee83469a2a5814fb8be47ec">~SkCanvas</a> ()</td></tr>
<tr class="separator:a50760a90eee83469a2a5814fb8be47ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8a74b34be1cefa29eac1ab7a1c6727"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_image_info.html">SkImageInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo</a> () const</td></tr>
<tr class="separator:aef8a74b34be1cefa29eac1ab7a1c6727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc56d1e844b40c50753429d7dd22b9a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a0cc56d1e844b40c50753429d7dd22b9a">getProps</a> (<a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *props) const</td></tr>
<tr class="separator:a0cc56d1e844b40c50753429d7dd22b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8ea661c6021dc4dde325aab87870bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a3f8ea661c6021dc4dde325aab87870bf">flush</a> ()</td></tr>
<tr class="separator:a3f8ea661c6021dc4dde325aab87870bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bf0f33cbdde5b0c90a2395d1ba14a8b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_sk_i_size.html">SkISize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a6bf0f33cbdde5b0c90a2395d1ba14a8b">getBaseLayerSize</a> () const</td></tr>
<tr class="separator:a6bf0f33cbdde5b0c90a2395d1ba14a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3254c3d33588ec4d617ea0d84abd1f38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a3254c3d33588ec4d617ea0d84abd1f38">makeSurface</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;info, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *props=nullptr)</td></tr>
<tr class="separator:a3254c3d33588ec4d617ea0d84abd1f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782b0cb2e900fb95fb2a0246e090a8a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a782b0cb2e900fb95fb2a0246e090a8a3">recordingContext</a> ()</td></tr>
<tr class="separator:a782b0cb2e900fb95fb2a0246e090a8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e6944f5f854b2b2c47b9a06aed6645"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_surface.html">SkSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a16e6944f5f854b2b2c47b9a06aed6645">getSurface</a> () const</td></tr>
<tr class="separator:a16e6944f5f854b2b2c47b9a06aed6645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af193f800a689be20669120395dc8e472"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#af193f800a689be20669120395dc8e472">accessTopLayerPixels</a> (<a class="el" href="struct_sk_image_info.html">SkImageInfo</a> *info, size_t *rowBytes, <a class="el" href="struct_sk_i_point.html">SkIPoint</a> *origin=nullptr)</td></tr>
<tr class="separator:af193f800a689be20669120395dc8e472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12a09e49fc7bb86c7b30c1c56433e286"><td class="memItemLeft" align="right" valign="top">SkRasterHandleAllocator::Handle&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a12a09e49fc7bb86c7b30c1c56433e286">accessTopRasterHandle</a> () const</td></tr>
<tr class="separator:a12a09e49fc7bb86c7b30c1c56433e286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da746e87186d5e3fc0b4838f782e1c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a1da746e87186d5e3fc0b4838f782e1c4">peekPixels</a> (<a class="el" href="class_sk_pixmap.html">SkPixmap</a> *pixmap)</td></tr>
<tr class="separator:a1da746e87186d5e3fc0b4838f782e1c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af267c56757f886aaae2d0876161141b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#af267c56757f886aaae2d0876161141b1">readPixels</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;dstInfo, void *dstPixels, size_t dstRowBytes, int srcX, int srcY)</td></tr>
<tr class="separator:af267c56757f886aaae2d0876161141b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a0e7a8560bf845ee9e30f6da722dcdf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a7a0e7a8560bf845ee9e30f6da722dcdf">readPixels</a> (const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> &amp;pixmap, int srcX, int srcY)</td></tr>
<tr class="separator:a7a0e7a8560bf845ee9e30f6da722dcdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d8f7b005de74e96c68dcb7ed48eb73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ae4d8f7b005de74e96c68dcb7ed48eb73">readPixels</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;bitmap, int srcX, int srcY)</td></tr>
<tr class="separator:ae4d8f7b005de74e96c68dcb7ed48eb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a65fff01806bf2381aec2d81485e773"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a4a65fff01806bf2381aec2d81485e773">writePixels</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;info, const void *pixels, size_t rowBytes, int x, int y)</td></tr>
<tr class="separator:a4a65fff01806bf2381aec2d81485e773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a586fe3d06e650f9f6debf137ab89ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a6a586fe3d06e650f9f6debf137ab89ce">writePixels</a> (const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;bitmap, int x, int y)</td></tr>
<tr class="separator:a6a586fe3d06e650f9f6debf137ab89ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98147dc771b47c7353a51e7c171e428"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ac98147dc771b47c7353a51e7c171e428">save</a> ()</td></tr>
<tr class="separator:ac98147dc771b47c7353a51e7c171e428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06bd76ce35082366bb6b8e6dfcb6f435"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a06bd76ce35082366bb6b8e6dfcb6f435">saveLayer</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> *bounds, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint)</td></tr>
<tr class="separator:a06bd76ce35082366bb6b8e6dfcb6f435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ba500cff0ee0035ea9aee097c6d5f00"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a8ba500cff0ee0035ea9aee097c6d5f00">saveLayer</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;bounds, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint)</td></tr>
<tr class="separator:a8ba500cff0ee0035ea9aee097c6d5f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853514477dff62c15ced03f5141b2eb7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a853514477dff62c15ced03f5141b2eb7">saveLayerAlpha</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> *bounds, <a class="el" href="_sk_types_8h.html#a6882636f582abdb2a130b7e5ff38aa83">U8CPU</a> alpha)</td></tr>
<tr class="separator:a853514477dff62c15ced03f5141b2eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41aa2893a587e4a371342d7ff809b0d5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a41aa2893a587e4a371342d7ff809b0d5">saveLayer</a> (const <a class="el" href="struct_sk_canvas_1_1_save_layer_rec.html">SaveLayerRec</a> &amp;layerRec)</td></tr>
<tr class="separator:a41aa2893a587e4a371342d7ff809b0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c68ed85badf62be77bb862b02dd4961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a2c68ed85badf62be77bb862b02dd4961">restore</a> ()</td></tr>
<tr class="separator:a2c68ed85badf62be77bb862b02dd4961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6fca118ff6ff1e207ed5457f118b4e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#aa6fca118ff6ff1e207ed5457f118b4e0">getSaveCount</a> () const</td></tr>
<tr class="separator:aa6fca118ff6ff1e207ed5457f118b4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae519c51173be795b59f4f4e10c67b9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#aae519c51173be795b59f4f4e10c67b9d">restoreToCount</a> (int saveCount)</td></tr>
<tr class="separator:aae519c51173be795b59f4f4e10c67b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314ca6b7393639642f44a93b2df63fdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a314ca6b7393639642f44a93b2df63fdb">translate</a> (SkScalar dx, SkScalar dy)</td></tr>
<tr class="separator:a314ca6b7393639642f44a93b2df63fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb01075c3bfab15fc3ded619961dfc15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#adb01075c3bfab15fc3ded619961dfc15">scale</a> (SkScalar sx, SkScalar sy)</td></tr>
<tr class="separator:adb01075c3bfab15fc3ded619961dfc15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaad49aba3b0c320915004e3c420a2780"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#aaad49aba3b0c320915004e3c420a2780">rotate</a> (SkScalar degrees)</td></tr>
<tr class="separator:aaad49aba3b0c320915004e3c420a2780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8897bee82cec6382b21425b5f7580d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a2f8897bee82cec6382b21425b5f7580d">rotate</a> (SkScalar degrees, SkScalar px, SkScalar py)</td></tr>
<tr class="separator:a2f8897bee82cec6382b21425b5f7580d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5049d341b5efe7a5f90207eb2f63641"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#af5049d341b5efe7a5f90207eb2f63641">skew</a> (SkScalar sx, SkScalar sy)</td></tr>
<tr class="separator:af5049d341b5efe7a5f90207eb2f63641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb493a60db8ccd84abbaa26fb9506bcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#adb493a60db8ccd84abbaa26fb9506bcf">concat</a> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;matrix)</td></tr>
<tr class="separator:adb493a60db8ccd84abbaa26fb9506bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259c22fe03b36b88dd71bcaea9b7d06f"><td class="memItemLeft" align="right" valign="top"><a id="a259c22fe03b36b88dd71bcaea9b7d06f"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>concat</b> (const <a class="el" href="class_sk_m44.html">SkM44</a> &amp;)</td></tr>
<tr class="separator:a259c22fe03b36b88dd71bcaea9b7d06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc70a1f31e2f7fc5cd5bb2537aa350e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#abdc70a1f31e2f7fc5cd5bb2537aa350e">markCTM</a> (const char *name)</td></tr>
<tr class="separator:abdc70a1f31e2f7fc5cd5bb2537aa350e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6ba7165d41350249d11c7c10353ad5"><td class="memItemLeft" align="right" valign="top"><a id="a5c6ba7165d41350249d11c7c10353ad5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>findMarkedCTM</b> (const char *name, <a class="el" href="class_sk_m44.html">SkM44</a> *) const</td></tr>
<tr class="separator:a5c6ba7165d41350249d11c7c10353ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07eb6c080bf2dbc8325e0d12d884915"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ad07eb6c080bf2dbc8325e0d12d884915">setMatrix</a> (const <a class="el" href="class_sk_m44.html">SkM44</a> &amp;matrix)</td></tr>
<tr class="separator:ad07eb6c080bf2dbc8325e0d12d884915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdf20250b659fca9581b5f683742333"><td class="memItemLeft" align="right" valign="top"><a id="abcdf20250b659fca9581b5f683742333"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setMatrix</b> (const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;matrix)</td></tr>
<tr class="separator:abcdf20250b659fca9581b5f683742333"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba129108fc68dca01850faf73d5db148"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#aba129108fc68dca01850faf73d5db148">resetMatrix</a> ()</td></tr>
<tr class="separator:aba129108fc68dca01850faf73d5db148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a193511e463259ceacfe0e4cf1be1393f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a193511e463259ceacfe0e4cf1be1393f">clipRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, SkClipOp op, bool doAntiAlias)</td></tr>
<tr class="separator:a193511e463259ceacfe0e4cf1be1393f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a407796e09a49830aa9c0339a5d89280c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a407796e09a49830aa9c0339a5d89280c">clipRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, SkClipOp op)</td></tr>
<tr class="separator:a407796e09a49830aa9c0339a5d89280c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b470e8047bf70d142cdb6c5a0d77ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a86b470e8047bf70d142cdb6c5a0d77ef">clipRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, bool doAntiAlias=false)</td></tr>
<tr class="separator:a86b470e8047bf70d142cdb6c5a0d77ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32eda3f4450837d4d3fa78cd8f0678c0"><td class="memItemLeft" align="right" valign="top"><a id="a32eda3f4450837d4d3fa78cd8f0678c0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clipIRect</b> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;irect, SkClipOp op=SkClipOp::kIntersect)</td></tr>
<tr class="separator:a32eda3f4450837d4d3fa78cd8f0678c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4048c03bae32364e8a660b5437e6a38c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a4048c03bae32364e8a660b5437e6a38c">androidFramework_setDeviceClipRestriction</a> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;rect)</td></tr>
<tr class="separator:a4048c03bae32364e8a660b5437e6a38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcefd4d2ac745ad086fd62f30bbd8564"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#afcefd4d2ac745ad086fd62f30bbd8564">clipRRect</a> (const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;rrect, SkClipOp op, bool doAntiAlias)</td></tr>
<tr class="separator:afcefd4d2ac745ad086fd62f30bbd8564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70b894a4a670bd9f7f8f49aca47c0997"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a70b894a4a670bd9f7f8f49aca47c0997">clipRRect</a> (const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;rrect, SkClipOp op)</td></tr>
<tr class="separator:a70b894a4a670bd9f7f8f49aca47c0997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b609adaa6a8bc1e65d831c2e17ec3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ab9b609adaa6a8bc1e65d831c2e17ec3d">clipRRect</a> (const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;rrect, bool doAntiAlias=false)</td></tr>
<tr class="separator:ab9b609adaa6a8bc1e65d831c2e17ec3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc79bd478516f398c31ae9f501154184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#abc79bd478516f398c31ae9f501154184">clipPath</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path, SkClipOp op, bool doAntiAlias)</td></tr>
<tr class="separator:abc79bd478516f398c31ae9f501154184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcca8a9ae91adb20f4cd3633f409410"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a7dcca8a9ae91adb20f4cd3633f409410">clipPath</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path, SkClipOp op)</td></tr>
<tr class="separator:a7dcca8a9ae91adb20f4cd3633f409410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1353983459a2a5496e4ad9bd39f37dd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a1353983459a2a5496e4ad9bd39f37dd1">clipPath</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path, bool doAntiAlias=false)</td></tr>
<tr class="separator:a1353983459a2a5496e4ad9bd39f37dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61af0be322108dae044f79e02691a55"><td class="memItemLeft" align="right" valign="top"><a id="ae61af0be322108dae044f79e02691a55"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clipShader</b> (<a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_shader.html">SkShader</a> &gt;, SkClipOp=SkClipOp::kIntersect)</td></tr>
<tr class="separator:ae61af0be322108dae044f79e02691a55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3773e18ab060b7bb4e1cfc769fb07b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a8e3773e18ab060b7bb4e1cfc769fb07b">clipRegion</a> (const <a class="el" href="class_sk_region.html">SkRegion</a> &amp;deviceRgn, SkClipOp op=SkClipOp::kIntersect)</td></tr>
<tr class="separator:a8e3773e18ab060b7bb4e1cfc769fb07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f091b4f9abb2cdefe749ad60cb1bb0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#af7f091b4f9abb2cdefe749ad60cb1bb0">quickReject</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect) const</td></tr>
<tr class="separator:af7f091b4f9abb2cdefe749ad60cb1bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7685f750ca3e98d8e4642af79b0422dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a7685f750ca3e98d8e4642af79b0422dd">quickReject</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path) const</td></tr>
<tr class="separator:a7685f750ca3e98d8e4642af79b0422dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc19266b3ac4ea8d2c7133dd2c54ad7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_rect.html">SkRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a4dc19266b3ac4ea8d2c7133dd2c54ad7">getLocalClipBounds</a> () const</td></tr>
<tr class="separator:a4dc19266b3ac4ea8d2c7133dd2c54ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f383a6c415bb12d78d111a2cc799f1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a5f383a6c415bb12d78d111a2cc799f1e">getLocalClipBounds</a> (<a class="el" href="struct_sk_rect.html">SkRect</a> *bounds) const</td></tr>
<tr class="separator:a5f383a6c415bb12d78d111a2cc799f1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd88df53c84d457aa08ddacc944468bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_i_rect.html">SkIRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#abd88df53c84d457aa08ddacc944468bf">getDeviceClipBounds</a> () const</td></tr>
<tr class="separator:abd88df53c84d457aa08ddacc944468bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4edc7c11810980f012551bc65124395"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#aa4edc7c11810980f012551bc65124395">getDeviceClipBounds</a> (<a class="el" href="struct_sk_i_rect.html">SkIRect</a> *bounds) const</td></tr>
<tr class="separator:aa4edc7c11810980f012551bc65124395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0017c7afd5dd3cbb6352f7b1c92084"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a3b0017c7afd5dd3cbb6352f7b1c92084">drawColor</a> (<a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a> color, SkBlendMode mode=SkBlendMode::kSrcOver)</td></tr>
<tr class="separator:a3b0017c7afd5dd3cbb6352f7b1c92084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e9e3ac4ff51408f6311dda19c5c475"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a81e9e3ac4ff51408f6311dda19c5c475">drawColor</a> (const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;color, SkBlendMode mode=SkBlendMode::kSrcOver)</td></tr>
<tr class="separator:a81e9e3ac4ff51408f6311dda19c5c475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98806bc7175a383ca7cf0696d0c5f0fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a98806bc7175a383ca7cf0696d0c5f0fe">clear</a> (<a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a> color)</td></tr>
<tr class="separator:a98806bc7175a383ca7cf0696d0c5f0fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46db57f2e6657d12e759be219e2afb39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a46db57f2e6657d12e759be219e2afb39">clear</a> (const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;color)</td></tr>
<tr class="separator:a46db57f2e6657d12e759be219e2afb39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bd70c9638c294068b908347e87ccc7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a4bd70c9638c294068b908347e87ccc7d">discard</a> ()</td></tr>
<tr class="separator:a4bd70c9638c294068b908347e87ccc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64cf967c90d18c096b91519b0d5336a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a64cf967c90d18c096b91519b0d5336a3">drawPaint</a> (const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a64cf967c90d18c096b91519b0d5336a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9be2866798af6038ee3e724722d1f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a1e9be2866798af6038ee3e724722d1f9">drawPoints</a> (<a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757b">PointMode</a> mode, size_t count, const <a class="el" href="struct_sk_point.html">SkPoint</a> pts[], const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a1e9be2866798af6038ee3e724722d1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ebda507728e3d6cc839492593fd7a3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a2ebda507728e3d6cc839492593fd7a3d">drawPoint</a> (SkScalar x, SkScalar y, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a2ebda507728e3d6cc839492593fd7a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a1b722337849eb7f99e27d84093c49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a32a1b722337849eb7f99e27d84093c49">drawPoint</a> (<a class="el" href="struct_sk_point.html">SkPoint</a> p, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a32a1b722337849eb7f99e27d84093c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6532d77a844abb68ba029243ce218ec6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a6532d77a844abb68ba029243ce218ec6">drawLine</a> (SkScalar x0, SkScalar y0, SkScalar x1, SkScalar y1, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a6532d77a844abb68ba029243ce218ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeafca9e73fd46514ffb4162160638895"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#aeafca9e73fd46514ffb4162160638895">drawLine</a> (<a class="el" href="struct_sk_point.html">SkPoint</a> p0, <a class="el" href="struct_sk_point.html">SkPoint</a> p1, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:aeafca9e73fd46514ffb4162160638895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a77a3479b8f8731442d4a4ea2772b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a15a77a3479b8f8731442d4a4ea2772b3">drawRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a15a77a3479b8f8731442d4a4ea2772b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9646a00be01648cb4b6206a84581e8fb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a9646a00be01648cb4b6206a84581e8fb">drawIRect</a> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;rect, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a9646a00be01648cb4b6206a84581e8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42682194b4c8bcbb8f6efbe931b74ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ac42682194b4c8bcbb8f6efbe931b74ac">drawRegion</a> (const <a class="el" href="class_sk_region.html">SkRegion</a> &amp;region, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:ac42682194b4c8bcbb8f6efbe931b74ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183daa228e12207a75660fae3dc5e3f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a183daa228e12207a75660fae3dc5e3f9">drawOval</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;oval, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a183daa228e12207a75660fae3dc5e3f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50290cf9da84da457652d73ea09c0f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ab50290cf9da84da457652d73ea09c0f5">drawRRect</a> (const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;rrect, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:ab50290cf9da84da457652d73ea09c0f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7149e359d4d0cfd2ad708e905f0d8c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ad7149e359d4d0cfd2ad708e905f0d8c6">drawDRRect</a> (const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;outer, const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;inner, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:ad7149e359d4d0cfd2ad708e905f0d8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeec18345530ada3fc5bfd077bc7eb2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#afeec18345530ada3fc5bfd077bc7eb2f">drawCircle</a> (SkScalar cx, SkScalar cy, SkScalar radius, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:afeec18345530ada3fc5bfd077bc7eb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70b82e3a846bba5a625e7aca15d4359"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ad70b82e3a846bba5a625e7aca15d4359">drawCircle</a> (<a class="el" href="struct_sk_point.html">SkPoint</a> center, SkScalar radius, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:ad70b82e3a846bba5a625e7aca15d4359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d43d64e7e6d756e60a6d42f3dc472d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ab7d43d64e7e6d756e60a6d42f3dc472d">drawArc</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;oval, SkScalar startAngle, SkScalar sweepAngle, bool useCenter, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:ab7d43d64e7e6d756e60a6d42f3dc472d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77ed3c2ed1f8bbe331e1063ab4f98a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ab77ed3c2ed1f8bbe331e1063ab4f98a9">drawRoundRect</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, SkScalar rx, SkScalar ry, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:ab77ed3c2ed1f8bbe331e1063ab4f98a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acddf41dddcd12333b061ce9c963616bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#acddf41dddcd12333b061ce9c963616bb">drawPath</a> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:acddf41dddcd12333b061ce9c963616bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c85bc4508e77a5ada59de2cd34d7de"><td class="memItemLeft" align="right" valign="top"><a id="af6c85bc4508e77a5ada59de2cd34d7de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawImage</b> (const <a class="el" href="class_sk_image.html">SkImage</a> *image, SkScalar left, SkScalar top)</td></tr>
<tr class="separator:af6c85bc4508e77a5ada59de2cd34d7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37570ba2c305284a79e88ad57a86313"><td class="memItemLeft" align="right" valign="top"><a id="ab37570ba2c305284a79e88ad57a86313"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawImage</b> (const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_image.html">SkImage</a> &gt; &amp;image, SkScalar left, SkScalar top)</td></tr>
<tr class="separator:ab37570ba2c305284a79e88ad57a86313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a435bea12d5bd58518ffa45be3d959b28"><td class="memItemLeft" align="right" valign="top"><a id="a435bea12d5bd58518ffa45be3d959b28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawImage</b> (const <a class="el" href="class_sk_image.html">SkImage</a> *, SkScalar x, SkScalar y, const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;, const <a class="el" href="class_sk_paint.html">SkPaint</a> *=nullptr)</td></tr>
<tr class="separator:a435bea12d5bd58518ffa45be3d959b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc551b54302841f62d813b7cbfa7c382"><td class="memItemLeft" align="right" valign="top"><a id="adc551b54302841f62d813b7cbfa7c382"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawImage</b> (const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_image.html">SkImage</a> &gt; &amp;image, SkScalar x, SkScalar y, const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;sampling, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint=nullptr)</td></tr>
<tr class="separator:adc551b54302841f62d813b7cbfa7c382"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95f7fb69982f33ec897ce974758f3d8"><td class="memItemLeft" align="right" valign="top"><a id="ac95f7fb69982f33ec897ce974758f3d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawImageRect</b> (const <a class="el" href="class_sk_image.html">SkImage</a> *, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;src, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;dst, const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;, const <a class="el" href="class_sk_paint.html">SkPaint</a> *, <a class="el" href="class_sk_canvas.html#a8997239ed4fd8e08bf4b66b3f6eeb40c">SrcRectConstraint</a>)</td></tr>
<tr class="separator:ac95f7fb69982f33ec897ce974758f3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88e2fabef07d9dce6ee258a7839c273"><td class="memItemLeft" align="right" valign="top"><a id="af88e2fabef07d9dce6ee258a7839c273"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawImageRect</b> (const <a class="el" href="class_sk_image.html">SkImage</a> *, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;dst, const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;, const <a class="el" href="class_sk_paint.html">SkPaint</a> *=nullptr)</td></tr>
<tr class="separator:af88e2fabef07d9dce6ee258a7839c273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29f5abcd0662d424a9b3b32fc422674"><td class="memItemLeft" align="right" valign="top"><a id="aa29f5abcd0662d424a9b3b32fc422674"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawImageRect</b> (const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_image.html">SkImage</a> &gt; &amp;image, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;src, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;dst, const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;sampling, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint, <a class="el" href="class_sk_canvas.html#a8997239ed4fd8e08bf4b66b3f6eeb40c">SrcRectConstraint</a> constraint)</td></tr>
<tr class="separator:aa29f5abcd0662d424a9b3b32fc422674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0f0b16e87bdc2ec0ec595f3a80712c"><td class="memItemLeft" align="right" valign="top"><a id="a2b0f0b16e87bdc2ec0ec595f3a80712c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawImageRect</b> (const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_image.html">SkImage</a> &gt; &amp;image, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;dst, const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;sampling, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint=nullptr)</td></tr>
<tr class="separator:a2b0f0b16e87bdc2ec0ec595f3a80712c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a9a10b43dcffdac586ca21b853627b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a3a9a10b43dcffdac586ca21b853627b3">drawImageNine</a> (const <a class="el" href="class_sk_image.html">SkImage</a> *image, const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;center, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;dst, SkFilterMode filter, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint=nullptr)</td></tr>
<tr class="separator:a3a9a10b43dcffdac586ca21b853627b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a724321360f9f71b409f8d11172628"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ab8a724321360f9f71b409f8d11172628">drawImageLattice</a> (const <a class="el" href="class_sk_image.html">SkImage</a> *image, const <a class="el" href="struct_sk_canvas_1_1_lattice.html">Lattice</a> &amp;lattice, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;dst, SkFilterMode filter, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint=nullptr)</td></tr>
<tr class="separator:ab8a724321360f9f71b409f8d11172628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c49d2208bfb605703f3b1d2798f054"><td class="memItemLeft" align="right" valign="top"><a id="ad3c49d2208bfb605703f3b1d2798f054"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>drawImageLattice</b> (const <a class="el" href="class_sk_image.html">SkImage</a> *image, const <a class="el" href="struct_sk_canvas_1_1_lattice.html">Lattice</a> &amp;lattice, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;dst)</td></tr>
<tr class="separator:ad3c49d2208bfb605703f3b1d2798f054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5d4fc04417355ca0d23feafcd81ac3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a8e5d4fc04417355ca0d23feafcd81ac3">experimental_DrawEdgeAAQuad</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, const <a class="el" href="struct_sk_point.html">SkPoint</a> clip[4], <a class="el" href="class_sk_canvas.html#af71b7245651dfa4a873a23336fafec48">QuadAAFlags</a> aaFlags, const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;color, SkBlendMode mode)</td></tr>
<tr class="separator:a8e5d4fc04417355ca0d23feafcd81ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab255f1cddb6905eb9bd4b7054df11ed7"><td class="memItemLeft" align="right" valign="top"><a id="ab255f1cddb6905eb9bd4b7054df11ed7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>experimental_DrawEdgeAAQuad</b> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, const <a class="el" href="struct_sk_point.html">SkPoint</a> clip[4], <a class="el" href="class_sk_canvas.html#af71b7245651dfa4a873a23336fafec48">QuadAAFlags</a> aaFlags, <a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a> color, SkBlendMode mode)</td></tr>
<tr class="separator:ab255f1cddb6905eb9bd4b7054df11ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e1a224a23c880db7ef8022adaf6480"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#aa9e1a224a23c880db7ef8022adaf6480">experimental_DrawEdgeAAImageSet</a> (const <a class="el" href="struct_sk_canvas_1_1_image_set_entry.html">ImageSetEntry</a> imageSet[], int cnt, const <a class="el" href="struct_sk_point.html">SkPoint</a> dstClips[], const <a class="el" href="class_sk_matrix.html">SkMatrix</a> preViewMatrices[], const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint=nullptr, <a class="el" href="class_sk_canvas.html#a8997239ed4fd8e08bf4b66b3f6eeb40c">SrcRectConstraint</a> constraint=<a class="el" href="class_sk_canvas.html#a8997239ed4fd8e08bf4b66b3f6eeb40ca33a44e18142c9cd28f2b76b7d5f7bc9e">kStrict_SrcRectConstraint</a>)</td></tr>
<tr class="separator:aa9e1a224a23c880db7ef8022adaf6480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1b67d0c3e6b574769e84c2351ef6a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a2f1b67d0c3e6b574769e84c2351ef6a0">drawSimpleText</a> (const void *text, size_t byteLength, SkTextEncoding encoding, SkScalar x, SkScalar y, const <a class="el" href="class_sk_font.html">SkFont</a> &amp;font, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a2f1b67d0c3e6b574769e84c2351ef6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae280406fb774e5a8bffbeaf3f1c927e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ae280406fb774e5a8bffbeaf3f1c927e7">drawString</a> (const char str[], SkScalar x, SkScalar y, const <a class="el" href="class_sk_font.html">SkFont</a> &amp;font, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:ae280406fb774e5a8bffbeaf3f1c927e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5342b30928986132363b72d5eb49240c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a5342b30928986132363b72d5eb49240c">drawString</a> (const <a class="el" href="class_sk_string.html">SkString</a> &amp;str, SkScalar x, SkScalar y, const <a class="el" href="class_sk_font.html">SkFont</a> &amp;font, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a5342b30928986132363b72d5eb49240c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cefe226459f3787b5f1eea25c433dc4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a8cefe226459f3787b5f1eea25c433dc4">drawGlyphs</a> (int count, const <a class="el" href="_sk_types_8h.html#a1d5e8bd1d16e0484508ec693933b0a54">SkGlyphID</a> glyphs[], const <a class="el" href="struct_sk_point.html">SkPoint</a> positions[], const uint32_t clusters[], int textByteCount, const char utf8text[], <a class="el" href="struct_sk_point.html">SkPoint</a> origin, const <a class="el" href="class_sk_font.html">SkFont</a> &amp;font, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a8cefe226459f3787b5f1eea25c433dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c65f566d391678b9222bc038a17756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a44c65f566d391678b9222bc038a17756">drawGlyphs</a> (int count, const <a class="el" href="_sk_types_8h.html#a1d5e8bd1d16e0484508ec693933b0a54">SkGlyphID</a> glyphs[], const <a class="el" href="struct_sk_point.html">SkPoint</a> positions[], <a class="el" href="struct_sk_point.html">SkPoint</a> origin, const <a class="el" href="class_sk_font.html">SkFont</a> &amp;font, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a44c65f566d391678b9222bc038a17756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cf46dce324c389b2351453b115354c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a32cf46dce324c389b2351453b115354c">drawGlyphs</a> (int count, const <a class="el" href="_sk_types_8h.html#a1d5e8bd1d16e0484508ec693933b0a54">SkGlyphID</a> glyphs[], const <a class="el" href="struct_sk_r_s_xform.html">SkRSXform</a> xforms[], <a class="el" href="struct_sk_point.html">SkPoint</a> origin, const <a class="el" href="class_sk_font.html">SkFont</a> &amp;font, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a32cf46dce324c389b2351453b115354c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b440d5b99d7c5025c05d518ae44b4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#af6b440d5b99d7c5025c05d518ae44b4a">drawTextBlob</a> (const <a class="el" href="class_sk_text_blob.html">SkTextBlob</a> *blob, SkScalar x, SkScalar y, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:af6b440d5b99d7c5025c05d518ae44b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefcef6a4389f0ec225b2cf229a372826"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#aefcef6a4389f0ec225b2cf229a372826">drawTextBlob</a> (const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_text_blob.html">SkTextBlob</a> &gt; &amp;blob, SkScalar x, SkScalar y, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:aefcef6a4389f0ec225b2cf229a372826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae291eaf5243302d4d7f56195b0a0bb1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ae291eaf5243302d4d7f56195b0a0bb1d">drawPicture</a> (const <a class="el" href="class_sk_picture.html">SkPicture</a> *picture)</td></tr>
<tr class="separator:ae291eaf5243302d4d7f56195b0a0bb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfa0f7173e172db0ff20417c3e07a12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a3cfa0f7173e172db0ff20417c3e07a12">drawPicture</a> (const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_picture.html">SkPicture</a> &gt; &amp;picture)</td></tr>
<tr class="separator:a3cfa0f7173e172db0ff20417c3e07a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9207103b010bda8def557aafbcc1825"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ac9207103b010bda8def557aafbcc1825">drawPicture</a> (const <a class="el" href="class_sk_picture.html">SkPicture</a> *picture, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> *matrix, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint)</td></tr>
<tr class="separator:ac9207103b010bda8def557aafbcc1825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9882919aa534a6c911be0bb362c9cfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ab9882919aa534a6c911be0bb362c9cfa">drawPicture</a> (const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_picture.html">SkPicture</a> &gt; &amp;picture, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> *matrix, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint)</td></tr>
<tr class="separator:ab9882919aa534a6c911be0bb362c9cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae971eebc0c442a0310b830a7711b8798"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ae971eebc0c442a0310b830a7711b8798">drawVertices</a> (const <a class="el" href="class_sk_vertices.html">SkVertices</a> *vertices, SkBlendMode mode, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:ae971eebc0c442a0310b830a7711b8798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7889fb296b46a8dd647b09749a0288e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#af7889fb296b46a8dd647b09749a0288e">drawVertices</a> (const <a class="el" href="class_sk_vertices.html">SkVertices</a> *vertices, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:af7889fb296b46a8dd647b09749a0288e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14234b29eb75b68c0da1c08119251f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ae14234b29eb75b68c0da1c08119251f4">drawVertices</a> (const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_vertices.html">SkVertices</a> &gt; &amp;vertices, SkBlendMode mode, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:ae14234b29eb75b68c0da1c08119251f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7b6fc878285446f43d7cdb3968b2ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#abd7b6fc878285446f43d7cdb3968b2ad">drawVertices</a> (const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_vertices.html">SkVertices</a> &gt; &amp;vertices, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:abd7b6fc878285446f43d7cdb3968b2ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b048324b32bfc785c0c256d65aa885"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a29b048324b32bfc785c0c256d65aa885">drawPatch</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> cubics[12], const <a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a> colors[4], const <a class="el" href="struct_sk_point.html">SkPoint</a> texCoords[4], SkBlendMode mode, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a29b048324b32bfc785c0c256d65aa885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af960b19fda72b8dc5017e29256ac4a81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#af960b19fda72b8dc5017e29256ac4a81">drawPatch</a> (const <a class="el" href="struct_sk_point.html">SkPoint</a> cubics[12], const <a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a> colors[4], const <a class="el" href="struct_sk_point.html">SkPoint</a> texCoords[4], const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:af960b19fda72b8dc5017e29256ac4a81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6d74f7e43162984c184cac4edc4363"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ace6d74f7e43162984c184cac4edc4363">drawAtlas</a> (const <a class="el" href="class_sk_image.html">SkImage</a> *atlas, const <a class="el" href="struct_sk_r_s_xform.html">SkRSXform</a> xform[], const <a class="el" href="struct_sk_rect.html">SkRect</a> tex[], const <a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a> colors[], int count, SkBlendMode mode, const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;sampling, const <a class="el" href="struct_sk_rect.html">SkRect</a> *cullRect, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint)</td></tr>
<tr class="separator:ace6d74f7e43162984c184cac4edc4363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675eb3bc89d1696b8077a2e9fdca87c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a675eb3bc89d1696b8077a2e9fdca87c4">drawDrawable</a> (<a class="el" href="class_sk_drawable.html">SkDrawable</a> *drawable, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> *matrix=nullptr)</td></tr>
<tr class="separator:a675eb3bc89d1696b8077a2e9fdca87c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3faa82931933f00648e32b4d3a4de0f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a3faa82931933f00648e32b4d3a4de0f0">drawDrawable</a> (<a class="el" href="class_sk_drawable.html">SkDrawable</a> *drawable, SkScalar x, SkScalar y)</td></tr>
<tr class="separator:a3faa82931933f00648e32b4d3a4de0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f267b5b50bf3990a6bb9747a21cd02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a69f267b5b50bf3990a6bb9747a21cd02">drawAnnotation</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, const char key[], <a class="el" href="class_sk_data.html">SkData</a> *value)</td></tr>
<tr class="separator:a69f267b5b50bf3990a6bb9747a21cd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfa2c8f18412d979b7c0e6fbf658a74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#afdfa2c8f18412d979b7c0e6fbf658a74">drawAnnotation</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, const char key[], const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt; &amp;value)</td></tr>
<tr class="separator:afdfa2c8f18412d979b7c0e6fbf658a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2160c39d4747ce925cce72f76a31e6be"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a2160c39d4747ce925cce72f76a31e6be">isClipEmpty</a> () const</td></tr>
<tr class="separator:a2160c39d4747ce925cce72f76a31e6be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe3bc1eb2d66d4c82c0e59c7daedcbe"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a5fe3bc1eb2d66d4c82c0e59c7daedcbe">isClipRect</a> () const</td></tr>
<tr class="separator:a5fe3bc1eb2d66d4c82c0e59c7daedcbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5ca44e20640c94bc43d3461d07b14b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_m44.html">SkM44</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a8d5ca44e20640c94bc43d3461d07b14b">getLocalToDevice</a> () const</td></tr>
<tr class="separator:a8d5ca44e20640c94bc43d3461d07b14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47155d29ae77a207af00974d71540116"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a47155d29ae77a207af00974d71540116">getLocalToDeviceAs3x3</a> () const</td></tr>
<tr class="separator:a47155d29ae77a207af00974d71540116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d3c67a63129f42692d6cb4fb75db23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_sk_matrix.html">SkMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ab5d3c67a63129f42692d6cb4fb75db23">getTotalMatrix</a> () const</td></tr>
<tr class="separator:ab5d3c67a63129f42692d6cb4fb75db23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad50301a9f62976a135c79a5910e6be17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ad50301a9f62976a135c79a5910e6be17">temporary_internal_getRgnClip</a> (<a class="el" href="class_sk_region.html">SkRegion</a> *region)</td></tr>
<tr class="separator:ad50301a9f62976a135c79a5910e6be17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6663e6f1798a1b72ada9a032c5999e31"><td class="memItemLeft" align="right" valign="top"><a id="a6663e6f1798a1b72ada9a032c5999e31"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>private_draw_shadow_rec</b> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;, const <a class="el" href="struct_sk_draw_shadow_rec.html">SkDrawShadowRec</a> &amp;)</td></tr>
<tr class="separator:a6663e6f1798a1b72ada9a032c5999e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae7b9b683fda2b9c957780903647d3b7a"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="class_sk_canvas.html">SkCanvas</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#ae7b9b683fda2b9c957780903647d3b7a">MakeRasterDirect</a> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;info, void *pixels, size_t rowBytes, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *props=nullptr)</td></tr>
<tr class="separator:ae7b9b683fda2b9c957780903647d3b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b50eebd3b47ae6f371a2c7af2a9f01"><td class="memItemLeft" align="right" valign="top">static std::unique_ptr&lt; <a class="el" href="class_sk_canvas.html">SkCanvas</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_sk_canvas.html#a00b50eebd3b47ae6f371a2c7af2a9f01">MakeRasterDirectN32</a> (int width, int height, <a class="el" href="_sk_color_8h.html#a9ec12bd74c4b63b5da802b419106b8ea">SkPMColor</a> *pixels, size_t rowBytes)</td></tr>
<tr class="separator:a00b50eebd3b47ae6f371a2c7af2a9f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a8efef4f31b028ac6c604893f09bf07f8"><td class="memItemLeft" align="right" valign="top"><a id="a8efef4f31b028ac6c604893f09bf07f8"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>SaveLayerStrategy</b> { <b>kFullLayer_SaveLayerStrategy</b>, 
<b>kNoLayer_SaveLayerStrategy</b>
 }</td></tr>
<tr class="separator:a8efef4f31b028ac6c604893f09bf07f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc93c5a7804be8977691df6a2e80c7f"><td class="memItemLeft" align="right" valign="top"><a id="adcc93c5a7804be8977691df6a2e80c7f"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>ClipEdgeStyle</b> { <b>kHard_ClipEdgeStyle</b>, 
<b>kSoft_ClipEdgeStyle</b>
 }</td></tr>
<tr class="separator:adcc93c5a7804be8977691df6a2e80c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aeb3ee5da5df75a4989362a840320b6bc"><td class="memItemLeft" align="right" valign="top"><a id="aeb3ee5da5df75a4989362a840320b6bc"></a>
virtual <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>onNewSurface</b> (const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;info, const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> &amp;props)</td></tr>
<tr class="separator:aeb3ee5da5df75a4989362a840320b6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f12ef0821fc288f72ce43f8bde2da04"><td class="memItemLeft" align="right" valign="top"><a id="a2f12ef0821fc288f72ce43f8bde2da04"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>onPeekPixels</b> (<a class="el" href="class_sk_pixmap.html">SkPixmap</a> *pixmap)</td></tr>
<tr class="separator:a2f12ef0821fc288f72ce43f8bde2da04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70ccb0cd26ec23892ad670cb698cc20c"><td class="memItemLeft" align="right" valign="top"><a id="a70ccb0cd26ec23892ad670cb698cc20c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>onAccessTopLayerPixels</b> (<a class="el" href="class_sk_pixmap.html">SkPixmap</a> *pixmap)</td></tr>
<tr class="separator:a70ccb0cd26ec23892ad670cb698cc20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349e71b0b870dfd489d612bcbfa1c8b4"><td class="memItemLeft" align="right" valign="top"><a id="a349e71b0b870dfd489d612bcbfa1c8b4"></a>
virtual <a class="el" href="struct_sk_image_info.html">SkImageInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><b>onImageInfo</b> () const</td></tr>
<tr class="separator:a349e71b0b870dfd489d612bcbfa1c8b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd6548f80691359343a8d563fe9f3d9"><td class="memItemLeft" align="right" valign="top"><a id="a4dd6548f80691359343a8d563fe9f3d9"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>onGetProps</b> (<a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *props) const</td></tr>
<tr class="separator:a4dd6548f80691359343a8d563fe9f3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9e802abed1233884a039a36ddbc0c1"><td class="memItemLeft" align="right" valign="top"><a id="a1e9e802abed1233884a039a36ddbc0c1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onFlush</b> ()</td></tr>
<tr class="separator:a1e9e802abed1233884a039a36ddbc0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95e7c2e960d332869d67d941c57e57c"><td class="memItemLeft" align="right" valign="top"><a id="ae95e7c2e960d332869d67d941c57e57c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>willSave</b> ()</td></tr>
<tr class="separator:ae95e7c2e960d332869d67d941c57e57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac210bba26feba620ff4f8e3d91881c"><td class="memItemLeft" align="right" valign="top"><a id="a7ac210bba26feba620ff4f8e3d91881c"></a>
virtual SaveLayerStrategy&#160;</td><td class="memItemRight" valign="bottom"><b>getSaveLayerStrategy</b> (const <a class="el" href="struct_sk_canvas_1_1_save_layer_rec.html">SaveLayerRec</a> &amp;)</td></tr>
<tr class="separator:a7ac210bba26feba620ff4f8e3d91881c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add90b900ebc8086e985694efbe78b547"><td class="memItemLeft" align="right" valign="top"><a id="add90b900ebc8086e985694efbe78b547"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>onDoSaveBehind</b> (const <a class="el" href="struct_sk_rect.html">SkRect</a> *)</td></tr>
<tr class="separator:add90b900ebc8086e985694efbe78b547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c9c2ef0f7b505f91b1d97e1bb24718"><td class="memItemLeft" align="right" valign="top"><a id="aa6c9c2ef0f7b505f91b1d97e1bb24718"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>willRestore</b> ()</td></tr>
<tr class="separator:aa6c9c2ef0f7b505f91b1d97e1bb24718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60815a4c33ce86b8f22e4de1e5b325a1"><td class="memItemLeft" align="right" valign="top"><a id="a60815a4c33ce86b8f22e4de1e5b325a1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>didRestore</b> ()</td></tr>
<tr class="separator:a60815a4c33ce86b8f22e4de1e5b325a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e7625fe61824a1ac182e212a383a89"><td class="memItemLeft" align="right" valign="top"><a id="ac0e7625fe61824a1ac182e212a383a89"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onMarkCTM</b> (const char *)</td></tr>
<tr class="separator:ac0e7625fe61824a1ac182e212a383a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69b160288be091dfd5084457a42d220"><td class="memItemLeft" align="right" valign="top"><a id="ac69b160288be091dfd5084457a42d220"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>didConcat44</b> (const <a class="el" href="class_sk_m44.html">SkM44</a> &amp;)</td></tr>
<tr class="separator:ac69b160288be091dfd5084457a42d220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d3978a547844e36b1c9da1b1bb276d"><td class="memItemLeft" align="right" valign="top"><a id="a58d3978a547844e36b1c9da1b1bb276d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>didSetM44</b> (const <a class="el" href="class_sk_m44.html">SkM44</a> &amp;)</td></tr>
<tr class="separator:a58d3978a547844e36b1c9da1b1bb276d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab341d87464348293385df7e4c36afccd"><td class="memItemLeft" align="right" valign="top"><a id="ab341d87464348293385df7e4c36afccd"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>didTranslate</b> (SkScalar, SkScalar)</td></tr>
<tr class="separator:ab341d87464348293385df7e4c36afccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5786f292747a0984ec35469b5c690689"><td class="memItemLeft" align="right" valign="top"><a id="a5786f292747a0984ec35469b5c690689"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>didScale</b> (SkScalar, SkScalar)</td></tr>
<tr class="separator:a5786f292747a0984ec35469b5c690689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d3d180ff7934a2ec01043d23a8e1fa"><td class="memItemLeft" align="right" valign="top"><a id="a47d3d180ff7934a2ec01043d23a8e1fa"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawPaint</b> (const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a47d3d180ff7934a2ec01043d23a8e1fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a27b56527eb62ab53f8a17bd8df7e39"><td class="memItemLeft" align="right" valign="top"><a id="a4a27b56527eb62ab53f8a17bd8df7e39"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawBehind</b> (const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a4a27b56527eb62ab53f8a17bd8df7e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686820d82c475fbd327355140b94f402"><td class="memItemLeft" align="right" valign="top"><a id="a686820d82c475fbd327355140b94f402"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawRect</b> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a686820d82c475fbd327355140b94f402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d5416fa27df6b4469fde7bbf613813"><td class="memItemLeft" align="right" valign="top"><a id="af8d5416fa27df6b4469fde7bbf613813"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawRRect</b> (const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;rrect, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:af8d5416fa27df6b4469fde7bbf613813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb893a42d89ac34eef5b8ab37356edb"><td class="memItemLeft" align="right" valign="top"><a id="a0fb893a42d89ac34eef5b8ab37356edb"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawDRRect</b> (const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;outer, const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;inner, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a0fb893a42d89ac34eef5b8ab37356edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf16ddea8c13c9c8ffdd2b7f6b6acc92"><td class="memItemLeft" align="right" valign="top"><a id="abf16ddea8c13c9c8ffdd2b7f6b6acc92"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawOval</b> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:abf16ddea8c13c9c8ffdd2b7f6b6acc92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc4bb65f025e00818826e038c3ae0a8"><td class="memItemLeft" align="right" valign="top"><a id="affc4bb65f025e00818826e038c3ae0a8"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawArc</b> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, SkScalar startAngle, SkScalar sweepAngle, bool useCenter, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:affc4bb65f025e00818826e038c3ae0a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4678442d4c403d0547738b9e68b5f1"><td class="memItemLeft" align="right" valign="top"><a id="a1a4678442d4c403d0547738b9e68b5f1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawPath</b> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a1a4678442d4c403d0547738b9e68b5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d178a1ce31cb4a65c4eccfbd31f3639"><td class="memItemLeft" align="right" valign="top"><a id="a6d178a1ce31cb4a65c4eccfbd31f3639"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawRegion</b> (const <a class="el" href="class_sk_region.html">SkRegion</a> &amp;region, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a6d178a1ce31cb4a65c4eccfbd31f3639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f657cc9dcb31b74f9222fd02b2c09d"><td class="memItemLeft" align="right" valign="top"><a id="a61f657cc9dcb31b74f9222fd02b2c09d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawTextBlob</b> (const <a class="el" href="class_sk_text_blob.html">SkTextBlob</a> *blob, SkScalar x, SkScalar y, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:a61f657cc9dcb31b74f9222fd02b2c09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf62da1bef5f3c34367753afc6b18ab1"><td class="memItemLeft" align="right" valign="top"><a id="abf62da1bef5f3c34367753afc6b18ab1"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawGlyphRunList</b> (const <a class="el" href="class_sk_glyph_run_list.html">SkGlyphRunList</a> &amp;glyphRunList, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:abf62da1bef5f3c34367753afc6b18ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab914823d16e1a960b2151b58e5be317"><td class="memItemLeft" align="right" valign="top"><a id="aab914823d16e1a960b2151b58e5be317"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawPatch</b> (const <a class="el" href="struct_sk_point.html">SkPoint</a> cubics[12], const <a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a> colors[4], const <a class="el" href="struct_sk_point.html">SkPoint</a> texCoords[4], SkBlendMode mode, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:aab914823d16e1a960b2151b58e5be317"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af481809a2b4b9716801937a1aff08d23"><td class="memItemLeft" align="right" valign="top"><a id="af481809a2b4b9716801937a1aff08d23"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawPoints</b> (<a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757b">PointMode</a> mode, size_t count, const <a class="el" href="struct_sk_point.html">SkPoint</a> pts[], const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:af481809a2b4b9716801937a1aff08d23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05883b056e3cd83952af1d2788b3c730"><td class="memItemLeft" align="right" valign="top"><a id="a05883b056e3cd83952af1d2788b3c730"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawImage2</b> (const <a class="el" href="class_sk_image.html">SkImage</a> *, SkScalar dx, SkScalar dy, const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;, const <a class="el" href="class_sk_paint.html">SkPaint</a> *)</td></tr>
<tr class="separator:a05883b056e3cd83952af1d2788b3c730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4ceffc91048e02e748b86c1e8eeae0a"><td class="memItemLeft" align="right" valign="top"><a id="ae4ceffc91048e02e748b86c1e8eeae0a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawImageRect2</b> (const <a class="el" href="class_sk_image.html">SkImage</a> *, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;src, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;dst, const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;, const <a class="el" href="class_sk_paint.html">SkPaint</a> *, <a class="el" href="class_sk_canvas.html#a8997239ed4fd8e08bf4b66b3f6eeb40c">SrcRectConstraint</a>)</td></tr>
<tr class="separator:ae4ceffc91048e02e748b86c1e8eeae0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a88c5093dcfe3d1bdd557777f1f94c3"><td class="memItemLeft" align="right" valign="top"><a id="a3a88c5093dcfe3d1bdd557777f1f94c3"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawImageLattice2</b> (const <a class="el" href="class_sk_image.html">SkImage</a> *, const <a class="el" href="struct_sk_canvas_1_1_lattice.html">Lattice</a> &amp;, const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;dst, SkFilterMode, const <a class="el" href="class_sk_paint.html">SkPaint</a> *)</td></tr>
<tr class="separator:a3a88c5093dcfe3d1bdd557777f1f94c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20a1efde9fb2070141cf5ce673945b43"><td class="memItemLeft" align="right" valign="top"><a id="a20a1efde9fb2070141cf5ce673945b43"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawAtlas2</b> (const <a class="el" href="class_sk_image.html">SkImage</a> *, const <a class="el" href="struct_sk_r_s_xform.html">SkRSXform</a>[], const <a class="el" href="struct_sk_rect.html">SkRect</a> src[], const <a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a>[], int count, SkBlendMode, const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;, const <a class="el" href="struct_sk_rect.html">SkRect</a> *cull, const <a class="el" href="class_sk_paint.html">SkPaint</a> *)</td></tr>
<tr class="separator:a20a1efde9fb2070141cf5ce673945b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6875592b0171222310b655c0767192ab"><td class="memItemLeft" align="right" valign="top"><a id="a6875592b0171222310b655c0767192ab"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawEdgeAAImageSet2</b> (const <a class="el" href="struct_sk_canvas_1_1_image_set_entry.html">ImageSetEntry</a> imageSet[], int count, const <a class="el" href="struct_sk_point.html">SkPoint</a> dstClips[], const <a class="el" href="class_sk_matrix.html">SkMatrix</a> preViewMatrices[], const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;, const <a class="el" href="class_sk_paint.html">SkPaint</a> *, <a class="el" href="class_sk_canvas.html#a8997239ed4fd8e08bf4b66b3f6eeb40c">SrcRectConstraint</a>)</td></tr>
<tr class="separator:a6875592b0171222310b655c0767192ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab654e69c02c44a67c9dd8112577c0d29"><td class="memItemLeft" align="right" valign="top"><a id="ab654e69c02c44a67c9dd8112577c0d29"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawVerticesObject</b> (const <a class="el" href="class_sk_vertices.html">SkVertices</a> *vertices, SkBlendMode mode, const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;paint)</td></tr>
<tr class="separator:ab654e69c02c44a67c9dd8112577c0d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43678ff9e8353be3c950158bfcbf7f07"><td class="memItemLeft" align="right" valign="top"><a id="a43678ff9e8353be3c950158bfcbf7f07"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawAnnotation</b> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, const char key[], <a class="el" href="class_sk_data.html">SkData</a> *value)</td></tr>
<tr class="separator:a43678ff9e8353be3c950158bfcbf7f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731637890a3bd45c466ee8310881b78c"><td class="memItemLeft" align="right" valign="top"><a id="a731637890a3bd45c466ee8310881b78c"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawShadowRec</b> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;, const <a class="el" href="struct_sk_draw_shadow_rec.html">SkDrawShadowRec</a> &amp;)</td></tr>
<tr class="separator:a731637890a3bd45c466ee8310881b78c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04666a612e1132554857882543169bd0"><td class="memItemLeft" align="right" valign="top"><a id="a04666a612e1132554857882543169bd0"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawDrawable</b> (<a class="el" href="class_sk_drawable.html">SkDrawable</a> *drawable, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> *matrix)</td></tr>
<tr class="separator:a04666a612e1132554857882543169bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f263f8e283c4dbda0a8ca589bd02874"><td class="memItemLeft" align="right" valign="top"><a id="a3f263f8e283c4dbda0a8ca589bd02874"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawPicture</b> (const <a class="el" href="class_sk_picture.html">SkPicture</a> *picture, const <a class="el" href="class_sk_matrix.html">SkMatrix</a> *matrix, const <a class="el" href="class_sk_paint.html">SkPaint</a> *paint)</td></tr>
<tr class="separator:a3f263f8e283c4dbda0a8ca589bd02874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af308a947db2dae141ff09f8d6266c12d"><td class="memItemLeft" align="right" valign="top"><a id="af308a947db2dae141ff09f8d6266c12d"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDrawEdgeAAQuad</b> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, const <a class="el" href="struct_sk_point.html">SkPoint</a> clip[4], <a class="el" href="class_sk_canvas.html#af71b7245651dfa4a873a23336fafec48">QuadAAFlags</a> aaFlags, const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;color, SkBlendMode mode)</td></tr>
<tr class="separator:af308a947db2dae141ff09f8d6266c12d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae5a9a9fed272ca4c87518499662c33"><td class="memItemLeft" align="right" valign="top"><a id="a7ae5a9a9fed272ca4c87518499662c33"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onClipRect</b> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;rect, SkClipOp op, ClipEdgeStyle edgeStyle)</td></tr>
<tr class="separator:a7ae5a9a9fed272ca4c87518499662c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1efdbe770c2929b02453e501c060fc4"><td class="memItemLeft" align="right" valign="top"><a id="ad1efdbe770c2929b02453e501c060fc4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onClipRRect</b> (const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;rrect, SkClipOp op, ClipEdgeStyle edgeStyle)</td></tr>
<tr class="separator:ad1efdbe770c2929b02453e501c060fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5921b15bcc03400de77d8a0dce6570a"><td class="memItemLeft" align="right" valign="top"><a id="ad5921b15bcc03400de77d8a0dce6570a"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onClipPath</b> (const <a class="el" href="class_sk_path.html">SkPath</a> &amp;path, SkClipOp op, ClipEdgeStyle edgeStyle)</td></tr>
<tr class="separator:ad5921b15bcc03400de77d8a0dce6570a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ac8df7c86315fe5bd9e8054583ce03"><td class="memItemLeft" align="right" valign="top"><a id="a53ac8df7c86315fe5bd9e8054583ce03"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onClipShader</b> (<a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_shader.html">SkShader</a> &gt;, SkClipOp)</td></tr>
<tr class="separator:a53ac8df7c86315fe5bd9e8054583ce03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa546ed5140c4bbf3b905d31fb01cf42"><td class="memItemLeft" align="right" valign="top"><a id="afa546ed5140c4bbf3b905d31fb01cf42"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onClipRegion</b> (const <a class="el" href="class_sk_region.html">SkRegion</a> &amp;deviceRgn, SkClipOp op)</td></tr>
<tr class="separator:afa546ed5140c4bbf3b905d31fb01cf42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c92f25effb0697c339ff4f8a878fa1e"><td class="memItemLeft" align="right" valign="top"><a id="a7c92f25effb0697c339ff4f8a878fa1e"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onResetClip</b> ()</td></tr>
<tr class="separator:a7c92f25effb0697c339ff4f8a878fa1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f825270696e9546d6f7eb6838523505"><td class="memItemLeft" align="right" valign="top"><a id="a6f825270696e9546d6f7eb6838523505"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><b>onDiscard</b> ()</td></tr>
<tr class="separator:a6f825270696e9546d6f7eb6838523505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61d6f6b36e713c49c0d77877db4000c"><td class="memItemLeft" align="right" valign="top"><a id="ad61d6f6b36e713c49c0d77877db4000c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SkCanvas</b> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;bounds)</td></tr>
<tr class="separator:ad61d6f6b36e713c49c0d77877db4000c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a8f66e144899422c0f7cee7b4b763d497"><td class="memItemLeft" align="right" valign="top"><a id="a8f66e144899422c0f7cee7b4b763d497"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkSurface_Base</b></td></tr>
<tr class="separator:a8f66e144899422c0f7cee7b4b763d497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31dfa637653f9dd51819e108a82996e"><td class="memItemLeft" align="right" valign="top"><a id="ad31dfa637653f9dd51819e108a82996e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkSurface_Gpu</b></td></tr>
<tr class="separator:ad31dfa637653f9dd51819e108a82996e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa9708790fc8da527a94e3e9bcc8b99"><td class="memItemLeft" align="right" valign="top"><a id="adaa9708790fc8da527a94e3e9bcc8b99"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkAndroidFrameworkUtils</b></td></tr>
<tr class="separator:adaa9708790fc8da527a94e3e9bcc8b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2a49f41eacfe731afe4fd84459923e5"><td class="memItemLeft" align="right" valign="top"><a id="ad2a49f41eacfe731afe4fd84459923e5"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkCanvasPriv</b></td></tr>
<tr class="separator:ad2a49f41eacfe731afe4fd84459923e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf108d172a9abe1c66b059f8fd5faa7"><td class="memItemLeft" align="right" valign="top"><a id="accf108d172a9abe1c66b059f8fd5faa7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>AutoLayerForImageFilter</b></td></tr>
<tr class="separator:accf108d172a9abe1c66b059f8fd5faa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64194a556fe90cd74ccf291271adc27"><td class="memItemLeft" align="right" valign="top"><a id="af64194a556fe90cd74ccf291271adc27"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkSurface_Raster</b></td></tr>
<tr class="separator:af64194a556fe90cd74ccf291271adc27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b87ce9122009d3f601f68b45a63f0b2"><td class="memItemLeft" align="right" valign="top"><a id="a7b87ce9122009d3f601f68b45a63f0b2"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkNoDrawCanvas</b></td></tr>
<tr class="separator:a7b87ce9122009d3f601f68b45a63f0b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72e36aa2d128cf597d8fb0cafb83be58"><td class="memItemLeft" align="right" valign="top"><a id="a72e36aa2d128cf597d8fb0cafb83be58"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkNWayCanvas</b></td></tr>
<tr class="separator:a72e36aa2d128cf597d8fb0cafb83be58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd117d063fd72535e203e9992da6907"><td class="memItemLeft" align="right" valign="top"><a id="aebd117d063fd72535e203e9992da6907"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkPictureRecord</b></td></tr>
<tr class="separator:aebd117d063fd72535e203e9992da6907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e77114a158c9b906f1e305f3e64b62"><td class="memItemLeft" align="right" valign="top"><a id="a77e77114a158c9b906f1e305f3e64b62"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkOverdrawCanvas</b></td></tr>
<tr class="separator:a77e77114a158c9b906f1e305f3e64b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f2a94da301d134aee8d4906c49ec23"><td class="memItemLeft" align="right" valign="top"><a id="ad4f2a94da301d134aee8d4906c49ec23"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkRasterHandleAllocator</b></td></tr>
<tr class="separator:ad4f2a94da301d134aee8d4906c49ec23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685b38cdcb69c808324decb4c519e8e7"><td class="memItemLeft" align="right" valign="top"><a id="a685b38cdcb69c808324decb4c519e8e7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>SkCanvasStateUtils</b></td></tr>
<tr class="separator:a685b38cdcb69c808324decb4c519e8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_sk_canvas.html">SkCanvas</a> provides an interface for drawing, and how the drawing is clipped and transformed. <a class="el" href="class_sk_canvas.html">SkCanvas</a> contains a stack of <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip values.</p>
<p><a class="el" href="class_sk_canvas.html">SkCanvas</a> and <a class="el" href="class_sk_paint.html">SkPaint</a> together provide the state to draw into <a class="el" href="class_sk_surface.html">SkSurface</a> or <a class="el" href="class_sk_base_device.html">SkBaseDevice</a>. Each <a class="el" href="class_sk_canvas.html">SkCanvas</a> draw call transforms the geometry of the object by the concatenation of all <a class="el" href="class_sk_matrix.html">SkMatrix</a> values in the stack. The transformed geometry is clipped by the intersection of all of clip values in the stack. The <a class="el" href="class_sk_canvas.html">SkCanvas</a> draw calls use <a class="el" href="class_sk_paint.html">SkPaint</a> to supply drawing state such as color, <a class="el" href="class_sk_typeface.html">SkTypeface</a>, text size, stroke width, <a class="el" href="class_sk_shader.html">SkShader</a> and so on.</p>
<p>To draw to a pixel-based destination, create raster surface or GPU surface. Request <a class="el" href="class_sk_canvas.html">SkCanvas</a> from <a class="el" href="class_sk_surface.html">SkSurface</a> to obtain the interface to draw. <a class="el" href="class_sk_canvas.html">SkCanvas</a> generated by raster surface draws to memory visible to the CPU. <a class="el" href="class_sk_canvas.html">SkCanvas</a> generated by GPU surface uses Vulkan or OpenGL to draw to the GPU.</p>
<p>To draw to a document, obtain <a class="el" href="class_sk_canvas.html">SkCanvas</a> from SVG canvas, document PDF, or <a class="el" href="class_sk_picture_recorder.html">SkPictureRecorder</a>. <a class="el" href="class_sk_document.html">SkDocument</a> based <a class="el" href="class_sk_canvas.html">SkCanvas</a> and other <a class="el" href="class_sk_canvas.html">SkCanvas</a> subclasses reference <a class="el" href="class_sk_base_device.html">SkBaseDevice</a> describing the destination.</p>
<p><a class="el" href="class_sk_canvas.html">SkCanvas</a> can be constructed to draw to <a class="el" href="class_sk_bitmap.html">SkBitmap</a> without first creating raster surface. This approach may be deprecated in the future. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="af1bcd412326a6886e0f260d4d2dc757b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1bcd412326a6886e0f260d4d2dc757b">&#9670;&nbsp;</a></span>PointMode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757b">SkCanvas::PointMode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af1bcd412326a6886e0f260d4d2dc757baf596e2b9e5758fc2e5bc8dbdbc191e01"></a>kPoints_PointMode&#160;</td><td class="fielddoc"><p>draw each point separately </p>
</td></tr>
<tr><td class="fieldname"><a id="af1bcd412326a6886e0f260d4d2dc757ba31b9758602c729b8e0fc9b7fac2ac0df"></a>kLines_PointMode&#160;</td><td class="fielddoc"><p>draw each pair of points as a line segment </p>
</td></tr>
<tr><td class="fieldname"><a id="af1bcd412326a6886e0f260d4d2dc757baa1fb56deddeccfc67fca4a7859d24480"></a>kPolygon_PointMode&#160;</td><td class="fielddoc"><p>draw the array of points as a open polygon </p>
</td></tr>
</table>

</div>
</div>
<a id="af71b7245651dfa4a873a23336fafec48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71b7245651dfa4a873a23336fafec48">&#9670;&nbsp;</a></span>QuadAAFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_canvas.html#af71b7245651dfa4a873a23336fafec48">SkCanvas::QuadAAFlags</a> : unsigned</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Experimental. Controls anti-aliasing of each edge of images in an image-set. </p>

</div>
</div>
<a id="abe5a2c0555b29ae161ae5d4f102183a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe5a2c0555b29ae161ae5d4f102183a5">&#9670;&nbsp;</a></span>SaveLayerFlagsSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_canvas.html#abe5a2c0555b29ae161ae5d4f102183a5">SkCanvas::SaveLayerFlagsSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abe5a2c0555b29ae161ae5d4f102183a5a6b717db5f1a0cffb43d24b994ab47ea2"></a>kInitWithPrevious_SaveLayerFlag&#160;</td><td class="fielddoc"><p>initializes with previous contents </p>
</td></tr>
<tr><td class="fieldname"><a id="abe5a2c0555b29ae161ae5d4f102183a5a5d9a15538ae26733f9239c750128251f"></a>kMaskAgainstCoverage_EXPERIMENTAL_DONT_USE_SaveLayerFlag&#160;</td><td class="fielddoc"><p>experimental: do not use </p>
</td></tr>
</table>

</div>
</div>
<a id="a8997239ed4fd8e08bf4b66b3f6eeb40c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8997239ed4fd8e08bf4b66b3f6eeb40c">&#9670;&nbsp;</a></span>SrcRectConstraint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_sk_canvas.html#a8997239ed4fd8e08bf4b66b3f6eeb40c">SkCanvas::SrcRectConstraint</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8997239ed4fd8e08bf4b66b3f6eeb40ca33a44e18142c9cd28f2b76b7d5f7bc9e"></a>kStrict_SrcRectConstraint&#160;</td><td class="fielddoc"><p>sample only inside bounds; slower </p>
</td></tr>
<tr><td class="fieldname"><a id="a8997239ed4fd8e08bf4b66b3f6eeb40cacad134f1b0dda4f919f5df87aa0b72bf"></a>kFast_SrcRectConstraint&#160;</td><td class="fielddoc"><p>sample outside bounds; faster </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afa6f6d23671e32a48715386609d77385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa6f6d23671e32a48715386609d77385">&#9670;&nbsp;</a></span>SkCanvas() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkCanvas::SkCanvas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an empty <a class="el" href="class_sk_canvas.html">SkCanvas</a> with no backing device or pixels, with a width and height of zero.</p>
<dl class="section return"><dt>Returns</dt><dd>empty <a class="el" href="class_sk_canvas.html">SkCanvas</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_empty_constructor">https://fiddle.skia.org/c/@Canvas_empty_constructor</a> </p>

</div>
</div>
<a id="adec6d012527048422c0bfa76b3e5b13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adec6d012527048422c0bfa76b3e5b13e">&#9670;&nbsp;</a></span>SkCanvas() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkCanvas::SkCanvas </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *&#160;</td>
          <td class="paramname"><em>props</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates <a class="el" href="class_sk_canvas.html">SkCanvas</a> of the specified dimensions without a <a class="el" href="class_sk_surface.html">SkSurface</a>. Used by subclasses with custom implementations for draw member functions.</p>
<p>If props equals nullptr, <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> are created with SkSurfaceProps::InitType settings, which choose the pixel striping direction and order. Since a platform may dynamically change its direction when the device is rotated, and since a platform may have multiple monitors with different characteristics, it is best not to rely on this legacy behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>zero or greater </td></tr>
    <tr><td class="paramname">height</td><td>zero or greater </td></tr>
    <tr><td class="paramname">props</td><td>LCD striping orientation and setting for device independent fonts; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_canvas.html">SkCanvas</a> placeholder with dimensions</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_int_int_const_SkSurfaceProps_star">https://fiddle.skia.org/c/@Canvas_int_int_const_SkSurfaceProps_star</a> </p>

</div>
</div>
<a id="ac755dcfa14d0af6146cacfab0d6ec2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac755dcfa14d0af6146cacfab0d6ec2cf">&#9670;&nbsp;</a></span>SkCanvas() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkCanvas::SkCanvas </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_base_device.html">SkBaseDevice</a> &gt;&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Private. For internal use only. </p>

</div>
</div>
<a id="af6966c7d203c37df6f3c21f27a4da0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6966c7d203c37df6f3c21f27a4da0d6">&#9670;&nbsp;</a></span>SkCanvas() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkCanvas::SkCanvas </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&#160;</td>
          <td class="paramname"><em>bitmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a canvas that draws into bitmap. Sets kUnknown_SkPixelGeometry in constructed <a class="el" href="class_sk_surface.html">SkSurface</a>.</p>
<p><a class="el" href="class_sk_bitmap.html">SkBitmap</a> is copied so that subsequently editing bitmap will not affect constructed <a class="el" href="class_sk_canvas.html">SkCanvas</a>.</p>
<p>May be deprecated in the future.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>width, height, SkColorType, SkAlphaType, and pixel storage of raster surface </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_canvas.html">SkCanvas</a> that can be used to draw into bitmap</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_copy_const_SkBitmap">https://fiddle.skia.org/c/@Canvas_copy_const_SkBitmap</a> </p>

</div>
</div>
<a id="a7d4a5fa0689ec0a9157946a0fe5aed86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4a5fa0689ec0a9157946a0fe5aed86">&#9670;&nbsp;</a></span>SkCanvas() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkCanvas::SkCanvas </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> &amp;&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a canvas that draws into bitmap. Use props to match the device characteristics, like LCD striping.</p>
<p>bitmap is copied so that subsequently editing bitmap will not affect constructed <a class="el" href="class_sk_canvas.html">SkCanvas</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>width, height, SkColorType, SkAlphaType, and pixel storage of raster surface </td></tr>
    <tr><td class="paramname">props</td><td>order and orientation of RGB striping; and whether to use device independent fonts </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_canvas.html">SkCanvas</a> that can be used to draw into bitmap</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_const_SkBitmap_const_SkSurfaceProps">https://fiddle.skia.org/c/@Canvas_const_SkBitmap_const_SkSurfaceProps</a> </p>

</div>
</div>
<a id="a50760a90eee83469a2a5814fb8be47ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50760a90eee83469a2a5814fb8be47ec">&#9670;&nbsp;</a></span>~SkCanvas()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SkCanvas::~SkCanvas </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws saved layers, if any. Frees up resources used by <a class="el" href="class_sk_canvas.html">SkCanvas</a>.</p>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_destructor">https://fiddle.skia.org/c/@Canvas_destructor</a> </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af193f800a689be20669120395dc8e472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af193f800a689be20669120395dc8e472">&#9670;&nbsp;</a></span>accessTopLayerPixels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * SkCanvas::accessTopLayerPixels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_image_info.html">SkImageInfo</a> *&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>rowBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sk_i_point.html">SkIPoint</a> *&#160;</td>
          <td class="paramname"><em>origin</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the pixel base address, <a class="el" href="struct_sk_image_info.html">SkImageInfo</a>, rowBytes, and origin if the pixels can be read directly. The returned address is only valid while <a class="el" href="class_sk_canvas.html">SkCanvas</a> is in scope and unchanged. Any <a class="el" href="class_sk_canvas.html">SkCanvas</a> call or <a class="el" href="class_sk_surface.html">SkSurface</a> call may invalidate the returned address and other returned values.</p>
<p>If pixels are inaccessible, info, rowBytes, and origin are unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>storage for writable pixels' <a class="el" href="struct_sk_image_info.html">SkImageInfo</a>; may be nullptr </td></tr>
    <tr><td class="paramname">rowBytes</td><td>storage for writable pixels' row bytes; may be nullptr </td></tr>
    <tr><td class="paramname">origin</td><td>storage for <a class="el" href="class_sk_canvas.html">SkCanvas</a> top layer origin, its top-left corner; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of pixels, or nullptr if inaccessible</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_accessTopLayerPixels_a">https://fiddle.skia.org/c/@Canvas_accessTopLayerPixels_a</a> example: <a href="https://fiddle.skia.org/c/@Canvas_accessTopLayerPixels_b">https://fiddle.skia.org/c/@Canvas_accessTopLayerPixels_b</a> </p>

</div>
</div>
<a id="a12a09e49fc7bb86c7b30c1c56433e286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12a09e49fc7bb86c7b30c1c56433e286">&#9670;&nbsp;</a></span>accessTopRasterHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SkRasterHandleAllocator::Handle SkCanvas::accessTopRasterHandle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns custom context that tracks the <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip.</p>
<p>Use <a class="el" href="class_sk_raster_handle_allocator.html">SkRasterHandleAllocator</a> to blend Skia drawing with custom drawing, typically performed by the host platform user interface. The custom context returned is generated by <a class="el" href="class_sk_raster_handle_allocator.html#ad5a06e782d7e4731b506f93ba360fefa">SkRasterHandleAllocator::MakeCanvas</a>, which creates a custom canvas with raster storage for the drawing destination.</p>
<dl class="section return"><dt>Returns</dt><dd>context of custom allocation</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_accessTopRasterHandle">https://fiddle.skia.org/c/@Canvas_accessTopRasterHandle</a> </p>

</div>
</div>
<a id="a4048c03bae32364e8a660b5437e6a38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4048c03bae32364e8a660b5437e6a38c">&#9670;&nbsp;</a></span>androidFramework_setDeviceClipRestriction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::androidFramework_setDeviceClipRestriction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the maximum clip rectangle, which can be set by <a class="el" href="class_sk_canvas.html#a193511e463259ceacfe0e4cf1be1393f">clipRect()</a>, <a class="el" href="class_sk_canvas.html#afcefd4d2ac745ad086fd62f30bbd8564">clipRRect()</a> and <a class="el" href="class_sk_canvas.html#abc79bd478516f398c31ae9f501154184">clipPath()</a> and intersect the current clip with the specified rect. The maximum clip affects only future clipping operations; it is not retroactive. The clip restriction is not recorded in pictures.</p>
<p>Pass an empty rect to disable maximum clip. This private API is for use by Android framework only.</p>
<p>DEPRECATED: Replace usage with SkAndroidFrameworkUtils::replaceClip()</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>maximum allowed clip in device coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a46db57f2e6657d12e759be219e2afb39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46db57f2e6657d12e759be219e2afb39">&#9670;&nbsp;</a></span>clear() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::clear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills clip with color color using SkBlendMode::kSrc. This has the effect of replacing all pixels contained by clip with color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_sk_color4f.html">SkColor4f</a> representing unpremultiplied color. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a98806bc7175a383ca7cf0696d0c5f0fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98806bc7175a383ca7cf0696d0c5f0fe">&#9670;&nbsp;</a></span>clear() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a>&#160;</td>
          <td class="paramname"><em>color</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills clip with color color using SkBlendMode::kSrc. This has the effect of replacing all pixels contained by clip with color.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>unpremultiplied ARGB </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1353983459a2a5496e4ad9bd39f37dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1353983459a2a5496e4ad9bd39f37dd1">&#9670;&nbsp;</a></span>clipPath() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::clipPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doAntiAlias</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces clip with the intersection of clip and path. Resulting clip is aliased; pixels are fully contained by the clip. SkPath::FillType determines if path describes the area inside or outside its contours; and if path contour overlaps itself or another path contour, whether the overlaps form part of the area. path is transformed by <a class="el" href="class_sk_matrix.html">SkMatrix</a> before it is combined with clip.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td><a class="el" href="class_sk_path.html">SkPath</a> to combine with clip </td></tr>
    <tr><td class="paramname">doAntiAlias</td><td>true if clip is to be anti-aliased </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7dcca8a9ae91adb20f4cd3633f409410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcca8a9ae91adb20f4cd3633f409410">&#9670;&nbsp;</a></span>clipPath() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::clipPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkClipOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces clip with the intersection or difference of clip and path. Resulting clip is aliased; pixels are fully contained by the clip. SkPath::FillType determines if path describes the area inside or outside its contours; and if path contour overlaps itself or another path contour, whether the overlaps form part of the area. path is transformed by <a class="el" href="class_sk_matrix.html">SkMatrix</a> before it is combined with clip.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td><a class="el" href="class_sk_path.html">SkPath</a> to combine with clip </td></tr>
    <tr><td class="paramname">op</td><td>SkClipOp to apply to clip </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc79bd478516f398c31ae9f501154184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc79bd478516f398c31ae9f501154184">&#9670;&nbsp;</a></span>clipPath() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::clipPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkClipOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doAntiAlias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces clip with the intersection or difference of clip and path, with an aliased or anti-aliased clip edge. SkPath::FillType determines if path describes the area inside or outside its contours; and if path contour overlaps itself or another path contour, whether the overlaps form part of the area. path is transformed by <a class="el" href="class_sk_matrix.html">SkMatrix</a> before it is combined with clip.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td><a class="el" href="class_sk_path.html">SkPath</a> to combine with clip </td></tr>
    <tr><td class="paramname">op</td><td>SkClipOp to apply to clip </td></tr>
    <tr><td class="paramname">doAntiAlias</td><td>true if clip is to be anti-aliased</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_clipPath">https://fiddle.skia.org/c/@Canvas_clipPath</a> </p>

</div>
</div>
<a id="a86b470e8047bf70d142cdb6c5a0d77ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b470e8047bf70d142cdb6c5a0d77ef">&#9670;&nbsp;</a></span>clipRect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::clipRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doAntiAlias</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces clip with the intersection of clip and rect. Resulting clip is aliased; pixels are fully contained by the clip. rect is transformed by <a class="el" href="class_sk_matrix.html">SkMatrix</a> before it is combined with clip.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to combine with clip </td></tr>
    <tr><td class="paramname">doAntiAlias</td><td>true if clip is to be anti-aliased </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a407796e09a49830aa9c0339a5d89280c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a407796e09a49830aa9c0339a5d89280c">&#9670;&nbsp;</a></span>clipRect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::clipRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkClipOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces clip with the intersection or difference of clip and rect. Resulting clip is aliased; pixels are fully contained by the clip. rect is transformed by <a class="el" href="class_sk_matrix.html">SkMatrix</a> before it is combined with clip.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to combine with clip </td></tr>
    <tr><td class="paramname">op</td><td>SkClipOp to apply to clip </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a193511e463259ceacfe0e4cf1be1393f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a193511e463259ceacfe0e4cf1be1393f">&#9670;&nbsp;</a></span>clipRect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::clipRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkClipOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doAntiAlias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces clip with the intersection or difference of clip and rect, with an aliased or anti-aliased clip edge. rect is transformed by <a class="el" href="class_sk_matrix.html">SkMatrix</a> before it is combined with clip.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to combine with clip </td></tr>
    <tr><td class="paramname">op</td><td>SkClipOp to apply to clip </td></tr>
    <tr><td class="paramname">doAntiAlias</td><td>true if clip is to be anti-aliased</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_clipRect">https://fiddle.skia.org/c/@Canvas_clipRect</a> </p>

</div>
</div>
<a id="a8e3773e18ab060b7bb4e1cfc769fb07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e3773e18ab060b7bb4e1cfc769fb07b">&#9670;&nbsp;</a></span>clipRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::clipRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_region.html">SkRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>deviceRgn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkClipOp&#160;</td>
          <td class="paramname"><em>op</em> = <code>SkClipOp::kIntersect</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces clip with the intersection or difference of clip and <a class="el" href="class_sk_region.html">SkRegion</a> deviceRgn. Resulting clip is aliased; pixels are fully contained by the clip. deviceRgn is unaffected by <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">deviceRgn</td><td><a class="el" href="class_sk_region.html">SkRegion</a> to combine with clip </td></tr>
    <tr><td class="paramname">op</td><td>SkClipOp to apply to clip</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_clipRegion">https://fiddle.skia.org/c/@Canvas_clipRegion</a> </p>

</div>
</div>
<a id="ab9b609adaa6a8bc1e65d831c2e17ec3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b609adaa6a8bc1e65d831c2e17ec3d">&#9670;&nbsp;</a></span>clipRRect() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::clipRRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rrect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doAntiAlias</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces clip with the intersection of clip and rrect, with an aliased or anti-aliased clip edge. rrect is transformed by <a class="el" href="class_sk_matrix.html">SkMatrix</a> before it is combined with clip.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rrect</td><td><a class="el" href="class_sk_r_rect.html">SkRRect</a> to combine with clip </td></tr>
    <tr><td class="paramname">doAntiAlias</td><td>true if clip is to be anti-aliased </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70b894a4a670bd9f7f8f49aca47c0997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b894a4a670bd9f7f8f49aca47c0997">&#9670;&nbsp;</a></span>clipRRect() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::clipRRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rrect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkClipOp&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Replaces clip with the intersection or difference of clip and rrect. Resulting clip is aliased; pixels are fully contained by the clip. rrect is transformed by <a class="el" href="class_sk_matrix.html">SkMatrix</a> before it is combined with clip.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rrect</td><td><a class="el" href="class_sk_r_rect.html">SkRRect</a> to combine with clip </td></tr>
    <tr><td class="paramname">op</td><td>SkClipOp to apply to clip </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afcefd4d2ac745ad086fd62f30bbd8564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcefd4d2ac745ad086fd62f30bbd8564">&#9670;&nbsp;</a></span>clipRRect() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::clipRRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rrect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkClipOp&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doAntiAlias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces clip with the intersection or difference of clip and rrect, with an aliased or anti-aliased clip edge. rrect is transformed by <a class="el" href="class_sk_matrix.html">SkMatrix</a> before it is combined with clip.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rrect</td><td><a class="el" href="class_sk_r_rect.html">SkRRect</a> to combine with clip </td></tr>
    <tr><td class="paramname">op</td><td>SkClipOp to apply to clip </td></tr>
    <tr><td class="paramname">doAntiAlias</td><td>true if clip is to be anti-aliased</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_clipRRect">https://fiddle.skia.org/c/@Canvas_clipRRect</a> </p>

</div>
</div>
<a id="adb493a60db8ccd84abbaa26fb9506bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb493a60db8ccd84abbaa26fb9506bcf">&#9670;&nbsp;</a></span>concat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::concat </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces <a class="el" href="class_sk_matrix.html">SkMatrix</a> with matrix premultiplied with existing <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>This has the effect of transforming the drawn geometry by matrix, before transforming the result with existing <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>matrix to premultiply with existing <a class="el" href="class_sk_matrix.html">SkMatrix</a></td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_concat">https://fiddle.skia.org/c/@Canvas_concat</a> </p>

</div>
</div>
<a id="a4bd70c9638c294068b908347e87ccc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bd70c9638c294068b908347e87ccc7d">&#9670;&nbsp;</a></span>discard()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::discard </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Makes <a class="el" href="class_sk_canvas.html">SkCanvas</a> contents undefined. Subsequent calls that read <a class="el" href="class_sk_canvas.html">SkCanvas</a> pixels, such as drawing with SkBlendMode, return undefined results. <a class="el" href="class_sk_canvas.html#a4bd70c9638c294068b908347e87ccc7d">discard()</a> does not change clip or <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p><a class="el" href="class_sk_canvas.html#a4bd70c9638c294068b908347e87ccc7d">discard()</a> may do nothing, depending on the implementation of <a class="el" href="class_sk_surface.html">SkSurface</a> or <a class="el" href="class_sk_base_device.html">SkBaseDevice</a> that created <a class="el" href="class_sk_canvas.html">SkCanvas</a>.</p>
<p><a class="el" href="class_sk_canvas.html#a4bd70c9638c294068b908347e87ccc7d">discard()</a> allows optimized performance on subsequent draws by removing cached data associated with <a class="el" href="class_sk_surface.html">SkSurface</a> or <a class="el" href="class_sk_base_device.html">SkBaseDevice</a>. It is not necessary to call <a class="el" href="class_sk_canvas.html#a4bd70c9638c294068b908347e87ccc7d">discard()</a> once done with <a class="el" href="class_sk_canvas.html">SkCanvas</a>; any cached data is deleted when owning <a class="el" href="class_sk_surface.html">SkSurface</a> or <a class="el" href="class_sk_base_device.html">SkBaseDevice</a> is deleted. </p>

</div>
</div>
<a id="afdfa2c8f18412d979b7c0e6fbf658a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfa2c8f18412d979b7c0e6fbf658a74">&#9670;&nbsp;</a></span>drawAnnotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawAnnotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>key</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_data.html">SkData</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Associates <a class="el" href="struct_sk_rect.html">SkRect</a> on <a class="el" href="class_sk_canvas.html">SkCanvas</a> when an annotation; a key-value pair, where the key is a null-terminated UTF-8 string, and optional value is stored as <a class="el" href="class_sk_data.html">SkData</a>.</p>
<p>Only some canvas implementations, such as recording to <a class="el" href="class_sk_picture.html">SkPicture</a>, or drawing to document PDF, use annotations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> extent of canvas to annotate </td></tr>
    <tr><td class="paramname">key</td><td>string used for lookup </td></tr>
    <tr><td class="paramname">value</td><td>data holding value stored in annotation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69f267b5b50bf3990a6bb9747a21cd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f267b5b50bf3990a6bb9747a21cd02">&#9670;&nbsp;</a></span>drawAnnotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawAnnotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>key</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_data.html">SkData</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associates <a class="el" href="struct_sk_rect.html">SkRect</a> on <a class="el" href="class_sk_canvas.html">SkCanvas</a> with an annotation; a key-value pair, where the key is a null-terminated UTF-8 string, and optional value is stored as <a class="el" href="class_sk_data.html">SkData</a>.</p>
<p>Only some canvas implementations, such as recording to <a class="el" href="class_sk_picture.html">SkPicture</a>, or drawing to document PDF, use annotations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> extent of canvas to annotate </td></tr>
    <tr><td class="paramname">key</td><td>string used for lookup </td></tr>
    <tr><td class="paramname">value</td><td>data holding value stored in annotation</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawAnnotation_2">https://fiddle.skia.org/c/@Canvas_drawAnnotation_2</a> </p>

</div>
</div>
<a id="ab7d43d64e7e6d756e60a6d42f3dc472d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d43d64e7e6d756e60a6d42f3dc472d">&#9670;&nbsp;</a></span>drawArc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawArc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>oval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>startAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sweepAngle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useCenter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws arc using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint.</p>
<p>Arc is part of oval bounded by oval, sweeping from startAngle to startAngle plus sweepAngle. startAngle and sweepAngle are in degrees.</p>
<p>startAngle of zero places start point at the right middle edge of oval. A positive sweepAngle places arc end point clockwise from start point; a negative sweepAngle places arc end point counterclockwise from start point. sweepAngle may exceed 360 degrees, a full circle. If useCenter is true, draw a wedge that includes lines from oval center to arc end points. If useCenter is false, draw arc between end points.</p>
<p>If <a class="el" href="struct_sk_rect.html">SkRect</a> oval is empty or sweepAngle is zero, nothing is drawn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oval</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> bounds of oval containing arc to draw </td></tr>
    <tr><td class="paramname">startAngle</td><td>angle in degrees where arc begins </td></tr>
    <tr><td class="paramname">sweepAngle</td><td>sweep angle in degrees; positive is clockwise </td></tr>
    <tr><td class="paramname">useCenter</td><td>if true, include the center of the oval </td></tr>
    <tr><td class="paramname">paint</td><td><a class="el" href="class_sk_paint.html">SkPaint</a> stroke or fill, blend, color, and so on, used to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ace6d74f7e43162984c184cac4edc4363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6d74f7e43162984c184cac4edc4363">&#9670;&nbsp;</a></span>drawAtlas()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawAtlas </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_image.html">SkImage</a> *&#160;</td>
          <td class="paramname"><em>atlas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_r_s_xform.html">SkRSXform</a>&#160;</td>
          <td class="paramname"><em>xform</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a>&#160;</td>
          <td class="paramname"><em>tex</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a>&#160;</td>
          <td class="paramname"><em>colors</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkBlendMode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>sampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> *&#160;</td>
          <td class="paramname"><em>cullRect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws a set of sprites from atlas, using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and optional <a class="el" href="class_sk_paint.html">SkPaint</a> paint. paint uses anti-alias, alpha, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>, and SkBlendMode to draw, if present. For each entry in the array, <a class="el" href="struct_sk_rect.html">SkRect</a> tex locates sprite in atlas, and <a class="el" href="struct_sk_r_s_xform.html">SkRSXform</a> xform transforms it into destination space.</p>
<p>xform, tex, and colors if present, must contain count entries. Optional colors are applied for each sprite using SkBlendMode mode, treating sprite as source and colors as destination. Optional cullRect is a conservative bounds of all transformed sprites. If cullRect is outside of clip, canvas can skip drawing.</p>
<p>If atlas is nullptr, this draws nothing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">atlas</td><td><a class="el" href="class_sk_image.html">SkImage</a> containing sprites </td></tr>
    <tr><td class="paramname">xform</td><td><a class="el" href="struct_sk_r_s_xform.html">SkRSXform</a> mappings for sprites in atlas </td></tr>
    <tr><td class="paramname">tex</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> locations of sprites in atlas </td></tr>
    <tr><td class="paramname">colors</td><td>one per sprite, blended with sprite using SkBlendMode; may be nullptr </td></tr>
    <tr><td class="paramname">count</td><td>number of sprites to draw </td></tr>
    <tr><td class="paramname">mode</td><td>SkBlendMode combining colors and sprites </td></tr>
    <tr><td class="paramname">sampling</td><td><a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> used when sampling from the atlas image </td></tr>
    <tr><td class="paramname">cullRect</td><td>bounds of transformed sprites for efficient clipping; may be nullptr </td></tr>
    <tr><td class="paramname">paint</td><td><a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>, SkBlendMode, and so on; may be nullptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad70b82e3a846bba5a625e7aca15d4359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70b82e3a846bba5a625e7aca15d4359">&#9670;&nbsp;</a></span>drawCircle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawCircle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws circle at center with radius using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint. If radius is zero or less, nothing is drawn. In paint: <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a> determines if circle is stroked or filled; if stroked, <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width describes the line thickness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">center</td><td>circle center </td></tr>
    <tr><td class="paramname">radius</td><td>half the diameter of circle </td></tr>
    <tr><td class="paramname">paint</td><td><a class="el" href="class_sk_paint.html">SkPaint</a> stroke or fill, blend, color, and so on, used to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afeec18345530ada3fc5bfd077bc7eb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeec18345530ada3fc5bfd077bc7eb2f">&#9670;&nbsp;</a></span>drawCircle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawCircle </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>cx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>cy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws circle at (cx, cy) with radius using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint. If radius is zero or less, nothing is drawn. In paint: <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a> determines if circle is stroked or filled; if stroked, <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width describes the line thickness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cx</td><td>circle center on the x-axis </td></tr>
    <tr><td class="paramname">cy</td><td>circle center on the y-axis </td></tr>
    <tr><td class="paramname">radius</td><td>half the diameter of circle </td></tr>
    <tr><td class="paramname">paint</td><td><a class="el" href="class_sk_paint.html">SkPaint</a> stroke or fill, blend, color, and so on, used to draw</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawCircle">https://fiddle.skia.org/c/@Canvas_drawCircle</a> </p>

</div>
</div>
<a id="a81e9e3ac4ff51408f6311dda19c5c475"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e9e3ac4ff51408f6311dda19c5c475">&#9670;&nbsp;</a></span>drawColor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawColor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkBlendMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>SkBlendMode::kSrcOver</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills clip with color color. mode determines how ARGB is combined with destination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td><a class="el" href="struct_sk_color4f.html">SkColor4f</a> representing unpremultiplied color. </td></tr>
    <tr><td class="paramname">mode</td><td>SkBlendMode used to combine source color and destination </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b0017c7afd5dd3cbb6352f7b1c92084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0017c7afd5dd3cbb6352f7b1c92084">&#9670;&nbsp;</a></span>drawColor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a>&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkBlendMode&#160;</td>
          <td class="paramname"><em>mode</em> = <code>SkBlendMode::kSrcOver</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fills clip with color color. mode determines how ARGB is combined with destination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">color</td><td>unpremultiplied ARGB </td></tr>
    <tr><td class="paramname">mode</td><td>SkBlendMode used to combine source color and destination</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawColor">https://fiddle.skia.org/c/@Canvas_drawColor</a> </p>

</div>
</div>
<a id="a675eb3bc89d1696b8077a2e9fdca87c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675eb3bc89d1696b8077a2e9fdca87c4">&#9670;&nbsp;</a></span>drawDrawable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawDrawable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_drawable.html">SkDrawable</a> *&#160;</td>
          <td class="paramname"><em>drawable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> *&#160;</td>
          <td class="paramname"><em>matrix</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_drawable.html">SkDrawable</a> drawable using clip and <a class="el" href="class_sk_matrix.html">SkMatrix</a>, concatenated with optional matrix.</p>
<p>If <a class="el" href="class_sk_canvas.html">SkCanvas</a> has an asynchronous implementation, as is the case when it is recording into <a class="el" href="class_sk_picture.html">SkPicture</a>, then drawable will be referenced, so that <a class="el" href="class_sk_drawable.html#ade63adbce24872944c202e3cb619359b">SkDrawable::draw()</a> can be called when the operation is finalized. To force immediate drawing, call <a class="el" href="class_sk_drawable.html#ade63adbce24872944c202e3cb619359b">SkDrawable::draw()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drawable</td><td>custom struct encapsulating drawing commands </td></tr>
    <tr><td class="paramname">matrix</td><td>transformation applied to drawing; may be nullptr</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawDrawable">https://fiddle.skia.org/c/@Canvas_drawDrawable</a> </p>

</div>
</div>
<a id="a3faa82931933f00648e32b4d3a4de0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3faa82931933f00648e32b4d3a4de0f0">&#9670;&nbsp;</a></span>drawDrawable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawDrawable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_drawable.html">SkDrawable</a> *&#160;</td>
          <td class="paramname"><em>drawable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_drawable.html">SkDrawable</a> drawable using clip and <a class="el" href="class_sk_matrix.html">SkMatrix</a>, offset by (x, y).</p>
<p>If <a class="el" href="class_sk_canvas.html">SkCanvas</a> has an asynchronous implementation, as is the case when it is recording into <a class="el" href="class_sk_picture.html">SkPicture</a>, then drawable will be referenced, so that <a class="el" href="class_sk_drawable.html#ade63adbce24872944c202e3cb619359b">SkDrawable::draw()</a> can be called when the operation is finalized. To force immediate drawing, call <a class="el" href="class_sk_drawable.html#ade63adbce24872944c202e3cb619359b">SkDrawable::draw()</a> instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drawable</td><td>custom struct encapsulating drawing commands </td></tr>
    <tr><td class="paramname">x</td><td>offset into <a class="el" href="class_sk_canvas.html">SkCanvas</a> writable pixels on x-axis </td></tr>
    <tr><td class="paramname">y</td><td>offset into <a class="el" href="class_sk_canvas.html">SkCanvas</a> writable pixels on y-axis</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawDrawable_2">https://fiddle.skia.org/c/@Canvas_drawDrawable_2</a> </p>

</div>
</div>
<a id="ad7149e359d4d0cfd2ad708e905f0d8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7149e359d4d0cfd2ad708e905f0d8c6">&#9670;&nbsp;</a></span>drawDRRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawDRRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;&#160;</td>
          <td class="paramname"><em>outer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_r_rect.html">SkRRect</a> outer and inner using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint. outer must contain inner or the drawing is undefined. In paint: <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a> determines if <a class="el" href="class_sk_r_rect.html">SkRRect</a> is stroked or filled; if stroked, <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width describes the line thickness. If stroked and <a class="el" href="class_sk_r_rect.html">SkRRect</a> corner has zero length radii, <a class="el" href="class_sk_paint.html#ac582b0cbf59909c9056de34a6b977cca">SkPaint::Join</a> can draw corners rounded or square.</p>
<p>GPU-backed platforms optimize drawing when both outer and inner are concave and outer contains inner. These platforms may not be able to draw <a class="el" href="class_sk_path.html">SkPath</a> built with identical data as fast.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outer</td><td><a class="el" href="class_sk_r_rect.html">SkRRect</a> outer bounds to draw </td></tr>
    <tr><td class="paramname">inner</td><td><a class="el" href="class_sk_r_rect.html">SkRRect</a> inner bounds to draw </td></tr>
    <tr><td class="paramname">paint</td><td><a class="el" href="class_sk_paint.html">SkPaint</a> stroke or fill, blend, color, and so on, used to draw</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawDRRect_a">https://fiddle.skia.org/c/@Canvas_drawDRRect_a</a> example: <a href="https://fiddle.skia.org/c/@Canvas_drawDRRect_b">https://fiddle.skia.org/c/@Canvas_drawDRRect_b</a> </p>

</div>
</div>
<a id="a8cefe226459f3787b5f1eea25c433dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cefe226459f3787b5f1eea25c433dc4">&#9670;&nbsp;</a></span>drawGlyphs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawGlyphs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_sk_types_8h.html#a1d5e8bd1d16e0484508ec693933b0a54">SkGlyphID</a>&#160;</td>
          <td class="paramname"><em>glyphs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>positions</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>clusters</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>textByteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>utf8text</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_font.html">SkFont</a> &amp;&#160;</td>
          <td class="paramname"><em>font</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws count glyphs, at positions relative to origin styled with font and paint with supporting utf8 and cluster information.</p>
<p>This function draw glyphs at the given positions relative to the given origin. It does not perform typeface fallback for glyphs not found in the <a class="el" href="class_sk_typeface.html">SkTypeface</a> in font.</p>
<p>The drawing obeys the current transform matrix and clipping.</p>
<p>All elements of paint: <a class="el" href="class_sk_path_effect.html">SkPathEffect</a>, <a class="el" href="class_sk_mask_filter.html">SkMaskFilter</a>, <a class="el" href="class_sk_shader.html">SkShader</a>, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, and <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>; apply to text. By default, draws filled black glyphs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>number of glyphs to draw </td></tr>
    <tr><td class="paramname">glyphs</td><td>the array of glyphIDs to draw </td></tr>
    <tr><td class="paramname">positions</td><td>where to draw each glyph relative to origin </td></tr>
    <tr><td class="paramname">clusters</td><td>array of size count of cluster information </td></tr>
    <tr><td class="paramname">textByteCount</td><td>size of the utf8text </td></tr>
    <tr><td class="paramname">utf8text</td><td>utf8text supporting information for the glyphs </td></tr>
    <tr><td class="paramname">origin</td><td>the origin of all the positions </td></tr>
    <tr><td class="paramname">font</td><td>typeface, text size and so, used to describe the text </td></tr>
    <tr><td class="paramname">paint</td><td>blend, color, and so on, used to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a44c65f566d391678b9222bc038a17756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44c65f566d391678b9222bc038a17756">&#9670;&nbsp;</a></span>drawGlyphs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawGlyphs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_sk_types_8h.html#a1d5e8bd1d16e0484508ec693933b0a54">SkGlyphID</a>&#160;</td>
          <td class="paramname"><em>glyphs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>positions</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_font.html">SkFont</a> &amp;&#160;</td>
          <td class="paramname"><em>font</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws count glyphs, at positions relative to origin styled with font and paint.</p>
<p>This function draw glyphs at the given positions relative to the given origin. It does not perform typeface fallback for glyphs not found in the <a class="el" href="class_sk_typeface.html">SkTypeface</a> in font.</p>
<p>The drawing obeys the current transform matrix and clipping.</p>
<p>All elements of paint: <a class="el" href="class_sk_path_effect.html">SkPathEffect</a>, <a class="el" href="class_sk_mask_filter.html">SkMaskFilter</a>, <a class="el" href="class_sk_shader.html">SkShader</a>, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, and <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>; apply to text. By default, draws filled black glyphs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>number of glyphs to draw </td></tr>
    <tr><td class="paramname">glyphs</td><td>the array of glyphIDs to draw </td></tr>
    <tr><td class="paramname">positions</td><td>where to draw each glyph relative to origin </td></tr>
    <tr><td class="paramname">origin</td><td>the origin of all the positions </td></tr>
    <tr><td class="paramname">font</td><td>typeface, text size and so, used to describe the text </td></tr>
    <tr><td class="paramname">paint</td><td>blend, color, and so on, used to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a32cf46dce324c389b2351453b115354c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cf46dce324c389b2351453b115354c">&#9670;&nbsp;</a></span>drawGlyphs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawGlyphs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_sk_types_8h.html#a1d5e8bd1d16e0484508ec693933b0a54">SkGlyphID</a>&#160;</td>
          <td class="paramname"><em>glyphs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_r_s_xform.html">SkRSXform</a>&#160;</td>
          <td class="paramname"><em>xforms</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_font.html">SkFont</a> &amp;&#160;</td>
          <td class="paramname"><em>font</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws count glyphs, at positions relative to origin styled with font and paint.</p>
<p>This function draw glyphs using the given scaling and rotations. They are positioned relative to the given origin. It does not perform typeface fallback for glyphs not found in the <a class="el" href="class_sk_typeface.html">SkTypeface</a> in font.</p>
<p>The drawing obeys the current transform matrix and clipping.</p>
<p>All elements of paint: <a class="el" href="class_sk_path_effect.html">SkPathEffect</a>, <a class="el" href="class_sk_mask_filter.html">SkMaskFilter</a>, <a class="el" href="class_sk_shader.html">SkShader</a>, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, and <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>; apply to text. By default, draws filled black glyphs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">count</td><td>number of glyphs to draw </td></tr>
    <tr><td class="paramname">glyphs</td><td>the array of glyphIDs to draw </td></tr>
    <tr><td class="paramname">xforms</td><td>where to draw and orient each glyph </td></tr>
    <tr><td class="paramname">origin</td><td>the origin of all the positions </td></tr>
    <tr><td class="paramname">font</td><td>typeface, text size and so, used to describe the text </td></tr>
    <tr><td class="paramname">paint</td><td>blend, color, and so on, used to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8a724321360f9f71b409f8d11172628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a724321360f9f71b409f8d11172628">&#9670;&nbsp;</a></span>drawImageLattice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawImageLattice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_image.html">SkImage</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_canvas_1_1_lattice.html">Lattice</a> &amp;&#160;</td>
          <td class="paramname"><em>lattice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkFilterMode&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&#160;</td>
          <td class="paramname"><em>paint</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_image.html">SkImage</a> image stretched proportionally to fit into <a class="el" href="struct_sk_rect.html">SkRect</a> dst.</p>
<p><a class="el" href="struct_sk_canvas_1_1_lattice.html">SkCanvas::Lattice</a> lattice divides image into a rectangular grid. Each intersection of an even-numbered row and column is fixed; fixed lattice elements never scale larger than their initial size and shrink proportionately when all fixed elements exceed the bitmap dimension. All other grid elements scale to fill the available space, if any.</p>
<p>Additionally transform draw using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and optional <a class="el" href="class_sk_paint.html">SkPaint</a> paint.</p>
<p>If <a class="el" href="class_sk_paint.html">SkPaint</a> paint is supplied, apply <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, alpha, <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>, and SkBlendMode. If image is kAlpha_8_SkColorType, apply <a class="el" href="class_sk_shader.html">SkShader</a>. If paint contains <a class="el" href="class_sk_mask_filter.html">SkMaskFilter</a>, generate mask from image bounds. Any <a class="el" href="class_sk_mask_filter.html">SkMaskFilter</a> on paint is ignored as is paint anti-aliasing state.</p>
<p>If generated mask extends beyond bitmap bounds, replicate bitmap edge colors, just as <a class="el" href="class_sk_shader.html">SkShader</a> made from SkShader::MakeBitmapShader with SkShader::kClamp_TileMode set replicates the bitmap edge color when it samples outside of its bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td><a class="el" href="class_sk_image.html">SkImage</a> containing pixels, dimensions, and format </td></tr>
    <tr><td class="paramname">lattice</td><td>division of bitmap into fixed and variable rectangles </td></tr>
    <tr><td class="paramname">dst</td><td>destination <a class="el" href="struct_sk_rect.html">SkRect</a> of image to draw to </td></tr>
    <tr><td class="paramname">filter</td><td>what technique to use when sampling the image </td></tr>
    <tr><td class="paramname">paint</td><td><a class="el" href="class_sk_paint.html">SkPaint</a> containing SkBlendMode, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>, and so on; or nullptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3a9a10b43dcffdac586ca21b853627b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a9a10b43dcffdac586ca21b853627b3">&#9670;&nbsp;</a></span>drawImageNine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawImageNine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_image.html">SkImage</a> *&#160;</td>
          <td class="paramname"><em>image</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkFilterMode&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&#160;</td>
          <td class="paramname"><em>paint</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_image.html">SkImage</a> image stretched proportionally to fit into <a class="el" href="struct_sk_rect.html">SkRect</a> dst. <a class="el" href="struct_sk_i_rect.html">SkIRect</a> center divides the image into nine sections: four sides, four corners, and the center. Corners are unmodified or scaled down proportionately if their sides are larger than dst; center and four sides are scaled to fit remaining space, if any.</p>
<p>Additionally transform draw using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and optional <a class="el" href="class_sk_paint.html">SkPaint</a> paint.</p>
<p>If <a class="el" href="class_sk_paint.html">SkPaint</a> paint is supplied, apply <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, alpha, <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>, and SkBlendMode. If image is kAlpha_8_SkColorType, apply <a class="el" href="class_sk_shader.html">SkShader</a>. If paint contains <a class="el" href="class_sk_mask_filter.html">SkMaskFilter</a>, generate mask from image bounds. Any <a class="el" href="class_sk_mask_filter.html">SkMaskFilter</a> on paint is ignored as is paint anti-aliasing state.</p>
<p>If generated mask extends beyond image bounds, replicate image edge colors, just as <a class="el" href="class_sk_shader.html">SkShader</a> made from <a class="el" href="class_sk_image.html#a74353e5b80ca5efdaf51a11755149aba">SkImage::makeShader</a> with SkShader::kClamp_TileMode set replicates the image edge color when it samples outside of its bounds.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">image</td><td><a class="el" href="class_sk_image.html">SkImage</a> containing pixels, dimensions, and format </td></tr>
    <tr><td class="paramname">center</td><td><a class="el" href="struct_sk_i_rect.html">SkIRect</a> edge of image corners and sides </td></tr>
    <tr><td class="paramname">dst</td><td>destination <a class="el" href="struct_sk_rect.html">SkRect</a> of image to draw to </td></tr>
    <tr><td class="paramname">filter</td><td>what technique to use when sampling the image </td></tr>
    <tr><td class="paramname">paint</td><td><a class="el" href="class_sk_paint.html">SkPaint</a> containing SkBlendMode, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>, and so on; or nullptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9646a00be01648cb4b6206a84581e8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9646a00be01648cb4b6206a84581e8fb">&#9670;&nbsp;</a></span>drawIRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawIRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws <a class="el" href="struct_sk_i_rect.html">SkIRect</a> rect using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint. In paint: <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a> determines if rectangle is stroked or filled; if stroked, <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width describes the line thickness, and <a class="el" href="class_sk_paint.html#ac582b0cbf59909c9056de34a6b977cca">SkPaint::Join</a> draws the corners rounded or square.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>rectangle to draw </td></tr>
    <tr><td class="paramname">paint</td><td>stroke or fill, blend, color, and so on, used to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aeafca9e73fd46514ffb4162160638895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeafca9e73fd46514ffb4162160638895">&#9670;&nbsp;</a></span>drawLine() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawLine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>p0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws line segment from p0 to p1 using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint. In paint: <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width describes the line thickness; <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333">SkPaint::Cap</a> draws the end rounded or square; <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a> is ignored, as if were set to <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fda4bcc9f35fd6468ad92012c70daf7a495" title="set to stroke geometry">SkPaint::kStroke_Style</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p0</td><td>start of line segment </td></tr>
    <tr><td class="paramname">p1</td><td>end of line segment </td></tr>
    <tr><td class="paramname">paint</td><td>stroke, blend, color, and so on, used to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6532d77a844abb68ba029243ce218ec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6532d77a844abb68ba029243ce218ec6">&#9670;&nbsp;</a></span>drawLine() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawLine </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws line segment from (x0, y0) to (x1, y1) using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint. In paint: <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width describes the line thickness; <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333">SkPaint::Cap</a> draws the end rounded or square; <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a> is ignored, as if were set to <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fda4bcc9f35fd6468ad92012c70daf7a495" title="set to stroke geometry">SkPaint::kStroke_Style</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x0</td><td>start of line segment on x-axis </td></tr>
    <tr><td class="paramname">y0</td><td>start of line segment on y-axis </td></tr>
    <tr><td class="paramname">x1</td><td>end of line segment on x-axis </td></tr>
    <tr><td class="paramname">y1</td><td>end of line segment on y-axis </td></tr>
    <tr><td class="paramname">paint</td><td>stroke, blend, color, and so on, used to draw</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawLine">https://fiddle.skia.org/c/@Canvas_drawLine</a> </p>

</div>
</div>
<a id="a183daa228e12207a75660fae3dc5e3f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183daa228e12207a75660fae3dc5e3f9">&#9670;&nbsp;</a></span>drawOval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawOval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>oval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws oval oval using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a>. In paint: <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a> determines if oval is stroked or filled; if stroked, <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width describes the line thickness.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oval</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> bounds of oval </td></tr>
    <tr><td class="paramname">paint</td><td><a class="el" href="class_sk_paint.html">SkPaint</a> stroke or fill, blend, color, and so on, used to draw</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawOval">https://fiddle.skia.org/c/@Canvas_drawOval</a> </p>

</div>
</div>
<a id="a64cf967c90d18c096b91519b0d5336a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64cf967c90d18c096b91519b0d5336a3">&#9670;&nbsp;</a></span>drawPaint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawPaint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills clip with <a class="el" href="class_sk_paint.html">SkPaint</a> paint. <a class="el" href="class_sk_paint.html">SkPaint</a> components, <a class="el" href="class_sk_shader.html">SkShader</a>, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>, and SkBlendMode affect drawing; <a class="el" href="class_sk_mask_filter.html">SkMaskFilter</a> and <a class="el" href="class_sk_path_effect.html">SkPathEffect</a> in paint are ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">paint</td><td>graphics state used to fill <a class="el" href="class_sk_canvas.html">SkCanvas</a></td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawPaint">https://fiddle.skia.org/c/@Canvas_drawPaint</a> </p>

</div>
</div>
<a id="af960b19fda72b8dc5017e29256ac4a81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af960b19fda72b8dc5017e29256ac4a81">&#9670;&nbsp;</a></span>drawPatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawPatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>cubics</em>[12], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a>&#160;</td>
          <td class="paramname"><em>colors</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>texCoords</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_path.html">SkPath</a> cubic Coons patch: the interpolation of four cubics with shared corners, associating a color, and optionally a texture <a class="el" href="struct_sk_point.html">SkPoint</a>, with each corner.</p>
<p>Coons patch uses clip and <a class="el" href="class_sk_matrix.html">SkMatrix</a>, paint <a class="el" href="class_sk_shader.html">SkShader</a>, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, alpha, <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>, and SkBlendMode. If <a class="el" href="class_sk_shader.html">SkShader</a> is provided it is treated as Coons patch texture; SkBlendMode mode combines color colors and <a class="el" href="class_sk_shader.html">SkShader</a> if both are provided.</p>
<p><a class="el" href="struct_sk_point.html">SkPoint</a> array cubics specifies four <a class="el" href="class_sk_path.html">SkPath</a> cubic starting at the top-left corner, in clockwise order, sharing every fourth point. The last <a class="el" href="class_sk_path.html">SkPath</a> cubic ends at the first point.</p>
<p>Color array color associates colors with corners in top-left, top-right, bottom-right, bottom-left order.</p>
<p>If paint contains <a class="el" href="class_sk_shader.html">SkShader</a>, <a class="el" href="struct_sk_point.html">SkPoint</a> array texCoords maps <a class="el" href="class_sk_shader.html">SkShader</a> as texture to corners in top-left, top-right, bottom-right, bottom-left order. If texCoords is nullptr, <a class="el" href="class_sk_shader.html">SkShader</a> is mapped using positions (derived from cubics).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cubics</td><td><a class="el" href="class_sk_path.html">SkPath</a> cubic array, sharing common points </td></tr>
    <tr><td class="paramname">colors</td><td>color array, one for each corner </td></tr>
    <tr><td class="paramname">texCoords</td><td><a class="el" href="struct_sk_point.html">SkPoint</a> array of texture coordinates, mapping <a class="el" href="class_sk_shader.html">SkShader</a> to corners; may be nullptr </td></tr>
    <tr><td class="paramname">paint</td><td><a class="el" href="class_sk_shader.html">SkShader</a>, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, SkBlendMode, used to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a29b048324b32bfc785c0c256d65aa885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29b048324b32bfc785c0c256d65aa885">&#9670;&nbsp;</a></span>drawPatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawPatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>cubics</em>[12], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_sk_color_8h.html#a84c81e6a24ff07a55333acf5603046a8">SkColor</a>&#160;</td>
          <td class="paramname"><em>colors</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>texCoords</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkBlendMode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws a Coons patch: the interpolation of four cubics with shared corners, associating a color, and optionally a texture <a class="el" href="struct_sk_point.html">SkPoint</a>, with each corner.</p>
<p>Coons patch uses clip and <a class="el" href="class_sk_matrix.html">SkMatrix</a>, paint <a class="el" href="class_sk_shader.html">SkShader</a>, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, alpha, <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>, and SkBlendMode. If <a class="el" href="class_sk_shader.html">SkShader</a> is provided it is treated as Coons patch texture; SkBlendMode mode combines color colors and <a class="el" href="class_sk_shader.html">SkShader</a> if both are provided.</p>
<p><a class="el" href="struct_sk_point.html">SkPoint</a> array cubics specifies four <a class="el" href="class_sk_path.html">SkPath</a> cubic starting at the top-left corner, in clockwise order, sharing every fourth point. The last <a class="el" href="class_sk_path.html">SkPath</a> cubic ends at the first point.</p>
<p>Color array color associates colors with corners in top-left, top-right, bottom-right, bottom-left order.</p>
<p>If paint contains <a class="el" href="class_sk_shader.html">SkShader</a>, <a class="el" href="struct_sk_point.html">SkPoint</a> array texCoords maps <a class="el" href="class_sk_shader.html">SkShader</a> as texture to corners in top-left, top-right, bottom-right, bottom-left order. If texCoords is nullptr, <a class="el" href="class_sk_shader.html">SkShader</a> is mapped using positions (derived from cubics).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cubics</td><td><a class="el" href="class_sk_path.html">SkPath</a> cubic array, sharing common points </td></tr>
    <tr><td class="paramname">colors</td><td>color array, one for each corner </td></tr>
    <tr><td class="paramname">texCoords</td><td><a class="el" href="struct_sk_point.html">SkPoint</a> array of texture coordinates, mapping <a class="el" href="class_sk_shader.html">SkShader</a> to corners; may be nullptr </td></tr>
    <tr><td class="paramname">mode</td><td>SkBlendMode for colors, and for <a class="el" href="class_sk_shader.html">SkShader</a> if paint has one </td></tr>
    <tr><td class="paramname">paint</td><td><a class="el" href="class_sk_shader.html">SkShader</a>, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, SkBlendMode, used to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acddf41dddcd12333b061ce9c963616bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acddf41dddcd12333b061ce9c963616bb">&#9670;&nbsp;</a></span>drawPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_path.html">SkPath</a> path using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint. <a class="el" href="class_sk_path.html">SkPath</a> contains an array of path contour, each of which may be open or closed.</p>
<p>In paint: <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a> determines if <a class="el" href="class_sk_r_rect.html">SkRRect</a> is stroked or filled: if filled, SkPath::FillType determines whether path contour describes inside or outside of fill; if stroked, <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width describes the line thickness, <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333">SkPaint::Cap</a> describes line ends, and <a class="el" href="class_sk_paint.html#ac582b0cbf59909c9056de34a6b977cca">SkPaint::Join</a> describes how corners are drawn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td><a class="el" href="class_sk_path.html">SkPath</a> to draw </td></tr>
    <tr><td class="paramname">paint</td><td>stroke, blend, color, and so on, used to draw</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawPath">https://fiddle.skia.org/c/@Canvas_drawPath</a> </p>

</div>
</div>
<a id="a3cfa0f7173e172db0ff20417c3e07a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfa0f7173e172db0ff20417c3e07a12">&#9670;&nbsp;</a></span>drawPicture() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawPicture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_picture.html">SkPicture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>picture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_picture.html">SkPicture</a> picture, using clip and <a class="el" href="class_sk_matrix.html">SkMatrix</a>. Clip and <a class="el" href="class_sk_matrix.html">SkMatrix</a> are unchanged by picture contents, as if <a class="el" href="class_sk_canvas.html#ac98147dc771b47c7353a51e7c171e428">save()</a> was called before and <a class="el" href="class_sk_canvas.html#a2c68ed85badf62be77bb862b02dd4961">restore()</a> was called after <a class="el" href="class_sk_canvas.html#ae291eaf5243302d4d7f56195b0a0bb1d">drawPicture()</a>.</p>
<p><a class="el" href="class_sk_picture.html">SkPicture</a> records a series of draw commands for later playback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">picture</td><td>recorded drawing commands to play </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab9882919aa534a6c911be0bb362c9cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9882919aa534a6c911be0bb362c9cfa">&#9670;&nbsp;</a></span>drawPicture() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawPicture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_picture.html">SkPicture</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>picture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_picture.html">SkPicture</a> picture, using clip and <a class="el" href="class_sk_matrix.html">SkMatrix</a>; transforming picture with <a class="el" href="class_sk_matrix.html">SkMatrix</a> matrix, if provided; and use <a class="el" href="class_sk_paint.html">SkPaint</a> paint alpha, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>, and SkBlendMode, if provided.</p>
<p>If paint is non-null, then the picture is always drawn into a temporary layer before actually landing on the canvas. Note that drawing into a layer can also change its appearance if there are any non-associative blendModes inside any of the pictures elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">picture</td><td>recorded drawing commands to play </td></tr>
    <tr><td class="paramname">matrix</td><td><a class="el" href="class_sk_matrix.html">SkMatrix</a> to rotate, scale, translate, and so on; may be nullptr </td></tr>
    <tr><td class="paramname">paint</td><td><a class="el" href="class_sk_paint.html">SkPaint</a> to apply transparency, filtering, and so on; may be nullptr </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae291eaf5243302d4d7f56195b0a0bb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae291eaf5243302d4d7f56195b0a0bb1d">&#9670;&nbsp;</a></span>drawPicture() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawPicture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_picture.html">SkPicture</a> *&#160;</td>
          <td class="paramname"><em>picture</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_picture.html">SkPicture</a> picture, using clip and <a class="el" href="class_sk_matrix.html">SkMatrix</a>. Clip and <a class="el" href="class_sk_matrix.html">SkMatrix</a> are unchanged by picture contents, as if <a class="el" href="class_sk_canvas.html#ac98147dc771b47c7353a51e7c171e428">save()</a> was called before and <a class="el" href="class_sk_canvas.html#a2c68ed85badf62be77bb862b02dd4961">restore()</a> was called after <a class="el" href="class_sk_canvas.html#ae291eaf5243302d4d7f56195b0a0bb1d">drawPicture()</a>.</p>
<p><a class="el" href="class_sk_picture.html">SkPicture</a> records a series of draw commands for later playback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">picture</td><td>recorded drawing commands to play </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9207103b010bda8def557aafbcc1825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9207103b010bda8def557aafbcc1825">&#9670;&nbsp;</a></span>drawPicture() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawPicture </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_picture.html">SkPicture</a> *&#160;</td>
          <td class="paramname"><em>picture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a> *&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_picture.html">SkPicture</a> picture, using clip and <a class="el" href="class_sk_matrix.html">SkMatrix</a>; transforming picture with <a class="el" href="class_sk_matrix.html">SkMatrix</a> matrix, if provided; and use <a class="el" href="class_sk_paint.html">SkPaint</a> paint alpha, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>, and SkBlendMode, if provided.</p>
<p>If paint is non-null, then the picture is always drawn into a temporary layer before actually landing on the canvas. Note that drawing into a layer can also change its appearance if there are any non-associative blendModes inside any of the pictures elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">picture</td><td>recorded drawing commands to play </td></tr>
    <tr><td class="paramname">matrix</td><td><a class="el" href="class_sk_matrix.html">SkMatrix</a> to rotate, scale, translate, and so on; may be nullptr </td></tr>
    <tr><td class="paramname">paint</td><td><a class="el" href="class_sk_paint.html">SkPaint</a> to apply transparency, filtering, and so on; may be nullptr</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawPicture_3">https://fiddle.skia.org/c/@Canvas_drawPicture_3</a> </p>

</div>
</div>
<a id="a32a1b722337849eb7f99e27d84093c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a1b722337849eb7f99e27d84093c49">&#9670;&nbsp;</a></span>drawPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws point p using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a> and <a class="el" href="class_sk_paint.html">SkPaint</a> paint.</p>
<p>The shape of point drawn depends on paint <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333">SkPaint::Cap</a>. If paint is set to <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333ab00b95302fe33924e63513c82b53f16b" title="adds circle">SkPaint::kRound_Cap</a>, draw a circle of diameter <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width. If paint is set to <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333ada3bff894a3c2a8874860e533bc04334" title="adds square">SkPaint::kSquare_Cap</a> or <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333abaac9668fb0acc014c962d843d6674b5" title="no stroke extension">SkPaint::kButt_Cap</a>, draw a square of width and height <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width. <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a> is ignored, as if were set to <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fda4bcc9f35fd6468ad92012c70daf7a495" title="set to stroke geometry">SkPaint::kStroke_Style</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>top-left edge of circle or square </td></tr>
    <tr><td class="paramname">paint</td><td>stroke, blend, color, and so on, used to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ebda507728e3d6cc839492593fd7a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ebda507728e3d6cc839492593fd7a3d">&#9670;&nbsp;</a></span>drawPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawPoint </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws point at (x, y) using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a> and <a class="el" href="class_sk_paint.html">SkPaint</a> paint.</p>
<p>The shape of point drawn depends on paint <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333">SkPaint::Cap</a>. If paint is set to <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333ab00b95302fe33924e63513c82b53f16b" title="adds circle">SkPaint::kRound_Cap</a>, draw a circle of diameter <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width. If paint is set to <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333ada3bff894a3c2a8874860e533bc04334" title="adds square">SkPaint::kSquare_Cap</a> or <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333abaac9668fb0acc014c962d843d6674b5" title="no stroke extension">SkPaint::kButt_Cap</a>, draw a square of width and height <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width. <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a> is ignored, as if were set to <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fda4bcc9f35fd6468ad92012c70daf7a495" title="set to stroke geometry">SkPaint::kStroke_Style</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>left edge of circle or square </td></tr>
    <tr><td class="paramname">y</td><td>top edge of circle or square </td></tr>
    <tr><td class="paramname">paint</td><td>stroke, blend, color, and so on, used to draw</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawPoint">https://fiddle.skia.org/c/@Canvas_drawPoint</a> </p>

</div>
</div>
<a id="a1e9be2866798af6038ee3e724722d1f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9be2866798af6038ee3e724722d1f9">&#9670;&nbsp;</a></span>drawPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#af1bcd412326a6886e0f260d4d2dc757b">PointMode</a>&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>pts</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws pts using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a> and <a class="el" href="class_sk_paint.html">SkPaint</a> paint. count is the number of points; if count is less than one, has no effect. mode may be one of: kPoints_PointMode, kLines_PointMode, or kPolygon_PointMode.</p>
<p>If mode is kPoints_PointMode, the shape of point drawn depends on paint <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333">SkPaint::Cap</a>. If paint is set to <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333ab00b95302fe33924e63513c82b53f16b" title="adds circle">SkPaint::kRound_Cap</a>, each point draws a circle of diameter <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width. If paint is set to <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333ada3bff894a3c2a8874860e533bc04334" title="adds square">SkPaint::kSquare_Cap</a> or <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333abaac9668fb0acc014c962d843d6674b5" title="no stroke extension">SkPaint::kButt_Cap</a>, each point draws a square of width and height <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width.</p>
<p>If mode is kLines_PointMode, each pair of points draws a line segment. One line is drawn for every two points; each point is used once. If count is odd, the final point is ignored.</p>
<p>If mode is kPolygon_PointMode, each adjacent pair of points draws a line segment. count minus one lines are drawn; the first and last point are used once.</p>
<p>Each line segment respects paint <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333">SkPaint::Cap</a> and <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width. <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a> is ignored, as if were set to <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fda4bcc9f35fd6468ad92012c70daf7a495" title="set to stroke geometry">SkPaint::kStroke_Style</a>.</p>
<p>Always draws each element one at a time; is not affected by <a class="el" href="class_sk_paint.html#ac582b0cbf59909c9056de34a6b977cca">SkPaint::Join</a>, and unlike <a class="el" href="class_sk_canvas.html#acddf41dddcd12333b061ce9c963616bb">drawPath()</a>, does not create a mask from all points and lines before drawing.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mode</td><td>whether pts draws points or lines </td></tr>
    <tr><td class="paramname">count</td><td>number of points in the array </td></tr>
    <tr><td class="paramname">pts</td><td>array of points to draw </td></tr>
    <tr><td class="paramname">paint</td><td>stroke, blend, color, and so on, used to draw</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawPoints">https://fiddle.skia.org/c/@Canvas_drawPoints</a> </p>

</div>
</div>
<a id="a15a77a3479b8f8731442d4a4ea2772b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15a77a3479b8f8731442d4a4ea2772b3">&#9670;&nbsp;</a></span>drawRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <a class="el" href="struct_sk_rect.html">SkRect</a> rect using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint. In paint: <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a> determines if rectangle is stroked or filled; if stroked, <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width describes the line thickness, and <a class="el" href="class_sk_paint.html#ac582b0cbf59909c9056de34a6b977cca">SkPaint::Join</a> draws the corners rounded or square.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td>rectangle to draw </td></tr>
    <tr><td class="paramname">paint</td><td>stroke or fill, blend, color, and so on, used to draw</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawRect">https://fiddle.skia.org/c/@Canvas_drawRect</a> </p>

</div>
</div>
<a id="ac42682194b4c8bcbb8f6efbe931b74ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42682194b4c8bcbb8f6efbe931b74ac">&#9670;&nbsp;</a></span>drawRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_region.html">SkRegion</a> &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_region.html">SkRegion</a> region using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint. In paint: <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a> determines if rectangle is stroked or filled; if stroked, <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width describes the line thickness, and <a class="el" href="class_sk_paint.html#ac582b0cbf59909c9056de34a6b977cca">SkPaint::Join</a> draws the corners rounded or square.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">region</td><td>region to draw </td></tr>
    <tr><td class="paramname">paint</td><td><a class="el" href="class_sk_paint.html">SkPaint</a> stroke or fill, blend, color, and so on, used to draw</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawRegion">https://fiddle.skia.org/c/@Canvas_drawRegion</a> </p>

</div>
</div>
<a id="ab77ed3c2ed1f8bbe331e1063ab4f98a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77ed3c2ed1f8bbe331e1063ab4f98a9">&#9670;&nbsp;</a></span>drawRoundRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawRoundRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>rx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>ry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_r_rect.html">SkRRect</a> bounded by <a class="el" href="struct_sk_rect.html">SkRect</a> rect, with corner radii (rx, ry) using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint.</p>
<p>In paint: <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a> determines if <a class="el" href="class_sk_r_rect.html">SkRRect</a> is stroked or filled; if stroked, <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width describes the line thickness. If rx or ry are less than zero, they are treated as if they are zero. If rx plus ry exceeds rect width or rect height, radii are scaled down to fit. If rx and ry are zero, <a class="el" href="class_sk_r_rect.html">SkRRect</a> is drawn as <a class="el" href="struct_sk_rect.html">SkRect</a> and if stroked is affected by <a class="el" href="class_sk_paint.html#ac582b0cbf59909c9056de34a6b977cca">SkPaint::Join</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> bounds of <a class="el" href="class_sk_r_rect.html">SkRRect</a> to draw </td></tr>
    <tr><td class="paramname">rx</td><td>axis length on x-axis of oval describing rounded corners </td></tr>
    <tr><td class="paramname">ry</td><td>axis length on y-axis of oval describing rounded corners </td></tr>
    <tr><td class="paramname">paint</td><td>stroke, blend, color, and so on, used to draw</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawRoundRect">https://fiddle.skia.org/c/@Canvas_drawRoundRect</a> </p>

</div>
</div>
<a id="ab50290cf9da84da457652d73ea09c0f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50290cf9da84da457652d73ea09c0f5">&#9670;&nbsp;</a></span>drawRRect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawRRect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_r_rect.html">SkRRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rrect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_r_rect.html">SkRRect</a> rrect using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint. In paint: <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a> determines if rrect is stroked or filled; if stroked, <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width describes the line thickness.</p>
<p>rrect may represent a rectangle, circle, oval, uniformly rounded rectangle, or may have any combination of positive non-square radii for the four corners.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rrect</td><td><a class="el" href="class_sk_r_rect.html">SkRRect</a> with up to eight corner radii to draw </td></tr>
    <tr><td class="paramname">paint</td><td><a class="el" href="class_sk_paint.html">SkPaint</a> stroke or fill, blend, color, and so on, used to draw</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawRRect">https://fiddle.skia.org/c/@Canvas_drawRRect</a> </p>

</div>
</div>
<a id="a2f1b67d0c3e6b574769e84c2351ef6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1b67d0c3e6b574769e84c2351ef6a0">&#9670;&nbsp;</a></span>drawSimpleText()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawSimpleText </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byteLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkTextEncoding&#160;</td>
          <td class="paramname"><em>encoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_font.html">SkFont</a> &amp;&#160;</td>
          <td class="paramname"><em>font</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws text, with origin at (x, y), using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, <a class="el" href="class_sk_font.html">SkFont</a> font, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint.</p>
<p>When encoding is SkTextEncoding::kUTF8, SkTextEncoding::kUTF16, or SkTextEncoding::kUTF32, this function uses the default character-to-glyph mapping from the <a class="el" href="class_sk_typeface.html">SkTypeface</a> in font. It does not perform typeface fallback for characters not found in the <a class="el" href="class_sk_typeface.html">SkTypeface</a>. It does not perform kerning or other complex shaping; glyphs are positioned based on their default advances.</p>
<p>Text meaning depends on SkTextEncoding.</p>
<p>Text size is affected by <a class="el" href="class_sk_matrix.html">SkMatrix</a> and <a class="el" href="class_sk_font.html">SkFont</a> text size. Default text size is 12 point.</p>
<p>All elements of paint: <a class="el" href="class_sk_path_effect.html">SkPathEffect</a>, <a class="el" href="class_sk_mask_filter.html">SkMaskFilter</a>, <a class="el" href="class_sk_shader.html">SkShader</a>, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, and <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>; apply to text. By default, draws filled black glyphs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">text</td><td>character code points or glyphs drawn </td></tr>
    <tr><td class="paramname">byteLength</td><td>byte length of text array </td></tr>
    <tr><td class="paramname">encoding</td><td>text encoding used in the text array </td></tr>
    <tr><td class="paramname">x</td><td>start of text on x-axis </td></tr>
    <tr><td class="paramname">y</td><td>start of text on y-axis </td></tr>
    <tr><td class="paramname">font</td><td>typeface, text size and so, used to describe the text </td></tr>
    <tr><td class="paramname">paint</td><td>blend, color, and so on, used to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae280406fb774e5a8bffbeaf3f1c927e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae280406fb774e5a8bffbeaf3f1c927e7">&#9670;&nbsp;</a></span>drawString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawString </td>
          <td>(</td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>str</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_font.html">SkFont</a> &amp;&#160;</td>
          <td class="paramname"><em>font</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws null terminated string, with origin at (x, y), using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, <a class="el" href="class_sk_font.html">SkFont</a> font, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint.</p>
<p>This function uses the default character-to-glyph mapping from the <a class="el" href="class_sk_typeface.html">SkTypeface</a> in font. It does not perform typeface fallback for characters not found in the <a class="el" href="class_sk_typeface.html">SkTypeface</a>. It does not perform kerning; glyphs are positioned based on their default advances.</p>
<p>String str is encoded as UTF-8.</p>
<p>Text size is affected by <a class="el" href="class_sk_matrix.html">SkMatrix</a> and font text size. Default text size is 12 point.</p>
<p>All elements of paint: <a class="el" href="class_sk_path_effect.html">SkPathEffect</a>, <a class="el" href="class_sk_mask_filter.html">SkMaskFilter</a>, <a class="el" href="class_sk_shader.html">SkShader</a>, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, and <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>; apply to text. By default, draws filled black glyphs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>character code points drawn, ending with a char value of zero </td></tr>
    <tr><td class="paramname">x</td><td>start of string on x-axis </td></tr>
    <tr><td class="paramname">y</td><td>start of string on y-axis </td></tr>
    <tr><td class="paramname">font</td><td>typeface, text size and so, used to describe the text </td></tr>
    <tr><td class="paramname">paint</td><td>blend, color, and so on, used to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5342b30928986132363b72d5eb49240c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5342b30928986132363b72d5eb49240c">&#9670;&nbsp;</a></span>drawString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_string.html">SkString</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_font.html">SkFont</a> &amp;&#160;</td>
          <td class="paramname"><em>font</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_string.html">SkString</a>, with origin at (x, y), using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, <a class="el" href="class_sk_font.html">SkFont</a> font, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint.</p>
<p>This function uses the default character-to-glyph mapping from the <a class="el" href="class_sk_typeface.html">SkTypeface</a> in font. It does not perform typeface fallback for characters not found in the <a class="el" href="class_sk_typeface.html">SkTypeface</a>. It does not perform kerning; glyphs are positioned based on their default advances.</p>
<p><a class="el" href="class_sk_string.html">SkString</a> str is encoded as UTF-8.</p>
<p>Text size is affected by <a class="el" href="class_sk_matrix.html">SkMatrix</a> and <a class="el" href="class_sk_font.html">SkFont</a> text size. Default text size is 12 point.</p>
<p>All elements of paint: <a class="el" href="class_sk_path_effect.html">SkPathEffect</a>, <a class="el" href="class_sk_mask_filter.html">SkMaskFilter</a>, <a class="el" href="class_sk_shader.html">SkShader</a>, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, and <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>; apply to text. By default, draws filled black glyphs.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>character code points drawn, ending with a char value of zero </td></tr>
    <tr><td class="paramname">x</td><td>start of string on x-axis </td></tr>
    <tr><td class="paramname">y</td><td>start of string on y-axis </td></tr>
    <tr><td class="paramname">font</td><td>typeface, text size and so, used to describe the text </td></tr>
    <tr><td class="paramname">paint</td><td>blend, color, and so on, used to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aefcef6a4389f0ec225b2cf229a372826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefcef6a4389f0ec225b2cf229a372826">&#9670;&nbsp;</a></span>drawTextBlob() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawTextBlob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_text_blob.html">SkTextBlob</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_text_blob.html">SkTextBlob</a> blob at (x, y), using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint.</p>
<p>blob contains glyphs, their positions, and paint attributes specific to text: <a class="el" href="class_sk_typeface.html">SkTypeface</a>, <a class="el" href="class_sk_paint.html">SkPaint</a> text size, <a class="el" href="class_sk_paint.html">SkPaint</a> text scale x, <a class="el" href="class_sk_paint.html">SkPaint</a> text skew x, SkPaint::Align, SkPaint::Hinting, anti-alias, <a class="el" href="class_sk_paint.html">SkPaint</a> fake bold, <a class="el" href="class_sk_paint.html">SkPaint</a> font embedded bitmaps, <a class="el" href="class_sk_paint.html">SkPaint</a> full hinting spacing, LCD text, <a class="el" href="class_sk_paint.html">SkPaint</a> linear text, and <a class="el" href="class_sk_paint.html">SkPaint</a> subpixel text.</p>
<p>SkTextEncoding must be set to SkTextEncoding::kGlyphID.</p>
<p>Elements of paint: <a class="el" href="class_sk_path_effect.html">SkPathEffect</a>, <a class="el" href="class_sk_mask_filter.html">SkMaskFilter</a>, <a class="el" href="class_sk_shader.html">SkShader</a>, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, and <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>; apply to blob.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>glyphs, positions, and their paints' text size, typeface, and so on </td></tr>
    <tr><td class="paramname">x</td><td>horizontal offset applied to blob </td></tr>
    <tr><td class="paramname">y</td><td>vertical offset applied to blob </td></tr>
    <tr><td class="paramname">paint</td><td>blend, color, stroking, and so on, used to draw </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6b440d5b99d7c5025c05d518ae44b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b440d5b99d7c5025c05d518ae44b4a">&#9670;&nbsp;</a></span>drawTextBlob() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawTextBlob </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_text_blob.html">SkTextBlob</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_text_blob.html">SkTextBlob</a> blob at (x, y), using clip, <a class="el" href="class_sk_matrix.html">SkMatrix</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint.</p>
<p>blob contains glyphs, their positions, and paint attributes specific to text: <a class="el" href="class_sk_typeface.html">SkTypeface</a>, <a class="el" href="class_sk_paint.html">SkPaint</a> text size, <a class="el" href="class_sk_paint.html">SkPaint</a> text scale x, <a class="el" href="class_sk_paint.html">SkPaint</a> text skew x, SkPaint::Align, SkPaint::Hinting, anti-alias, <a class="el" href="class_sk_paint.html">SkPaint</a> fake bold, <a class="el" href="class_sk_paint.html">SkPaint</a> font embedded bitmaps, <a class="el" href="class_sk_paint.html">SkPaint</a> full hinting spacing, LCD text, <a class="el" href="class_sk_paint.html">SkPaint</a> linear text, and <a class="el" href="class_sk_paint.html">SkPaint</a> subpixel text.</p>
<p>SkTextEncoding must be set to SkTextEncoding::kGlyphID.</p>
<p>Elements of paint: anti-alias, SkBlendMode, color including alpha, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, <a class="el" href="class_sk_paint.html">SkPaint</a> dither, <a class="el" href="class_sk_mask_filter.html">SkMaskFilter</a>, <a class="el" href="class_sk_path_effect.html">SkPathEffect</a>, <a class="el" href="class_sk_shader.html">SkShader</a>, and <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fd">SkPaint::Style</a>; apply to blob. If <a class="el" href="class_sk_paint.html">SkPaint</a> contains <a class="el" href="class_sk_paint.html#a6f5b4ff088821b2940b148dd4cb6b9fda4bcc9f35fd6468ad92012c70daf7a495" title="set to stroke geometry">SkPaint::kStroke_Style</a>: <a class="el" href="class_sk_paint.html">SkPaint</a> miter limit, <a class="el" href="class_sk_paint.html#a0f78de8559b795defba93171f6cb6333">SkPaint::Cap</a>, <a class="el" href="class_sk_paint.html#ac582b0cbf59909c9056de34a6b977cca">SkPaint::Join</a>, and <a class="el" href="class_sk_paint.html">SkPaint</a> stroke width; apply to <a class="el" href="class_sk_path.html">SkPath</a> created from blob.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blob</td><td>glyphs, positions, and their paints' text size, typeface, and so on </td></tr>
    <tr><td class="paramname">x</td><td>horizontal offset applied to blob </td></tr>
    <tr><td class="paramname">y</td><td>vertical offset applied to blob </td></tr>
    <tr><td class="paramname">paint</td><td>blend, color, stroking, and so on, used to draw</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawTextBlob">https://fiddle.skia.org/c/@Canvas_drawTextBlob</a> </p>

</div>
</div>
<a id="abd7b6fc878285446f43d7cdb3968b2ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7b6fc878285446f43d7cdb3968b2ad">&#9670;&nbsp;</a></span>drawVertices() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_vertices.html">SkVertices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Variant of 3-parameter drawVertices, using the default of Modulate for the blend parameter. Note that <a class="el" href="class_sk_vertices.html">SkVertices</a> that include per-vertex-data ignore this mode parameter. </p>

</div>
</div>
<a id="ae14234b29eb75b68c0da1c08119251f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14234b29eb75b68c0da1c08119251f4">&#9670;&nbsp;</a></span>drawVertices() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_vertices.html">SkVertices</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkBlendMode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_vertices.html">SkVertices</a> vertices, a triangle mesh, using clip and <a class="el" href="class_sk_matrix.html">SkMatrix</a>. If paint contains an <a class="el" href="class_sk_shader.html">SkShader</a> and vertices does not contain texCoords, the shader is mapped using the vertices' positions.</p>
<p>If vertices colors are defined in vertices, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint contains <a class="el" href="class_sk_shader.html">SkShader</a>, SkBlendMode mode combines vertices colors with <a class="el" href="class_sk_shader.html">SkShader</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>triangle mesh to draw </td></tr>
    <tr><td class="paramname">mode</td><td>combines vertices colors with <a class="el" href="class_sk_shader.html">SkShader</a>, if both are present </td></tr>
    <tr><td class="paramname">paint</td><td>specifies the <a class="el" href="class_sk_shader.html">SkShader</a>, used as <a class="el" href="class_sk_vertices.html">SkVertices</a> texture, may be nullptr</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawVertices_2">https://fiddle.skia.org/c/@Canvas_drawVertices_2</a> </p>

</div>
</div>
<a id="af7889fb296b46a8dd647b09749a0288e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7889fb296b46a8dd647b09749a0288e">&#9670;&nbsp;</a></span>drawVertices() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_vertices.html">SkVertices</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Variant of 3-parameter drawVertices, using the default of Modulate for the blend parameter. Note that <a class="el" href="class_sk_vertices.html">SkVertices</a> that include per-vertex-data ignore this mode parameter. </p>

</div>
</div>
<a id="ae971eebc0c442a0310b830a7711b8798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae971eebc0c442a0310b830a7711b8798">&#9670;&nbsp;</a></span>drawVertices() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::drawVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_vertices.html">SkVertices</a> *&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkBlendMode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> &amp;&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draws <a class="el" href="class_sk_vertices.html">SkVertices</a> vertices, a triangle mesh, using clip and <a class="el" href="class_sk_matrix.html">SkMatrix</a>. If paint contains an <a class="el" href="class_sk_shader.html">SkShader</a> and vertices does not contain texCoords, the shader is mapped using the vertices' positions.</p>
<p>If vertices colors are defined in vertices, and <a class="el" href="class_sk_paint.html">SkPaint</a> paint contains <a class="el" href="class_sk_shader.html">SkShader</a>, SkBlendMode mode combines vertices colors with <a class="el" href="class_sk_shader.html">SkShader</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertices</td><td>triangle mesh to draw </td></tr>
    <tr><td class="paramname">mode</td><td>combines vertices colors with <a class="el" href="class_sk_shader.html">SkShader</a>, if both are present </td></tr>
    <tr><td class="paramname">paint</td><td>specifies the <a class="el" href="class_sk_shader.html">SkShader</a>, used as <a class="el" href="class_sk_vertices.html">SkVertices</a> texture; may be nullptr</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_drawVertices">https://fiddle.skia.org/c/@Canvas_drawVertices</a> </p>

</div>
</div>
<a id="aa9e1a224a23c880db7ef8022adaf6480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e1a224a23c880db7ef8022adaf6480">&#9670;&nbsp;</a></span>experimental_DrawEdgeAAImageSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::experimental_DrawEdgeAAImageSet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_canvas_1_1_image_set_entry.html">ImageSetEntry</a>&#160;</td>
          <td class="paramname"><em>imageSet</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>dstClips</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_matrix.html">SkMatrix</a>&#160;</td>
          <td class="paramname"><em>preViewMatrices</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_sampling_options.html">SkSamplingOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>sampling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&#160;</td>
          <td class="paramname"><em>paint</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#a8997239ed4fd8e08bf4b66b3f6eeb40c">SrcRectConstraint</a>&#160;</td>
          <td class="paramname"><em>constraint</em> = <code><a class="el" href="class_sk_canvas.html#a8997239ed4fd8e08bf4b66b3f6eeb40ca33a44e18142c9cd28f2b76b7d5f7bc9e">kStrict_SrcRectConstraint</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an bulk variant of <a class="el" href="class_sk_canvas.html#a8e5d4fc04417355ca0d23feafcd81ac3">experimental_DrawEdgeAAQuad()</a> that renders 'cnt' textured quads. For each entry, 'fDstRect' is rendered with its clip (determined by entry's 'fHasClip' and the current index in 'dstClip'). The entry's fImage is applied to the destination rectangle by sampling from 'fSrcRect' sub-image. The corners of 'fSrcRect' map to the corners of 'fDstRect', just like in drawImageRect(), and they will be properly interpolated when applying a clip.</p>
<p>Like <a class="el" href="class_sk_canvas.html#a8e5d4fc04417355ca0d23feafcd81ac3">experimental_DrawEdgeAAQuad()</a>, each entry can specify edge AA flags that apply to both the destination rect and its clip.</p>
<p>If provided, the 'dstClips' array must have length equal 4 * the number of entries with fHasClip true. If 'dstClips' is null, every entry must have 'fHasClip' set to false. The destination clip coordinates will be read consecutively with the image set entries, advancing by 4 points every time an entry with fHasClip is passed.</p>
<p>This entry point supports per-entry manipulations to the canvas's current matrix. If an entry provides 'fMatrixIndex' &gt;= 0, it will be drawn as if the canvas's CTM was canvas-&gt;<a class="el" href="class_sk_canvas.html#ab5d3c67a63129f42692d6cb4fb75db23">getTotalMatrix()</a> * preViewMatrices[fMatrixIndex]. If 'fMatrixIndex' is less than 0, the pre-view matrix transform is implicitly the identity, so it will be drawn using just the current canvas matrix. The pre-view matrix modifies the canvas's view matrix, it does not affect the local coordinates of each entry.</p>
<p>An optional paint may be provided, which supports the same subset of features usable with drawImageRect (i.e. assumed to be filled and no path effects). When a paint is provided, the image set is drawn as if each image used the applied paint independently, so each is affected by the image, color, and/or mask filter. </p>

</div>
</div>
<a id="a8e5d4fc04417355ca0d23feafcd81ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5d4fc04417355ca0d23feafcd81ac3">&#9670;&nbsp;</a></span>experimental_DrawEdgeAAQuad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::experimental_DrawEdgeAAQuad </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_point.html">SkPoint</a>&#160;</td>
          <td class="paramname"><em>clip</em>[4], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_sk_canvas.html#af71b7245651dfa4a873a23336fafec48">QuadAAFlags</a>&#160;</td>
          <td class="paramname"><em>aaFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_color4f.html">SkColor4f</a> &amp;&#160;</td>
          <td class="paramname"><em>color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkBlendMode&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is an experimental API for the SkiaRenderer Chromium project, and its API will surely evolve if it is not removed outright.</p>
<p>This behaves very similarly to <a class="el" href="class_sk_canvas.html#a15a77a3479b8f8731442d4a4ea2772b3">drawRect()</a> combined with a <a class="el" href="class_sk_canvas.html#abc79bd478516f398c31ae9f501154184">clipPath()</a> formed by clip quadrilateral. 'rect' and 'clip' are in the same coordinate space. If 'clip' is null, then it is as if the rectangle was not clipped (or, alternatively, clipped to itself). If not null, then it must provide 4 points.</p>
<p>In addition to combining the draw and clipping into one operation, this function adds the additional capability of controlling each of the rectangle's edges anti-aliasing independently. The edges of the clip will respect the per-edge AA flags. It is required that 'clip' be contained inside 'rect'. In terms of mapping to edge labels, the 'clip' points should be ordered top-left, top-right, bottom-right, bottom-left so that the edge between [0] and [1] is "top", [1] and [2] is "right", [2] and [3] is "bottom", and [3] and [0] is "left". This ordering matches <a class="el" href="struct_sk_rect.html#a1c64f14d3855d1947aa48e7cc7c9ba1f">SkRect::toQuad()</a>.</p>
<p>This API only draws solid color, filled rectangles so it does not accept a full <a class="el" href="class_sk_paint.html">SkPaint</a>. </p>

</div>
</div>
<a id="a3f8ea661c6021dc4dde325aab87870bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8ea661c6021dc4dde325aab87870bf">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triggers the immediate execution of all pending draw operations. If <a class="el" href="class_sk_canvas.html">SkCanvas</a> is associated with GPU surface, resolves all pending GPU operations. If <a class="el" href="class_sk_canvas.html">SkCanvas</a> is associated with raster surface, has no effect; raster draw operations are never deferred.</p>
<p>DEPRECATED: Replace usage with GrDirectContext::flush() </p>

</div>
</div>
<a id="a6bf0f33cbdde5b0c90a2395d1ba14a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bf0f33cbdde5b0c90a2395d1ba14a8b">&#9670;&nbsp;</a></span>getBaseLayerSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_i_size.html">SkISize</a> SkCanvas::getBaseLayerSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets the size of the base or root layer in global canvas coordinates. The origin of the base layer is always (0,0). The area available for drawing may be smaller (due to clipping or saveLayer).</p>
<dl class="section return"><dt>Returns</dt><dd>integral width and height of base layer</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_getBaseLayerSize">https://fiddle.skia.org/c/@Canvas_getBaseLayerSize</a> </p>

<p>Reimplemented in <a class="el" href="class_sk_paint_filter_canvas.html#a43c111df7db427594b024771d13f6b2b">SkPaintFilterCanvas</a>.</p>

</div>
</div>
<a id="abd88df53c84d457aa08ddacc944468bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd88df53c84d457aa08ddacc944468bf">&#9670;&nbsp;</a></span>getDeviceClipBounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_i_rect.html">SkIRect</a> SkCanvas::getDeviceClipBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_i_rect.html">SkIRect</a> bounds of clip, unaffected by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. If clip is empty, return <a class="el" href="struct_sk_rect.html#a058722ba4a7ab6a2024bd67e88dadb5b">SkRect::MakeEmpty</a>, where all <a class="el" href="struct_sk_rect.html">SkRect</a> sides equal zero.</p>
<p>Unlike <a class="el" href="class_sk_canvas.html#a4dc19266b3ac4ea8d2c7133dd2c54ad7">getLocalClipBounds()</a>, returned <a class="el" href="struct_sk_i_rect.html">SkIRect</a> is not outset.</p>
<dl class="section return"><dt>Returns</dt><dd>bounds of clip in <a class="el" href="class_sk_base_device.html">SkBaseDevice</a> coordinates</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_getDeviceClipBounds">https://fiddle.skia.org/c/@Canvas_getDeviceClipBounds</a> </p>

</div>
</div>
<a id="aa4edc7c11810980f012551bc65124395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4edc7c11810980f012551bc65124395">&#9670;&nbsp;</a></span>getDeviceClipBounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::getDeviceClipBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_i_rect.html">SkIRect</a> *&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_i_rect.html">SkIRect</a> bounds of clip, unaffected by <a class="el" href="class_sk_matrix.html">SkMatrix</a>. If clip is empty, return false, and set bounds to <a class="el" href="struct_sk_rect.html#a058722ba4a7ab6a2024bd67e88dadb5b">SkRect::MakeEmpty</a>, where all <a class="el" href="struct_sk_rect.html">SkRect</a> sides equal zero.</p>
<p>Unlike <a class="el" href="class_sk_canvas.html#a4dc19266b3ac4ea8d2c7133dd2c54ad7">getLocalClipBounds()</a>, bounds is not outset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounds</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> of clip in device coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if clip bounds is not empty </dd></dl>

</div>
</div>
<a id="a4dc19266b3ac4ea8d2c7133dd2c54ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc19266b3ac4ea8d2c7133dd2c54ad7">&#9670;&nbsp;</a></span>getLocalClipBounds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_rect.html">SkRect</a> SkCanvas::getLocalClipBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns bounds of clip, transformed by inverse of <a class="el" href="class_sk_matrix.html">SkMatrix</a>. If clip is empty, return <a class="el" href="struct_sk_rect.html#a058722ba4a7ab6a2024bd67e88dadb5b">SkRect::MakeEmpty</a>, where all <a class="el" href="struct_sk_rect.html">SkRect</a> sides equal zero.</p>
<p><a class="el" href="struct_sk_rect.html">SkRect</a> returned is outset by one to account for partial pixel coverage if clip is anti-aliased.</p>
<dl class="section return"><dt>Returns</dt><dd>bounds of clip in local coordinates</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_getLocalClipBounds">https://fiddle.skia.org/c/@Canvas_getLocalClipBounds</a> </p>

</div>
</div>
<a id="a5f383a6c415bb12d78d111a2cc799f1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f383a6c415bb12d78d111a2cc799f1e">&#9670;&nbsp;</a></span>getLocalClipBounds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::getLocalClipBounds </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_rect.html">SkRect</a> *&#160;</td>
          <td class="paramname"><em>bounds</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns bounds of clip, transformed by inverse of <a class="el" href="class_sk_matrix.html">SkMatrix</a>. If clip is empty, return false, and set bounds to <a class="el" href="struct_sk_rect.html#a058722ba4a7ab6a2024bd67e88dadb5b">SkRect::MakeEmpty</a>, where all <a class="el" href="struct_sk_rect.html">SkRect</a> sides equal zero.</p>
<p>bounds is outset by one to account for partial pixel coverage if clip is anti-aliased.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounds</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> of clip in local coordinates </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if clip bounds is not empty </dd></dl>

</div>
</div>
<a id="a8d5ca44e20640c94bc43d3461d07b14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5ca44e20640c94bc43d3461d07b14b">&#9670;&nbsp;</a></span>getLocalToDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_m44.html">SkM44</a> SkCanvas::getLocalToDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current transform from local coordinates to the 'device', which for most purposes means pixels.</p>
<dl class="section return"><dt>Returns</dt><dd>transformation from local coordinates to device / pixels. </dd></dl>

</div>
</div>
<a id="a47155d29ae77a207af00974d71540116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47155d29ae77a207af00974d71540116">&#9670;&nbsp;</a></span>getLocalToDeviceAs3x3()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> SkCanvas::getLocalToDeviceAs3x3 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Throws away the 3rd row and column in the matrix, so be warned. </p>

</div>
</div>
<a id="a0cc56d1e844b40c50753429d7dd22b9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc56d1e844b40c50753429d7dd22b9a">&#9670;&nbsp;</a></span>getProps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::getProps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *&#160;</td>
          <td class="paramname"><em>props</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a>, if <a class="el" href="class_sk_canvas.html">SkCanvas</a> is associated with raster surface or GPU surface, and returns true. Otherwise, returns false and leave props unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">props</td><td>storage for writable <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> was copied</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_getProps">https://fiddle.skia.org/c/@Canvas_getProps</a> </p>

</div>
</div>
<a id="aa6fca118ff6ff1e207ed5457f118b4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6fca118ff6ff1e207ed5457f118b4e0">&#9670;&nbsp;</a></span>getSaveCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SkCanvas::getSaveCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of saved states, each containing: <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip. Equals the number of <a class="el" href="class_sk_canvas.html#ac98147dc771b47c7353a51e7c171e428">save()</a> calls less the number of <a class="el" href="class_sk_canvas.html#a2c68ed85badf62be77bb862b02dd4961">restore()</a> calls plus one. The save count of a new canvas is one.</p>
<dl class="section return"><dt>Returns</dt><dd>depth of save state stack</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_getSaveCount">https://fiddle.skia.org/c/@Canvas_getSaveCount</a> </p>

</div>
</div>
<a id="a16e6944f5f854b2b2c47b9a06aed6645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e6944f5f854b2b2c47b9a06aed6645">&#9670;&nbsp;</a></span>getSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_surface.html">SkSurface</a> * SkCanvas::getSurface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sometimes a canvas is owned by a surface. If it is, <a class="el" href="class_sk_canvas.html#a16e6944f5f854b2b2c47b9a06aed6645">getSurface()</a> will return a bare pointer to that surface, else this will return nullptr. </p>

</div>
</div>
<a id="ab5d3c67a63129f42692d6cb4fb75db23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d3c67a63129f42692d6cb4fb75db23">&#9670;&nbsp;</a></span>getTotalMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_sk_matrix.html">SkMatrix</a> SkCanvas::getTotalMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DEPRECATED Legacy version of <a class="el" href="class_sk_canvas.html#a8d5ca44e20640c94bc43d3461d07b14b">getLocalToDevice()</a>, which strips away any Z information, and just returns a 3x3 version.</p>
<dl class="section return"><dt>Returns</dt><dd>3x3 version of <a class="el" href="class_sk_canvas.html#a8d5ca44e20640c94bc43d3461d07b14b">getLocalToDevice()</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_getTotalMatrix">https://fiddle.skia.org/c/@Canvas_getTotalMatrix</a> example: <a href="https://fiddle.skia.org/c/@Clip">https://fiddle.skia.org/c/@Clip</a> </p>

</div>
</div>
<a id="aef8a74b34be1cefa29eac1ab7a1c6727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef8a74b34be1cefa29eac1ab7a1c6727">&#9670;&nbsp;</a></span>imageInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_image_info.html">SkImageInfo</a> SkCanvas::imageInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> for <a class="el" href="class_sk_canvas.html">SkCanvas</a>. If <a class="el" href="class_sk_canvas.html">SkCanvas</a> is not associated with raster surface or GPU surface, returned SkColorType is set to kUnknown_SkColorType.</p>
<dl class="section return"><dt>Returns</dt><dd>dimensions and SkColorType of <a class="el" href="class_sk_canvas.html">SkCanvas</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_imageInfo">https://fiddle.skia.org/c/@Canvas_imageInfo</a> </p>

</div>
</div>
<a id="a2160c39d4747ce925cce72f76a31e6be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2160c39d4747ce925cce72f76a31e6be">&#9670;&nbsp;</a></span>isClipEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::isClipEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if clip is empty; that is, nothing will draw.</p>
<p>May do work when called; it should not be called more often than needed. However, once called, subsequent calls perform no work until clip changes.</p>
<dl class="section return"><dt>Returns</dt><dd>true if clip is empty</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_isClipEmpty">https://fiddle.skia.org/c/@Canvas_isClipEmpty</a> </p>

</div>
</div>
<a id="a5fe3bc1eb2d66d4c82c0e59c7daedcbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe3bc1eb2d66d4c82c0e59c7daedcbe">&#9670;&nbsp;</a></span>isClipRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::isClipRect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if clip is <a class="el" href="struct_sk_rect.html">SkRect</a> and not empty. Returns false if the clip is empty, or if it is not <a class="el" href="struct_sk_rect.html">SkRect</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if clip is <a class="el" href="struct_sk_rect.html">SkRect</a> and not empty</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_isClipRect">https://fiddle.skia.org/c/@Canvas_isClipRect</a> </p>

</div>
</div>
<a id="ae7b9b683fda2b9c957780903647d3b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b9b683fda2b9c957780903647d3b7a">&#9670;&nbsp;</a></span>MakeRasterDirect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="class_sk_canvas.html">SkCanvas</a> &gt; SkCanvas::MakeRasterDirect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *&#160;</td>
          <td class="paramname"><em>props</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates raster <a class="el" href="class_sk_canvas.html">SkCanvas</a> that will draw directly into pixels.</p>
<p><a class="el" href="class_sk_canvas.html">SkCanvas</a> is returned if all parameters are valid. Valid parameters include: info dimensions are zero or positive; info contains SkColorType and SkAlphaType supported by raster surface; pixels is not nullptr; rowBytes is zero or large enough to contain info width pixels of SkColorType.</p>
<p>Pass zero for rowBytes to compute rowBytes from info width and size of pixel. If rowBytes is greater than zero, it must be equal to or greater than info width times bytes required for SkColorType.</p>
<p><a class="el" href="struct_pixel.html">Pixel</a> buffer size should be info height times computed rowBytes. Pixels are not initialized. To access pixels after drawing, call <a class="el" href="class_sk_canvas.html#a3f8ea661c6021dc4dde325aab87870bf">flush()</a> or <a class="el" href="class_sk_canvas.html#a1da746e87186d5e3fc0b4838f782e1c4">peekPixels()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>width, height, SkColorType, SkAlphaType, <a class="el" href="class_sk_color_space.html">SkColorSpace</a>, of raster surface; width, or height, or both, may be zero </td></tr>
    <tr><td class="paramname">pixels</td><td>pointer to destination pixels buffer </td></tr>
    <tr><td class="paramname">rowBytes</td><td>interval from one <a class="el" href="class_sk_surface.html">SkSurface</a> row to the next, or zero </td></tr>
    <tr><td class="paramname">props</td><td>LCD striping orientation and setting for device independent fonts; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_canvas.html">SkCanvas</a> if all parameters are valid; otherwise, nullptr </dd></dl>

</div>
</div>
<a id="a00b50eebd3b47ae6f371a2c7af2a9f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b50eebd3b47ae6f371a2c7af2a9f01">&#9670;&nbsp;</a></span>MakeRasterDirectN32()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::unique_ptr&lt;<a class="el" href="class_sk_canvas.html">SkCanvas</a>&gt; SkCanvas::MakeRasterDirectN32 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_color_8h.html#a9ec12bd74c4b63b5da802b419106b8ea">SkPMColor</a> *&#160;</td>
          <td class="paramname"><em>pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates raster <a class="el" href="class_sk_canvas.html">SkCanvas</a> specified by inline image specification. Subsequent <a class="el" href="class_sk_canvas.html">SkCanvas</a> calls draw into pixels. SkColorType is set to kN32_SkColorType. SkAlphaType is set to kPremul_SkAlphaType. To access pixels after drawing, call <a class="el" href="class_sk_canvas.html#a3f8ea661c6021dc4dde325aab87870bf">flush()</a> or <a class="el" href="class_sk_canvas.html#a1da746e87186d5e3fc0b4838f782e1c4">peekPixels()</a>.</p>
<p><a class="el" href="class_sk_canvas.html">SkCanvas</a> is returned if all parameters are valid. Valid parameters include: width and height are zero or positive; pixels is not nullptr; rowBytes is zero or large enough to contain width pixels of kN32_SkColorType.</p>
<p>Pass zero for rowBytes to compute rowBytes from width and size of pixel. If rowBytes is greater than zero, it must be equal to or greater than width times bytes required for SkColorType.</p>
<p><a class="el" href="struct_pixel.html">Pixel</a> buffer size should be height times rowBytes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>pixel column count on raster surface created; must be zero or greater </td></tr>
    <tr><td class="paramname">height</td><td>pixel row count on raster surface created; must be zero or greater </td></tr>
    <tr><td class="paramname">pixels</td><td>pointer to destination pixels buffer; buffer size should be height times rowBytes </td></tr>
    <tr><td class="paramname">rowBytes</td><td>interval from one <a class="el" href="class_sk_surface.html">SkSurface</a> row to the next, or zero </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_canvas.html">SkCanvas</a> if all parameters are valid; otherwise, nullptr </dd></dl>

</div>
</div>
<a id="a3254c3d33588ec4d617ea0d84abd1f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3254c3d33588ec4d617ea0d84abd1f38">&#9670;&nbsp;</a></span>makeSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsk__sp.html">sk_sp</a>&lt; <a class="el" href="class_sk_surface.html">SkSurface</a> &gt; SkCanvas::makeSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> *&#160;</td>
          <td class="paramname"><em>props</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates <a class="el" href="class_sk_surface.html">SkSurface</a> matching info and props, and associates it with <a class="el" href="class_sk_canvas.html">SkCanvas</a>. Returns nullptr if no match found.</p>
<p>If props is nullptr, matches <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> in <a class="el" href="class_sk_canvas.html">SkCanvas</a>. If props is nullptr and <a class="el" href="class_sk_canvas.html">SkCanvas</a> does not have <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a>, creates <a class="el" href="class_sk_surface.html">SkSurface</a> with default <a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>width, height, SkColorType, SkAlphaType, and <a class="el" href="class_sk_color_space.html">SkColorSpace</a> </td></tr>
    <tr><td class="paramname">props</td><td><a class="el" href="class_sk_surface_props.html">SkSurfaceProps</a> to match; may be nullptr to match <a class="el" href="class_sk_canvas.html">SkCanvas</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_sk_surface.html">SkSurface</a> matching info and props, or nullptr if no match is available</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_makeSurface">https://fiddle.skia.org/c/@Canvas_makeSurface</a> </p>

</div>
</div>
<a id="abdc70a1f31e2f7fc5cd5bb2537aa350e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc70a1f31e2f7fc5cd5bb2537aa350e">&#9670;&nbsp;</a></span>markCTM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::markCTM </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Record a marker (provided by caller) for the current CTM. This does not change anything about the ctm or clip, but does "name" this matrix value, so it can be referenced by custom effects (who access it by specifying the same name).</p>
<p>Within a save frame, marking with the same name more than once just replaces the previous value. However, between save frames, marking with the same name does not lose the marker in the previous save frame. It is "visible" when the current <a class="el" href="class_sk_canvas.html#ac98147dc771b47c7353a51e7c171e428">save()</a> is balanced with a <a class="el" href="class_sk_canvas.html#a2c68ed85badf62be77bb862b02dd4961">restore()</a>. </p>

</div>
</div>
<a id="a1da746e87186d5e3fc0b4838f782e1c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da746e87186d5e3fc0b4838f782e1c4">&#9670;&nbsp;</a></span>peekPixels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::peekPixels </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_pixmap.html">SkPixmap</a> *&#160;</td>
          <td class="paramname"><em>pixmap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="class_sk_canvas.html">SkCanvas</a> has direct access to its pixels.</p>
<p>Pixels are readable when <a class="el" href="class_sk_base_device.html">SkBaseDevice</a> is raster. Pixels are not readable when <a class="el" href="class_sk_canvas.html">SkCanvas</a> is returned from GPU surface, returned by <a class="el" href="class_sk_document.html#a79e3acb788004038aef9dccb1e221160">SkDocument::beginPage</a>, returned by <a class="el" href="class_sk_picture_recorder.html#a197a4390057dac85b24c0fa35b905d06">SkPictureRecorder::beginRecording</a>, or <a class="el" href="class_sk_canvas.html">SkCanvas</a> is the base of a utility class like DebugCanvas.</p>
<p>pixmap is valid only while <a class="el" href="class_sk_canvas.html">SkCanvas</a> is in scope and unchanged. Any <a class="el" href="class_sk_canvas.html">SkCanvas</a> or <a class="el" href="class_sk_surface.html">SkSurface</a> call may invalidate the pixmap values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixmap</td><td>storage for pixel state if pixels are readable; otherwise, ignored </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="class_sk_canvas.html">SkCanvas</a> has direct access to pixels</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_peekPixels">https://fiddle.skia.org/c/@Canvas_peekPixels</a> </p>

</div>
</div>
<a id="a7685f750ca3e98d8e4642af79b0422dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7685f750ca3e98d8e4642af79b0422dd">&#9670;&nbsp;</a></span>quickReject() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::quickReject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_path.html">SkPath</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if path, transformed by <a class="el" href="class_sk_matrix.html">SkMatrix</a>, can be quickly determined to be outside of clip. May return false even though path is outside of clip.</p>
<p>Use to check if an area to be drawn is clipped out, to skip subsequent draw calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td><a class="el" href="class_sk_path.html">SkPath</a> to compare with clip </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if path, transformed by <a class="el" href="class_sk_matrix.html">SkMatrix</a>, does not intersect clip</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_quickReject_2">https://fiddle.skia.org/c/@Canvas_quickReject_2</a> </p>

</div>
</div>
<a id="af7f091b4f9abb2cdefe749ad60cb1bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f091b4f9abb2cdefe749ad60cb1bb0">&#9670;&nbsp;</a></span>quickReject() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::quickReject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>rect</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="struct_sk_rect.html">SkRect</a> rect, transformed by <a class="el" href="class_sk_matrix.html">SkMatrix</a>, can be quickly determined to be outside of clip. May return false even though rect is outside of clip.</p>
<p>Use to check if an area to be drawn is clipped out, to skip subsequent draw calls.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rect</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> to compare with clip </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rect, transformed by <a class="el" href="class_sk_matrix.html">SkMatrix</a>, does not intersect clip</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_quickReject">https://fiddle.skia.org/c/@Canvas_quickReject</a> </p>

</div>
</div>
<a id="ae4d8f7b005de74e96c68dcb7ed48eb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d8f7b005de74e96c68dcb7ed48eb73">&#9670;&nbsp;</a></span>readPixels() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::readPixels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="struct_sk_rect.html">SkRect</a> of pixels from <a class="el" href="class_sk_canvas.html">SkCanvas</a> into bitmap. <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip are ignored.</p>
<p>Source <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (srcX, srcY) and (<a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.width(), <a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.height()). Destination <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (0, 0) and (bitmap.width(), bitmap.height()). Copies each readable pixel intersecting both rectangles, without scaling, converting to bitmap.colorType() and bitmap.alphaType() if required.</p>
<p>Pixels are readable when <a class="el" href="class_sk_base_device.html">SkBaseDevice</a> is raster, or backed by a GPU. Pixels are not readable when <a class="el" href="class_sk_canvas.html">SkCanvas</a> is returned by <a class="el" href="class_sk_document.html#a79e3acb788004038aef9dccb1e221160">SkDocument::beginPage</a>, returned by <a class="el" href="class_sk_picture_recorder.html#a197a4390057dac85b24c0fa35b905d06">SkPictureRecorder::beginRecording</a>, or <a class="el" href="class_sk_canvas.html">SkCanvas</a> is the base of a utility class like DebugCanvas.</p>
<p>Caller must allocate pixel storage in bitmap if needed.</p>
<p><a class="el" href="class_sk_bitmap.html">SkBitmap</a> values are converted only if SkColorType and SkAlphaType do not match. Only pixels within both source and destination rectangles are copied. <a class="el" href="class_sk_bitmap.html">SkBitmap</a> pixels outside <a class="el" href="struct_sk_rect.html">SkRect</a> intersection are unchanged.</p>
<p>Pass negative values for srcX or srcY to offset pixels across or down bitmap.</p>
<p>Does not copy, and returns false if:</p><ul>
<li>Source and destination rectangles do not intersect.</li>
<li><a class="el" href="class_sk_canvas.html">SkCanvas</a> pixels could not be converted to bitmap.colorType() or bitmap.alphaType().</li>
<li><a class="el" href="class_sk_canvas.html">SkCanvas</a> pixels are not readable; for instance, <a class="el" href="class_sk_canvas.html">SkCanvas</a> is document-based.</li>
<li>bitmap pixels could not be allocated.</li>
<li>bitmap.rowBytes() is too small to contain one row of pixels.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>storage for pixels copied from <a class="el" href="class_sk_canvas.html">SkCanvas</a> </td></tr>
    <tr><td class="paramname">srcX</td><td>offset into readable pixels on x-axis; may be negative </td></tr>
    <tr><td class="paramname">srcY</td><td>offset into readable pixels on y-axis; may be negative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if pixels were copied</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_readPixels_3">https://fiddle.skia.org/c/@Canvas_readPixels_3</a> </p>

</div>
</div>
<a id="af267c56757f886aaae2d0876161141b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af267c56757f886aaae2d0876161141b1">&#9670;&nbsp;</a></span>readPixels() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::readPixels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>dstInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dstPixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstRowBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="struct_sk_rect.html">SkRect</a> of pixels from <a class="el" href="class_sk_canvas.html">SkCanvas</a> into dstPixels. <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip are ignored.</p>
<p>Source <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (srcX, srcY) and (<a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.width(), <a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.height()). Destination <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (0, 0) and (dstInfo.width(), dstInfo.height()). Copies each readable pixel intersecting both rectangles, without scaling, converting to dstInfo.colorType() and dstInfo.alphaType() if required.</p>
<p>Pixels are readable when <a class="el" href="class_sk_base_device.html">SkBaseDevice</a> is raster, or backed by a GPU. Pixels are not readable when <a class="el" href="class_sk_canvas.html">SkCanvas</a> is returned by <a class="el" href="class_sk_document.html#a79e3acb788004038aef9dccb1e221160">SkDocument::beginPage</a>, returned by <a class="el" href="class_sk_picture_recorder.html#a197a4390057dac85b24c0fa35b905d06">SkPictureRecorder::beginRecording</a>, or <a class="el" href="class_sk_canvas.html">SkCanvas</a> is the base of a utility class like DebugCanvas.</p>
<p>The destination pixel storage must be allocated by the caller.</p>
<p><a class="el" href="struct_pixel.html">Pixel</a> values are converted only if SkColorType and SkAlphaType do not match. Only pixels within both source and destination rectangles are copied. dstPixels contents outside <a class="el" href="struct_sk_rect.html">SkRect</a> intersection are unchanged.</p>
<p>Pass negative values for srcX or srcY to offset pixels across or down destination.</p>
<p>Does not copy, and returns false if:</p><ul>
<li>Source and destination rectangles do not intersect.</li>
<li><a class="el" href="class_sk_canvas.html">SkCanvas</a> pixels could not be converted to dstInfo.colorType() or dstInfo.alphaType().</li>
<li><a class="el" href="class_sk_canvas.html">SkCanvas</a> pixels are not readable; for instance, <a class="el" href="class_sk_canvas.html">SkCanvas</a> is document-based.</li>
<li>dstRowBytes is too small to contain one row of pixels.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dstInfo</td><td>width, height, SkColorType, and SkAlphaType of dstPixels </td></tr>
    <tr><td class="paramname">dstPixels</td><td>storage for pixels; dstInfo.height() times dstRowBytes, or larger </td></tr>
    <tr><td class="paramname">dstRowBytes</td><td>size of one destination row; dstInfo.width() times pixel size, or larger </td></tr>
    <tr><td class="paramname">srcX</td><td>offset into readable pixels on x-axis; may be negative </td></tr>
    <tr><td class="paramname">srcY</td><td>offset into readable pixels on y-axis; may be negative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if pixels were copied </dd></dl>

</div>
</div>
<a id="a7a0e7a8560bf845ee9e30f6da722dcdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a0e7a8560bf845ee9e30f6da722dcdf">&#9670;&nbsp;</a></span>readPixels() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::readPixels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_pixmap.html">SkPixmap</a> &amp;&#160;</td>
          <td class="paramname"><em>pixmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>srcY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="struct_sk_rect.html">SkRect</a> of pixels from <a class="el" href="class_sk_canvas.html">SkCanvas</a> into pixmap. <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip are ignored.</p>
<p>Source <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (srcX, srcY) and (<a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.width(), <a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.height()). Destination <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (0, 0) and (pixmap.width(), pixmap.height()). Copies each readable pixel intersecting both rectangles, without scaling, converting to pixmap.colorType() and pixmap.alphaType() if required.</p>
<p>Pixels are readable when <a class="el" href="class_sk_base_device.html">SkBaseDevice</a> is raster, or backed by a GPU. Pixels are not readable when <a class="el" href="class_sk_canvas.html">SkCanvas</a> is returned by <a class="el" href="class_sk_document.html#a79e3acb788004038aef9dccb1e221160">SkDocument::beginPage</a>, returned by <a class="el" href="class_sk_picture_recorder.html#a197a4390057dac85b24c0fa35b905d06">SkPictureRecorder::beginRecording</a>, or <a class="el" href="class_sk_canvas.html">SkCanvas</a> is the base of a utility class like DebugCanvas.</p>
<p>Caller must allocate pixel storage in pixmap if needed.</p>
<p><a class="el" href="struct_pixel.html">Pixel</a> values are converted only if SkColorType and SkAlphaType do not match. Only pixels within both source and destination <a class="el" href="struct_sk_rect.html">SkRect</a> are copied. pixmap pixels contents outside <a class="el" href="struct_sk_rect.html">SkRect</a> intersection are unchanged.</p>
<p>Pass negative values for srcX or srcY to offset pixels across or down pixmap.</p>
<p>Does not copy, and returns false if:</p><ul>
<li>Source and destination rectangles do not intersect.</li>
<li><a class="el" href="class_sk_canvas.html">SkCanvas</a> pixels could not be converted to pixmap.colorType() or pixmap.alphaType().</li>
<li><a class="el" href="class_sk_canvas.html">SkCanvas</a> pixels are not readable; for instance, <a class="el" href="class_sk_canvas.html">SkCanvas</a> is document-based.</li>
<li><a class="el" href="class_sk_pixmap.html">SkPixmap</a> pixels could not be allocated.</li>
<li>pixmap.rowBytes() is too small to contain one row of pixels.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixmap</td><td>storage for pixels copied from <a class="el" href="class_sk_canvas.html">SkCanvas</a> </td></tr>
    <tr><td class="paramname">srcX</td><td>offset into readable pixels on x-axis; may be negative </td></tr>
    <tr><td class="paramname">srcY</td><td>offset into readable pixels on y-axis; may be negative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if pixels were copied</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_readPixels_2">https://fiddle.skia.org/c/@Canvas_readPixels_2</a> </p>

</div>
</div>
<a id="a782b0cb2e900fb95fb2a0246e090a8a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782b0cb2e900fb95fb2a0246e090a8a3">&#9670;&nbsp;</a></span>recordingContext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_gr_recording_context.html">GrRecordingContext</a> * SkCanvas::recordingContext </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns GPU context of the GPU surface associated with <a class="el" href="class_sk_canvas.html">SkCanvas</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>GPU context, if available; nullptr otherwise</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_recordingContext">https://fiddle.skia.org/c/@Canvas_recordingContext</a> </p>

<p>Reimplemented in <a class="el" href="class_sk_paint_filter_canvas.html#a656aef48857da3a60f1bdad92fb28cbf">SkPaintFilterCanvas</a>.</p>

</div>
</div>
<a id="aba129108fc68dca01850faf73d5db148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba129108fc68dca01850faf73d5db148">&#9670;&nbsp;</a></span>resetMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::resetMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="class_sk_matrix.html">SkMatrix</a> to the identity matrix. Any prior matrix state is overwritten.</p>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_resetMatrix">https://fiddle.skia.org/c/@Canvas_resetMatrix</a> </p>

</div>
</div>
<a id="a2c68ed85badf62be77bb862b02dd4961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c68ed85badf62be77bb862b02dd4961">&#9670;&nbsp;</a></span>restore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::restore </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes changes to <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip since <a class="el" href="class_sk_canvas.html">SkCanvas</a> state was last saved. The state is removed from the stack.</p>
<p>Does nothing if the stack is empty.</p>
<p>example: <a href="https://fiddle.skia.org/c/@AutoCanvasRestore_restore">https://fiddle.skia.org/c/@AutoCanvasRestore_restore</a></p>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_restore">https://fiddle.skia.org/c/@Canvas_restore</a> </p>

</div>
</div>
<a id="aae519c51173be795b59f4f4e10c67b9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae519c51173be795b59f4f4e10c67b9d">&#9670;&nbsp;</a></span>restoreToCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::restoreToCount </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>saveCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restores state to <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip values when <a class="el" href="class_sk_canvas.html#ac98147dc771b47c7353a51e7c171e428">save()</a>, <a class="el" href="class_sk_canvas.html#a06bd76ce35082366bb6b8e6dfcb6f435">saveLayer()</a>, saveLayerPreserveLCDTextRequests(), or <a class="el" href="class_sk_canvas.html#a853514477dff62c15ced03f5141b2eb7">saveLayerAlpha()</a> returned saveCount.</p>
<p>Does nothing if saveCount is greater than state stack count. Restores state to initial values if saveCount is less than or equal to one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">saveCount</td><td>depth of state stack to restore</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_restoreToCount">https://fiddle.skia.org/c/@Canvas_restoreToCount</a> </p>

</div>
</div>
<a id="aaad49aba3b0c320915004e3c420a2780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaad49aba3b0c320915004e3c420a2780">&#9670;&nbsp;</a></span>rotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::rotate </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>degrees</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotates <a class="el" href="class_sk_matrix.html">SkMatrix</a> by degrees. Positive degrees rotates clockwise.</p>
<p>Mathematically, replaces <a class="el" href="class_sk_matrix.html">SkMatrix</a> with a rotation matrix premultiplied with <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>This has the effect of rotating the drawing by degrees before transforming the result with <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>amount to rotate, in degrees</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_rotate">https://fiddle.skia.org/c/@Canvas_rotate</a> </p>

</div>
</div>
<a id="a2f8897bee82cec6382b21425b5f7580d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8897bee82cec6382b21425b5f7580d">&#9670;&nbsp;</a></span>rotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::rotate </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>degrees</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>px</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>py</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotates <a class="el" href="class_sk_matrix.html">SkMatrix</a> by degrees about a point at (px, py). Positive degrees rotates clockwise.</p>
<p>Mathematically, constructs a rotation matrix; premultiplies the rotation matrix by a translation matrix; then replaces <a class="el" href="class_sk_matrix.html">SkMatrix</a> with the resulting matrix premultiplied with <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>This has the effect of rotating the drawing about a given point before transforming the result with <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">degrees</td><td>amount to rotate, in degrees </td></tr>
    <tr><td class="paramname">px</td><td>x-axis value of the point to rotate about </td></tr>
    <tr><td class="paramname">py</td><td>y-axis value of the point to rotate about</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_rotate_2">https://fiddle.skia.org/c/@Canvas_rotate_2</a> </p>

</div>
</div>
<a id="ac98147dc771b47c7353a51e7c171e428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98147dc771b47c7353a51e7c171e428">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SkCanvas::save </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip. Calling <a class="el" href="class_sk_canvas.html#a2c68ed85badf62be77bb862b02dd4961">restore()</a> discards changes to <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip, restoring the <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip to their state when <a class="el" href="class_sk_canvas.html#ac98147dc771b47c7353a51e7c171e428">save()</a> was called.</p>
<p><a class="el" href="class_sk_matrix.html">SkMatrix</a> may be changed by <a class="el" href="class_sk_canvas.html#a314ca6b7393639642f44a93b2df63fdb">translate()</a>, <a class="el" href="class_sk_canvas.html#adb01075c3bfab15fc3ded619961dfc15">scale()</a>, <a class="el" href="class_sk_canvas.html#aaad49aba3b0c320915004e3c420a2780">rotate()</a>, <a class="el" href="class_sk_canvas.html#af5049d341b5efe7a5f90207eb2f63641">skew()</a>, <a class="el" href="class_sk_canvas.html#adb493a60db8ccd84abbaa26fb9506bcf">concat()</a>, <a class="el" href="class_sk_canvas.html#ad07eb6c080bf2dbc8325e0d12d884915">setMatrix()</a>, and <a class="el" href="class_sk_canvas.html#aba129108fc68dca01850faf73d5db148">resetMatrix()</a>. Clip may be changed by <a class="el" href="class_sk_canvas.html#a193511e463259ceacfe0e4cf1be1393f">clipRect()</a>, <a class="el" href="class_sk_canvas.html#afcefd4d2ac745ad086fd62f30bbd8564">clipRRect()</a>, <a class="el" href="class_sk_canvas.html#abc79bd478516f398c31ae9f501154184">clipPath()</a>, <a class="el" href="class_sk_canvas.html#a8e3773e18ab060b7bb4e1cfc769fb07b">clipRegion()</a>.</p>
<p>Saved <a class="el" href="class_sk_canvas.html">SkCanvas</a> state is put on a stack; multiple calls to <a class="el" href="class_sk_canvas.html#ac98147dc771b47c7353a51e7c171e428">save()</a> should be balance by an equal number of calls to <a class="el" href="class_sk_canvas.html#a2c68ed85badf62be77bb862b02dd4961">restore()</a>.</p>
<p>Call <a class="el" href="class_sk_canvas.html#aae519c51173be795b59f4f4e10c67b9d">restoreToCount()</a> with result to restore this and subsequent saves.</p>
<dl class="section return"><dt>Returns</dt><dd>depth of saved stack</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_save">https://fiddle.skia.org/c/@Canvas_save</a> </p>

</div>
</div>
<a id="a41aa2893a587e4a371342d7ff809b0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41aa2893a587e4a371342d7ff809b0d5">&#9670;&nbsp;</a></span>saveLayer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SkCanvas::saveLayer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_canvas_1_1_save_layer_rec.html">SaveLayerRec</a> &amp;&#160;</td>
          <td class="paramname"><em>layerRec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip, and allocates <a class="el" href="class_sk_bitmap.html">SkBitmap</a> for subsequent drawing.</p>
<p>Calling <a class="el" href="class_sk_canvas.html#a2c68ed85badf62be77bb862b02dd4961">restore()</a> discards changes to <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip, and blends <a class="el" href="class_sk_bitmap.html">SkBitmap</a> with alpha opacity onto the prior layer.</p>
<p><a class="el" href="class_sk_matrix.html">SkMatrix</a> may be changed by <a class="el" href="class_sk_canvas.html#a314ca6b7393639642f44a93b2df63fdb">translate()</a>, <a class="el" href="class_sk_canvas.html#adb01075c3bfab15fc3ded619961dfc15">scale()</a>, <a class="el" href="class_sk_canvas.html#aaad49aba3b0c320915004e3c420a2780">rotate()</a>, <a class="el" href="class_sk_canvas.html#af5049d341b5efe7a5f90207eb2f63641">skew()</a>, <a class="el" href="class_sk_canvas.html#adb493a60db8ccd84abbaa26fb9506bcf">concat()</a>, <a class="el" href="class_sk_canvas.html#ad07eb6c080bf2dbc8325e0d12d884915">setMatrix()</a>, and <a class="el" href="class_sk_canvas.html#aba129108fc68dca01850faf73d5db148">resetMatrix()</a>. Clip may be changed by <a class="el" href="class_sk_canvas.html#a193511e463259ceacfe0e4cf1be1393f">clipRect()</a>, <a class="el" href="class_sk_canvas.html#afcefd4d2ac745ad086fd62f30bbd8564">clipRRect()</a>, <a class="el" href="class_sk_canvas.html#abc79bd478516f398c31ae9f501154184">clipPath()</a>, <a class="el" href="class_sk_canvas.html#a8e3773e18ab060b7bb4e1cfc769fb07b">clipRegion()</a>.</p>
<p><a class="el" href="struct_sk_canvas_1_1_save_layer_rec.html">SaveLayerRec</a> contains the state used to create the layer.</p>
<p>Call <a class="el" href="class_sk_canvas.html#aae519c51173be795b59f4f4e10c67b9d">restoreToCount()</a> with returned value to restore this and subsequent saves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerRec</td><td>layer state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>depth of save state stack before this call was made.</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_saveLayer_3">https://fiddle.skia.org/c/@Canvas_saveLayer_3</a> </p>

</div>
</div>
<a id="a8ba500cff0ee0035ea9aee097c6d5f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ba500cff0ee0035ea9aee097c6d5f00">&#9670;&nbsp;</a></span>saveLayer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int SkCanvas::saveLayer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Saves <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip, and allocates a <a class="el" href="class_sk_bitmap.html">SkBitmap</a> for subsequent drawing. Calling <a class="el" href="class_sk_canvas.html#a2c68ed85badf62be77bb862b02dd4961">restore()</a> discards changes to <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip, and draws the <a class="el" href="class_sk_bitmap.html">SkBitmap</a>.</p>
<p><a class="el" href="class_sk_matrix.html">SkMatrix</a> may be changed by <a class="el" href="class_sk_canvas.html#a314ca6b7393639642f44a93b2df63fdb">translate()</a>, <a class="el" href="class_sk_canvas.html#adb01075c3bfab15fc3ded619961dfc15">scale()</a>, <a class="el" href="class_sk_canvas.html#aaad49aba3b0c320915004e3c420a2780">rotate()</a>, <a class="el" href="class_sk_canvas.html#af5049d341b5efe7a5f90207eb2f63641">skew()</a>, <a class="el" href="class_sk_canvas.html#adb493a60db8ccd84abbaa26fb9506bcf">concat()</a>, <a class="el" href="class_sk_canvas.html#ad07eb6c080bf2dbc8325e0d12d884915">setMatrix()</a>, and <a class="el" href="class_sk_canvas.html#aba129108fc68dca01850faf73d5db148">resetMatrix()</a>. Clip may be changed by <a class="el" href="class_sk_canvas.html#a193511e463259ceacfe0e4cf1be1393f">clipRect()</a>, <a class="el" href="class_sk_canvas.html#afcefd4d2ac745ad086fd62f30bbd8564">clipRRect()</a>, <a class="el" href="class_sk_canvas.html#abc79bd478516f398c31ae9f501154184">clipPath()</a>, <a class="el" href="class_sk_canvas.html#a8e3773e18ab060b7bb4e1cfc769fb07b">clipRegion()</a>.</p>
<p><a class="el" href="struct_sk_rect.html">SkRect</a> bounds suggests but does not define the layer size. To clip drawing to a specific rectangle, use <a class="el" href="class_sk_canvas.html#a193511e463259ceacfe0e4cf1be1393f">clipRect()</a>.</p>
<p>Optional <a class="el" href="class_sk_paint.html">SkPaint</a> paint applies alpha, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>, and SkBlendMode when <a class="el" href="class_sk_canvas.html#a2c68ed85badf62be77bb862b02dd4961">restore()</a> is called.</p>
<p>Call <a class="el" href="class_sk_canvas.html#aae519c51173be795b59f4f4e10c67b9d">restoreToCount()</a> with returned value to restore this and subsequent saves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounds</td><td>hint to limit the size of layer; may be nullptr </td></tr>
    <tr><td class="paramname">paint</td><td>graphics state for layer; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>depth of saved stack </dd></dl>

</div>
</div>
<a id="a06bd76ce35082366bb6b8e6dfcb6f435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06bd76ce35082366bb6b8e6dfcb6f435">&#9670;&nbsp;</a></span>saveLayer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SkCanvas::saveLayer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> *&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_sk_paint.html">SkPaint</a> *&#160;</td>
          <td class="paramname"><em>paint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip, and allocates a <a class="el" href="class_sk_bitmap.html">SkBitmap</a> for subsequent drawing. Calling <a class="el" href="class_sk_canvas.html#a2c68ed85badf62be77bb862b02dd4961">restore()</a> discards changes to <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip, and draws the <a class="el" href="class_sk_bitmap.html">SkBitmap</a>.</p>
<p><a class="el" href="class_sk_matrix.html">SkMatrix</a> may be changed by <a class="el" href="class_sk_canvas.html#a314ca6b7393639642f44a93b2df63fdb">translate()</a>, <a class="el" href="class_sk_canvas.html#adb01075c3bfab15fc3ded619961dfc15">scale()</a>, <a class="el" href="class_sk_canvas.html#aaad49aba3b0c320915004e3c420a2780">rotate()</a>, <a class="el" href="class_sk_canvas.html#af5049d341b5efe7a5f90207eb2f63641">skew()</a>, <a class="el" href="class_sk_canvas.html#adb493a60db8ccd84abbaa26fb9506bcf">concat()</a>, <a class="el" href="class_sk_canvas.html#ad07eb6c080bf2dbc8325e0d12d884915">setMatrix()</a>, and <a class="el" href="class_sk_canvas.html#aba129108fc68dca01850faf73d5db148">resetMatrix()</a>. Clip may be changed by <a class="el" href="class_sk_canvas.html#a193511e463259ceacfe0e4cf1be1393f">clipRect()</a>, <a class="el" href="class_sk_canvas.html#afcefd4d2ac745ad086fd62f30bbd8564">clipRRect()</a>, <a class="el" href="class_sk_canvas.html#abc79bd478516f398c31ae9f501154184">clipPath()</a>, <a class="el" href="class_sk_canvas.html#a8e3773e18ab060b7bb4e1cfc769fb07b">clipRegion()</a>.</p>
<p><a class="el" href="struct_sk_rect.html">SkRect</a> bounds suggests but does not define the <a class="el" href="class_sk_bitmap.html">SkBitmap</a> size. To clip drawing to a specific rectangle, use <a class="el" href="class_sk_canvas.html#a193511e463259ceacfe0e4cf1be1393f">clipRect()</a>.</p>
<p>Optional <a class="el" href="class_sk_paint.html">SkPaint</a> paint applies alpha, <a class="el" href="class_sk_color_filter.html">SkColorFilter</a>, <a class="el" href="class_sk_image_filter.html">SkImageFilter</a>, and SkBlendMode when <a class="el" href="class_sk_canvas.html#a2c68ed85badf62be77bb862b02dd4961">restore()</a> is called.</p>
<p>Call <a class="el" href="class_sk_canvas.html#aae519c51173be795b59f4f4e10c67b9d">restoreToCount()</a> with returned value to restore this and subsequent saves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounds</td><td>hint to limit the size of the layer; may be nullptr </td></tr>
    <tr><td class="paramname">paint</td><td>graphics state for layer; may be nullptr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>depth of saved stack</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_saveLayer">https://fiddle.skia.org/c/@Canvas_saveLayer</a> example: <a href="https://fiddle.skia.org/c/@Canvas_saveLayer_4">https://fiddle.skia.org/c/@Canvas_saveLayer_4</a> </p>

</div>
</div>
<a id="a853514477dff62c15ced03f5141b2eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853514477dff62c15ced03f5141b2eb7">&#9670;&nbsp;</a></span>saveLayerAlpha()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SkCanvas::saveLayerAlpha </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> *&#160;</td>
          <td class="paramname"><em>bounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_sk_types_8h.html#a6882636f582abdb2a130b7e5ff38aa83">U8CPU</a>&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Saves <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip, and allocates <a class="el" href="class_sk_bitmap.html">SkBitmap</a> for subsequent drawing.</p>
<p>Calling <a class="el" href="class_sk_canvas.html#a2c68ed85badf62be77bb862b02dd4961">restore()</a> discards changes to <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip, and blends layer with alpha opacity onto prior layer.</p>
<p><a class="el" href="class_sk_matrix.html">SkMatrix</a> may be changed by <a class="el" href="class_sk_canvas.html#a314ca6b7393639642f44a93b2df63fdb">translate()</a>, <a class="el" href="class_sk_canvas.html#adb01075c3bfab15fc3ded619961dfc15">scale()</a>, <a class="el" href="class_sk_canvas.html#aaad49aba3b0c320915004e3c420a2780">rotate()</a>, <a class="el" href="class_sk_canvas.html#af5049d341b5efe7a5f90207eb2f63641">skew()</a>, <a class="el" href="class_sk_canvas.html#adb493a60db8ccd84abbaa26fb9506bcf">concat()</a>, <a class="el" href="class_sk_canvas.html#ad07eb6c080bf2dbc8325e0d12d884915">setMatrix()</a>, and <a class="el" href="class_sk_canvas.html#aba129108fc68dca01850faf73d5db148">resetMatrix()</a>. Clip may be changed by <a class="el" href="class_sk_canvas.html#a193511e463259ceacfe0e4cf1be1393f">clipRect()</a>, <a class="el" href="class_sk_canvas.html#afcefd4d2ac745ad086fd62f30bbd8564">clipRRect()</a>, <a class="el" href="class_sk_canvas.html#abc79bd478516f398c31ae9f501154184">clipPath()</a>, <a class="el" href="class_sk_canvas.html#a8e3773e18ab060b7bb4e1cfc769fb07b">clipRegion()</a>.</p>
<p><a class="el" href="struct_sk_rect.html">SkRect</a> bounds suggests but does not define layer size. To clip drawing to a specific rectangle, use <a class="el" href="class_sk_canvas.html#a193511e463259ceacfe0e4cf1be1393f">clipRect()</a>.</p>
<p>alpha of zero is fully transparent, 255 is fully opaque.</p>
<p>Call <a class="el" href="class_sk_canvas.html#aae519c51173be795b59f4f4e10c67b9d">restoreToCount()</a> with returned value to restore this and subsequent saves.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bounds</td><td>hint to limit the size of layer; may be nullptr </td></tr>
    <tr><td class="paramname">alpha</td><td>opacity of layer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>depth of saved stack</dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_saveLayerAlpha">https://fiddle.skia.org/c/@Canvas_saveLayerAlpha</a> </p>

</div>
</div>
<a id="adb01075c3bfab15fc3ded619961dfc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb01075c3bfab15fc3ded619961dfc15">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::scale </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scales <a class="el" href="class_sk_matrix.html">SkMatrix</a> by sx on the x-axis and sy on the y-axis.</p>
<p>Mathematically, replaces <a class="el" href="class_sk_matrix.html">SkMatrix</a> with a scale matrix premultiplied with <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>This has the effect of scaling the drawing by (sx, sy) before transforming the result with <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>amount to scale on x-axis </td></tr>
    <tr><td class="paramname">sy</td><td>amount to scale on y-axis</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_scale">https://fiddle.skia.org/c/@Canvas_scale</a> </p>

</div>
</div>
<a id="ad07eb6c080bf2dbc8325e0d12d884915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07eb6c080bf2dbc8325e0d12d884915">&#9670;&nbsp;</a></span>setMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::setMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_m44.html">SkM44</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces <a class="el" href="class_sk_matrix.html">SkMatrix</a> with matrix. Unlike <a class="el" href="class_sk_canvas.html#adb493a60db8ccd84abbaa26fb9506bcf">concat()</a>, any prior matrix state is overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>matrix to copy, replacing existing <a class="el" href="class_sk_matrix.html">SkMatrix</a></td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_setMatrix">https://fiddle.skia.org/c/@Canvas_setMatrix</a> </p>

</div>
</div>
<a id="af5049d341b5efe7a5f90207eb2f63641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5049d341b5efe7a5f90207eb2f63641">&#9670;&nbsp;</a></span>skew()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::skew </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>sy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Skews <a class="el" href="class_sk_matrix.html">SkMatrix</a> by sx on the x-axis and sy on the y-axis. A positive value of sx skews the drawing right as y-axis values increase; a positive value of sy skews the drawing down as x-axis values increase.</p>
<p>Mathematically, replaces <a class="el" href="class_sk_matrix.html">SkMatrix</a> with a skew matrix premultiplied with <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>This has the effect of skewing the drawing by (sx, sy) before transforming the result with <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sx</td><td>amount to skew on x-axis </td></tr>
    <tr><td class="paramname">sy</td><td>amount to skew on y-axis</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_skew">https://fiddle.skia.org/c/@Canvas_skew</a> </p>

</div>
</div>
<a id="ad50301a9f62976a135c79a5910e6be17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad50301a9f62976a135c79a5910e6be17">&#9670;&nbsp;</a></span>temporary_internal_getRgnClip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::temporary_internal_getRgnClip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_sk_region.html">SkRegion</a> *&#160;</td>
          <td class="paramname"><em>region</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the global clip as a region. If the clip contains AA, then only the bounds of the clip may be returned. </p>

</div>
</div>
<a id="a314ca6b7393639642f44a93b2df63fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314ca6b7393639642f44a93b2df63fdb">&#9670;&nbsp;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkCanvas::translate </td>
          <td>(</td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SkScalar&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translates <a class="el" href="class_sk_matrix.html">SkMatrix</a> by dx along the x-axis and dy along the y-axis.</p>
<p>Mathematically, replaces <a class="el" href="class_sk_matrix.html">SkMatrix</a> with a translation matrix premultiplied with <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<p>This has the effect of moving the drawing by (dx, dy) before transforming the result with <a class="el" href="class_sk_matrix.html">SkMatrix</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>distance to translate on x-axis </td></tr>
    <tr><td class="paramname">dy</td><td>distance to translate on y-axis</td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_translate">https://fiddle.skia.org/c/@Canvas_translate</a> </p>

</div>
</div>
<a id="a6a586fe3d06e650f9f6debf137ab89ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a586fe3d06e650f9f6debf137ab89ce">&#9670;&nbsp;</a></span>writePixels() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::writePixels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_sk_bitmap.html">SkBitmap</a> &amp;&#160;</td>
          <td class="paramname"><em>bitmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="struct_sk_rect.html">SkRect</a> from pixels to <a class="el" href="class_sk_canvas.html">SkCanvas</a>. <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip are ignored. Source <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (0, 0) and (bitmap.width(), bitmap.height()).</p>
<p>Destination <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (x, y) and (<a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.width(), <a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.height()).</p>
<p>Copies each readable pixel intersecting both rectangles, without scaling, converting to <a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.colorType() and <a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.alphaType() if required.</p>
<p>Pixels are writable when <a class="el" href="class_sk_base_device.html">SkBaseDevice</a> is raster, or backed by a GPU. Pixels are not writable when <a class="el" href="class_sk_canvas.html">SkCanvas</a> is returned by <a class="el" href="class_sk_document.html#a79e3acb788004038aef9dccb1e221160">SkDocument::beginPage</a>, returned by <a class="el" href="class_sk_picture_recorder.html#a197a4390057dac85b24c0fa35b905d06">SkPictureRecorder::beginRecording</a>, or <a class="el" href="class_sk_canvas.html">SkCanvas</a> is the base of a utility class like DebugCanvas.</p>
<p><a class="el" href="struct_pixel.html">Pixel</a> values are converted only if SkColorType and SkAlphaType do not match. Only pixels within both source and destination rectangles are copied. <a class="el" href="class_sk_canvas.html">SkCanvas</a> pixels outside <a class="el" href="struct_sk_rect.html">SkRect</a> intersection are unchanged.</p>
<p>Pass negative values for x or y to offset pixels to the left or above <a class="el" href="class_sk_canvas.html">SkCanvas</a> pixels.</p>
<p>Does not copy, and returns false if:</p><ul>
<li>Source and destination rectangles do not intersect.</li>
<li>bitmap does not have allocated pixels.</li>
<li>bitmap pixels could not be converted to <a class="el" href="class_sk_canvas.html">SkCanvas</a> <a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.colorType() or <a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.alphaType().</li>
<li><a class="el" href="class_sk_canvas.html">SkCanvas</a> pixels are not writable; for instance, <a class="el" href="class_sk_canvas.html">SkCanvas</a> is document based.</li>
<li>bitmap pixels are inaccessible; for instance, bitmap wraps a texture.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bitmap</td><td>contains pixels copied to <a class="el" href="class_sk_canvas.html">SkCanvas</a> </td></tr>
    <tr><td class="paramname">x</td><td>offset into <a class="el" href="class_sk_canvas.html">SkCanvas</a> writable pixels on x-axis; may be negative </td></tr>
    <tr><td class="paramname">y</td><td>offset into <a class="el" href="class_sk_canvas.html">SkCanvas</a> writable pixels on y-axis; may be negative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if pixels were written to <a class="el" href="class_sk_canvas.html">SkCanvas</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_writePixels_2">https://fiddle.skia.org/c/@Canvas_writePixels_2</a> example: <a href="https://fiddle.skia.org/c/@State_Stack_a">https://fiddle.skia.org/c/@State_Stack_a</a> example: <a href="https://fiddle.skia.org/c/@State_Stack_b">https://fiddle.skia.org/c/@State_Stack_b</a> </p>

</div>
</div>
<a id="a4a65fff01806bf2381aec2d81485e773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a65fff01806bf2381aec2d81485e773">&#9670;&nbsp;</a></span>writePixels() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkCanvas::writePixels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_image_info.html">SkImageInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rowBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="struct_sk_rect.html">SkRect</a> from pixels to <a class="el" href="class_sk_canvas.html">SkCanvas</a>. <a class="el" href="class_sk_matrix.html">SkMatrix</a> and clip are ignored. Source <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (0, 0) and (info.width(), info.height()). Destination <a class="el" href="struct_sk_rect.html">SkRect</a> corners are (x, y) and (<a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.width(), <a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.height()).</p>
<p>Copies each readable pixel intersecting both rectangles, without scaling, converting to <a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.colorType() and <a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.alphaType() if required.</p>
<p>Pixels are writable when <a class="el" href="class_sk_base_device.html">SkBaseDevice</a> is raster, or backed by a GPU. Pixels are not writable when <a class="el" href="class_sk_canvas.html">SkCanvas</a> is returned by <a class="el" href="class_sk_document.html#a79e3acb788004038aef9dccb1e221160">SkDocument::beginPage</a>, returned by <a class="el" href="class_sk_picture_recorder.html#a197a4390057dac85b24c0fa35b905d06">SkPictureRecorder::beginRecording</a>, or <a class="el" href="class_sk_canvas.html">SkCanvas</a> is the base of a utility class like DebugCanvas.</p>
<p><a class="el" href="struct_pixel.html">Pixel</a> values are converted only if SkColorType and SkAlphaType do not match. Only pixels within both source and destination rectangles are copied. <a class="el" href="class_sk_canvas.html">SkCanvas</a> pixels outside <a class="el" href="struct_sk_rect.html">SkRect</a> intersection are unchanged.</p>
<p>Pass negative values for x or y to offset pixels to the left or above <a class="el" href="class_sk_canvas.html">SkCanvas</a> pixels.</p>
<p>Does not copy, and returns false if:</p><ul>
<li>Source and destination rectangles do not intersect.</li>
<li>pixels could not be converted to <a class="el" href="class_sk_canvas.html">SkCanvas</a> <a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.colorType() or <a class="el" href="class_sk_canvas.html#aef8a74b34be1cefa29eac1ab7a1c6727">imageInfo()</a>.alphaType().</li>
<li><a class="el" href="class_sk_canvas.html">SkCanvas</a> pixels are not writable; for instance, <a class="el" href="class_sk_canvas.html">SkCanvas</a> is document-based.</li>
<li>rowBytes is too small to contain one row of pixels.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">info</td><td>width, height, SkColorType, and SkAlphaType of pixels </td></tr>
    <tr><td class="paramname">pixels</td><td>pixels to copy, of size info.height() times rowBytes, or larger </td></tr>
    <tr><td class="paramname">rowBytes</td><td>size of one row of pixels; info.width() times pixel size, or larger </td></tr>
    <tr><td class="paramname">x</td><td>offset into <a class="el" href="class_sk_canvas.html">SkCanvas</a> writable pixels on x-axis; may be negative </td></tr>
    <tr><td class="paramname">y</td><td>offset into <a class="el" href="class_sk_canvas.html">SkCanvas</a> writable pixels on y-axis; may be negative </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if pixels were written to <a class="el" href="class_sk_canvas.html">SkCanvas</a></dd></dl>
<p>example: <a href="https://fiddle.skia.org/c/@Canvas_writePixels">https://fiddle.skia.org/c/@Canvas_writePixels</a> </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/include/core/<a class="el" href="_sk_canvas_8h_source.html">SkCanvas.h</a></li>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/src/core/SkCanvas.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
