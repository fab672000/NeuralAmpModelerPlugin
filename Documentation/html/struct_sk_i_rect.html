<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: SkIRect Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="struct_sk_i_rect-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SkIRect Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_sk_rect_8h_source.html">SkRect.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aea0d8659ca3e49661c0f890f9c0f8a09"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#aea0d8659ca3e49661c0f890f9c0f8a09">left</a> () const</td></tr>
<tr class="separator:aea0d8659ca3e49661c0f890f9c0f8a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335ade4b4dddc29ee3331e291ebf33c1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a335ade4b4dddc29ee3331e291ebf33c1">top</a> () const</td></tr>
<tr class="separator:a335ade4b4dddc29ee3331e291ebf33c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95ef233d58c8aa90957cbfbf88016958"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a95ef233d58c8aa90957cbfbf88016958">right</a> () const</td></tr>
<tr class="separator:a95ef233d58c8aa90957cbfbf88016958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e81a7d18cd163d078beb38ca05399e1"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a3e81a7d18cd163d078beb38ca05399e1">bottom</a> () const</td></tr>
<tr class="separator:a3e81a7d18cd163d078beb38ca05399e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279993343bc4cfda9a4ef9d8093f8a6b"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a279993343bc4cfda9a4ef9d8093f8a6b">x</a> () const</td></tr>
<tr class="separator:a279993343bc4cfda9a4ef9d8093f8a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1b3309a1927c362797005730ad6f28"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a9d1b3309a1927c362797005730ad6f28">y</a> () const</td></tr>
<tr class="separator:a9d1b3309a1927c362797005730ad6f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a71d7f4bdf0a59255bb5172284d1eab"><td class="memItemLeft" align="right" valign="top"><a id="a9a71d7f4bdf0a59255bb5172284d1eab"></a>
<a class="el" href="struct_sk_i_point.html">SkIPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><b>topLeft</b> () const</td></tr>
<tr class="separator:a9a71d7f4bdf0a59255bb5172284d1eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3dd982f5c5669c09194f6db2b476554"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#aa3dd982f5c5669c09194f6db2b476554">width</a> () const</td></tr>
<tr class="separator:aa3dd982f5c5669c09194f6db2b476554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e1986ee6775d616e62400ecab1daa8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#aa0e1986ee6775d616e62400ecab1daa8">height</a> () const</td></tr>
<tr class="separator:aa0e1986ee6775d616e62400ecab1daa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc06f8cd83d72180fa3b220a562e5b3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_i_size.html">SkISize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#afc06f8cd83d72180fa3b220a562e5b3c">size</a> () const</td></tr>
<tr class="separator:afc06f8cd83d72180fa3b220a562e5b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f5e4e8f1ae45707f88f9733f8642d8"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a03f5e4e8f1ae45707f88f9733f8642d8">width64</a> () const</td></tr>
<tr class="separator:a03f5e4e8f1ae45707f88f9733f8642d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e5cb54cdbe935c80cd6ed1bcf897dff"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a5e5cb54cdbe935c80cd6ed1bcf897dff">height64</a> () const</td></tr>
<tr class="separator:a5e5cb54cdbe935c80cd6ed1bcf897dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c84ab05011ba8fa931c91a6b49347d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a1c84ab05011ba8fa931c91a6b49347d0">isEmpty64</a> () const</td></tr>
<tr class="separator:a1c84ab05011ba8fa931c91a6b49347d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73ec235f58891a46196258ab26b6c5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#aa73ec235f58891a46196258ab26b6c5e">isEmpty</a> () const</td></tr>
<tr class="separator:aa73ec235f58891a46196258ab26b6c5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a8ffcccc31078c8428a440dc875d6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a98a8ffcccc31078c8428a440dc875d6d">setEmpty</a> ()</td></tr>
<tr class="separator:a98a8ffcccc31078c8428a440dc875d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af513207f943cca0f0b030d6c187f57ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#af513207f943cca0f0b030d6c187f57ba">setLTRB</a> (int32_t <a class="el" href="struct_sk_i_rect.html#aea0d8659ca3e49661c0f890f9c0f8a09">left</a>, int32_t <a class="el" href="struct_sk_i_rect.html#a335ade4b4dddc29ee3331e291ebf33c1">top</a>, int32_t <a class="el" href="struct_sk_i_rect.html#a95ef233d58c8aa90957cbfbf88016958">right</a>, int32_t <a class="el" href="struct_sk_i_rect.html#a3e81a7d18cd163d078beb38ca05399e1">bottom</a>)</td></tr>
<tr class="separator:af513207f943cca0f0b030d6c187f57ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94e134617a0f94147ed3a4e58f1d8c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#aa94e134617a0f94147ed3a4e58f1d8c3">setXYWH</a> (int32_t <a class="el" href="struct_sk_i_rect.html#a279993343bc4cfda9a4ef9d8093f8a6b">x</a>, int32_t <a class="el" href="struct_sk_i_rect.html#a9d1b3309a1927c362797005730ad6f28">y</a>, int32_t <a class="el" href="struct_sk_i_rect.html#aa3dd982f5c5669c09194f6db2b476554">width</a>, int32_t <a class="el" href="struct_sk_i_rect.html#aa0e1986ee6775d616e62400ecab1daa8">height</a>)</td></tr>
<tr class="separator:aa94e134617a0f94147ed3a4e58f1d8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe3bdcbf80a2580a5708bb9bb059a1a"><td class="memItemLeft" align="right" valign="top"><a id="abfe3bdcbf80a2580a5708bb9bb059a1a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setWH</b> (int32_t <a class="el" href="struct_sk_i_rect.html#aa3dd982f5c5669c09194f6db2b476554">width</a>, int32_t <a class="el" href="struct_sk_i_rect.html#aa0e1986ee6775d616e62400ecab1daa8">height</a>)</td></tr>
<tr class="separator:abfe3bdcbf80a2580a5708bb9bb059a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff66410684aa1c7d4d433f0309170be9"><td class="memItemLeft" align="right" valign="top"><a id="aff66410684aa1c7d4d433f0309170be9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>setSize</b> (<a class="el" href="struct_sk_i_size.html">SkISize</a> <a class="el" href="struct_sk_i_rect.html#afc06f8cd83d72180fa3b220a562e5b3c">size</a>)</td></tr>
<tr class="separator:aff66410684aa1c7d4d433f0309170be9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5756c4267b4e73f11e94cfb3198299"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a9c5756c4267b4e73f11e94cfb3198299">makeOffset</a> (int32_t dx, int32_t dy) const</td></tr>
<tr class="separator:a9c5756c4267b4e73f11e94cfb3198299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d27401addd6d7ec8a4b1891f42cc89"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a85d27401addd6d7ec8a4b1891f42cc89">makeOffset</a> (<a class="el" href="struct_sk_i_point.html">SkIVector</a> <a class="el" href="struct_sk_i_rect.html#a9856695993dcdc090216e19a6ae7e2b8">offset</a>) const</td></tr>
<tr class="separator:a85d27401addd6d7ec8a4b1891f42cc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2f7ee902b0959fa8f4d0884847194fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_i_rect.html">SkIRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#ac2f7ee902b0959fa8f4d0884847194fc">makeInset</a> (int32_t dx, int32_t dy) const</td></tr>
<tr class="separator:ac2f7ee902b0959fa8f4d0884847194fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154e937c43233101f856eb5ab9f96037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_i_rect.html">SkIRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a154e937c43233101f856eb5ab9f96037">makeOutset</a> (int32_t dx, int32_t dy) const</td></tr>
<tr class="separator:a154e937c43233101f856eb5ab9f96037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9856695993dcdc090216e19a6ae7e2b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a9856695993dcdc090216e19a6ae7e2b8">offset</a> (int32_t dx, int32_t dy)</td></tr>
<tr class="separator:a9856695993dcdc090216e19a6ae7e2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5c0c17f09b26bbb11a30e49bd4f57f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a3c5c0c17f09b26bbb11a30e49bd4f57f">offset</a> (const <a class="el" href="struct_sk_i_point.html">SkIPoint</a> &amp;delta)</td></tr>
<tr class="separator:a3c5c0c17f09b26bbb11a30e49bd4f57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9faa26af22878dddf952654019e3e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a4a9faa26af22878dddf952654019e3e0">offsetTo</a> (int32_t newX, int32_t newY)</td></tr>
<tr class="separator:a4a9faa26af22878dddf952654019e3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c311b0d2276c74bd09e41795c252989"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a1c311b0d2276c74bd09e41795c252989">inset</a> (int32_t dx, int32_t dy)</td></tr>
<tr class="separator:a1c311b0d2276c74bd09e41795c252989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda5d94d3be0a4bd09285f5e3ceea988"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#acda5d94d3be0a4bd09285f5e3ceea988">outset</a> (int32_t dx, int32_t dy)</td></tr>
<tr class="separator:acda5d94d3be0a4bd09285f5e3ceea988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a143fc1b0346bf6b329a69a8cb3f3e37c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a143fc1b0346bf6b329a69a8cb3f3e37c">adjust</a> (int32_t dL, int32_t dT, int32_t dR, int32_t dB)</td></tr>
<tr class="separator:a143fc1b0346bf6b329a69a8cb3f3e37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8a7df65a36f913a7813f9964e0bc30"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#afd8a7df65a36f913a7813f9964e0bc30">contains</a> (int32_t <a class="el" href="struct_sk_i_rect.html#a279993343bc4cfda9a4ef9d8093f8a6b">x</a>, int32_t <a class="el" href="struct_sk_i_rect.html#a9d1b3309a1927c362797005730ad6f28">y</a>) const</td></tr>
<tr class="separator:afd8a7df65a36f913a7813f9964e0bc30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24beee0000dc6e8739616d5e2b354be8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a24beee0000dc6e8739616d5e2b354be8">contains</a> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;r) const</td></tr>
<tr class="separator:a24beee0000dc6e8739616d5e2b354be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c743a8228593dad52fe91699b5b983"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a86c743a8228593dad52fe91699b5b983">contains</a> (const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;r) const</td></tr>
<tr class="separator:a86c743a8228593dad52fe91699b5b983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5576d2cd82bd27798db7d783820771e1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a5576d2cd82bd27798db7d783820771e1">containsNoEmptyCheck</a> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;r) const</td></tr>
<tr class="separator:a5576d2cd82bd27798db7d783820771e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c5d8e4f3449c29d37a6f0d07d7838dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a3c5d8e4f3449c29d37a6f0d07d7838dc">intersect</a> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;r)</td></tr>
<tr class="separator:a3c5d8e4f3449c29d37a6f0d07d7838dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3807af1a53cceaa067fa2ffc64ee39"><td class="memItemLeft" align="right" valign="top">bool SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a6f3807af1a53cceaa067fa2ffc64ee39">intersect</a> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;a, const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;b)</td></tr>
<tr class="separator:a6f3807af1a53cceaa067fa2ffc64ee39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854f6a5d1cfd501a0a124a818114a180"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a854f6a5d1cfd501a0a124a818114a180">join</a> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;r)</td></tr>
<tr class="separator:a854f6a5d1cfd501a0a124a818114a180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b80c7843b17d05794019b88294cb8bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a0b80c7843b17d05794019b88294cb8bb">sort</a> ()</td></tr>
<tr class="separator:a0b80c7843b17d05794019b88294cb8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac92cc5c6eb41a38c86e5504fe31b516f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_sk_i_rect.html">SkIRect</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#ac92cc5c6eb41a38c86e5504fe31b516f">makeSorted</a> () const</td></tr>
<tr class="separator:ac92cc5c6eb41a38c86e5504fe31b516f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac3bd57e554c77893522e7614194fd45c"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#ac3bd57e554c77893522e7614194fd45c">MakeEmpty</a> ()</td></tr>
<tr class="separator:ac3bd57e554c77893522e7614194fd45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68dc46a2d9268c02749ef1474c1ff06"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#ab68dc46a2d9268c02749ef1474c1ff06">MakeWH</a> (int32_t w, int32_t h)</td></tr>
<tr class="separator:ab68dc46a2d9268c02749ef1474c1ff06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a4d57a3e2c8473203bec363b023df9"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a98a4d57a3e2c8473203bec363b023df9">MakeSize</a> (const <a class="el" href="struct_sk_i_size.html">SkISize</a> &amp;<a class="el" href="struct_sk_i_rect.html#afc06f8cd83d72180fa3b220a562e5b3c">size</a>)</td></tr>
<tr class="separator:a98a4d57a3e2c8473203bec363b023df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bde81ab75e4a436020676424b748a0a"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a3bde81ab75e4a436020676424b748a0a">MakePtSize</a> (<a class="el" href="struct_sk_i_point.html">SkIPoint</a> pt, <a class="el" href="struct_sk_i_size.html">SkISize</a> <a class="el" href="struct_sk_i_rect.html#afc06f8cd83d72180fa3b220a562e5b3c">size</a>)</td></tr>
<tr class="separator:a3bde81ab75e4a436020676424b748a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3756e980b26210a353ad05e004a01714"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a3756e980b26210a353ad05e004a01714">MakeLTRB</a> (int32_t l, int32_t t, int32_t r, int32_t b)</td></tr>
<tr class="separator:a3756e980b26210a353ad05e004a01714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631ca4a73d6debdaf8405fd4b5a77759"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a> SK_WARN_UNUSED_RESULT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a631ca4a73d6debdaf8405fd4b5a77759">MakeXYWH</a> (int32_t <a class="el" href="struct_sk_i_rect.html#a279993343bc4cfda9a4ef9d8093f8a6b">x</a>, int32_t <a class="el" href="struct_sk_i_rect.html#a9d1b3309a1927c362797005730ad6f28">y</a>, int32_t w, int32_t h)</td></tr>
<tr class="separator:a631ca4a73d6debdaf8405fd4b5a77759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fbf43ad2b1161a351d2457b0381212"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a44fbf43ad2b1161a351d2457b0381212">Intersects</a> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;a, const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;b)</td></tr>
<tr class="separator:a44fbf43ad2b1161a351d2457b0381212"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac3c4aefa2175abca9eed325b0ad279d2"><td class="memItemLeft" align="right" valign="top"><a id="ac3c4aefa2175abca9eed325b0ad279d2"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#ac3c4aefa2175abca9eed325b0ad279d2">fLeft</a></td></tr>
<tr class="memdesc:ac3c4aefa2175abca9eed325b0ad279d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">smaller x-axis bounds <br /></td></tr>
<tr class="separator:ac3c4aefa2175abca9eed325b0ad279d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d97be3c30b629a8f2abff70cb9d116"><td class="memItemLeft" align="right" valign="top"><a id="a83d97be3c30b629a8f2abff70cb9d116"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a83d97be3c30b629a8f2abff70cb9d116">fTop</a></td></tr>
<tr class="memdesc:a83d97be3c30b629a8f2abff70cb9d116"><td class="mdescLeft">&#160;</td><td class="mdescRight">smaller y-axis bounds <br /></td></tr>
<tr class="separator:a83d97be3c30b629a8f2abff70cb9d116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde91c6f6148539deaad5e5908cd2e36"><td class="memItemLeft" align="right" valign="top"><a id="afde91c6f6148539deaad5e5908cd2e36"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#afde91c6f6148539deaad5e5908cd2e36">fRight</a></td></tr>
<tr class="memdesc:afde91c6f6148539deaad5e5908cd2e36"><td class="mdescLeft">&#160;</td><td class="mdescRight">larger x-axis bounds <br /></td></tr>
<tr class="separator:afde91c6f6148539deaad5e5908cd2e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47eefff9ead395f2ab701137a91076a3"><td class="memItemLeft" align="right" valign="top"><a id="a47eefff9ead395f2ab701137a91076a3"></a>
int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a47eefff9ead395f2ab701137a91076a3">fBottom</a></td></tr>
<tr class="memdesc:a47eefff9ead395f2ab701137a91076a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">larger y-axis bounds <br /></td></tr>
<tr class="separator:a47eefff9ead395f2ab701137a91076a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a93d568ef8568ca674274d2aeaa2d34be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a93d568ef8568ca674274d2aeaa2d34be">operator==</a> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;a, const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;b)</td></tr>
<tr class="separator:a93d568ef8568ca674274d2aeaa2d34be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f36c798aadfd9cca3ce57bef8ce6ba6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_sk_i_rect.html#a0f36c798aadfd9cca3ce57bef8ce6ba6">operator!=</a> (const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;a, const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;b)</td></tr>
<tr class="separator:a0f36c798aadfd9cca3ce57bef8ce6ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="struct_sk_i_rect.html">SkIRect</a> holds four 32-bit integer coordinates describing the upper and lower bounds of a rectangle. <a class="el" href="struct_sk_i_rect.html">SkIRect</a> may be created from outer bounds or from position, width, and height. <a class="el" href="struct_sk_i_rect.html">SkIRect</a> describes an area; if its right is less than or equal to its left, or if its bottom is less than or equal to its top, it is considered empty. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a143fc1b0346bf6b329a69a8cb3f3e37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a143fc1b0346bf6b329a69a8cb3f3e37c">&#9670;&nbsp;</a></span>adjust()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkIRect::adjust </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adjusts <a class="el" href="struct_sk_i_rect.html">SkIRect</a> by adding dL to fLeft, dT to fTop, dR to fRight, and dB to fBottom.</p>
<p>If dL is positive, narrows <a class="el" href="struct_sk_i_rect.html">SkIRect</a> on the left. If negative, widens it on the left. If dT is positive, shrinks <a class="el" href="struct_sk_i_rect.html">SkIRect</a> on the top. If negative, lengthens it on the top. If dR is positive, narrows <a class="el" href="struct_sk_i_rect.html">SkIRect</a> on the right. If negative, widens it on the right. If dB is positive, shrinks <a class="el" href="struct_sk_i_rect.html">SkIRect</a> on the bottom. If negative, lengthens it on the bottom.</p>
<p>The resulting <a class="el" href="struct_sk_i_rect.html">SkIRect</a> is not checked for validity. Thus, if the resulting <a class="el" href="struct_sk_i_rect.html">SkIRect</a> left is greater than right, the <a class="el" href="struct_sk_i_rect.html">SkIRect</a> will be considered empty. Call <a class="el" href="struct_sk_i_rect.html#a0b80c7843b17d05794019b88294cb8bb">sort()</a> after this call if that is not the desired behavior.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dL</td><td>offset added to fLeft </td></tr>
    <tr><td class="paramname">dT</td><td>offset added to fTop </td></tr>
    <tr><td class="paramname">dR</td><td>offset added to fRight </td></tr>
    <tr><td class="paramname">dB</td><td>offset added to fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3e81a7d18cd163d078beb38ca05399e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e81a7d18cd163d078beb38ca05399e1">&#9670;&nbsp;</a></span>bottom()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SkIRect::bottom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns bottom edge of <a class="el" href="struct_sk_i_rect.html">SkIRect</a>, if sorted. Call <a class="el" href="struct_sk_i_rect.html#aa73ec235f58891a46196258ab26b6c5e">isEmpty()</a> to see if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> may be invalid, and <a class="el" href="struct_sk_i_rect.html#a0b80c7843b17d05794019b88294cb8bb">sort()</a> to reverse fTop and fBottom if needed.</p>
<dl class="section return"><dt>Returns</dt><dd>fBottom </dd></dl>

</div>
</div>
<a id="a24beee0000dc6e8739616d5e2b354be8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24beee0000dc6e8739616d5e2b354be8">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkIRect::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> contains r. Returns false if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> is empty or r is empty.</p>
<p><a class="el" href="struct_sk_i_rect.html">SkIRect</a> contains r when <a class="el" href="struct_sk_i_rect.html">SkIRect</a> area completely includes r area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td><a class="el" href="struct_sk_i_rect.html">SkIRect</a> contained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all sides of <a class="el" href="struct_sk_i_rect.html">SkIRect</a> are outside r </dd></dl>

</div>
</div>
<a id="a86c743a8228593dad52fe91699b5b983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c743a8228593dad52fe91699b5b983">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkIRect::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_rect.html">SkRect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> contains r. Returns false if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> is empty or r is empty.</p>
<p><a class="el" href="struct_sk_i_rect.html">SkIRect</a> contains r when <a class="el" href="struct_sk_i_rect.html">SkIRect</a> area completely includes r area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td><a class="el" href="struct_sk_rect.html">SkRect</a> contained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all sides of <a class="el" href="struct_sk_i_rect.html">SkIRect</a> are outside r </dd></dl>

</div>
</div>
<a id="afd8a7df65a36f913a7813f9964e0bc30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd8a7df65a36f913a7813f9964e0bc30">&#9670;&nbsp;</a></span>contains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkIRect::contains </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if: fLeft &lt;= x &lt; fRight &amp;&amp; fTop &lt;= y &lt; fBottom. Returns false if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> is empty.</p>
<p>Considers input to describe constructed <a class="el" href="struct_sk_i_rect.html">SkIRect</a>: (x, y, x + 1, y + 1) and returns true if constructed area is completely enclosed by <a class="el" href="struct_sk_i_rect.html">SkIRect</a> area.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>test <a class="el" href="struct_sk_i_point.html">SkIPoint</a> x-coordinate </td></tr>
    <tr><td class="paramname">y</td><td>test <a class="el" href="struct_sk_i_point.html">SkIPoint</a> y-coordinate </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if (x, y) is inside <a class="el" href="struct_sk_i_rect.html">SkIRect</a> </dd></dl>

</div>
</div>
<a id="a5576d2cd82bd27798db7d783820771e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5576d2cd82bd27798db7d783820771e1">&#9670;&nbsp;</a></span>containsNoEmptyCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkIRect::containsNoEmptyCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> contains construction. Asserts if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> is empty or construction is empty, and if SK_DEBUG is defined.</p>
<p>Return is undefined if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> is empty or construction is empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td><a class="el" href="struct_sk_i_rect.html">SkIRect</a> contained </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all sides of <a class="el" href="struct_sk_i_rect.html">SkIRect</a> are outside r </dd></dl>

</div>
</div>
<a id="aa0e1986ee6775d616e62400ecab1daa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e1986ee6775d616e62400ecab1daa8">&#9670;&nbsp;</a></span>height()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SkIRect::height </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns span on the y-axis. This does not check if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> is sorted, or if result fits in 32-bit signed integer; result may be negative.</p>
<dl class="section return"><dt>Returns</dt><dd>fBottom minus fTop </dd></dl>

</div>
</div>
<a id="a5e5cb54cdbe935c80cd6ed1bcf897dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e5cb54cdbe935c80cd6ed1bcf897dff">&#9670;&nbsp;</a></span>height64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t SkIRect::height64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns span on the y-axis. This does not check if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> is sorted, so the result may be negative. This is safer than calling <a class="el" href="struct_sk_i_rect.html#aa0e1986ee6775d616e62400ecab1daa8">height()</a> since <a class="el" href="struct_sk_i_rect.html#aa0e1986ee6775d616e62400ecab1daa8">height()</a> might overflow in its calculation.</p>
<dl class="section return"><dt>Returns</dt><dd>fBottom minus fTop cast to int64_t </dd></dl>

</div>
</div>
<a id="a1c311b0d2276c74bd09e41795c252989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c311b0d2276c74bd09e41795c252989">&#9670;&nbsp;</a></span>inset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkIRect::inset </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Insets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> by (dx,dy).</p>
<p>If dx is positive, makes <a class="el" href="struct_sk_i_rect.html">SkIRect</a> narrower. If dx is negative, makes <a class="el" href="struct_sk_i_rect.html">SkIRect</a> wider. If dy is positive, makes <a class="el" href="struct_sk_i_rect.html">SkIRect</a> shorter. If dy is negative, makes <a class="el" href="struct_sk_i_rect.html">SkIRect</a> taller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>offset added to fLeft and subtracted from fRight </td></tr>
    <tr><td class="paramname">dy</td><td>offset added to fTop and subtracted from fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f3807af1a53cceaa067fa2ffc64ee39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3807af1a53cceaa067fa2ffc64ee39">&#9670;&nbsp;</a></span>intersect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SkIRect::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if a intersects b, and sets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> to intersection. Returns false if a does not intersect b, and leaves <a class="el" href="struct_sk_i_rect.html">SkIRect</a> unchanged.</p>
<p>Returns false if either a or b is empty, leaving <a class="el" href="struct_sk_i_rect.html">SkIRect</a> unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="struct_sk_i_rect.html">SkIRect</a> to intersect </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="struct_sk_i_rect.html">SkIRect</a> to intersect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a and b have area in common </dd></dl>

</div>
</div>
<a id="a3c5d8e4f3449c29d37a6f0d07d7838dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5d8e4f3449c29d37a6f0d07d7838dc">&#9670;&nbsp;</a></span>intersect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkIRect::intersect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> intersects r, and sets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> to intersection. Returns false if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> does not intersect r, and leaves <a class="el" href="struct_sk_i_rect.html">SkIRect</a> unchanged.</p>
<p>Returns false if either r or <a class="el" href="struct_sk_i_rect.html">SkIRect</a> is empty, leaving <a class="el" href="struct_sk_i_rect.html">SkIRect</a> unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>limit of result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if r and <a class="el" href="struct_sk_i_rect.html">SkIRect</a> have area in common </dd></dl>

</div>
</div>
<a id="a44fbf43ad2b1161a351d2457b0381212"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fbf43ad2b1161a351d2457b0381212">&#9670;&nbsp;</a></span>Intersects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool SkIRect::Intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if a intersects b. Returns false if either a or b is empty, or do not intersect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="struct_sk_i_rect.html">SkIRect</a> to intersect </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="struct_sk_i_rect.html">SkIRect</a> to intersect </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a and b have area in common </dd></dl>

</div>
</div>
<a id="aa73ec235f58891a46196258ab26b6c5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73ec235f58891a46196258ab26b6c5e">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkIRect::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if <a class="el" href="struct_sk_i_rect.html#aa3dd982f5c5669c09194f6db2b476554">width()</a> or <a class="el" href="struct_sk_i_rect.html#aa0e1986ee6775d616e62400ecab1daa8">height()</a> are zero or negative.</p>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="struct_sk_i_rect.html#aa3dd982f5c5669c09194f6db2b476554">width()</a> or <a class="el" href="struct_sk_i_rect.html#aa0e1986ee6775d616e62400ecab1daa8">height()</a> are zero or negative </dd></dl>

</div>
</div>
<a id="a1c84ab05011ba8fa931c91a6b49347d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c84ab05011ba8fa931c91a6b49347d0">&#9670;&nbsp;</a></span>isEmpty64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool SkIRect::isEmpty64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if fLeft is equal to or greater than fRight, or if fTop is equal to or greater than fBottom. Call <a class="el" href="struct_sk_i_rect.html#a0b80c7843b17d05794019b88294cb8bb">sort()</a> to reverse rectangles with negative <a class="el" href="struct_sk_i_rect.html#a03f5e4e8f1ae45707f88f9733f8642d8">width64()</a> or <a class="el" href="struct_sk_i_rect.html#a5e5cb54cdbe935c80cd6ed1bcf897dff">height64()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if <a class="el" href="struct_sk_i_rect.html#a03f5e4e8f1ae45707f88f9733f8642d8">width64()</a> or <a class="el" href="struct_sk_i_rect.html#a5e5cb54cdbe935c80cd6ed1bcf897dff">height64()</a> are zero or negative </dd></dl>

</div>
</div>
<a id="a854f6a5d1cfd501a0a124a818114a180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854f6a5d1cfd501a0a124a818114a180">&#9670;&nbsp;</a></span>join()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SkIRect::join </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> to the union of itself and r.</p>
<p>Has no effect if r is empty. Otherwise, if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> is empty, sets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> to r.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>expansion <a class="el" href="struct_sk_i_rect.html">SkIRect</a></td></tr>
  </table>
  </dd>
</dl>
<p>example: <a href="https://fiddle.skia.org/c/@IRect_join_2">https://fiddle.skia.org/c/@IRect_join_2</a> </p>

</div>
</div>
<a id="aea0d8659ca3e49661c0f890f9c0f8a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0d8659ca3e49661c0f890f9c0f8a09">&#9670;&nbsp;</a></span>left()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SkIRect::left </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns left edge of <a class="el" href="struct_sk_i_rect.html">SkIRect</a>, if sorted. Call <a class="el" href="struct_sk_i_rect.html#a0b80c7843b17d05794019b88294cb8bb">sort()</a> to reverse fLeft and fRight if needed.</p>
<dl class="section return"><dt>Returns</dt><dd>fLeft </dd></dl>

</div>
</div>
<a id="ac3bd57e554c77893522e7614194fd45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3bd57e554c77893522e7614194fd45c">&#9670;&nbsp;</a></span>MakeEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a> SK_WARN_UNUSED_RESULT SkIRect::MakeEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_sk_i_rect.html">SkIRect</a> set to (0, 0, 0, 0). Many other rectangles are empty; if left is equal to or greater than right, or if top is equal to or greater than bottom. Setting all members to zero is a convenience, but does not designate a special empty rectangle.</p>
<dl class="section return"><dt>Returns</dt><dd>bounds (0, 0, 0, 0) </dd></dl>

</div>
</div>
<a id="ac2f7ee902b0959fa8f4d0884847194fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2f7ee902b0959fa8f4d0884847194fc">&#9670;&nbsp;</a></span>makeInset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_i_rect.html">SkIRect</a> SkIRect::makeInset </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_i_rect.html">SkIRect</a>, inset by (dx, dy).</p>
<p>If dx is negative, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is wider. If dx is positive, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is narrower. If dy is negative, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is taller. If dy is positive, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is shorter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>offset added to fLeft and subtracted from fRight </td></tr>
    <tr><td class="paramname">dy</td><td>offset added to fTop and subtracted from fBottom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_sk_i_rect.html">SkIRect</a> inset symmetrically left and right, top and bottom </dd></dl>

</div>
</div>
<a id="a3756e980b26210a353ad05e004a01714"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3756e980b26210a353ad05e004a01714">&#9670;&nbsp;</a></span>MakeLTRB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a> SK_WARN_UNUSED_RESULT SkIRect::MakeLTRB </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>l</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_sk_i_rect.html">SkIRect</a> set to (l, t, r, b). Does not sort input; <a class="el" href="struct_sk_i_rect.html">SkIRect</a> may result in fLeft greater than fRight, or fTop greater than fBottom.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l</td><td>integer stored in fLeft </td></tr>
    <tr><td class="paramname">t</td><td>integer stored in fTop </td></tr>
    <tr><td class="paramname">r</td><td>integer stored in fRight </td></tr>
    <tr><td class="paramname">b</td><td>integer stored in fBottom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bounds (l, t, r, b) </dd></dl>

</div>
</div>
<a id="a9c5756c4267b4e73f11e94cfb3198299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5756c4267b4e73f11e94cfb3198299">&#9670;&nbsp;</a></span>makeOffset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a> SkIRect::makeOffset </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_i_rect.html">SkIRect</a> offset by (dx, dy).</p>
<p>If dx is negative, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is moved to the left. If dx is positive, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is moved to the right. If dy is negative, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is moved upward. If dy is positive, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is moved downward.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>offset added to fLeft and fRight </td></tr>
    <tr><td class="paramname">dy</td><td>offset added to fTop and fBottom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_sk_i_rect.html">SkIRect</a> offset by dx and dy, with original width and height </dd></dl>

</div>
</div>
<a id="a85d27401addd6d7ec8a4b1891f42cc89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d27401addd6d7ec8a4b1891f42cc89">&#9670;&nbsp;</a></span>makeOffset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a> SkIRect::makeOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_i_point.html">SkIVector</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_i_rect.html">SkIRect</a> offset by (offset.x(), offset.y()).</p>
<p>If offset.x() is negative, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is moved to the left. If offset.x() is positive, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is moved to the right. If offset.y() is negative, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is moved upward. If offset.y() is positive, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is moved downward.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>translation vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_sk_i_rect.html">SkIRect</a> translated by offset, with original width and height </dd></dl>

</div>
</div>
<a id="a154e937c43233101f856eb5ab9f96037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154e937c43233101f856eb5ab9f96037">&#9670;&nbsp;</a></span>makeOutset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_i_rect.html">SkIRect</a> SkIRect::makeOutset </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_i_rect.html">SkIRect</a>, outset by (dx, dy).</p>
<p>If dx is negative, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is narrower. If dx is positive, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is wider. If dy is negative, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is shorter. If dy is positive, <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned is taller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>offset subtracted to fLeft and added from fRight </td></tr>
    <tr><td class="paramname">dy</td><td>offset subtracted to fTop and added from fBottom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_sk_i_rect.html">SkIRect</a> outset symmetrically left and right, top and bottom </dd></dl>

</div>
</div>
<a id="a3bde81ab75e4a436020676424b748a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bde81ab75e4a436020676424b748a0a">&#9670;&nbsp;</a></span>MakePtSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a> SK_WARN_UNUSED_RESULT SkIRect::MakePtSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_sk_i_point.html">SkIPoint</a>&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_sk_i_size.html">SkISize</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_sk_i_rect.html">SkIRect</a> set to (pt.x(), pt.y(), pt.x() + size.width(), pt.y() + size.height()). Does not validate input; size.width() or size.height() may be negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pt</td><td>values for <a class="el" href="struct_sk_i_rect.html">SkIRect</a> fLeft and fTop </td></tr>
    <tr><td class="paramname">size</td><td>values for <a class="el" href="struct_sk_i_rect.html">SkIRect</a> width and height </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bounds at pt with width and height of size </dd></dl>

</div>
</div>
<a id="a98a4d57a3e2c8473203bec363b023df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a4d57a3e2c8473203bec363b023df9">&#9670;&nbsp;</a></span>MakeSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a> SK_WARN_UNUSED_RESULT SkIRect::MakeSize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_size.html">SkISize</a> &amp;&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_sk_i_rect.html">SkIRect</a> set to (0, 0, size.width(), size.height()). Does not validate input; size.width() or size.height() may be negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>values for <a class="el" href="struct_sk_i_rect.html">SkIRect</a> width and height </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bounds (0, 0, size.width(), size.height()) </dd></dl>

</div>
</div>
<a id="ac92cc5c6eb41a38c86e5504fe31b516f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac92cc5c6eb41a38c86e5504fe31b516f">&#9670;&nbsp;</a></span>makeSorted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_i_rect.html">SkIRect</a> SkIRect::makeSorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns <a class="el" href="struct_sk_i_rect.html">SkIRect</a> with fLeft and fRight swapped if fLeft is greater than fRight; and with fTop and fBottom swapped if fTop is greater than fBottom. Result may be empty; and <a class="el" href="struct_sk_i_rect.html#aa3dd982f5c5669c09194f6db2b476554">width()</a> and <a class="el" href="struct_sk_i_rect.html#aa0e1986ee6775d616e62400ecab1daa8">height()</a> will be zero or positive.</p>
<dl class="section return"><dt>Returns</dt><dd>sorted <a class="el" href="struct_sk_i_rect.html">SkIRect</a> </dd></dl>

</div>
</div>
<a id="ab68dc46a2d9268c02749ef1474c1ff06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68dc46a2d9268c02749ef1474c1ff06">&#9670;&nbsp;</a></span>MakeWH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a> SK_WARN_UNUSED_RESULT SkIRect::MakeWH </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_sk_i_rect.html">SkIRect</a> set to (0, 0, w, h). Does not validate input; w or h may be negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>width of constructed <a class="el" href="struct_sk_i_rect.html">SkIRect</a> </td></tr>
    <tr><td class="paramname">h</td><td>height of constructed <a class="el" href="struct_sk_i_rect.html">SkIRect</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bounds (0, 0, w, h) </dd></dl>

</div>
</div>
<a id="a631ca4a73d6debdaf8405fd4b5a77759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631ca4a73d6debdaf8405fd4b5a77759">&#9670;&nbsp;</a></span>MakeXYWH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="struct_sk_i_rect.html">SkIRect</a> SK_WARN_UNUSED_RESULT SkIRect::MakeXYWH </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>h</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns constructed <a class="el" href="struct_sk_i_rect.html">SkIRect</a> set to: (x, y, x + w, y + h). Does not validate input; w or h may be negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>stored in fLeft </td></tr>
    <tr><td class="paramname">y</td><td>stored in fTop </td></tr>
    <tr><td class="paramname">w</td><td>added to x and stored in fRight </td></tr>
    <tr><td class="paramname">h</td><td>added to y and stored in fBottom </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bounds at (x, y) with width w and height h </dd></dl>

</div>
</div>
<a id="a3c5c0c17f09b26bbb11a30e49bd4f57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c5c0c17f09b26bbb11a30e49bd4f57f">&#9670;&nbsp;</a></span>offset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkIRect::offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_point.html">SkIPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Offsets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> by adding delta.fX to fLeft, fRight; and by adding delta.fY to fTop, fBottom.</p>
<p>If delta.fX is negative, moves <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned to the left. If delta.fX is positive, moves <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned to the right. If delta.fY is negative, moves <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned upward. If delta.fY is positive, moves <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned downward.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>offset added to <a class="el" href="struct_sk_i_rect.html">SkIRect</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9856695993dcdc090216e19a6ae7e2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9856695993dcdc090216e19a6ae7e2b8">&#9670;&nbsp;</a></span>offset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkIRect::offset </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Offsets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> by adding dx to fLeft, fRight; and by adding dy to fTop, fBottom.</p>
<p>If dx is negative, moves <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned to the left. If dx is positive, moves <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned to the right. If dy is negative, moves <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned upward. If dy is positive, moves <a class="el" href="struct_sk_i_rect.html">SkIRect</a> returned downward.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>offset added to fLeft and fRight </td></tr>
    <tr><td class="paramname">dy</td><td>offset added to fTop and fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a9faa26af22878dddf952654019e3e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9faa26af22878dddf952654019e3e0">&#9670;&nbsp;</a></span>offsetTo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkIRect::offsetTo </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>newX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>newY</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Offsets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> so that fLeft equals newX, and fTop equals newY. width and height are unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">newX</td><td>stored in fLeft, preserving <a class="el" href="struct_sk_i_rect.html#aa3dd982f5c5669c09194f6db2b476554">width()</a> </td></tr>
    <tr><td class="paramname">newY</td><td>stored in fTop, preserving <a class="el" href="struct_sk_i_rect.html#aa0e1986ee6775d616e62400ecab1daa8">height()</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acda5d94d3be0a4bd09285f5e3ceea988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda5d94d3be0a4bd09285f5e3ceea988">&#9670;&nbsp;</a></span>outset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkIRect::outset </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Outsets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> by (dx, dy).</p>
<p>If dx is positive, makes <a class="el" href="struct_sk_i_rect.html">SkIRect</a> wider. If dx is negative, makes <a class="el" href="struct_sk_i_rect.html">SkIRect</a> narrower. If dy is positive, makes <a class="el" href="struct_sk_i_rect.html">SkIRect</a> taller. If dy is negative, makes <a class="el" href="struct_sk_i_rect.html">SkIRect</a> shorter.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dx</td><td>subtracted to fLeft and added from fRight </td></tr>
    <tr><td class="paramname">dy</td><td>subtracted to fTop and added from fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95ef233d58c8aa90957cbfbf88016958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95ef233d58c8aa90957cbfbf88016958">&#9670;&nbsp;</a></span>right()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SkIRect::right </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns right edge of <a class="el" href="struct_sk_i_rect.html">SkIRect</a>, if sorted. Call <a class="el" href="struct_sk_i_rect.html#a0b80c7843b17d05794019b88294cb8bb">sort()</a> to reverse fLeft and fRight if needed.</p>
<dl class="section return"><dt>Returns</dt><dd>fRight </dd></dl>

</div>
</div>
<a id="a98a8ffcccc31078c8428a440dc875d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a8ffcccc31078c8428a440dc875d6d">&#9670;&nbsp;</a></span>setEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkIRect::setEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> to (0, 0, 0, 0).</p>
<p>Many other rectangles are empty; if left is equal to or greater than right, or if top is equal to or greater than bottom. Setting all members to zero is a convenience, but does not designate a special empty rectangle. </p>

</div>
</div>
<a id="af513207f943cca0f0b030d6c187f57ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af513207f943cca0f0b030d6c187f57ba">&#9670;&nbsp;</a></span>setLTRB()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkIRect::setLTRB </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>top</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>bottom</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> to (left, top, right, bottom). left and right are not sorted; left is not necessarily less than right. top and bottom are not sorted; top is not necessarily less than bottom.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">left</td><td>stored in fLeft </td></tr>
    <tr><td class="paramname">top</td><td>stored in fTop </td></tr>
    <tr><td class="paramname">right</td><td>stored in fRight </td></tr>
    <tr><td class="paramname">bottom</td><td>stored in fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa94e134617a0f94147ed3a4e58f1d8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94e134617a0f94147ed3a4e58f1d8c3">&#9670;&nbsp;</a></span>setXYWH()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkIRect::setXYWH </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets <a class="el" href="struct_sk_i_rect.html">SkIRect</a> to: (x, y, x + width, y + height). Does not validate input; width or height may be negative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>stored in fLeft </td></tr>
    <tr><td class="paramname">y</td><td>stored in fTop </td></tr>
    <tr><td class="paramname">width</td><td>added to x and stored in fRight </td></tr>
    <tr><td class="paramname">height</td><td>added to y and stored in fBottom </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc06f8cd83d72180fa3b220a562e5b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc06f8cd83d72180fa3b220a562e5b3c">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_sk_i_size.html">SkISize</a> SkIRect::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns spans on the x-axis and y-axis. This does not check if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> is sorted, or if result fits in 32-bit signed integer; result may be negative.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="struct_sk_i_size.html">SkISize</a> (width, height) </dd></dl>

</div>
</div>
<a id="a0b80c7843b17d05794019b88294cb8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b80c7843b17d05794019b88294cb8bb">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SkIRect::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps fLeft and fRight if fLeft is greater than fRight; and swaps fTop and fBottom if fTop is greater than fBottom. Result may be empty, and <a class="el" href="struct_sk_i_rect.html#aa3dd982f5c5669c09194f6db2b476554">width()</a> and <a class="el" href="struct_sk_i_rect.html#aa0e1986ee6775d616e62400ecab1daa8">height()</a> will be zero or positive. </p>

</div>
</div>
<a id="a335ade4b4dddc29ee3331e291ebf33c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335ade4b4dddc29ee3331e291ebf33c1">&#9670;&nbsp;</a></span>top()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SkIRect::top </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns top edge of <a class="el" href="struct_sk_i_rect.html">SkIRect</a>, if sorted. Call <a class="el" href="struct_sk_i_rect.html#aa73ec235f58891a46196258ab26b6c5e">isEmpty()</a> to see if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> may be invalid, and <a class="el" href="struct_sk_i_rect.html#a0b80c7843b17d05794019b88294cb8bb">sort()</a> to reverse fTop and fBottom if needed.</p>
<dl class="section return"><dt>Returns</dt><dd>fTop </dd></dl>

</div>
</div>
<a id="aa3dd982f5c5669c09194f6db2b476554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3dd982f5c5669c09194f6db2b476554">&#9670;&nbsp;</a></span>width()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SkIRect::width </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns span on the x-axis. This does not check if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> is sorted, or if result fits in 32-bit signed integer; result may be negative.</p>
<dl class="section return"><dt>Returns</dt><dd>fRight minus fLeft </dd></dl>

</div>
</div>
<a id="a03f5e4e8f1ae45707f88f9733f8642d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f5e4e8f1ae45707f88f9733f8642d8">&#9670;&nbsp;</a></span>width64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t SkIRect::width64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns span on the x-axis. This does not check if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> is sorted, so the result may be negative. This is safer than calling <a class="el" href="struct_sk_i_rect.html#aa3dd982f5c5669c09194f6db2b476554">width()</a> since <a class="el" href="struct_sk_i_rect.html#aa3dd982f5c5669c09194f6db2b476554">width()</a> might overflow in its calculation.</p>
<dl class="section return"><dt>Returns</dt><dd>fRight minus fLeft cast to int64_t </dd></dl>

</div>
</div>
<a id="a279993343bc4cfda9a4ef9d8093f8a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279993343bc4cfda9a4ef9d8093f8a6b">&#9670;&nbsp;</a></span>x()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SkIRect::x </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns left edge of <a class="el" href="struct_sk_i_rect.html">SkIRect</a>, if sorted. Call <a class="el" href="struct_sk_i_rect.html#aa73ec235f58891a46196258ab26b6c5e">isEmpty()</a> to see if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> may be invalid, and <a class="el" href="struct_sk_i_rect.html#a0b80c7843b17d05794019b88294cb8bb">sort()</a> to reverse fLeft and fRight if needed.</p>
<dl class="section return"><dt>Returns</dt><dd>fLeft </dd></dl>

</div>
</div>
<a id="a9d1b3309a1927c362797005730ad6f28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1b3309a1927c362797005730ad6f28">&#9670;&nbsp;</a></span>y()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int32_t SkIRect::y </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns top edge of <a class="el" href="struct_sk_i_rect.html">SkIRect</a>, if sorted. Call <a class="el" href="struct_sk_i_rect.html#aa73ec235f58891a46196258ab26b6c5e">isEmpty()</a> to see if <a class="el" href="struct_sk_i_rect.html">SkIRect</a> may be invalid, and <a class="el" href="struct_sk_i_rect.html#a0b80c7843b17d05794019b88294cb8bb">sort()</a> to reverse fTop and fBottom if needed.</p>
<dl class="section return"><dt>Returns</dt><dd>fTop </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0f36c798aadfd9cca3ce57bef8ce6ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f36c798aadfd9cca3ce57bef8ce6ba6">&#9670;&nbsp;</a></span>operator!=</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if any member in a: fLeft, fTop, fRight, and fBottom; is not identical to the corresponding member in b.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="struct_sk_i_rect.html">SkIRect</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="struct_sk_i_rect.html">SkIRect</a> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if members are not equal </dd></dl>

</div>
</div>
<a id="a93d568ef8568ca674274d2aeaa2d34be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d568ef8568ca674274d2aeaa2d34be">&#9670;&nbsp;</a></span>operator==</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_sk_i_rect.html">SkIRect</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if all members in a: fLeft, fTop, fRight, and fBottom; are identical to corresponding members in b.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td><a class="el" href="struct_sk_i_rect.html">SkIRect</a> to compare </td></tr>
    <tr><td class="paramname">b</td><td><a class="el" href="struct_sk_i_rect.html">SkIRect</a> to compare </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if members are equal </dd></dl>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/include/core/<a class="el" href="_sk_rect_8h_source.html">SkRect.h</a></li>
<li>C:/Users/fab/src/Github/branches/NeuralAmpModelerPlugin/iPlug2/Dependencies/Build/src/skia/src/core/SkRect.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
