\hypertarget{class_sk_path_priv}{}\doxysection{Sk\+Path\+Priv Class Reference}
\label{class_sk_path_priv}\index{SkPathPriv@{SkPathPriv}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_sk_path_priv_1_1_iterate}{Iterate}}
\item 
struct \mbox{\hyperlink{struct_sk_path_priv_1_1_verbs}{Verbs}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{class_sk_path_priv_afa26be0f27e3bce6b8254c066752e8f6}{Range\+Iter}} = Sk\+Path\+::\+Range\+Iter
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_path_priv_a5ad157a1d82b87f36b0cbc2f4d7cb06f}\label{class_sk_path_priv_a5ad157a1d82b87f36b0cbc2f4d7cb06f}} 
static Sk\+Path\+First\+Direction {\bfseries As\+First\+Direction} (Sk\+Path\+Direction dir)
\item 
static Sk\+Path\+First\+Direction \mbox{\hyperlink{class_sk_path_priv_afdf0ef457f06b1aebcab817440bd4df1}{Opposite\+First\+Direction}} (Sk\+Path\+First\+Direction dir)
\item 
static Sk\+Path\+First\+Direction \mbox{\hyperlink{class_sk_path_priv_a96836104a718378e3dacf0fe2104b7ca}{Compute\+First\+Direction}} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&)
\item 
\mbox{\Hypertarget{class_sk_path_priv_a1e50f3fbf859bd638c86bd595aa6cb71}\label{class_sk_path_priv_a1e50f3fbf859bd638c86bd595aa6cb71}} 
static bool {\bfseries Is\+Closed\+Single\+Contour} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path)
\item 
\mbox{\Hypertarget{class_sk_path_priv_aa8dfcfbf3e3bae96e48a647493cce21d}\label{class_sk_path_priv_aa8dfcfbf3e3bae96e48a647493cce21d}} 
static int {\bfseries Leading\+Move\+To\+Count} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path)
\item 
\mbox{\Hypertarget{class_sk_path_priv_aa99fb56006bade26771f6bd3bf508003}\label{class_sk_path_priv_aa99fb56006bade26771f6bd3bf508003}} 
static void {\bfseries Add\+Gen\+I\+D\+Change\+Listener} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_i_d_change_listener}{Sk\+I\+D\+Change\+Listener}} $>$ listener)
\item 
static bool \mbox{\hyperlink{class_sk_path_priv_a36a7904a1a2d59e5b55a9d24d24d3c09}{Is\+Simple\+Rect}} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path, bool is\+Simple\+Fill, \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} $\ast$rect, Sk\+Path\+Direction $\ast$direction, unsigned $\ast$start)
\item 
static void \mbox{\hyperlink{class_sk_path_priv_af70725b380d7215e207b03cd539bd1ca}{Create\+Draw\+Arc\+Path}} (\mbox{\hyperlink{class_sk_path}{Sk\+Path}} $\ast$path, const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&oval, Sk\+Scalar start\+Angle, Sk\+Scalar sweep\+Angle, bool use\+Center, bool is\+Fill\+No\+Path\+Effect)
\item 
static bool \mbox{\hyperlink{class_sk_path_priv_a3ec211f22e498325683cc91ffd9e6c6c}{Draw\+Arc\+Is\+Convex}} (Sk\+Scalar sweep\+Angle, bool use\+Center, bool is\+Fill\+No\+Path\+Effect)
\item 
\mbox{\Hypertarget{class_sk_path_priv_ab9d353b7262beb1f6d9b56a641390186}\label{class_sk_path_priv_ab9d353b7262beb1f6d9b56a641390186}} 
static void {\bfseries Shrink\+To\+Fit} (\mbox{\hyperlink{class_sk_path}{Sk\+Path}} $\ast$path)
\item 
static const uint8\+\_\+t $\ast$ \mbox{\hyperlink{class_sk_path_priv_ade41289b83382e558bd0cdfe3b823228}{Verb\+Data}} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path)
\item 
static const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} $\ast$ \mbox{\hyperlink{class_sk_path_priv_aa192dbe9c006cee375864cf43ae445e6}{Point\+Data}} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path)
\item 
static int \mbox{\hyperlink{class_sk_path_priv_ae9f7bad945c4cf9639b6aff8faeddb0c}{Conic\+Weight\+Cnt}} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path)
\item 
static const Sk\+Scalar $\ast$ \mbox{\hyperlink{class_sk_path_priv_ac056bd4ac724ac11594c0f177dd1c157}{Conic\+Weight\+Data}} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path)
\item 
static bool \mbox{\hyperlink{class_sk_path_priv_a72cbba2fe0dfba3bf7e1f11ba030be78}{Testing\+Only\+\_\+unique}} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path)
\item 
\mbox{\Hypertarget{class_sk_path_priv_a3cb8b1221033f0fdb7eb01f0f6bfb2f9}\label{class_sk_path_priv_a3cb8b1221033f0fdb7eb01f0f6bfb2f9}} 
static bool {\bfseries Has\+Computed\+Bounds} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path)
\item 
static bool \mbox{\hyperlink{class_sk_path_priv_a4acd5590bff624c7a395b5a30315f78b}{Is\+Oval}} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path, \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} $\ast$rect, Sk\+Path\+Direction $\ast$dir, unsigned $\ast$start)
\item 
static bool \mbox{\hyperlink{class_sk_path_priv_a23daf9e6eb20dcf64629ab6f09e1f5e2}{Is\+R\+Rect}} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path, \mbox{\hyperlink{class_sk_r_rect}{Sk\+R\+Rect}} $\ast$rrect, Sk\+Path\+Direction $\ast$dir, unsigned $\ast$start)
\item 
static bool \mbox{\hyperlink{class_sk_path_priv_ae3c83873b245858ca7263c997e2ba8bc}{Too\+Big\+For\+Math}} (const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&bounds)
\item 
\mbox{\Hypertarget{class_sk_path_priv_a33eff26201c29fb2cbf4287c8eeba5cb}\label{class_sk_path_priv_a33eff26201c29fb2cbf4287c8eeba5cb}} 
static bool {\bfseries Too\+Big\+For\+Math} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path)
\item 
\mbox{\Hypertarget{class_sk_path_priv_a72cb2373bba6415aea961b9b051dd9f6}\label{class_sk_path_priv_a72cb2373bba6415aea961b9b051dd9f6}} 
static int {\bfseries Pts\+In\+Iter} (unsigned verb)
\item 
\mbox{\Hypertarget{class_sk_path_priv_a1275cf6f2a3adbb83ebe1802bd7f345a}\label{class_sk_path_priv_a1275cf6f2a3adbb83ebe1802bd7f345a}} 
static int {\bfseries Pts\+In\+Verb} (unsigned verb)
\item 
\mbox{\Hypertarget{class_sk_path_priv_a66c1b5c1653d2452900c3d17933c6dc0}\label{class_sk_path_priv_a66c1b5c1653d2452900c3d17933c6dc0}} 
static bool {\bfseries Is\+Axis\+Aligned} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path)
\item 
\mbox{\Hypertarget{class_sk_path_priv_ae5ec2cfb13c1e05d6d5b857d1aab1802}\label{class_sk_path_priv_ae5ec2cfb13c1e05d6d5b857d1aab1802}} 
static bool {\bfseries All\+Points\+Eq} (const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} pts\mbox{[}$\,$\mbox{]}, int count)
\item 
\mbox{\Hypertarget{class_sk_path_priv_a2ce9e2c47192be8b878695fdc7a3e609}\label{class_sk_path_priv_a2ce9e2c47192be8b878695fdc7a3e609}} 
static int {\bfseries Last\+Move\+To\+Index} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path)
\item 
\mbox{\Hypertarget{class_sk_path_priv_accf2dcc6d754cc09681043f6e7e569ff}\label{class_sk_path_priv_accf2dcc6d754cc09681043f6e7e569ff}} 
static bool {\bfseries Is\+Rect\+Contour} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&, bool allow\+Partial, int $\ast$curr\+Verb, const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} $\ast$$\ast$pts\+Ptr, bool $\ast$is\+Closed, Sk\+Path\+Direction $\ast$direction, \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} $\ast$rect)
\item 
static bool \mbox{\hyperlink{class_sk_path_priv_a2a549fbe35e86222480c60923ca62cbb}{Is\+Nested\+Fill\+Rects}} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&, \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} rect\mbox{[}2\mbox{]}, Sk\+Path\+Direction dirs\mbox{[}2\mbox{]}=nullptr)
\item 
\mbox{\Hypertarget{class_sk_path_priv_a01869b5b859a66627a22b24c5e93247e}\label{class_sk_path_priv_a01869b5b859a66627a22b24c5e93247e}} 
static bool {\bfseries Is\+Inverse\+Fill\+Type} (Sk\+Path\+Fill\+Type fill)
\item 
static Sk\+Path\+Fill\+Type \mbox{\hyperlink{class_sk_path_priv_afe19af683a863e08642245344eb91a3b}{Convert\+To\+Non\+Inverse\+Fill\+Type}} (Sk\+Path\+Fill\+Type fill)
\item 
static bool \mbox{\hyperlink{class_sk_path_priv_abf5aa5767145821c9bc1283825025eb2}{Perspective\+Clip}} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&src, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} \&, \mbox{\hyperlink{class_sk_path}{Sk\+Path}} $\ast$result)
\item 
static int \mbox{\hyperlink{class_sk_path_priv_a3b2fcd4d3edbeaf7a109d54a521e3f2d}{Gen\+I\+D\+Change\+Listeners\+Count}} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&)
\item 
\mbox{\Hypertarget{class_sk_path_priv_ac1212b1f2ce85ab500494928a15a6196}\label{class_sk_path_priv_ac1212b1f2ce85ab500494928a15a6196}} 
static void {\bfseries Update\+Path\+Point} (\mbox{\hyperlink{class_sk_path}{Sk\+Path}} $\ast$path, int index, const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&pt)
\item 
\mbox{\Hypertarget{class_sk_path_priv_a1e62b5dcffb5898f05128e3ee121981a}\label{class_sk_path_priv_a1e62b5dcffb5898f05128e3ee121981a}} 
static Sk\+Path\+Convexity {\bfseries Get\+Convexity} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path)
\item 
\mbox{\Hypertarget{class_sk_path_priv_ab1d64d898806687435e31943b36f1ea2}\label{class_sk_path_priv_ab1d64d898806687435e31943b36f1ea2}} 
static Sk\+Path\+Convexity {\bfseries Get\+Convexity\+Or\+Unknown} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path)
\item 
\mbox{\Hypertarget{class_sk_path_priv_a3c57dc05f0e59d1e51f062ccd9e2ea1a}\label{class_sk_path_priv_a3c57dc05f0e59d1e51f062ccd9e2ea1a}} 
static void {\bfseries Set\+Convexity} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path, Sk\+Path\+Convexity c)
\item 
\mbox{\Hypertarget{class_sk_path_priv_a3ef59ac91326974d48d4783a64d345c7}\label{class_sk_path_priv_a3ef59ac91326974d48d4783a64d345c7}} 
static void {\bfseries Set\+Convexity} (\mbox{\hyperlink{class_sk_path_builder}{Sk\+Path\+Builder}} $\ast$builder, Sk\+Path\+Convexity c)
\item 
\mbox{\Hypertarget{class_sk_path_priv_a48fad5ed619fa226db240f8d6ab6b9f5}\label{class_sk_path_priv_a48fad5ed619fa226db240f8d6ab6b9f5}} 
static void {\bfseries Force\+Compute\+Convexity} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path)
\item 
\mbox{\Hypertarget{class_sk_path_priv_a75b9b16617ff72649844886c3cee74a5}\label{class_sk_path_priv_a75b9b16617ff72649844886c3cee74a5}} 
static void {\bfseries Reverse\+Add\+Path} (\mbox{\hyperlink{class_sk_path_builder}{Sk\+Path\+Builder}} $\ast$builder, const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&reverse\+Me)
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_path_priv_ab66f8a5e5c762c2a9bac1110e9d06b7f}\label{class_sk_path_priv_ab66f8a5e5c762c2a9bac1110e9d06b7f}} 
static const int {\bfseries k\+Path\+Ref\+Gen\+I\+D\+Bit\+Cnt} = 32
\item 
\mbox{\Hypertarget{class_sk_path_priv_aa90c6a7df1b6378e226afae08133ffa3}\label{class_sk_path_priv_aa90c6a7df1b6378e226afae08133ffa3}} 
static constexpr Sk\+Scalar {\bfseries k\+W0\+Plane\+Distance} = 1.f / (1 $<$$<$ 14)
\end{DoxyCompactItemize}


\doxysubsection{Member Typedef Documentation}
\mbox{\Hypertarget{class_sk_path_priv_afa26be0f27e3bce6b8254c066752e8f6}\label{class_sk_path_priv_afa26be0f27e3bce6b8254c066752e8f6}} 
\index{SkPathPriv@{SkPathPriv}!RangeIter@{RangeIter}}
\index{RangeIter@{RangeIter}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{RangeIter}{RangeIter}}
{\footnotesize\ttfamily using \mbox{\hyperlink{class_sk_path_priv_afa26be0f27e3bce6b8254c066752e8f6}{Sk\+Path\+Priv\+::\+Range\+Iter}} =  Sk\+Path\+::\+Range\+Iter}

Iterates through a raw range of path verbs, points, and conics. All values are returned unaltered.

N\+O\+TE\+: This class\textquotesingle{}s definition will be moved into \mbox{\hyperlink{class_sk_path_priv}{Sk\+Path\+Priv}} once Range\+Iter is removed. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_path_priv_a96836104a718378e3dacf0fe2104b7ca}\label{class_sk_path_priv_a96836104a718378e3dacf0fe2104b7ca}} 
\index{SkPathPriv@{SkPathPriv}!ComputeFirstDirection@{ComputeFirstDirection}}
\index{ComputeFirstDirection@{ComputeFirstDirection}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{ComputeFirstDirection()}{ComputeFirstDirection()}}
{\footnotesize\ttfamily Sk\+Path\+First\+Direction Sk\+Path\+Priv\+::\+Compute\+First\+Direction (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&}]{path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Tries to compute the direction of the outer-\/most non-\/degenerate contour. If it can be computed, return that direction. If it cannot be determined, or the contour is known to be convex, return k\+Unknown. If the direction was determined, it is cached to make subsequent calls return quickly. \mbox{\Hypertarget{class_sk_path_priv_ae9f7bad945c4cf9639b6aff8faeddb0c}\label{class_sk_path_priv_ae9f7bad945c4cf9639b6aff8faeddb0c}} 
\index{SkPathPriv@{SkPathPriv}!ConicWeightCnt@{ConicWeightCnt}}
\index{ConicWeightCnt@{ConicWeightCnt}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{ConicWeightCnt()}{ConicWeightCnt()}}
{\footnotesize\ttfamily static int Sk\+Path\+Priv\+::\+Conic\+Weight\+Cnt (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&}]{path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Returns the number of conic weights in the path \mbox{\Hypertarget{class_sk_path_priv_ac056bd4ac724ac11594c0f177dd1c157}\label{class_sk_path_priv_ac056bd4ac724ac11594c0f177dd1c157}} 
\index{SkPathPriv@{SkPathPriv}!ConicWeightData@{ConicWeightData}}
\index{ConicWeightData@{ConicWeightData}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{ConicWeightData()}{ConicWeightData()}}
{\footnotesize\ttfamily static const Sk\+Scalar$\ast$ Sk\+Path\+Priv\+::\+Conic\+Weight\+Data (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&}]{path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Returns a raw pointer to the path conic weights. \mbox{\Hypertarget{class_sk_path_priv_afe19af683a863e08642245344eb91a3b}\label{class_sk_path_priv_afe19af683a863e08642245344eb91a3b}} 
\index{SkPathPriv@{SkPathPriv}!ConvertToNonInverseFillType@{ConvertToNonInverseFillType}}
\index{ConvertToNonInverseFillType@{ConvertToNonInverseFillType}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{ConvertToNonInverseFillType()}{ConvertToNonInverseFillType()}}
{\footnotesize\ttfamily static Sk\+Path\+Fill\+Type Sk\+Path\+Priv\+::\+Convert\+To\+Non\+Inverse\+Fill\+Type (\begin{DoxyParamCaption}\item[{Sk\+Path\+Fill\+Type}]{fill }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Returns equivalent Sk\+Path\+::\+Fill\+Type representing \mbox{\hyperlink{class_sk_path}{Sk\+Path}} fill inside its bounds. 
\begin{DoxyParams}{Parameters}
{\em fill} & one of\+: k\+Winding\+\_\+\+Fill\+Type, k\+Even\+Odd\+\_\+\+Fill\+Type, k\+Inverse\+Winding\+\_\+\+Fill\+Type, k\+Inverse\+Even\+Odd\+\_\+\+Fill\+Type \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
fill, or k\+Winding\+\_\+\+Fill\+Type or k\+Even\+Odd\+\_\+\+Fill\+Type if fill is inverted 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_path_priv_af70725b380d7215e207b03cd539bd1ca}\label{class_sk_path_priv_af70725b380d7215e207b03cd539bd1ca}} 
\index{SkPathPriv@{SkPathPriv}!CreateDrawArcPath@{CreateDrawArcPath}}
\index{CreateDrawArcPath@{CreateDrawArcPath}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{CreateDrawArcPath()}{CreateDrawArcPath()}}
{\footnotesize\ttfamily void Sk\+Path\+Priv\+::\+Create\+Draw\+Arc\+Path (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_path}{Sk\+Path}} $\ast$}]{path,  }\item[{const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&}]{oval,  }\item[{Sk\+Scalar}]{start\+Angle,  }\item[{Sk\+Scalar}]{sweep\+Angle,  }\item[{bool}]{use\+Center,  }\item[{bool}]{is\+Fill\+No\+Path\+Effect }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Creates a path from arc params using the semantics of \mbox{\hyperlink{class_sk_canvas_ab7d43d64e7e6d756e60a6d42f3dc472d}{Sk\+Canvas\+::draw\+Arc}}. This function assumes empty ovals and zero sweeps have already been filtered out. \mbox{\Hypertarget{class_sk_path_priv_a3ec211f22e498325683cc91ffd9e6c6c}\label{class_sk_path_priv_a3ec211f22e498325683cc91ffd9e6c6c}} 
\index{SkPathPriv@{SkPathPriv}!DrawArcIsConvex@{DrawArcIsConvex}}
\index{DrawArcIsConvex@{DrawArcIsConvex}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{DrawArcIsConvex()}{DrawArcIsConvex()}}
{\footnotesize\ttfamily bool Sk\+Path\+Priv\+::\+Draw\+Arc\+Is\+Convex (\begin{DoxyParamCaption}\item[{Sk\+Scalar}]{sweep\+Angle,  }\item[{bool}]{use\+Center,  }\item[{bool}]{is\+Fill\+No\+Path\+Effect }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Determines whether an arc produced by Create\+Draw\+Arc\+Path will be convex. Assumes a non-\/empty oval. \mbox{\Hypertarget{class_sk_path_priv_a3b2fcd4d3edbeaf7a109d54a521e3f2d}\label{class_sk_path_priv_a3b2fcd4d3edbeaf7a109d54a521e3f2d}} 
\index{SkPathPriv@{SkPathPriv}!GenIDChangeListenersCount@{GenIDChangeListenersCount}}
\index{GenIDChangeListenersCount@{GenIDChangeListenersCount}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{GenIDChangeListenersCount()}{GenIDChangeListenersCount()}}
{\footnotesize\ttfamily int Sk\+Path\+Priv\+::\+Gen\+I\+D\+Change\+Listeners\+Count (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&}]{path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Gets the number of Gen\+I\+D\+Change\+Listeners. If another thread has access to this path then this may be stale before return and only indicates that the count was the return value at some point during the execution of the function. \mbox{\Hypertarget{class_sk_path_priv_a2a549fbe35e86222480c60923ca62cbb}\label{class_sk_path_priv_a2a549fbe35e86222480c60923ca62cbb}} 
\index{SkPathPriv@{SkPathPriv}!IsNestedFillRects@{IsNestedFillRects}}
\index{IsNestedFillRects@{IsNestedFillRects}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{IsNestedFillRects()}{IsNestedFillRects()}}
{\footnotesize\ttfamily bool Sk\+Path\+Priv\+::\+Is\+Nested\+Fill\+Rects (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&}]{path,  }\item[{\mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}}}]{rect\mbox{[}2\mbox{]},  }\item[{Sk\+Path\+Direction}]{dirs\mbox{[}2\mbox{]} = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns true if \mbox{\hyperlink{class_sk_path}{Sk\+Path}} is equivalent to nested \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} pair when filled. If false, rect and dirs are unchanged. If true, rect and dirs are written to if not nullptr\+: setting rect\mbox{[}0\mbox{]} to outer \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}}, and rect\mbox{[}1\mbox{]} to inner \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}}; setting dirs\mbox{[}0\mbox{]} to Sk\+Path\+Direction of outer \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}}, and dirs\mbox{[}1\mbox{]} to Sk\+Path\+Direction of inner \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}}.


\begin{DoxyParams}{Parameters}
{\em rect} & storage for \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} pair; may be nullptr \\
\hline
{\em dirs} & storage for Sk\+Path\+Direction pair; may be nullptr \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if \mbox{\hyperlink{class_sk_path}{Sk\+Path}} contains nested \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} pair 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_path_priv_a4acd5590bff624c7a395b5a30315f78b}\label{class_sk_path_priv_a4acd5590bff624c7a395b5a30315f78b}} 
\index{SkPathPriv@{SkPathPriv}!IsOval@{IsOval}}
\index{IsOval@{IsOval}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{IsOval()}{IsOval()}}
{\footnotesize\ttfamily static bool Sk\+Path\+Priv\+::\+Is\+Oval (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&}]{path,  }\item[{\mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} $\ast$}]{rect,  }\item[{Sk\+Path\+Direction $\ast$}]{dir,  }\item[{unsigned $\ast$}]{start }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Returns true if constructed by add\+Circle(), add\+Oval(); and in some cases, add\+Round\+Rect(), add\+R\+Rect(). \mbox{\hyperlink{class_sk_path}{Sk\+Path}} constructed with conic\+To() or r\+Conic\+To() will not return true though \mbox{\hyperlink{class_sk_path}{Sk\+Path}} draws oval.

rect receives bounds of oval. dir receives Sk\+Path\+Direction of oval\+: k\+C\+W\+\_\+\+Direction if clockwise, k\+C\+C\+W\+\_\+\+Direction if counterclockwise. start receives start of oval\+: 0 for top, 1 for right, 2 for bottom, 3 for left.

rect, dir, and start are unmodified if oval is not found.

Triggers performance optimizations on some G\+PU surface implementations.


\begin{DoxyParams}{Parameters}
{\em rect} & storage for bounding \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} of oval; may be nullptr \\
\hline
{\em dir} & storage for Sk\+Path\+Direction; may be nullptr \\
\hline
{\em start} & storage for start of oval; may be nullptr \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if \mbox{\hyperlink{class_sk_path}{Sk\+Path}} was constructed by method that reduces to oval 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_path_priv_a23daf9e6eb20dcf64629ab6f09e1f5e2}\label{class_sk_path_priv_a23daf9e6eb20dcf64629ab6f09e1f5e2}} 
\index{SkPathPriv@{SkPathPriv}!IsRRect@{IsRRect}}
\index{IsRRect@{IsRRect}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{IsRRect()}{IsRRect()}}
{\footnotesize\ttfamily static bool Sk\+Path\+Priv\+::\+Is\+R\+Rect (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&}]{path,  }\item[{\mbox{\hyperlink{class_sk_r_rect}{Sk\+R\+Rect}} $\ast$}]{rrect,  }\item[{Sk\+Path\+Direction $\ast$}]{dir,  }\item[{unsigned $\ast$}]{start }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Returns true if constructed by add\+Round\+Rect(), add\+R\+Rect(); and if construction is not empty, not \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}}, and not oval. \mbox{\hyperlink{class_sk_path}{Sk\+Path}} constructed with other calls will not return true though \mbox{\hyperlink{class_sk_path}{Sk\+Path}} draws \mbox{\hyperlink{class_sk_r_rect}{Sk\+R\+Rect}}.

rrect receives bounds of \mbox{\hyperlink{class_sk_r_rect}{Sk\+R\+Rect}}. dir receives Sk\+Path\+Direction of oval\+: k\+C\+W\+\_\+\+Direction if clockwise, k\+C\+C\+W\+\_\+\+Direction if counterclockwise. start receives start of \mbox{\hyperlink{class_sk_r_rect}{Sk\+R\+Rect}}\+: 0 for top, 1 for right, 2 for bottom, 3 for left.

rrect, dir, and start are unmodified if \mbox{\hyperlink{class_sk_r_rect}{Sk\+R\+Rect}} is not found.

Triggers performance optimizations on some G\+PU surface implementations.


\begin{DoxyParams}{Parameters}
{\em rrect} & storage for bounding \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} of \mbox{\hyperlink{class_sk_r_rect}{Sk\+R\+Rect}}; may be nullptr \\
\hline
{\em dir} & storage for Sk\+Path\+Direction; may be nullptr \\
\hline
{\em start} & storage for start of \mbox{\hyperlink{class_sk_r_rect}{Sk\+R\+Rect}}; may be nullptr \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if \mbox{\hyperlink{class_sk_path}{Sk\+Path}} contains only \mbox{\hyperlink{class_sk_r_rect}{Sk\+R\+Rect}} 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_path_priv_a36a7904a1a2d59e5b55a9d24d24d3c09}\label{class_sk_path_priv_a36a7904a1a2d59e5b55a9d24d24d3c09}} 
\index{SkPathPriv@{SkPathPriv}!IsSimpleRect@{IsSimpleRect}}
\index{IsSimpleRect@{IsSimpleRect}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{IsSimpleRect()}{IsSimpleRect()}}
{\footnotesize\ttfamily bool Sk\+Path\+Priv\+::\+Is\+Simple\+Rect (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&}]{path,  }\item[{bool}]{is\+Simple\+Fill,  }\item[{\mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} $\ast$}]{rect,  }\item[{Sk\+Path\+Direction $\ast$}]{direction,  }\item[{unsigned $\ast$}]{start }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This returns true for a rect that has a move followed by 3 or 4 lines and a close. If \textquotesingle{}is\+Simple\+Fill\textquotesingle{} is true, an uncloseed rect will also be accepted as long as it starts and ends at the same corner. This does not permit degenerate line or point rectangles. \mbox{\Hypertarget{class_sk_path_priv_afdf0ef457f06b1aebcab817440bd4df1}\label{class_sk_path_priv_afdf0ef457f06b1aebcab817440bd4df1}} 
\index{SkPathPriv@{SkPathPriv}!OppositeFirstDirection@{OppositeFirstDirection}}
\index{OppositeFirstDirection@{OppositeFirstDirection}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{OppositeFirstDirection()}{OppositeFirstDirection()}}
{\footnotesize\ttfamily static Sk\+Path\+First\+Direction Sk\+Path\+Priv\+::\+Opposite\+First\+Direction (\begin{DoxyParamCaption}\item[{Sk\+Path\+First\+Direction}]{dir }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Return the opposite of the specified direction. k\+Unknown is its own opposite. \mbox{\Hypertarget{class_sk_path_priv_abf5aa5767145821c9bc1283825025eb2}\label{class_sk_path_priv_abf5aa5767145821c9bc1283825025eb2}} 
\index{SkPathPriv@{SkPathPriv}!PerspectiveClip@{PerspectiveClip}}
\index{PerspectiveClip@{PerspectiveClip}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{PerspectiveClip()}{PerspectiveClip()}}
{\footnotesize\ttfamily bool Sk\+Path\+Priv\+::\+Perspective\+Clip (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&}]{src,  }\item[{const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} \&}]{matrix,  }\item[{\mbox{\hyperlink{class_sk_path}{Sk\+Path}} $\ast$}]{result }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

If needed (to not blow-\/up under a perspective matrix), clip the path, returning the answer in \char`\"{}result\char`\"{}, and return true.

Note result might be empty (if the path was completely clipped out).

If no clipping is needed, returns false and \char`\"{}result\char`\"{} is left unchanged. \mbox{\Hypertarget{class_sk_path_priv_aa192dbe9c006cee375864cf43ae445e6}\label{class_sk_path_priv_aa192dbe9c006cee375864cf43ae445e6}} 
\index{SkPathPriv@{SkPathPriv}!PointData@{PointData}}
\index{PointData@{PointData}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{PointData()}{PointData()}}
{\footnotesize\ttfamily static const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}}$\ast$ Sk\+Path\+Priv\+::\+Point\+Data (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&}]{path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Returns a raw pointer to the path points \mbox{\Hypertarget{class_sk_path_priv_a72cbba2fe0dfba3bf7e1f11ba030be78}\label{class_sk_path_priv_a72cbba2fe0dfba3bf7e1f11ba030be78}} 
\index{SkPathPriv@{SkPathPriv}!TestingOnly\_unique@{TestingOnly\_unique}}
\index{TestingOnly\_unique@{TestingOnly\_unique}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{TestingOnly\_unique()}{TestingOnly\_unique()}}
{\footnotesize\ttfamily static bool Sk\+Path\+Priv\+::\+Testing\+Only\+\_\+unique (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&}]{path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Returns true if the underlying \mbox{\hyperlink{class_sk_path_ref}{Sk\+Path\+Ref}} has one single owner. \mbox{\Hypertarget{class_sk_path_priv_ae3c83873b245858ca7263c997e2ba8bc}\label{class_sk_path_priv_ae3c83873b245858ca7263c997e2ba8bc}} 
\index{SkPathPriv@{SkPathPriv}!TooBigForMath@{TooBigForMath}}
\index{TooBigForMath@{TooBigForMath}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{TooBigForMath()}{TooBigForMath()}}
{\footnotesize\ttfamily static bool Sk\+Path\+Priv\+::\+Too\+Big\+For\+Math (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&}]{bounds }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Sometimes in the drawing pipeline, we have to perform math on path coordinates, even after the path is in device-\/coordinates. Tessellation and clipping are two examples. Usually this is pretty modest, but it can involve subtracting/adding coordinates, or multiplying by small constants (e.\+g. 2,3,4). To try to preflight issues where these optionations could turn finite path values into infinities (or Na\+Ns), we allow the upper drawing code to reject the path if its bounds (in device coordinates) is too close to max float. \mbox{\Hypertarget{class_sk_path_priv_ade41289b83382e558bd0cdfe3b823228}\label{class_sk_path_priv_ade41289b83382e558bd0cdfe3b823228}} 
\index{SkPathPriv@{SkPathPriv}!VerbData@{VerbData}}
\index{VerbData@{VerbData}!SkPathPriv@{SkPathPriv}}
\doxysubsubsection{\texorpdfstring{VerbData()}{VerbData()}}
{\footnotesize\ttfamily static const uint8\+\_\+t$\ast$ Sk\+Path\+Priv\+::\+Verb\+Data (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&}]{path }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Returns a pointer to the verb data. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Path\+Priv.\+h\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Path.\+cpp\end{DoxyCompactItemize}
