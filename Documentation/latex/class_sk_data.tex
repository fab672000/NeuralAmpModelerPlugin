\hypertarget{class_sk_data}{}\doxysection{Sk\+Data Class Reference}
\label{class_sk_data}\index{SkData@{SkData}}


{\ttfamily \#include $<$Sk\+Data.\+h$>$}

Inheritance diagram for Sk\+Data\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_sk_data}
\end{center}
\end{figure}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
typedef void($\ast$ \mbox{\hyperlink{class_sk_data_a31c328f384cf55f14cee22dd7c554f8b}{Release\+Proc}}) (const void $\ast$ptr, void $\ast$context)
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
size\+\_\+t \mbox{\hyperlink{class_sk_data_af0a8942d7354681e7b464eb08c2175dd}{size}} () const
\item 
\mbox{\Hypertarget{class_sk_data_af337786927fd597f027175516c953a5c}\label{class_sk_data_af337786927fd597f027175516c953a5c}} 
bool {\bfseries is\+Empty} () const
\item 
const void $\ast$ \mbox{\hyperlink{class_sk_data_a8d5ba46dccd5d65a464d8118974a21a8}{data}} () const
\item 
const uint8\+\_\+t $\ast$ \mbox{\hyperlink{class_sk_data_adcc1e2dd78bb42b8950f90c7ad73ea6f}{bytes}} () const
\item 
void $\ast$ \mbox{\hyperlink{class_sk_data_ad52c15d46ad1022b97e9bc6798aadfd4}{writable\+\_\+data}} ()
\item 
size\+\_\+t \mbox{\hyperlink{class_sk_data_a242136fd8363522ff4cef7bc668047bf}{copy\+Range}} (size\+\_\+t offset, size\+\_\+t length, void $\ast$\mbox{\hyperlink{structbuffer}{buffer}}) const
\item 
bool \mbox{\hyperlink{class_sk_data_a3e2be64efdc9654eca5ab5488fec6f5e}{equals}} (const \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $\ast$other) const
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ \mbox{\hyperlink{class_sk_data_aaa84b14c6b74e3f707f37ab1487fc88e}{Make\+With\+Copy}} (const void $\ast$\mbox{\hyperlink{class_sk_data_a8d5ba46dccd5d65a464d8118974a21a8}{data}}, size\+\_\+t length)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ \mbox{\hyperlink{class_sk_data_a3b05487231e2da5dc8bbaf14a732b460}{Make\+Uninitialized}} (size\+\_\+t length)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ \mbox{\hyperlink{class_sk_data_a7f8ba6391c395e940697a74e71ef6814}{Make\+With\+C\+String}} (const char cstr\mbox{[}$\,$\mbox{]})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ \mbox{\hyperlink{class_sk_data_a932340206a27ea58ce2d5342aa68f5da}{Make\+With\+Proc}} (const void $\ast$ptr, size\+\_\+t length, \mbox{\hyperlink{class_sk_data_a31c328f384cf55f14cee22dd7c554f8b}{Release\+Proc}} proc, void $\ast$ctx)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ \mbox{\hyperlink{class_sk_data_a6d92a0c08dcf6ea12f18daa549daf774}{Make\+Without\+Copy}} (const void $\ast$\mbox{\hyperlink{class_sk_data_a8d5ba46dccd5d65a464d8118974a21a8}{data}}, size\+\_\+t length)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ \mbox{\hyperlink{class_sk_data_a24bb5637f48fbf0d502b4dd9e53f58a9}{Make\+From\+Malloc}} (const void $\ast$\mbox{\hyperlink{class_sk_data_a8d5ba46dccd5d65a464d8118974a21a8}{data}}, size\+\_\+t length)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ \mbox{\hyperlink{class_sk_data_ae03a3bee58352e734963b220f5d8b389}{Make\+From\+File\+Name}} (const char path\mbox{[}$\,$\mbox{]})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ \mbox{\hyperlink{class_sk_data_a9dd11b6db9baa02555b59bf0baa34484}{Make\+From\+F\+I\+LE}} (F\+I\+LE $\ast$f)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ \mbox{\hyperlink{class_sk_data_a827e71e03fb8cc50d606424c6dae1f9d}{Make\+From\+FD}} (int fd)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ \mbox{\hyperlink{class_sk_data_ac3d9cd0aef39574f1d95afd8c71dfe3b}{Make\+From\+Stream}} (\mbox{\hyperlink{class_sk_stream}{Sk\+Stream}} $\ast$, size\+\_\+t \mbox{\hyperlink{class_sk_data_af0a8942d7354681e7b464eb08c2175dd}{size}})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ \mbox{\hyperlink{class_sk_data_aaf99667744456ad53358ed2ccef2e84f}{Make\+Subset}} (const \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $\ast$src, size\+\_\+t offset, size\+\_\+t length)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ \mbox{\hyperlink{class_sk_data_ad33f05448cdc8c748c8b82e308cf59e6}{Make\+Empty}} ()
\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_data_a31ec01a9651a78d2e9fe229e6aaae630}\label{class_sk_data_a31ec01a9651a78d2e9fe229e6aaae630}} 
class {\bfseries Sk\+N\+V\+Ref\+Cnt$<$ Sk\+Data $>$}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\mbox{\hyperlink{class_sk_data}{Sk\+Data}} holds an immutable data buffer. Not only is the data immutable, but the actual ptr that is returned (by \mbox{\hyperlink{class_sk_data_a8d5ba46dccd5d65a464d8118974a21a8}{data()}} or \mbox{\hyperlink{class_sk_data_adcc1e2dd78bb42b8950f90c7ad73ea6f}{bytes()}}) is guaranteed to always be the same for the life of this instance. 

\doxysubsection{Member Typedef Documentation}
\mbox{\Hypertarget{class_sk_data_a31c328f384cf55f14cee22dd7c554f8b}\label{class_sk_data_a31c328f384cf55f14cee22dd7c554f8b}} 
\index{SkData@{SkData}!ReleaseProc@{ReleaseProc}}
\index{ReleaseProc@{ReleaseProc}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{ReleaseProc}{ReleaseProc}}
{\footnotesize\ttfamily typedef void($\ast$ Sk\+Data\+::\+Release\+Proc) (const void $\ast$ptr, void $\ast$context)}

Function that, if provided, will be called when the \mbox{\hyperlink{class_sk_data}{Sk\+Data}} goes out of scope, allowing for custom allocation/freeing of the data\textquotesingle{}s contents. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_data_adcc1e2dd78bb42b8950f90c7ad73ea6f}\label{class_sk_data_adcc1e2dd78bb42b8950f90c7ad73ea6f}} 
\index{SkData@{SkData}!bytes@{bytes}}
\index{bytes@{bytes}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{bytes()}{bytes()}}
{\footnotesize\ttfamily const uint8\+\_\+t$\ast$ Sk\+Data\+::bytes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Like \mbox{\hyperlink{class_sk_data_a8d5ba46dccd5d65a464d8118974a21a8}{data()}}, returns a read-\/only ptr into the data, but in this case it is cast to uint8\+\_\+t$\ast$, to make it easy to add an offset to it. \mbox{\Hypertarget{class_sk_data_a242136fd8363522ff4cef7bc668047bf}\label{class_sk_data_a242136fd8363522ff4cef7bc668047bf}} 
\index{SkData@{SkData}!copyRange@{copyRange}}
\index{copyRange@{copyRange}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{copyRange()}{copyRange()}}
{\footnotesize\ttfamily size\+\_\+t Sk\+Data\+::copy\+Range (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{offset,  }\item[{size\+\_\+t}]{length,  }\item[{void $\ast$}]{buffer }\end{DoxyParamCaption}) const}

Helper to copy a range of the data into a caller-\/provided buffer. Returns the actual number of bytes copied, after clamping offset and length to the size of the data. If buffer is N\+U\+LL, it is ignored, and only the computed number of bytes is returned. \mbox{\Hypertarget{class_sk_data_a8d5ba46dccd5d65a464d8118974a21a8}\label{class_sk_data_a8d5ba46dccd5d65a464d8118974a21a8}} 
\index{SkData@{SkData}!data@{data}}
\index{data@{data}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{data()}{data()}}
{\footnotesize\ttfamily const void$\ast$ Sk\+Data\+::data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the ptr to the data. \mbox{\Hypertarget{class_sk_data_a3e2be64efdc9654eca5ab5488fec6f5e}\label{class_sk_data_a3e2be64efdc9654eca5ab5488fec6f5e}} 
\index{SkData@{SkData}!equals@{equals}}
\index{equals@{equals}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{equals()}{equals()}}
{\footnotesize\ttfamily bool Sk\+Data\+::equals (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $\ast$}]{other }\end{DoxyParamCaption}) const}

Returns true if these two objects have the same length and contents, effectively returning 0 == memcmp(...) \mbox{\Hypertarget{class_sk_data_ad33f05448cdc8c748c8b82e308cf59e6}\label{class_sk_data_ad33f05448cdc8c748c8b82e308cf59e6}} 
\index{SkData@{SkData}!MakeEmpty@{MakeEmpty}}
\index{MakeEmpty@{MakeEmpty}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{MakeEmpty()}{MakeEmpty()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ Sk\+Data\+::\+Make\+Empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns a new empty dataref (or a reference to a shared empty dataref). New or shared, the caller must see that unref() is eventually called. \mbox{\Hypertarget{class_sk_data_a827e71e03fb8cc50d606424c6dae1f9d}\label{class_sk_data_a827e71e03fb8cc50d606424c6dae1f9d}} 
\index{SkData@{SkData}!MakeFromFD@{MakeFromFD}}
\index{MakeFromFD@{MakeFromFD}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{MakeFromFD()}{MakeFromFD()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ Sk\+Data\+::\+Make\+From\+FD (\begin{DoxyParamCaption}\item[{int}]{fd }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a new dataref from a file descriptor. This does not take ownership of the file descriptor, nor close it. The caller is free to close the file descriptor at its convenience. The file descriptor must be open for reading only. Returns N\+U\+LL on failure. \mbox{\Hypertarget{class_sk_data_a9dd11b6db9baa02555b59bf0baa34484}\label{class_sk_data_a9dd11b6db9baa02555b59bf0baa34484}} 
\index{SkData@{SkData}!MakeFromFILE@{MakeFromFILE}}
\index{MakeFromFILE@{MakeFromFILE}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{MakeFromFILE()}{MakeFromFILE()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ Sk\+Data\+::\+Make\+From\+F\+I\+LE (\begin{DoxyParamCaption}\item[{F\+I\+LE $\ast$}]{f }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a new dataref from a stdio F\+I\+LE. This does not take ownership of the F\+I\+LE, nor close it. The caller is free to close the F\+I\+LE at its convenience. The F\+I\+LE must be open for reading only. Returns N\+U\+LL on failure. \mbox{\Hypertarget{class_sk_data_ae03a3bee58352e734963b220f5d8b389}\label{class_sk_data_ae03a3bee58352e734963b220f5d8b389}} 
\index{SkData@{SkData}!MakeFromFileName@{MakeFromFileName}}
\index{MakeFromFileName@{MakeFromFileName}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{MakeFromFileName()}{MakeFromFileName()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ Sk\+Data\+::\+Make\+From\+File\+Name (\begin{DoxyParamCaption}\item[{const char}]{path\mbox{[}$\,$\mbox{]} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a new dataref the file with the specified path. If the file cannot be opened, this returns N\+U\+LL. \mbox{\Hypertarget{class_sk_data_a24bb5637f48fbf0d502b4dd9e53f58a9}\label{class_sk_data_a24bb5637f48fbf0d502b4dd9e53f58a9}} 
\index{SkData@{SkData}!MakeFromMalloc@{MakeFromMalloc}}
\index{MakeFromMalloc@{MakeFromMalloc}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{MakeFromMalloc()}{MakeFromMalloc()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ Sk\+Data\+::\+Make\+From\+Malloc (\begin{DoxyParamCaption}\item[{const void $\ast$}]{data,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a new dataref from a pointer allocated by malloc. The Data object takes ownership of that allocation, and will handling calling sk\+\_\+free. \mbox{\Hypertarget{class_sk_data_ac3d9cd0aef39574f1d95afd8c71dfe3b}\label{class_sk_data_ac3d9cd0aef39574f1d95afd8c71dfe3b}} 
\index{SkData@{SkData}!MakeFromStream@{MakeFromStream}}
\index{MakeFromStream@{MakeFromStream}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{MakeFromStream()}{MakeFromStream()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ Sk\+Data\+::\+Make\+From\+Stream (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_stream}{Sk\+Stream}} $\ast$}]{stream,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Attempt to read size bytes into a \mbox{\hyperlink{class_sk_data}{Sk\+Data}}. If the read succeeds, return the data, else return N\+U\+LL. Either way the stream\textquotesingle{}s cursor may have been changed as a result of calling read(). \mbox{\Hypertarget{class_sk_data_aaf99667744456ad53358ed2ccef2e84f}\label{class_sk_data_aaf99667744456ad53358ed2ccef2e84f}} 
\index{SkData@{SkData}!MakeSubset@{MakeSubset}}
\index{MakeSubset@{MakeSubset}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{MakeSubset()}{MakeSubset()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ Sk\+Data\+::\+Make\+Subset (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $\ast$}]{src,  }\item[{size\+\_\+t}]{offset,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a new dataref using a subset of the data in the specified src dataref. \mbox{\Hypertarget{class_sk_data_a3b05487231e2da5dc8bbaf14a732b460}\label{class_sk_data_a3b05487231e2da5dc8bbaf14a732b460}} 
\index{SkData@{SkData}!MakeUninitialized@{MakeUninitialized}}
\index{MakeUninitialized@{MakeUninitialized}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{MakeUninitialized()}{MakeUninitialized()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ Sk\+Data\+::\+Make\+Uninitialized (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a new data with uninitialized contents. The caller should call \mbox{\hyperlink{class_sk_data_ad52c15d46ad1022b97e9bc6798aadfd4}{writable\+\_\+data()}} to write into the buffer, but this must be done before another ref() is made. \mbox{\Hypertarget{class_sk_data_aaa84b14c6b74e3f707f37ab1487fc88e}\label{class_sk_data_aaa84b14c6b74e3f707f37ab1487fc88e}} 
\index{SkData@{SkData}!MakeWithCopy@{MakeWithCopy}}
\index{MakeWithCopy@{MakeWithCopy}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{MakeWithCopy()}{MakeWithCopy()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ Sk\+Data\+::\+Make\+With\+Copy (\begin{DoxyParamCaption}\item[{const void $\ast$}]{data,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a new dataref by copying the specified data \mbox{\Hypertarget{class_sk_data_a7f8ba6391c395e940697a74e71ef6814}\label{class_sk_data_a7f8ba6391c395e940697a74e71ef6814}} 
\index{SkData@{SkData}!MakeWithCString@{MakeWithCString}}
\index{MakeWithCString@{MakeWithCString}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{MakeWithCString()}{MakeWithCString()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ Sk\+Data\+::\+Make\+With\+C\+String (\begin{DoxyParamCaption}\item[{const char}]{cstr\mbox{[}$\,$\mbox{]} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a new dataref by copying the specified c-\/string (a null-\/terminated array of bytes). The returned \mbox{\hyperlink{class_sk_data}{Sk\+Data}} will have \mbox{\hyperlink{class_sk_data_af0a8942d7354681e7b464eb08c2175dd}{size()}} equal to strlen(cstr) + 1. If cstr is N\+U\+LL, it will be treated the same as \char`\"{}\char`\"{}. \mbox{\Hypertarget{class_sk_data_a6d92a0c08dcf6ea12f18daa549daf774}\label{class_sk_data_a6d92a0c08dcf6ea12f18daa549daf774}} 
\index{SkData@{SkData}!MakeWithoutCopy@{MakeWithoutCopy}}
\index{MakeWithoutCopy@{MakeWithoutCopy}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{MakeWithoutCopy()}{MakeWithoutCopy()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_data}{Sk\+Data}}$>$ Sk\+Data\+::\+Make\+Without\+Copy (\begin{DoxyParamCaption}\item[{const void $\ast$}]{data,  }\item[{size\+\_\+t}]{length }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Call this when the data parameter is already const and will outlive the lifetime of the \mbox{\hyperlink{class_sk_data}{Sk\+Data}}. Suitable for with const globals. \mbox{\Hypertarget{class_sk_data_a932340206a27ea58ce2d5342aa68f5da}\label{class_sk_data_a932340206a27ea58ce2d5342aa68f5da}} 
\index{SkData@{SkData}!MakeWithProc@{MakeWithProc}}
\index{MakeWithProc@{MakeWithProc}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{MakeWithProc()}{MakeWithProc()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ Sk\+Data\+::\+Make\+With\+Proc (\begin{DoxyParamCaption}\item[{const void $\ast$}]{ptr,  }\item[{size\+\_\+t}]{length,  }\item[{\mbox{\hyperlink{class_sk_data_a31c328f384cf55f14cee22dd7c554f8b}{Release\+Proc}}}]{proc,  }\item[{void $\ast$}]{ctx }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a new dataref, taking the ptr as is, and using the releaseproc to free it. The proc may be N\+U\+LL. \mbox{\Hypertarget{class_sk_data_af0a8942d7354681e7b464eb08c2175dd}\label{class_sk_data_af0a8942d7354681e7b464eb08c2175dd}} 
\index{SkData@{SkData}!size@{size}}
\index{size@{size}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{size()}{size()}}
{\footnotesize\ttfamily size\+\_\+t Sk\+Data\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the number of bytes stored. \mbox{\Hypertarget{class_sk_data_ad52c15d46ad1022b97e9bc6798aadfd4}\label{class_sk_data_ad52c15d46ad1022b97e9bc6798aadfd4}} 
\index{SkData@{SkData}!writable\_data@{writable\_data}}
\index{writable\_data@{writable\_data}!SkData@{SkData}}
\doxysubsubsection{\texorpdfstring{writable\_data()}{writable\_data()}}
{\footnotesize\ttfamily void$\ast$ Sk\+Data\+::writable\+\_\+data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

U\+SE W\+I\+TH C\+A\+U\+T\+I\+ON. This call will assert that the refcnt is 1, as a precaution against modifying the contents when another client/thread has access to the data. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/include/core/Sk\+Data.\+h\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Data.\+cpp\end{DoxyCompactItemize}
