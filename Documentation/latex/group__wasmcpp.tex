\hypertarget{group__wasmcpp}{}\doxysection{C++ interface for compiling Faust code. Note that the A\+PI is not thread safe.}
\label{group__wasmcpp}\index{C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classwasm__dsp}{wasm\+\_\+dsp}}
\item 
class \mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \mbox{\hyperlink{group__wasmcpp_ga4dc6a8a1408922d179a375f4625c9411}{get\+C\+Lib\+Faust\+Version}} ()
\item 
\mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}} $\ast$ \mbox{\hyperlink{group__wasmcpp_gaf2df449aec7caf2e0fa6dc31210812e2}{get\+Wasm\+D\+S\+P\+Factory\+From\+S\+H\+A\+Key}} (const std\+::string \&sha\+\_\+key)
\item 
\mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}} $\ast$ \mbox{\hyperlink{group__wasmcpp_ga15b752592bf7e0454942ea08677d6b3f}{create\+Wasm\+D\+S\+P\+Factory\+From\+File}} (const std\+::string \&filename, int argc, const char $\ast$argv\mbox{[}$\,$\mbox{]}, std\+::string \&error\+\_\+msg, bool internal\+\_\+memory)
\item 
\mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}} $\ast$ \mbox{\hyperlink{group__wasmcpp_ga0c695229873a4737092b67d67255781f}{create\+Wasm\+D\+S\+P\+Factory\+From\+String}} (const std\+::string \&name\+\_\+app, const std\+::string \&dsp\+\_\+content, int argc, const char $\ast$argv\mbox{[}$\,$\mbox{]}, std\+::string \&error\+\_\+msg, bool internal\+\_\+memory)
\item 
bool \mbox{\hyperlink{group__wasmcpp_ga9013d991d2c824bc98bc66ddcc573df5}{delete\+Wasm\+D\+S\+P\+Factory}} (\mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}} $\ast$factory)
\item 
void \mbox{\hyperlink{group__wasmcpp_ga43ecfe639299646685cf2b54c3ea0925}{delete\+All\+Wasm\+D\+S\+P\+Factories}} ()
\item 
std\+::vector$<$ std\+::string $>$ \mbox{\hyperlink{group__wasmcpp_ga8cdda7a1df2ea35d7ae37a5019065cdc}{get\+All\+Wasm\+D\+S\+P\+Factories}} ()
\item 
\mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}} $\ast$ \mbox{\hyperlink{group__wasmcpp_gae1a7c9e95327c9995df00028977f96f9}{read\+Wasm\+D\+S\+P\+Factory\+From\+Machine}} (const std\+::string \&machine\+\_\+code, std\+::string \&error\+\_\+msg)
\item 
std\+::string \mbox{\hyperlink{group__wasmcpp_ga4cf138ebd999e677397fa1b30b5fc7d3}{write\+Wasm\+D\+S\+P\+Factory\+To\+Machine}} (\mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}} $\ast$factory)
\item 
\mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}} $\ast$ \mbox{\hyperlink{group__wasmcpp_ga0d2a0df0713ac3d561d896425cfdbeb1}{read\+Wasm\+D\+S\+P\+Factory\+From\+Machine\+File}} (const std\+::string \&machine\+\_\+code\+\_\+path, std\+::string \&error\+\_\+msg)
\item 
void \mbox{\hyperlink{group__wasmcpp_ga65182f30ae2463dd901eb44e44709cda}{write\+Wasm\+D\+S\+P\+Factory\+To\+Machine\+File}} (\mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}} $\ast$factory, const std\+::string \&machine\+\_\+code\+\_\+path)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{group__wasmcpp_ga15b752592bf7e0454942ea08677d6b3f}\label{group__wasmcpp_ga15b752592bf7e0454942ea08677d6b3f}} 
\index{C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}!createWasmDSPFactoryFromFile@{createWasmDSPFactoryFromFile}}
\index{createWasmDSPFactoryFromFile@{createWasmDSPFactoryFromFile}!C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}}
\doxysubsubsection{\texorpdfstring{createWasmDSPFactoryFromFile()}{createWasmDSPFactoryFromFile()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}}$\ast$ create\+Wasm\+D\+S\+P\+Factory\+From\+File (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{filename,  }\item[{int}]{argc,  }\item[{const char $\ast$}]{argv\mbox{[}$\,$\mbox{]},  }\item[{std\+::string \&}]{error\+\_\+msg,  }\item[{bool}]{internal\+\_\+memory }\end{DoxyParamCaption})}

Create a \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory from a \mbox{\hyperlink{class_d_s_p}{D\+SP}} source code as a file. Note that the library keeps an internal cache of all allocated factories so that the compilation of same \mbox{\hyperlink{class_d_s_p}{D\+SP}} code (that is same source code and same set of \textquotesingle{}normalized\textquotesingle{} compilations options) will return the same (reference counted) factory pointer. You will have to explicitly use delete\+Interpreter\+D\+S\+P\+Factory to properly decrement reference counter when the factory is no more needed.


\begin{DoxyParams}{Parameters}
{\em filename} & -\/ the \mbox{\hyperlink{class_d_s_p}{D\+SP}} filename \\
\hline
{\em argc} & -\/ the number of parameters in argv array \\
\hline
{\em argv} & -\/ the array of parameters \\
\hline
{\em error\+\_\+msg} & -\/ the error string to be filled \\
\hline
{\em internal\+\_\+memory} & -\/ whether to use an internallay allocated memory block for wasm module\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory on success, otherwise a null pointer. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wasmcpp_ga0c695229873a4737092b67d67255781f}\label{group__wasmcpp_ga0c695229873a4737092b67d67255781f}} 
\index{C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}!createWasmDSPFactoryFromString@{createWasmDSPFactoryFromString}}
\index{createWasmDSPFactoryFromString@{createWasmDSPFactoryFromString}!C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}}
\doxysubsubsection{\texorpdfstring{createWasmDSPFactoryFromString()}{createWasmDSPFactoryFromString()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}}$\ast$ create\+Wasm\+D\+S\+P\+Factory\+From\+String (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{name\+\_\+app,  }\item[{const std\+::string \&}]{dsp\+\_\+content,  }\item[{int}]{argc,  }\item[{const char $\ast$}]{argv\mbox{[}$\,$\mbox{]},  }\item[{std\+::string \&}]{error\+\_\+msg,  }\item[{bool}]{internal\+\_\+memory }\end{DoxyParamCaption})}

Create a \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory from a \mbox{\hyperlink{class_d_s_p}{D\+SP}} source code as a string. Note that the library keeps an internal cache of all allocated factories so that the compilation of same \mbox{\hyperlink{class_d_s_p}{D\+SP}} code (that is same source code and same set of \textquotesingle{}normalized\textquotesingle{} compilations options) will return the same (reference counted) factory pointer. You will have to explicitly use delete\+D\+S\+P\+Factory to properly decrement reference counter when the factory is no more needed.


\begin{DoxyParams}{Parameters}
{\em name\+\_\+app} & -\/ the name of the \mbox{\hyperlink{struct_faust}{Faust}} program \\
\hline
{\em dsp\+\_\+content} & -\/ the \mbox{\hyperlink{struct_faust}{Faust}} program as a string \\
\hline
{\em argc} & -\/ the number of parameters in argv array \\
\hline
{\em argv} & -\/ the array of parameters \\
\hline
{\em error\+\_\+msg} & -\/ the error string to be filled \\
\hline
{\em internal\+\_\+memory} & -\/ whether to use an internallay allocated memory block for wasm module\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory on success, otherwise a null pointer. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wasmcpp_ga43ecfe639299646685cf2b54c3ea0925}\label{group__wasmcpp_ga43ecfe639299646685cf2b54c3ea0925}} 
\index{C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}!deleteAllWasmDSPFactories@{deleteAllWasmDSPFactories}}
\index{deleteAllWasmDSPFactories@{deleteAllWasmDSPFactories}!C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}}
\doxysubsubsection{\texorpdfstring{deleteAllWasmDSPFactories()}{deleteAllWasmDSPFactories()}}
{\footnotesize\ttfamily void delete\+All\+Wasm\+D\+S\+P\+Factories (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Delete all \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} factories kept in the library cache. Beware \+: all kept factory and \mbox{\hyperlink{class_d_s_p}{D\+SP}} pointers (in local variables...) thus become invalid. \mbox{\Hypertarget{group__wasmcpp_ga9013d991d2c824bc98bc66ddcc573df5}\label{group__wasmcpp_ga9013d991d2c824bc98bc66ddcc573df5}} 
\index{C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}!deleteWasmDSPFactory@{deleteWasmDSPFactory}}
\index{deleteWasmDSPFactory@{deleteWasmDSPFactory}!C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}}
\doxysubsubsection{\texorpdfstring{deleteWasmDSPFactory()}{deleteWasmDSPFactory()}}
{\footnotesize\ttfamily bool delete\+Wasm\+D\+S\+P\+Factory (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}} $\ast$}]{factory }\end{DoxyParamCaption})}

Delete a \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory, that is decrements it\textquotesingle{}s reference counter, possibly really deleting the internal pointer. Possibly also delete \mbox{\hyperlink{class_d_s_p}{D\+SP}} pointers associated with this factory, if they were not explicitly deleted. Beware \+: all kept factories and \mbox{\hyperlink{class_d_s_p}{D\+SP}} pointers (in local variables...) thus become invalid.


\begin{DoxyParams}{Parameters}
{\em factory} & -\/ the \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the factory internal pointer was really deleted, and false if only \textquotesingle{}decremented\textquotesingle{}. Delete a \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory, that is decrements it\textquotesingle{}s reference counter, possible really deleting the internal pointer. Possibly also delete \mbox{\hyperlink{class_d_s_p}{D\+SP}} pointers associated with this factory, if they were not explicitly deleted. Beware \+: all kept factories and \mbox{\hyperlink{class_d_s_p}{D\+SP}} pointers (in local variables...) thus become invalid.
\end{DoxyReturn}

\begin{DoxyParams}{Parameters}
{\em factory} & -\/ the \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the factory internal pointer was really deleted, and false if only \textquotesingle{}decremented\textquotesingle{}. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wasmcpp_ga8cdda7a1df2ea35d7ae37a5019065cdc}\label{group__wasmcpp_ga8cdda7a1df2ea35d7ae37a5019065cdc}} 
\index{C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}!getAllWasmDSPFactories@{getAllWasmDSPFactories}}
\index{getAllWasmDSPFactories@{getAllWasmDSPFactories}!C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}}
\doxysubsubsection{\texorpdfstring{getAllWasmDSPFactories()}{getAllWasmDSPFactories()}}
{\footnotesize\ttfamily std\+::vector$<$std\+::string$>$ get\+All\+Wasm\+D\+S\+P\+Factories (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Return \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} factories of the library cache as a vector of their S\+HA keys.

\begin{DoxyReturn}{Returns}
the \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} factories. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wasmcpp_ga4dc6a8a1408922d179a375f4625c9411}\label{group__wasmcpp_ga4dc6a8a1408922d179a375f4625c9411}} 
\index{C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}!getCLibFaustVersion@{getCLibFaustVersion}}
\index{getCLibFaustVersion@{getCLibFaustVersion}!C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}}
\doxysubsubsection{\texorpdfstring{getCLibFaustVersion()}{getCLibFaustVersion()}}
{\footnotesize\ttfamily const char$\ast$ get\+C\+Lib\+Faust\+Version (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Get the library version.

\begin{DoxyReturn}{Returns}
the library version as a static string. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wasmcpp_gaf2df449aec7caf2e0fa6dc31210812e2}\label{group__wasmcpp_gaf2df449aec7caf2e0fa6dc31210812e2}} 
\index{C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}!getWasmDSPFactoryFromSHAKey@{getWasmDSPFactoryFromSHAKey}}
\index{getWasmDSPFactoryFromSHAKey@{getWasmDSPFactoryFromSHAKey}!C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}}
\doxysubsubsection{\texorpdfstring{getWasmDSPFactoryFromSHAKey()}{getWasmDSPFactoryFromSHAKey()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}}$\ast$ get\+Wasm\+D\+S\+P\+Factory\+From\+S\+H\+A\+Key (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{sha\+\_\+key }\end{DoxyParamCaption})}

Get the \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory associated with a given S\+HA key (created from the \textquotesingle{}expanded\textquotesingle{} \mbox{\hyperlink{class_d_s_p}{D\+SP}} source), if already allocated in the factories cache and increment it\textquotesingle{}s reference counter. You will have to explicitly use delete\+Wasm\+D\+S\+P\+Factory to properly decrement reference counter when the factory is no more needed.


\begin{DoxyParams}{Parameters}
{\em sha\+\_\+key} & -\/ the S\+HA key for an already created factory, kept in the factory cache\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a valid \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory if one is associated with the S\+HA key, otherwise a null pointer. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wasmcpp_gae1a7c9e95327c9995df00028977f96f9}\label{group__wasmcpp_gae1a7c9e95327c9995df00028977f96f9}} 
\index{C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}!readWasmDSPFactoryFromMachine@{readWasmDSPFactoryFromMachine}}
\index{readWasmDSPFactoryFromMachine@{readWasmDSPFactoryFromMachine}!C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}}
\doxysubsubsection{\texorpdfstring{readWasmDSPFactoryFromMachine()}{readWasmDSPFactoryFromMachine()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}}$\ast$ read\+Wasm\+D\+S\+P\+Factory\+From\+Machine (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{machine\+\_\+code,  }\item[{std\+::string \&}]{error\+\_\+msg }\end{DoxyParamCaption})}

Create a \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory from a machine code string. Note that the library keeps an internal cache of all allocated factories so that the compilation of the same \mbox{\hyperlink{class_d_s_p}{D\+SP}} code (that is the same machine code string) will return the same (reference counted) factory pointer. You will have to explicitly use delete\+Wasm\+D\+S\+P\+Factory to properly decrement reference counter when the factory is no more needed.


\begin{DoxyParams}{Parameters}
{\em machine\+\_\+code} & -\/ the machine code string \\
\hline
{\em error\+\_\+msg} & -\/ the error string to be filled\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory on success, otherwise a null pointer. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wasmcpp_ga0d2a0df0713ac3d561d896425cfdbeb1}\label{group__wasmcpp_ga0d2a0df0713ac3d561d896425cfdbeb1}} 
\index{C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}!readWasmDSPFactoryFromMachineFile@{readWasmDSPFactoryFromMachineFile}}
\index{readWasmDSPFactoryFromMachineFile@{readWasmDSPFactoryFromMachineFile}!C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}}
\doxysubsubsection{\texorpdfstring{readWasmDSPFactoryFromMachineFile()}{readWasmDSPFactoryFromMachineFile()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}}$\ast$ read\+Wasm\+D\+S\+P\+Factory\+From\+Machine\+File (\begin{DoxyParamCaption}\item[{const std\+::string \&}]{machine\+\_\+code\+\_\+path,  }\item[{std\+::string \&}]{error\+\_\+msg }\end{DoxyParamCaption})}

Create a \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory from a machine code file. Note that the library keeps an internal cache of all allocated factories so that the compilation of the same \mbox{\hyperlink{class_d_s_p}{D\+SP}} code (that is the same machine code file) will return the same (reference counted) factory pointer. You will have to explicitly use delete\+Wasm\+D\+S\+P\+Factory to properly decrement reference counter when the factory is no more needed.


\begin{DoxyParams}{Parameters}
{\em machine\+\_\+code\+\_\+path} & -\/ the machine code file pathname \\
\hline
{\em error\+\_\+msg} & -\/ the error string to be filled\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory on success, otherwise a null pointer. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wasmcpp_ga4cf138ebd999e677397fa1b30b5fc7d3}\label{group__wasmcpp_ga4cf138ebd999e677397fa1b30b5fc7d3}} 
\index{C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}!writeWasmDSPFactoryToMachine@{writeWasmDSPFactoryToMachine}}
\index{writeWasmDSPFactoryToMachine@{writeWasmDSPFactoryToMachine}!C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}}
\doxysubsubsection{\texorpdfstring{writeWasmDSPFactoryToMachine()}{writeWasmDSPFactoryToMachine()}}
{\footnotesize\ttfamily std\+::string write\+Wasm\+D\+S\+P\+Factory\+To\+Machine (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}} $\ast$}]{factory }\end{DoxyParamCaption})}

Write a \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory into a machine code string.


\begin{DoxyParams}{Parameters}
{\em factory} & -\/ the \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the machine code as a string. 
\end{DoxyReturn}
\mbox{\Hypertarget{group__wasmcpp_ga65182f30ae2463dd901eb44e44709cda}\label{group__wasmcpp_ga65182f30ae2463dd901eb44e44709cda}} 
\index{C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}!writeWasmDSPFactoryToMachineFile@{writeWasmDSPFactoryToMachineFile}}
\index{writeWasmDSPFactoryToMachineFile@{writeWasmDSPFactoryToMachineFile}!C++ interface for compiling Faust code. Note that the API is not thread safe.@{C++ interface for compiling Faust code. Note that the API is not thread safe.}}
\doxysubsubsection{\texorpdfstring{writeWasmDSPFactoryToMachineFile()}{writeWasmDSPFactoryToMachineFile()}}
{\footnotesize\ttfamily void write\+Wasm\+D\+S\+P\+Factory\+To\+Machine\+File (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classwasm__dsp__factory}{wasm\+\_\+dsp\+\_\+factory}} $\ast$}]{factory,  }\item[{const std\+::string \&}]{machine\+\_\+code\+\_\+path }\end{DoxyParamCaption})}

Write a \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory into a machine code file.


\begin{DoxyParams}{Parameters}
{\em factory} & -\/ the \mbox{\hyperlink{class_d_s_p}{D\+SP}} factory \\
\hline
{\em machine\+\_\+code\+\_\+path} & -\/ the machine code file pathname \\
\hline
\end{DoxyParams}
