\hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l}{}\doxysection{Eigen\+::I\+D\+R\+S\+T\+A\+BL$<$ Matrix\+Type\+\_\+, Preconditioner\+\_\+ $>$ Class Template Reference}
\label{class_eigen_1_1_i_d_r_s_t_a_b_l}\index{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}}


The I\+D\+R(s)S\+T\+A\+B(l) is a combination of I\+D\+R(s) and Bi\+C\+G\+S\+T\+A\+B(l). It is a short-\/recurrences Krylov method for sparse square problems. It can outperform both I\+D\+R(s) and Bi\+C\+G\+S\+T\+A\+B(l). I\+D\+R(s)S\+T\+A\+B(l) generally closely follows the optimal \mbox{\hyperlink{class_eigen_1_1_g_m_r_e_s}{G\+M\+R\+ES}} convergence in terms of the number of Matrix-\/\+Vector products. However, without the increasing cost per iteration of \mbox{\hyperlink{class_eigen_1_1_g_m_r_e_s}{G\+M\+R\+ES}}. I\+D\+R(s)S\+T\+A\+B(l) is suitable for both indefinite systems and systems with complex eigenvalues.  




{\ttfamily \#include $<$I\+D\+R\+S\+T\+A\+B\+L.\+h$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a5a22b075477144149504ca8a7fbf1abd}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a5a22b075477144149504ca8a7fbf1abd}} 
typedef Matrix\+Type\+\_\+ {\bfseries Matrix\+Type}
\item 
\mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a3a00036d0015205c7fff7e5c005e69ff}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a3a00036d0015205c7fff7e5c005e69ff}} 
typedef Matrix\+Type\+::\+Scalar {\bfseries Scalar}
\item 
\mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a945f80e628e6ac96c68820e3e2a77067}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a945f80e628e6ac96c68820e3e2a77067}} 
typedef Matrix\+Type\+::\+Real\+Scalar {\bfseries Real\+Scalar}
\item 
\mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a1ffff2d83840eecd5807f6dc6c64e812}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a1ffff2d83840eecd5807f6dc6c64e812}} 
typedef Preconditioner\+\_\+ {\bfseries Preconditioner}
\item 
\mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a5a22b075477144149504ca8a7fbf1abd}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a5a22b075477144149504ca8a7fbf1abd}} 
typedef Matrix\+Type\+\_\+ {\bfseries Matrix\+Type}
\item 
\mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a3a00036d0015205c7fff7e5c005e69ff}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a3a00036d0015205c7fff7e5c005e69ff}} 
typedef Matrix\+Type\+::\+Scalar {\bfseries Scalar}
\item 
\mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a945f80e628e6ac96c68820e3e2a77067}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a945f80e628e6ac96c68820e3e2a77067}} 
typedef Matrix\+Type\+::\+Real\+Scalar {\bfseries Real\+Scalar}
\item 
\mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a1ffff2d83840eecd5807f6dc6c64e812}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a1ffff2d83840eecd5807f6dc6c64e812}} 
typedef Preconditioner\+\_\+ {\bfseries Preconditioner}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l_a3c25cf3ea47ea97a8c1b52cf465f1ae0}{I\+D\+R\+S\+T\+A\+BL}} ()
\item 
{\footnotesize template$<$typename Matrix\+Derived $>$ }\\\mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l_a7618647d726f62a5850ff5355980ffd1}{I\+D\+R\+S\+T\+A\+BL}} (const \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}$<$ Matrix\+Derived $>$ \&\mbox{\hyperlink{class_eigen_1_1_matrix}{A}})
\item 
{\footnotesize template$<$typename Rhs , typename Dest $>$ }\\void \mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l_ad77080d2d09e6e71c1302f535e26f03b}{\+\_\+solve\+\_\+vector\+\_\+with\+\_\+guess\+\_\+impl}} (const Rhs \&b, Dest \&x) const
\item 
void \mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l_a1215cc6c5165fc7cd33a6de056e79fd5}{setL}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} L)
\item 
void \mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l_a57d1018bcbff8e316caa486a42537615}{setS}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} S)
\item 
\mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l_a3c25cf3ea47ea97a8c1b52cf465f1ae0}{I\+D\+R\+S\+T\+A\+BL}} ()
\item 
{\footnotesize template$<$typename Matrix\+Derived $>$ }\\\mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l_a7618647d726f62a5850ff5355980ffd1}{I\+D\+R\+S\+T\+A\+BL}} (const \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}$<$ Matrix\+Derived $>$ \&\mbox{\hyperlink{class_eigen_1_1_matrix}{A}})
\item 
{\footnotesize template$<$typename Rhs , typename Dest $>$ }\\void \mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l_ad77080d2d09e6e71c1302f535e26f03b}{\+\_\+solve\+\_\+vector\+\_\+with\+\_\+guess\+\_\+impl}} (const Rhs \&b, Dest \&x) const
\item 
void \mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l_a1215cc6c5165fc7cd33a6de056e79fd5}{setL}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} L)
\item 
void \mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l_a57d1018bcbff8e316caa486a42537615}{setS}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} S)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Matrix\+Type\+\_\+, typename Preconditioner\+\_\+$>$\newline
class Eigen\+::\+I\+D\+R\+S\+T\+A\+B\+L$<$ Matrix\+Type\+\_\+, Preconditioner\+\_\+ $>$}

The I\+D\+R(s)S\+T\+A\+B(l) is a combination of I\+D\+R(s) and Bi\+C\+G\+S\+T\+A\+B(l). It is a short-\/recurrences Krylov method for sparse square problems. It can outperform both I\+D\+R(s) and Bi\+C\+G\+S\+T\+A\+B(l). I\+D\+R(s)S\+T\+A\+B(l) generally closely follows the optimal \mbox{\hyperlink{class_eigen_1_1_g_m_r_e_s}{G\+M\+R\+ES}} convergence in terms of the number of Matrix-\/\+Vector products. However, without the increasing cost per iteration of \mbox{\hyperlink{class_eigen_1_1_g_m_r_e_s}{G\+M\+R\+ES}}. I\+D\+R(s)S\+T\+A\+B(l) is suitable for both indefinite systems and systems with complex eigenvalues. 

This class allows solving for A.\+x = b sparse linear problems. The vectors x and b can be either dense or sparse.


\begin{DoxyTemplParams}{Template Parameters}
{\em Matrix\+Type\+\_\+} & the type of the sparse matrix A, can be a dense or a sparse matrix. \\
\hline
{\em Preconditioner\+\_\+} & the type of the preconditioner. Default is \mbox{\hyperlink{class_eigen_1_1_diagonal_preconditioner}{Diagonal\+Preconditioner}}\\
\hline
\end{DoxyTemplParams}
\textbackslash{}implsparsesolverconcept

The maximum number of iterations and tolerance value can be controlled via the set\+Max\+Iterations() and set\+Tolerance() methods. The defaults are the size of the problem for the maximum number of iterations and \mbox{\hyperlink{group__gtc__constants_ga2a1e57fc5592b69cfae84174cbfc9429}{Num\+Traits$<$\+Scalar$>$\+::epsilon()}} for the tolerance.

The tolerance is the maximum relative residual error\+: $\vert$\+Ax-\/b$\vert$/$\vert$b$\vert$ for which the linear system is considered solved.

{\bfseries{Performance\+:}} When using sparse matrices, best performance is achieved for a row-\/major sparse matrix format. Moreover, in this case multi-\/threading can be exploited if the user code is compiled with Open\+MP enabled. See \mbox{\hyperlink{TopicMultiThreading}{Eigen and multi-\/threading}} for details.

By default the iterations start with x=0 as an initial guess of the solution. One can control the start using the solve\+With\+Guess() method.

I\+D\+R(s)S\+T\+A\+B(l) can also be used in a matrix-\/free context, see the following \mbox{\hyperlink{group___matrixfree_solver_example}{example }}.

\begin{DoxySeeAlso}{See also}
class \mbox{\hyperlink{class_eigen_1_1_simplicial_cholesky}{Simplicial\+Cholesky}}, \mbox{\hyperlink{class_eigen_1_1_diagonal_preconditioner}{Diagonal\+Preconditioner}}, \mbox{\hyperlink{class_eigen_1_1_identity_preconditioner}{Identity\+Preconditioner}} 
\end{DoxySeeAlso}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a3c25cf3ea47ea97a8c1b52cf465f1ae0}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a3c25cf3ea47ea97a8c1b52cf465f1ae0}} 
\index{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}!IDRSTABL@{IDRSTABL}}
\index{IDRSTABL@{IDRSTABL}!Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}}
\doxysubsubsection{\texorpdfstring{IDRSTABL()}{IDRSTABL()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , typename Preconditioner\+\_\+ $>$ \\
\mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l}{Eigen\+::\+I\+D\+R\+S\+T\+A\+BL}}$<$ Matrix\+Type\+\_\+, Preconditioner\+\_\+ $>$\+::\mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l}{I\+D\+R\+S\+T\+A\+BL}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Default constructor. \mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a7618647d726f62a5850ff5355980ffd1}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a7618647d726f62a5850ff5355980ffd1}} 
\index{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}!IDRSTABL@{IDRSTABL}}
\index{IDRSTABL@{IDRSTABL}!Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}}
\doxysubsubsection{\texorpdfstring{IDRSTABL()}{IDRSTABL()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , typename Preconditioner\+\_\+ $>$ \\
template$<$typename Matrix\+Derived $>$ \\
\mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l}{Eigen\+::\+I\+D\+R\+S\+T\+A\+BL}}$<$ Matrix\+Type\+\_\+, Preconditioner\+\_\+ $>$\+::\mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l}{I\+D\+R\+S\+T\+A\+BL}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}$<$ Matrix\+Derived $>$ \&}]{A }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}

Initialize the solver with matrix {\itshape A} for further {\ttfamily Ax=b} solving.

This constructor is a shortcut for the default constructor followed by a call to compute().

\begin{DoxyWarning}{Warning}
this class stores a reference to the matrix A as well as some precomputed values that depend on it. Therefore, if {\itshape A} is changed this class becomes invalid. Call compute() to update it with the new matrix A, or modify a copy of A. 
\end{DoxyWarning}
\mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a3c25cf3ea47ea97a8c1b52cf465f1ae0}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a3c25cf3ea47ea97a8c1b52cf465f1ae0}} 
\index{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}!IDRSTABL@{IDRSTABL}}
\index{IDRSTABL@{IDRSTABL}!Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}}
\doxysubsubsection{\texorpdfstring{IDRSTABL()}{IDRSTABL()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , typename Preconditioner\+\_\+ $>$ \\
\mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l}{Eigen\+::\+I\+D\+R\+S\+T\+A\+BL}}$<$ Matrix\+Type\+\_\+, Preconditioner\+\_\+ $>$\+::\mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l}{I\+D\+R\+S\+T\+A\+BL}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Default constructor. \mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a7618647d726f62a5850ff5355980ffd1}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a7618647d726f62a5850ff5355980ffd1}} 
\index{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}!IDRSTABL@{IDRSTABL}}
\index{IDRSTABL@{IDRSTABL}!Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}}
\doxysubsubsection{\texorpdfstring{IDRSTABL()}{IDRSTABL()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , typename Preconditioner\+\_\+ $>$ \\
template$<$typename Matrix\+Derived $>$ \\
\mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l}{Eigen\+::\+I\+D\+R\+S\+T\+A\+BL}}$<$ Matrix\+Type\+\_\+, Preconditioner\+\_\+ $>$\+::\mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l}{I\+D\+R\+S\+T\+A\+BL}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}$<$ Matrix\+Derived $>$ \&}]{A }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}

Initialize the solver with matrix {\itshape A} for further {\ttfamily Ax=b} solving.

This constructor is a shortcut for the default constructor followed by a call to compute().

\begin{DoxyWarning}{Warning}
this class stores a reference to the matrix A as well as some precomputed values that depend on it. Therefore, if {\itshape A} is changed this class becomes invalid. Call compute() to update it with the new matrix A, or modify a copy of A. 
\end{DoxyWarning}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_ad77080d2d09e6e71c1302f535e26f03b}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_ad77080d2d09e6e71c1302f535e26f03b}} 
\index{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}!\_solve\_vector\_with\_guess\_impl@{\_solve\_vector\_with\_guess\_impl}}
\index{\_solve\_vector\_with\_guess\_impl@{\_solve\_vector\_with\_guess\_impl}!Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}}
\doxysubsubsection{\texorpdfstring{\_solve\_vector\_with\_guess\_impl()}{\_solve\_vector\_with\_guess\_impl()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , typename Preconditioner\+\_\+ $>$ \\
template$<$typename Rhs , typename Dest $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l}{Eigen\+::\+I\+D\+R\+S\+T\+A\+BL}}$<$ Matrix\+Type\+\_\+, Preconditioner\+\_\+ $>$\+::\+\_\+solve\+\_\+vector\+\_\+with\+\_\+guess\+\_\+impl (\begin{DoxyParamCaption}\item[{const Rhs \&}]{b,  }\item[{Dest \&}]{x }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Loops over the number of columns of b and does the following\+:
\begin{DoxyEnumerate}
\item sets the tolerance and max\+Iterations
\item Calls the function that has the core solver routine 
\end{DoxyEnumerate}\mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_ad77080d2d09e6e71c1302f535e26f03b}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_ad77080d2d09e6e71c1302f535e26f03b}} 
\index{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}!\_solve\_vector\_with\_guess\_impl@{\_solve\_vector\_with\_guess\_impl}}
\index{\_solve\_vector\_with\_guess\_impl@{\_solve\_vector\_with\_guess\_impl}!Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}}
\doxysubsubsection{\texorpdfstring{\_solve\_vector\_with\_guess\_impl()}{\_solve\_vector\_with\_guess\_impl()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , typename Preconditioner\+\_\+ $>$ \\
template$<$typename Rhs , typename Dest $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l}{Eigen\+::\+I\+D\+R\+S\+T\+A\+BL}}$<$ Matrix\+Type\+\_\+, Preconditioner\+\_\+ $>$\+::\+\_\+solve\+\_\+vector\+\_\+with\+\_\+guess\+\_\+impl (\begin{DoxyParamCaption}\item[{const Rhs \&}]{b,  }\item[{Dest \&}]{x }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Loops over the number of columns of b and does the following\+:
\begin{DoxyEnumerate}
\item sets the tolerance and max\+Iterations
\item Calls the function that has the core solver routine 
\end{DoxyEnumerate}\mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a1215cc6c5165fc7cd33a6de056e79fd5}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a1215cc6c5165fc7cd33a6de056e79fd5}} 
\index{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}!setL@{setL}}
\index{setL@{setL}!Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}}
\doxysubsubsection{\texorpdfstring{setL()}{setL()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , typename Preconditioner\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l}{Eigen\+::\+I\+D\+R\+S\+T\+A\+BL}}$<$ Matrix\+Type\+\_\+, Preconditioner\+\_\+ $>$\+::setL (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{L }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Sets the parameter L, indicating the amount of minimize residual steps are used. \mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a1215cc6c5165fc7cd33a6de056e79fd5}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a1215cc6c5165fc7cd33a6de056e79fd5}} 
\index{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}!setL@{setL}}
\index{setL@{setL}!Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}}
\doxysubsubsection{\texorpdfstring{setL()}{setL()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , typename Preconditioner\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l}{Eigen\+::\+I\+D\+R\+S\+T\+A\+BL}}$<$ Matrix\+Type\+\_\+, Preconditioner\+\_\+ $>$\+::setL (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{L }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Sets the parameter L, indicating the amount of minimize residual steps are used. \mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a57d1018bcbff8e316caa486a42537615}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a57d1018bcbff8e316caa486a42537615}} 
\index{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}!setS@{setS}}
\index{setS@{setS}!Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}}
\doxysubsubsection{\texorpdfstring{setS()}{setS()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , typename Preconditioner\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l}{Eigen\+::\+I\+D\+R\+S\+T\+A\+BL}}$<$ Matrix\+Type\+\_\+, Preconditioner\+\_\+ $>$\+::setS (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{S }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Sets the parameter S, indicating the dimension of the shadow residual space.. \mbox{\Hypertarget{class_eigen_1_1_i_d_r_s_t_a_b_l_a57d1018bcbff8e316caa486a42537615}\label{class_eigen_1_1_i_d_r_s_t_a_b_l_a57d1018bcbff8e316caa486a42537615}} 
\index{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}!setS@{setS}}
\index{setS@{setS}!Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$@{Eigen::IDRSTABL$<$ MatrixType\_, Preconditioner\_ $>$}}
\doxysubsubsection{\texorpdfstring{setS()}{setS()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Matrix\+Type\+\_\+ , typename Preconditioner\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_i_d_r_s_t_a_b_l}{Eigen\+::\+I\+D\+R\+S\+T\+A\+BL}}$<$ Matrix\+Type\+\_\+, Preconditioner\+\_\+ $>$\+::setS (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{S }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Sets the parameter S, indicating the dimension of the shadow residual space.. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/eigen/unsupported/\+Eigen/src/\+Iterative\+Solvers/I\+D\+R\+S\+T\+A\+B\+L.\+h\end{DoxyCompactItemize}
