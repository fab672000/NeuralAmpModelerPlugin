\hypertarget{class_eigen_1_1_sparse_matrix}{}\doxysection{Eigen\+::Sparse\+Matrix$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$ Class Template Reference}
\label{class_eigen_1_1_sparse_matrix}\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}


A versatible sparse matrix representation.  




{\ttfamily \#include $<$Sparse\+Matrix.\+h$>$}

Inheritance diagram for Eigen\+::Sparse\+Matrix$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_eigen_1_1_sparse_matrix}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_eigen_1_1_sparse_matrix_1_1_index_pos_pair}{Index\+Pos\+Pair}}
\item 
class \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_1_1_singleton_vector}{Singleton\+Vector}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a691345e9899a2d839fede70a999236e4}\label{class_eigen_1_1_sparse_matrix_a691345e9899a2d839fede70a999236e4}} 
enum \{ {\bfseries Options} = Options\+\_\+
 \}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_aa2c9dc4fbb171fc6dcab594233d7708c}\label{class_eigen_1_1_sparse_matrix_aa2c9dc4fbb171fc6dcab594233d7708c}} 
enum \{ {\bfseries Options} = Options\+\_\+
 \}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a82ddf82aca8feb988166bbb4df7648fe}\label{class_eigen_1_1_sparse_matrix_a82ddf82aca8feb988166bbb4df7648fe}} 
typedef \mbox{\hyperlink{class_eigen_1_1_map}{Eigen\+::\+Map}}$<$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}}$<$ Scalar, Flags, Storage\+Index $>$ $>$ {\bfseries Map}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_abe476855efa1004607b543f45d91df73}\label{class_eigen_1_1_sparse_matrix_abe476855efa1004607b543f45d91df73}} 
typedef \mbox{\hyperlink{class_eigen_1_1_diagonal}{Diagonal}}$<$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} $>$ {\bfseries Diagonal\+Return\+Type}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ac61b240f39819875dec55b79762e44ba}\label{class_eigen_1_1_sparse_matrix_ac61b240f39819875dec55b79762e44ba}} 
typedef \mbox{\hyperlink{class_eigen_1_1_diagonal}{Diagonal}}$<$ const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} $>$ {\bfseries Const\+Diagonal\+Return\+Type}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ac59e12794ec77242f9219a65a7b9224a}\label{class_eigen_1_1_sparse_matrix_ac59e12794ec77242f9219a65a7b9224a}} 
typedef \mbox{\hyperlink{class_eigen_1_1_sparse_compressed_base_1_1_inner_iterator}{Base\+::\+Inner\+Iterator}} {\bfseries Inner\+Iterator}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_af4e53848677e57de281a41b0b2f7f2d5}\label{class_eigen_1_1_sparse_matrix_af4e53848677e57de281a41b0b2f7f2d5}} 
typedef \mbox{\hyperlink{class_eigen_1_1_sparse_compressed_base_1_1_reverse_inner_iterator}{Base\+::\+Reverse\+Inner\+Iterator}} {\bfseries Reverse\+Inner\+Iterator}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a8bc458fc0ae6e7326ca18dd754bc3107}\label{class_eigen_1_1_sparse_matrix_a8bc458fc0ae6e7326ca18dd754bc3107}} 
typedef \mbox{\hyperlink{class_eigen_1_1internal_1_1_compressed_storage}{internal\+::\+Compressed\+Storage}}$<$ Scalar, Storage\+Index $>$ {\bfseries Storage}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a0420953aaf5136c95288622f0234dc63}\label{class_eigen_1_1_sparse_matrix_a0420953aaf5136c95288622f0234dc63}} 
typedef \mbox{\hyperlink{class_eigen_1_1_matrix}{Base\+::\+Index\+Vector}} {\bfseries Index\+Vector}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_aef1cf96cdef4e594ed5fee32ef8c1ba0}\label{class_eigen_1_1_sparse_matrix_aef1cf96cdef4e594ed5fee32ef8c1ba0}} 
typedef Base\+::\+Scalar\+Vector {\bfseries Scalar\+Vector}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_afad0a1c7013ff97b74142c5fbbb6d46e}\label{class_eigen_1_1_sparse_matrix_afad0a1c7013ff97b74142c5fbbb6d46e}} 
typedef \mbox{\hyperlink{class_eigen_1_1_map}{Eigen\+::\+Map}}$<$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}}$<$ Scalar, Options\+\_\+, Storage\+Index $>$ $>$ {\bfseries Map}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_abe476855efa1004607b543f45d91df73}\label{class_eigen_1_1_sparse_matrix_abe476855efa1004607b543f45d91df73}} 
typedef \mbox{\hyperlink{class_eigen_1_1_diagonal}{Diagonal}}$<$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} $>$ {\bfseries Diagonal\+Return\+Type}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ac61b240f39819875dec55b79762e44ba}\label{class_eigen_1_1_sparse_matrix_ac61b240f39819875dec55b79762e44ba}} 
typedef \mbox{\hyperlink{class_eigen_1_1_diagonal}{Diagonal}}$<$ const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} $>$ {\bfseries Const\+Diagonal\+Return\+Type}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ac59e12794ec77242f9219a65a7b9224a}\label{class_eigen_1_1_sparse_matrix_ac59e12794ec77242f9219a65a7b9224a}} 
typedef \mbox{\hyperlink{class_eigen_1_1_sparse_compressed_base_1_1_inner_iterator}{Base\+::\+Inner\+Iterator}} {\bfseries Inner\+Iterator}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_af4e53848677e57de281a41b0b2f7f2d5}\label{class_eigen_1_1_sparse_matrix_af4e53848677e57de281a41b0b2f7f2d5}} 
typedef \mbox{\hyperlink{class_eigen_1_1_sparse_compressed_base_1_1_reverse_inner_iterator}{Base\+::\+Reverse\+Inner\+Iterator}} {\bfseries Reverse\+Inner\+Iterator}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a8bc458fc0ae6e7326ca18dd754bc3107}\label{class_eigen_1_1_sparse_matrix_a8bc458fc0ae6e7326ca18dd754bc3107}} 
typedef \mbox{\hyperlink{class_eigen_1_1internal_1_1_compressed_storage}{internal\+::\+Compressed\+Storage}}$<$ Scalar, Storage\+Index $>$ {\bfseries Storage}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a0420953aaf5136c95288622f0234dc63}\label{class_eigen_1_1_sparse_matrix_a0420953aaf5136c95288622f0234dc63}} 
typedef \mbox{\hyperlink{class_eigen_1_1_matrix}{Base\+::\+Index\+Vector}} {\bfseries Index\+Vector}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_aef1cf96cdef4e594ed5fee32ef8c1ba0}\label{class_eigen_1_1_sparse_matrix_aef1cf96cdef4e594ed5fee32ef8c1ba0}} 
typedef Base\+::\+Scalar\+Vector {\bfseries Scalar\+Vector}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a853a76dd42349fa2f3654a4a61e0f574}{rows}} () const
\item 
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a36b8cc95234b4e2de38a199b6b2af9fc}{cols}} () const
\item 
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_aa6411a0a909423d2d843a2e7d8b8e4e7}{inner\+Size}} () const
\item 
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a47c7cdf3c713ea69d08387aaf78e0c53}{outer\+Size}} () const
\item 
const Scalar $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6ed99bab9d4f142c629f69a93a2d1efb}{value\+Ptr}} () const
\item 
Scalar $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a5e9513f7d7336a698a47ff3135d6d555}{value\+Ptr}} ()
\item 
const Storage\+Index $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ade3e26297390865d80a09d1ce06cc916}{inner\+Index\+Ptr}} () const
\item 
Storage\+Index $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a0f927d1e7251a78585b12bf451423d4e}{inner\+Index\+Ptr}} ()
\item 
const Storage\+Index $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ad2d1a4d9033c2bc0917ea09cdc5c700c}{outer\+Index\+Ptr}} () const
\item 
Storage\+Index $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6de5655e0e36dfefd9812d65f48092f9}{outer\+Index\+Ptr}} ()
\item 
const Storage\+Index $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a62ba20726a10c2c9d095aed024297a2a}{inner\+Non\+Zero\+Ptr}} () const
\item 
Storage\+Index $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a0fa5da473fe96a8ae7fae6f3ca2d5b62}{inner\+Non\+Zero\+Ptr}} ()
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a8ae6da207cad2055c8e6a5f467b997ea}\label{class_eigen_1_1_sparse_matrix_a8ae6da207cad2055c8e6a5f467b997ea}} 
\mbox{\hyperlink{class_eigen_1_1internal_1_1_compressed_storage}{Storage}} \& {\bfseries data} ()
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a10c695b6b9b4987ba9e616c03c337e6b}\label{class_eigen_1_1_sparse_matrix_a10c695b6b9b4987ba9e616c03c337e6b}} 
const \mbox{\hyperlink{class_eigen_1_1internal_1_1_compressed_storage}{Storage}} \& {\bfseries data} () const
\item 
Scalar \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a05c9adc323553ed53726acae06fc4c18}{coeff}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} row, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col) const
\item 
Scalar \& \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6e4f970149f1cbab1eecc2a04c291fb1}{coeff\+Ref}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} row, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col)
\item 
Scalar \& \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ae2d8f72ff86a300b76f9edd67df8d8fd}{insert}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} row, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col)
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a2feb71dd2ed222057a77ff92b736badc}{set\+Zero}} ()
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ad9e36e669468663012b77bf1bff8cc4f}{reserve}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} reserve\+Size)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ac881079cb90522f0e8392d47aa7adb7a}\label{class_eigen_1_1_sparse_matrix_ac881079cb90522f0e8392d47aa7adb7a}} 
{\footnotesize template$<$class Sizes\+Type $>$ }\\void {\bfseries reserve} (const Sizes\+Type \&reserve\+Sizes, const typename Sizes\+Type\+::value\+\_\+type \&enableif=typename Sizes\+Type\+::value\+\_\+type())
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ad46211f9f38f0cb99f7e2262fe634cd6}\label{class_eigen_1_1_sparse_matrix_ad46211f9f38f0cb99f7e2262fe634cd6}} 
Scalar \& {\bfseries insert\+Back} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} row, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a4cac4cc4fe57ac796c344d3f68ff75fe}\label{class_eigen_1_1_sparse_matrix_a4cac4cc4fe57ac796c344d3f68ff75fe}} 
Scalar \& {\bfseries insert\+Back\+By\+Outer\+Inner} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} outer, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} inner)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_aea808bafd08024942e2d96a1f5904031}\label{class_eigen_1_1_sparse_matrix_aea808bafd08024942e2d96a1f5904031}} 
Scalar \& {\bfseries insert\+Back\+By\+Outer\+Inner\+Unordered} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} outer, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} inner)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a42bc66a0851cf65b23b70b1d602fee26}\label{class_eigen_1_1_sparse_matrix_a42bc66a0851cf65b23b70b1d602fee26}} 
void {\bfseries start\+Vec} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} outer)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6046c670175cdb44e3c7909db56c5172}\label{class_eigen_1_1_sparse_matrix_a6046c670175cdb44e3c7909db56c5172}} 
void {\bfseries finalize} ()
\item 
{\footnotesize template$<$typename Input\+Iterators $>$ }\\void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a8f09e3597f37aa8861599260af6a53e0}{set\+From\+Triplets}} (const Input\+Iterators \&begin, const Input\+Iterators \&end)
\item 
{\footnotesize template$<$typename Input\+Iterators , typename Dup\+Functor $>$ }\\void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a3e8c96b7dd72d03f14b5cf40f5005d55}{set\+From\+Triplets}} (const Input\+Iterators \&begin, const Input\+Iterators \&end, Dup\+Functor dup\+\_\+func)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6222c9a5338c413ec4edae119d454724}\label{class_eigen_1_1_sparse_matrix_a6222c9a5338c413ec4edae119d454724}} 
void {\bfseries sumup\+Duplicates} ()
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a3ef7fd1b03805b10906f3e6596de525c}\label{class_eigen_1_1_sparse_matrix_a3ef7fd1b03805b10906f3e6596de525c}} 
{\footnotesize template$<$typename Dup\+Functor $>$ }\\void {\bfseries collapse\+Duplicates} (Dup\+Functor dup\+\_\+func=Dup\+Functor())
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6cacf861d0a03b22aec1c3c4b4f8b657}\label{class_eigen_1_1_sparse_matrix_a6cacf861d0a03b22aec1c3c4b4f8b657}} 
Scalar \& {\bfseries insert\+By\+Outer\+Inner} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} j, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} i)
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6400e6e733a7131f9b776d6386d2ed89}{make\+Compressed}} ()
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a542c2a877dcffbd48248b43d3eaf670f}{uncompress}} ()
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ab4b7ffe0c08f653f5c34b02b9b12e6bf}{prune}} (const Scalar \&reference, const Real\+Scalar \&epsilon=\mbox{\hyperlink{struct_eigen_1_1_num_traits}{Num\+Traits}}$<$ Real\+Scalar $>$\+::dummy\+\_\+precision())
\item 
{\footnotesize template$<$typename Keep\+Func $>$ }\\void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_aca3916ec112e13c513380b47fad7954b}{prune}} (const Keep\+Func \&keep=Keep\+Func())
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ab0e43ac03eb34e451e0f16e97ea2afda}{conservative\+Resize}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a853a76dd42349fa2f3654a4a61e0f574}{rows}}, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a36b8cc95234b4e2de38a199b6b2af9fc}{cols}})
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a835ae5b304ddbb187eac25d5850b2ced}{resize}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a853a76dd42349fa2f3654a4a61e0f574}{rows}}, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a36b8cc95234b4e2de38a199b6b2af9fc}{cols}})
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ab903403b32107a7e91c53e8f1a1ff0eb}\label{class_eigen_1_1_sparse_matrix_ab903403b32107a7e91c53e8f1a1ff0eb}} 
void {\bfseries resize\+Non\+Zeros} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} size)
\item 
const \mbox{\hyperlink{class_eigen_1_1_diagonal}{Const\+Diagonal\+Return\+Type}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a20301b7b657f0948d6a6da68509fb4da}{diagonal}} () const
\item 
\mbox{\hyperlink{class_eigen_1_1_diagonal}{Diagonal\+Return\+Type}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ae6f4db56c76e4d374eb8507fbef5bdb5}{diagonal}} ()
\item 
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a4f28e83ea504f0d8ee76c4b8701939d6}{Sparse\+Matrix}} ()
\item 
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_aa647b5f0462b9986e3c907e9ca7c5984}{Sparse\+Matrix}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a853a76dd42349fa2f3654a4a61e0f574}{rows}}, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a36b8cc95234b4e2de38a199b6b2af9fc}{cols}})
\item 
{\footnotesize template$<$typename Other\+Derived $>$ }\\\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ac4a6307cd6ba6b4ee7124d590d3120bf}{Sparse\+Matrix}} (const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_base}{Sparse\+Matrix\+Base}}$<$ Other\+Derived $>$ \&other)
\item 
{\footnotesize template$<$typename Other\+Derived , unsigned int Up\+Lo$>$ }\\\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a794f49fa972d5d39fc81c0925aae1513}{Sparse\+Matrix}} (const \mbox{\hyperlink{class_eigen_1_1_sparse_self_adjoint_view}{Sparse\+Self\+Adjoint\+View}}$<$ Other\+Derived, Up\+Lo $>$ \&other)
\item 
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a85ce452dd42db3db4e262e955f7820aa}{Sparse\+Matrix}} (const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a394987faa818eb6a0a5c9f92c3740f1a}\label{class_eigen_1_1_sparse_matrix_a394987faa818eb6a0a5c9f92c3740f1a}} 
{\footnotesize template$<$typename Other\+Derived $>$ }\\\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a394987faa818eb6a0a5c9f92c3740f1a}{Sparse\+Matrix}} (const \mbox{\hyperlink{class_eigen_1_1_return_by_value}{Return\+By\+Value}}$<$ Other\+Derived $>$ \&other)
\begin{DoxyCompactList}\small\item\em Copy constructor with in-\/place evaluation. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a9c8a247192285453d402becafdd106c4}\label{class_eigen_1_1_sparse_matrix_a9c8a247192285453d402becafdd106c4}} 
{\footnotesize template$<$typename Other\+Derived $>$ }\\\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a9c8a247192285453d402becafdd106c4}{Sparse\+Matrix}} (const \mbox{\hyperlink{class_eigen_1_1_diagonal_base}{Diagonal\+Base}}$<$ Other\+Derived $>$ \&other)
\begin{DoxyCompactList}\small\item\em Copy constructor with in-\/place evaluation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a20eec45a940a4dd7edcacfa21468b328}{swap}} (\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \&other)
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_aa4064cc1e3a4038cf09ff03af5a3ffb5}{set\+Identity}} ()
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ace1e29fbee762d9fc890e279c2969fa9}\label{class_eigen_1_1_sparse_matrix_ace1e29fbee762d9fc890e279c2969fa9}} 
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \& {\bfseries operator=} (const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a4723a57e84b89bb8a64eb6c44a860955}\label{class_eigen_1_1_sparse_matrix_a4723a57e84b89bb8a64eb6c44a860955}} 
{\footnotesize template$<$typename Other\+Derived $>$ }\\\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \& {\bfseries operator=} (const \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}$<$ Other\+Derived $>$ \&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_abf46ae2a000529efeef7493bf44f241e}\label{class_eigen_1_1_sparse_matrix_abf46ae2a000529efeef7493bf44f241e}} 
{\footnotesize template$<$typename Lhs , typename Rhs $>$ }\\\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \& {\bfseries operator=} (const \mbox{\hyperlink{class_eigen_1_1_product}{Product}}$<$ Lhs, Rhs, Alias\+Free\+Product $>$ \&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a1d7d2d6e4ae19526c6260eac3707123c}\label{class_eigen_1_1_sparse_matrix_a1d7d2d6e4ae19526c6260eac3707123c}} 
{\footnotesize template$<$typename Other\+Derived $>$ }\\E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+I\+N\+L\+I\+NE \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \& {\bfseries operator=} (const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_base}{Sparse\+Matrix\+Base}}$<$ Other\+Derived $>$ \&other)
\item 
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ac837d39f0ae378ecb132f5ef2d7fa74b}{$\sim$\+Sparse\+Matrix}} ()
\item 
Scalar \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ad2b635a54bf2fe66facd1cb1872aae9f}{sum}} () const
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a432a162ad5f4e177c094f7585407129b}\label{class_eigen_1_1_sparse_matrix_a432a162ad5f4e177c094f7585407129b}} 
E\+I\+G\+E\+N\+\_\+\+S\+T\+R\+O\+N\+G\+\_\+\+I\+N\+L\+I\+NE Scalar \& {\bfseries insert\+Back\+Uncompressed} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} row, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col)
\item 
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a853a76dd42349fa2f3654a4a61e0f574}{rows}} () const
\item 
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a36b8cc95234b4e2de38a199b6b2af9fc}{cols}} () const
\item 
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_aa6411a0a909423d2d843a2e7d8b8e4e7}{inner\+Size}} () const
\item 
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a47c7cdf3c713ea69d08387aaf78e0c53}{outer\+Size}} () const
\item 
const Scalar $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6ed99bab9d4f142c629f69a93a2d1efb}{value\+Ptr}} () const
\item 
Scalar $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a5e9513f7d7336a698a47ff3135d6d555}{value\+Ptr}} ()
\item 
const Storage\+Index $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ade3e26297390865d80a09d1ce06cc916}{inner\+Index\+Ptr}} () const
\item 
Storage\+Index $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a0f927d1e7251a78585b12bf451423d4e}{inner\+Index\+Ptr}} ()
\item 
const Storage\+Index $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ad2d1a4d9033c2bc0917ea09cdc5c700c}{outer\+Index\+Ptr}} () const
\item 
Storage\+Index $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6de5655e0e36dfefd9812d65f48092f9}{outer\+Index\+Ptr}} ()
\item 
const Storage\+Index $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a62ba20726a10c2c9d095aed024297a2a}{inner\+Non\+Zero\+Ptr}} () const
\item 
Storage\+Index $\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a0fa5da473fe96a8ae7fae6f3ca2d5b62}{inner\+Non\+Zero\+Ptr}} ()
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a8ae6da207cad2055c8e6a5f467b997ea}\label{class_eigen_1_1_sparse_matrix_a8ae6da207cad2055c8e6a5f467b997ea}} 
\mbox{\hyperlink{class_eigen_1_1internal_1_1_compressed_storage}{Storage}} \& {\bfseries data} ()
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a10c695b6b9b4987ba9e616c03c337e6b}\label{class_eigen_1_1_sparse_matrix_a10c695b6b9b4987ba9e616c03c337e6b}} 
const \mbox{\hyperlink{class_eigen_1_1internal_1_1_compressed_storage}{Storage}} \& {\bfseries data} () const
\item 
Scalar \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a05c9adc323553ed53726acae06fc4c18}{coeff}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} row, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col) const
\item 
Scalar \& \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6e4f970149f1cbab1eecc2a04c291fb1}{coeff\+Ref}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} row, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col)
\item 
Scalar \& \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ab3911a1444c1c8afc25c8c205ab7a05c}{insert}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} row, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col)
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a2feb71dd2ed222057a77ff92b736badc}{set\+Zero}} ()
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ad9e36e669468663012b77bf1bff8cc4f}{reserve}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} reserve\+Size)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ac881079cb90522f0e8392d47aa7adb7a}\label{class_eigen_1_1_sparse_matrix_ac881079cb90522f0e8392d47aa7adb7a}} 
{\footnotesize template$<$class Sizes\+Type $>$ }\\void {\bfseries reserve} (const Sizes\+Type \&reserve\+Sizes, const typename Sizes\+Type\+::value\+\_\+type \&enableif=typename Sizes\+Type\+::value\+\_\+type())
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ad46211f9f38f0cb99f7e2262fe634cd6}\label{class_eigen_1_1_sparse_matrix_ad46211f9f38f0cb99f7e2262fe634cd6}} 
Scalar \& {\bfseries insert\+Back} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} row, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a4cac4cc4fe57ac796c344d3f68ff75fe}\label{class_eigen_1_1_sparse_matrix_a4cac4cc4fe57ac796c344d3f68ff75fe}} 
Scalar \& {\bfseries insert\+Back\+By\+Outer\+Inner} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} outer, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} inner)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_aea808bafd08024942e2d96a1f5904031}\label{class_eigen_1_1_sparse_matrix_aea808bafd08024942e2d96a1f5904031}} 
Scalar \& {\bfseries insert\+Back\+By\+Outer\+Inner\+Unordered} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} outer, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} inner)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a42bc66a0851cf65b23b70b1d602fee26}\label{class_eigen_1_1_sparse_matrix_a42bc66a0851cf65b23b70b1d602fee26}} 
void {\bfseries start\+Vec} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} outer)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6046c670175cdb44e3c7909db56c5172}\label{class_eigen_1_1_sparse_matrix_a6046c670175cdb44e3c7909db56c5172}} 
void {\bfseries finalize} ()
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a549d8e75547dd49d0242a5e73fb4df27}\label{class_eigen_1_1_sparse_matrix_a549d8e75547dd49d0242a5e73fb4df27}} 
{\footnotesize template$<$typename Input\+Iterators $>$ }\\void {\bfseries set\+From\+Triplets} (const Input\+Iterators \&begin, const Input\+Iterators \&end)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a9db60b2c58dabb1e817a335d74a7bdf6}\label{class_eigen_1_1_sparse_matrix_a9db60b2c58dabb1e817a335d74a7bdf6}} 
{\footnotesize template$<$typename Input\+Iterators , typename Dup\+Functor $>$ }\\void {\bfseries set\+From\+Triplets} (const Input\+Iterators \&begin, const Input\+Iterators \&end, Dup\+Functor dup\+\_\+func)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a14090a04f0018389fc6d1cf7d40667dd}\label{class_eigen_1_1_sparse_matrix_a14090a04f0018389fc6d1cf7d40667dd}} 
{\footnotesize template$<$typename Derived , typename Dup\+Functor $>$ }\\void {\bfseries collapse\+Duplicates} (\mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}}$<$ Derived $>$ \&wi, Dup\+Functor dup\+\_\+func=Dup\+Functor())
\item 
{\footnotesize template$<$typename Input\+Iterators $>$ }\\void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a39c6b1ee045d58ced163b140b9c6bf36}{set\+From\+Sorted\+Triplets}} (const Input\+Iterators \&begin, const Input\+Iterators \&end)
\item 
{\footnotesize template$<$typename Input\+Iterators , typename Dup\+Functor $>$ }\\void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a73841eccfc1066680c7bed8bf98ec3e1}{set\+From\+Sorted\+Triplets}} (const Input\+Iterators \&begin, const Input\+Iterators \&end, Dup\+Functor dup\+\_\+func)
\item 
{\footnotesize template$<$typename Input\+Iterators $>$ }\\void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_af5bf43559efce09f5415d6b66aa31d53}{insert\+From\+Triplets}} (const Input\+Iterators \&begin, const Input\+Iterators \&end)
\item 
{\footnotesize template$<$typename Input\+Iterators , typename Dup\+Functor $>$ }\\void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ab452919fafc44dc6f8407fe4e5ffeddd}{insert\+From\+Triplets}} (const Input\+Iterators \&begin, const Input\+Iterators \&end, Dup\+Functor dup\+\_\+func)
\item 
{\footnotesize template$<$typename Input\+Iterators $>$ }\\void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a5983337b43e23cf688a00a23e30cfffb}{insert\+From\+Sorted\+Triplets}} (const Input\+Iterators \&begin, const Input\+Iterators \&end)
\item 
{\footnotesize template$<$typename Input\+Iterators , typename Dup\+Functor $>$ }\\void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a29f17d24f224a1fb73ab903e2a42aba4}{insert\+From\+Sorted\+Triplets}} (const Input\+Iterators \&begin, const Input\+Iterators \&end, Dup\+Functor dup\+\_\+func)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6cacf861d0a03b22aec1c3c4b4f8b657}\label{class_eigen_1_1_sparse_matrix_a6cacf861d0a03b22aec1c3c4b4f8b657}} 
Scalar \& {\bfseries insert\+By\+Outer\+Inner} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} j, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} i)
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6400e6e733a7131f9b776d6386d2ed89}{make\+Compressed}} ()
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a542c2a877dcffbd48248b43d3eaf670f}{uncompress}} ()
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ab4b7ffe0c08f653f5c34b02b9b12e6bf}{prune}} (const Scalar \&reference, const Real\+Scalar \&epsilon=\mbox{\hyperlink{struct_eigen_1_1_num_traits}{Num\+Traits}}$<$ Real\+Scalar $>$\+::dummy\+\_\+precision())
\item 
{\footnotesize template$<$typename Keep\+Func $>$ }\\void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_aca3916ec112e13c513380b47fad7954b}{prune}} (const Keep\+Func \&keep=Keep\+Func())
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ab0e43ac03eb34e451e0f16e97ea2afda}{conservative\+Resize}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a853a76dd42349fa2f3654a4a61e0f574}{rows}}, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a36b8cc95234b4e2de38a199b6b2af9fc}{cols}})
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a835ae5b304ddbb187eac25d5850b2ced}{resize}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a853a76dd42349fa2f3654a4a61e0f574}{rows}}, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a36b8cc95234b4e2de38a199b6b2af9fc}{cols}})
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ab903403b32107a7e91c53e8f1a1ff0eb}\label{class_eigen_1_1_sparse_matrix_ab903403b32107a7e91c53e8f1a1ff0eb}} 
void {\bfseries resize\+Non\+Zeros} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} size)
\item 
const \mbox{\hyperlink{class_eigen_1_1_diagonal}{Const\+Diagonal\+Return\+Type}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a20301b7b657f0948d6a6da68509fb4da}{diagonal}} () const
\item 
\mbox{\hyperlink{class_eigen_1_1_diagonal}{Diagonal\+Return\+Type}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ae6f4db56c76e4d374eb8507fbef5bdb5}{diagonal}} ()
\item 
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a4f28e83ea504f0d8ee76c4b8701939d6}{Sparse\+Matrix}} ()
\item 
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_aa647b5f0462b9986e3c907e9ca7c5984}{Sparse\+Matrix}} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a853a76dd42349fa2f3654a4a61e0f574}{rows}}, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a36b8cc95234b4e2de38a199b6b2af9fc}{cols}})
\item 
{\footnotesize template$<$typename Other\+Derived $>$ }\\\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ac4a6307cd6ba6b4ee7124d590d3120bf}{Sparse\+Matrix}} (const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_base}{Sparse\+Matrix\+Base}}$<$ Other\+Derived $>$ \&other)
\item 
{\footnotesize template$<$typename Other\+Derived , unsigned int Up\+Lo$>$ }\\\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a794f49fa972d5d39fc81c0925aae1513}{Sparse\+Matrix}} (const \mbox{\hyperlink{class_eigen_1_1_sparse_self_adjoint_view}{Sparse\+Self\+Adjoint\+View}}$<$ Other\+Derived, Up\+Lo $>$ \&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_afacbbae87083903bc8a0032810e68d4d}\label{class_eigen_1_1_sparse_matrix_afacbbae87083903bc8a0032810e68d4d}} 
{\bfseries Sparse\+Matrix} (\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \&\&other)
\item 
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a85ce452dd42db3db4e262e955f7820aa}{Sparse\+Matrix}} (const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a394987faa818eb6a0a5c9f92c3740f1a}\label{class_eigen_1_1_sparse_matrix_a394987faa818eb6a0a5c9f92c3740f1a}} 
{\footnotesize template$<$typename Other\+Derived $>$ }\\\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a394987faa818eb6a0a5c9f92c3740f1a}{Sparse\+Matrix}} (const \mbox{\hyperlink{class_eigen_1_1_return_by_value}{Return\+By\+Value}}$<$ Other\+Derived $>$ \&other)
\begin{DoxyCompactList}\small\item\em Copy constructor with in-\/place evaluation. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a9c8a247192285453d402becafdd106c4}\label{class_eigen_1_1_sparse_matrix_a9c8a247192285453d402becafdd106c4}} 
{\footnotesize template$<$typename Other\+Derived $>$ }\\\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a9c8a247192285453d402becafdd106c4}{Sparse\+Matrix}} (const \mbox{\hyperlink{class_eigen_1_1_diagonal_base}{Diagonal\+Base}}$<$ Other\+Derived $>$ \&other)
\begin{DoxyCompactList}\small\item\em Copy constructor with in-\/place evaluation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a20eec45a940a4dd7edcacfa21468b328}{swap}} (\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \&other)
\item 
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_aa4064cc1e3a4038cf09ff03af5a3ffb5}{set\+Identity}} ()
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ace1e29fbee762d9fc890e279c2969fa9}\label{class_eigen_1_1_sparse_matrix_ace1e29fbee762d9fc890e279c2969fa9}} 
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \& {\bfseries operator=} (const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a3cbe34a408979949ec8678c7cf8850da}\label{class_eigen_1_1_sparse_matrix_a3cbe34a408979949ec8678c7cf8850da}} 
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \& {\bfseries operator=} (\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \&\&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a4723a57e84b89bb8a64eb6c44a860955}\label{class_eigen_1_1_sparse_matrix_a4723a57e84b89bb8a64eb6c44a860955}} 
{\footnotesize template$<$typename Other\+Derived $>$ }\\\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \& {\bfseries operator=} (const \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}$<$ Other\+Derived $>$ \&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_abf46ae2a000529efeef7493bf44f241e}\label{class_eigen_1_1_sparse_matrix_abf46ae2a000529efeef7493bf44f241e}} 
{\footnotesize template$<$typename Lhs , typename Rhs $>$ }\\\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \& {\bfseries operator=} (const \mbox{\hyperlink{class_eigen_1_1_product}{Product}}$<$ Lhs, Rhs, Alias\+Free\+Product $>$ \&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a1d7d2d6e4ae19526c6260eac3707123c}\label{class_eigen_1_1_sparse_matrix_a1d7d2d6e4ae19526c6260eac3707123c}} 
{\footnotesize template$<$typename Other\+Derived $>$ }\\E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+I\+N\+L\+I\+NE \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \& {\bfseries operator=} (const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_base}{Sparse\+Matrix\+Base}}$<$ Other\+Derived $>$ \&other)
\item 
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ac837d39f0ae378ecb132f5ef2d7fa74b}{$\sim$\+Sparse\+Matrix}} ()
\item 
Scalar \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a5bfe2c81a8afbd1bf2aa991a673c486d}{sum}} () const
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a432a162ad5f4e177c094f7585407129b}\label{class_eigen_1_1_sparse_matrix_a432a162ad5f4e177c094f7585407129b}} 
E\+I\+G\+E\+N\+\_\+\+S\+T\+R\+O\+N\+G\+\_\+\+I\+N\+L\+I\+NE Scalar \& {\bfseries insert\+Back\+Uncompressed} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} row, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a61ab64396b1a71e60c822c53c2229282}\label{class_eigen_1_1_sparse_matrix_a61ab64396b1a71e60c822c53c2229282}} 
{\footnotesize template$<$typename Other\+Derived $>$ }\\E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+I\+N\+L\+I\+NE \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}}$<$ Scalar, Options\+\_\+, Storage\+Index\+\_\+ $>$ \& {\bfseries operator=} (const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_base}{Sparse\+Matrix\+Base}}$<$ Other\+Derived $>$ \&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a7857c321fa3f3c74e41a3d5c7d852b3a}\label{class_eigen_1_1_sparse_matrix_a7857c321fa3f3c74e41a3d5c7d852b3a}} 
{\footnotesize template$<$typename Lhs , typename Rhs $>$ }\\\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}}$<$ Scalar, Options\+\_\+, Storage\+Index\+\_\+ $>$ \& {\bfseries operator=} (const \mbox{\hyperlink{class_eigen_1_1_product}{Product}}$<$ Lhs, Rhs, Alias\+Free\+Product $>$ \&src)
\item 
bool \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ae257333ca0e0b16cf5d3080bbefeaf47}{is\+Compressed}} () const
\item 
bool \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ae257333ca0e0b16cf5d3080bbefeaf47}{is\+Compressed}} () const
\item 
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ae53743108cd668b8da927ff149631fe0}{non\+Zeros}} () const
\item 
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ae53743108cd668b8da927ff149631fe0}{non\+Zeros}} () const
\item 
bool \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ae257333ca0e0b16cf5d3080bbefeaf47}{is\+Compressed}} () const
\item 
bool \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ae257333ca0e0b16cf5d3080bbefeaf47}{is\+Compressed}} () const
\item 
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ae53743108cd668b8da927ff149631fe0}{non\+Zeros}} () const
\item 
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ae53743108cd668b8da927ff149631fe0}{non\+Zeros}} () const
\end{DoxyCompactItemize}
\doxysubsection*{Protected Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_aa69a39f979185401dacefbd7a8f63b45}\label{class_eigen_1_1_sparse_matrix_aa69a39f979185401dacefbd7a8f63b45}} 
typedef \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}}$<$ Scalar,(Flags \&$\sim$\mbox{\hyperlink{group__flags_gae4f56c2a60bbe4bd2e44c5b19cbe8762}{Row\+Major\+Bit}})$\vert$(Is\+Row\+Major?Row\+Major\+Bit\+:0), Storage\+Index $>$ {\bfseries Transposed\+Sparse\+Matrix}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a62b4ae929a173403f05ed043a823287b}\label{class_eigen_1_1_sparse_matrix_a62b4ae929a173403f05ed043a823287b}} 
typedef \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}}$<$ Scalar, Is\+Row\+Major ? \mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{Col\+Major}} \+:\mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{Row\+Major}}, Storage\+Index $>$ {\bfseries Transposed\+Sparse\+Matrix}
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6279d14bb06354f2b149185903d2886c}\label{class_eigen_1_1_sparse_matrix_a6279d14bb06354f2b149185903d2886c}} 
{\footnotesize template$<$class Sizes\+Type $>$ }\\void {\bfseries reserve\+Inner\+Vectors} (const Sizes\+Type \&reserve\+Sizes)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6efecfb5d8d51eac0ad988f09e726b8d}\label{class_eigen_1_1_sparse_matrix_a6efecfb5d8d51eac0ad988f09e726b8d}} 
{\footnotesize template$<$typename Other $>$ }\\void {\bfseries init\+Assignment} (const Other \&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a016b1a91367a894e6d77e84a539e3df8}\label{class_eigen_1_1_sparse_matrix_a016b1a91367a894e6d77e84a539e3df8}} 
E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+I\+N\+L\+I\+NE Scalar \& {\bfseries insert\+Compressed} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} row, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a18a5db16bd5830276dc4f452c5d097a5}\label{class_eigen_1_1_sparse_matrix_a18a5db16bd5830276dc4f452c5d097a5}} 
E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+I\+N\+L\+I\+NE Scalar \& {\bfseries insert\+Uncompressed} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} row, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a2d82c0cbc0c3996b5d1b8b89a5f60b71}\label{class_eigen_1_1_sparse_matrix_a2d82c0cbc0c3996b5d1b8b89a5f60b71}} 
{\footnotesize template$<$typename Diag\+Xpr , typename Func $>$ }\\void {\bfseries assign\+Diagonal} (const Diag\+Xpr diag\+Xpr, const Func \&assign\+Func)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6279d14bb06354f2b149185903d2886c}\label{class_eigen_1_1_sparse_matrix_a6279d14bb06354f2b149185903d2886c}} 
{\footnotesize template$<$class Sizes\+Type $>$ }\\void {\bfseries reserve\+Inner\+Vectors} (const Sizes\+Type \&reserve\+Sizes)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6efecfb5d8d51eac0ad988f09e726b8d}\label{class_eigen_1_1_sparse_matrix_a6efecfb5d8d51eac0ad988f09e726b8d}} 
{\footnotesize template$<$typename Other $>$ }\\void {\bfseries init\+Assignment} (const Other \&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a870b028fce0f75cda9c7f524e5de57cb}\label{class_eigen_1_1_sparse_matrix_a870b028fce0f75cda9c7f524e5de57cb}} 
E\+I\+G\+E\+N\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+ED E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+I\+N\+L\+I\+NE Scalar \& {\bfseries insert\+Compressed} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} row, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a5c4f80d46d047a3001be911a3a696002}\label{class_eigen_1_1_sparse_matrix_a5c4f80d46d047a3001be911a3a696002}} 
E\+I\+G\+E\+N\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+ED E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+I\+N\+L\+I\+NE Scalar \& {\bfseries insert\+Uncompressed} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} row, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} col)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a2d82c0cbc0c3996b5d1b8b89a5f60b71}\label{class_eigen_1_1_sparse_matrix_a2d82c0cbc0c3996b5d1b8b89a5f60b71}} 
{\footnotesize template$<$typename Diag\+Xpr , typename Func $>$ }\\void {\bfseries assign\+Diagonal} (const Diag\+Xpr diag\+Xpr, const Func \&assign\+Func)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_afec3e1d303327378164371e16d9b49c3}\label{class_eigen_1_1_sparse_matrix_afec3e1d303327378164371e16d9b49c3}} 
E\+I\+G\+E\+N\+\_\+\+S\+T\+R\+O\+N\+G\+\_\+\+I\+N\+L\+I\+NE Scalar \& {\bfseries insert\+At\+By\+Outer\+Inner} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} outer, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} inner, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} dst)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a067731d09fd181ce0a1f10f66c65de14}\label{class_eigen_1_1_sparse_matrix_a067731d09fd181ce0a1f10f66c65de14}} 
Scalar \& {\bfseries insert\+Compressed\+At\+By\+Outer\+Inner} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} outer, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} inner, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} dst)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a21caf616236a1f91620d09abd7582641}\label{class_eigen_1_1_sparse_matrix_a21caf616236a1f91620d09abd7582641}} 
Scalar \& {\bfseries insert\+Uncompressed\+At\+By\+Outer\+Inner} (\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} outer, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} inner, \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} dst)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6ae44163705c2ca028527caa60c8c148}\label{class_eigen_1_1_sparse_matrix_a6ae44163705c2ca028527caa60c8c148}} 
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} {\bfseries m\+\_\+outer\+Size}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_af0c29e0b9abac0a43d228562a3551ddc}\label{class_eigen_1_1_sparse_matrix_af0c29e0b9abac0a43d228562a3551ddc}} 
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} {\bfseries m\+\_\+inner\+Size}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a7969fc27848623744ad1b88c31317728}\label{class_eigen_1_1_sparse_matrix_a7969fc27848623744ad1b88c31317728}} 
Storage\+Index $\ast$ {\bfseries m\+\_\+outer\+Index}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a01652a1dffe9d922a21427997b02cd23}\label{class_eigen_1_1_sparse_matrix_a01652a1dffe9d922a21427997b02cd23}} 
Storage\+Index $\ast$ {\bfseries m\+\_\+inner\+Non\+Zeros}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a140a4a7d53b455ecc94fb858fc9daa9f}\label{class_eigen_1_1_sparse_matrix_a140a4a7d53b455ecc94fb858fc9daa9f}} 
\mbox{\hyperlink{class_eigen_1_1internal_1_1_compressed_storage}{Storage}} {\bfseries m\+\_\+data}
\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a5140946cd5ed916fc012c8f086cf48e3}\label{class_eigen_1_1_sparse_matrix_a5140946cd5ed916fc012c8f086cf48e3}} 
class {\bfseries Sparse\+Vector$<$ Scalar\+\_\+, 0, Storage\+Index\+\_\+ $>$}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a73cc30ad676def82be71665641e5256f}\label{class_eigen_1_1_sparse_matrix_a73cc30ad676def82be71665641e5256f}} 
{\footnotesize template$<$typename , typename , typename , typename , typename $>$ }\\struct {\bfseries internal\+::\+Assignment}
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ae7cb03fccbdb1456601051ffa6522c46}\label{class_eigen_1_1_sparse_matrix_ae7cb03fccbdb1456601051ffa6522c46}} 
std\+::ostream \& {\bfseries operator$<$$<$} (std\+::ostream \&s, const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \&m)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ae7cb03fccbdb1456601051ffa6522c46}\label{class_eigen_1_1_sparse_matrix_ae7cb03fccbdb1456601051ffa6522c46}} 
std\+::ostream \& {\bfseries operator$<$$<$} (std\+::ostream \&s, const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} \&m)
\item 
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ae4a0dbeb79ee3734a3399020d7dfdfbf}\label{class_eigen_1_1_sparse_matrix_ae4a0dbeb79ee3734a3399020d7dfdfbf}} 
{\footnotesize template$<$typename , typename , typename , typename , typename $>$ }\\struct {\bfseries internal\+::\+Assignment}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Scalar\+\_\+, int Options\+\_\+, typename Storage\+Index\+\_\+$>$\newline
class Eigen\+::\+Sparse\+Matrix$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$}

A versatible sparse matrix representation. 

This class implements a more versatile variants of the common {\itshape compressed} row/column storage format. Each colmun\textquotesingle{}s (resp. row) non zeros are stored as a pair of value with associated row (resp. colmiun) index. All the non zeros are stored in a single large buffer. Unlike the {\itshape compressed} format, there might be extra space in between the nonzeros of two successive colmuns (resp. rows) such that insertion of new non-\/zero can be done with limited memory reallocation and copies.

A call to the function \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6400e6e733a7131f9b776d6386d2ed89}{make\+Compressed()}} turns the matrix into the standard {\itshape compressed} format compatible with many library.

More details on this storage sceheme are given in the \mbox{\hyperlink{group___tutorial_sparse}{manual pages}}.


\begin{DoxyTemplParams}{Template Parameters}
{\em Scalar\+\_\+} & the scalar type, i.\+e. the type of the coefficients \\
\hline
{\em Options\+\_\+} & Union of bit flags controlling the storage scheme. Currently the only possibility is Col\+Major or Row\+Major. The default is 0 which means column-\/major. \\
\hline
{\em Storage\+Index\+\_\+} & the type of the indices. It has to be a {\bfseries{signed}} type (e.\+g., short, int, std\+::ptrdiff\+\_\+t). Default is {\ttfamily int}.\\
\hline
\end{DoxyTemplParams}
\begin{DoxyWarning}{Warning}
In Eigen 3.\+2, the undocumented type {\ttfamily Sparse\+Matrix\+::\+Index} was improperly defined as the storage index type (e.\+g., int), whereas it is now (starting from Eigen 3.\+3) deprecated and always defined as \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Eigen\+::\+Index}}. Codes making use of {\ttfamily Sparse\+Matrix\+::\+Index}, might thus likely have to be changed to use {\ttfamily Sparse\+Matrix\+::\+Storage\+Index} instead.
\end{DoxyWarning}
This class can be extended with the help of the plugin mechanism described on the page \mbox{\hyperlink{TopicCustomizing_Plugins}{Extending Matrix\+Base (and other classes)}} by defining the preprocessor symbol {\ttfamily E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a4f28e83ea504f0d8ee76c4b8701939d6}\label{class_eigen_1_1_sparse_matrix_a4f28e83ea504f0d8ee76c4b8701939d6}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!SparseMatrix@{SparseMatrix}}
\index{SparseMatrix@{SparseMatrix}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{SparseMatrix()}{SparseMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/10]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Default constructor yielding an empty {\ttfamily 0} {\ttfamily x} {\ttfamily 0} matrix \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_aa647b5f0462b9986e3c907e9ca7c5984}\label{class_eigen_1_1_sparse_matrix_aa647b5f0462b9986e3c907e9ca7c5984}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!SparseMatrix@{SparseMatrix}}
\index{SparseMatrix@{SparseMatrix}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{SparseMatrix()}{SparseMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/10]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{rows,  }\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{cols }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Constructs a {\itshape rows} {\ttfamily x} {\itshape cols} empty matrix \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ac4a6307cd6ba6b4ee7124d590d3120bf}\label{class_eigen_1_1_sparse_matrix_ac4a6307cd6ba6b4ee7124d590d3120bf}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!SparseMatrix@{SparseMatrix}}
\index{SparseMatrix@{SparseMatrix}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{SparseMatrix()}{SparseMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [3/10]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
template$<$typename Other\+Derived $>$ \\
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_base}{Sparse\+Matrix\+Base}}$<$ Other\+Derived $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Constructs a sparse matrix from the sparse expression {\itshape other} \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a794f49fa972d5d39fc81c0925aae1513}\label{class_eigen_1_1_sparse_matrix_a794f49fa972d5d39fc81c0925aae1513}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!SparseMatrix@{SparseMatrix}}
\index{SparseMatrix@{SparseMatrix}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{SparseMatrix()}{SparseMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [4/10]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
template$<$typename Other\+Derived , unsigned int Up\+Lo$>$ \\
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_eigen_1_1_sparse_self_adjoint_view}{Sparse\+Self\+Adjoint\+View}}$<$ Other\+Derived, Up\+Lo $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Constructs a sparse matrix from the sparse selfadjoint view {\itshape other} \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a85ce452dd42db3db4e262e955f7820aa}\label{class_eigen_1_1_sparse_matrix_a85ce452dd42db3db4e262e955f7820aa}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!SparseMatrix@{SparseMatrix}}
\index{SparseMatrix@{SparseMatrix}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{SparseMatrix()}{SparseMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [5/10]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Copy constructor (it performs a deep copy) \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ac837d39f0ae378ecb132f5ef2d7fa74b}\label{class_eigen_1_1_sparse_matrix_ac837d39f0ae378ecb132f5ef2d7fa74b}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!````~SparseMatrix@{$\sim$SparseMatrix}}
\index{````~SparseMatrix@{$\sim$SparseMatrix}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{$\sim$SparseMatrix()}{~SparseMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::$\sim$\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Destructor \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a4f28e83ea504f0d8ee76c4b8701939d6}\label{class_eigen_1_1_sparse_matrix_a4f28e83ea504f0d8ee76c4b8701939d6}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!SparseMatrix@{SparseMatrix}}
\index{SparseMatrix@{SparseMatrix}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{SparseMatrix()}{SparseMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [6/10]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Default constructor yielding an empty {\ttfamily 0} {\ttfamily x} {\ttfamily 0} matrix \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_aa647b5f0462b9986e3c907e9ca7c5984}\label{class_eigen_1_1_sparse_matrix_aa647b5f0462b9986e3c907e9ca7c5984}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!SparseMatrix@{SparseMatrix}}
\index{SparseMatrix@{SparseMatrix}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{SparseMatrix()}{SparseMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [7/10]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{rows,  }\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{cols }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Constructs a {\itshape rows} {\ttfamily x} {\itshape cols} empty matrix \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ac4a6307cd6ba6b4ee7124d590d3120bf}\label{class_eigen_1_1_sparse_matrix_ac4a6307cd6ba6b4ee7124d590d3120bf}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!SparseMatrix@{SparseMatrix}}
\index{SparseMatrix@{SparseMatrix}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{SparseMatrix()}{SparseMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [8/10]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
template$<$typename Other\+Derived $>$ \\
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_base}{Sparse\+Matrix\+Base}}$<$ Other\+Derived $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Constructs a sparse matrix from the sparse expression {\itshape other} \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a794f49fa972d5d39fc81c0925aae1513}\label{class_eigen_1_1_sparse_matrix_a794f49fa972d5d39fc81c0925aae1513}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!SparseMatrix@{SparseMatrix}}
\index{SparseMatrix@{SparseMatrix}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{SparseMatrix()}{SparseMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [9/10]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
template$<$typename Other\+Derived , unsigned int Up\+Lo$>$ \\
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_eigen_1_1_sparse_self_adjoint_view}{Sparse\+Self\+Adjoint\+View}}$<$ Other\+Derived, Up\+Lo $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Constructs a sparse matrix from the sparse selfadjoint view {\itshape other} \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a85ce452dd42db3db4e262e955f7820aa}\label{class_eigen_1_1_sparse_matrix_a85ce452dd42db3db4e262e955f7820aa}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!SparseMatrix@{SparseMatrix}}
\index{SparseMatrix@{SparseMatrix}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{SparseMatrix()}{SparseMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [10/10]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Copy constructor (it performs a deep copy) \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ac837d39f0ae378ecb132f5ef2d7fa74b}\label{class_eigen_1_1_sparse_matrix_ac837d39f0ae378ecb132f5ef2d7fa74b}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!````~SparseMatrix@{$\sim$SparseMatrix}}
\index{````~SparseMatrix@{$\sim$SparseMatrix}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{$\sim$SparseMatrix()}{~SparseMatrix()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::$\sim$\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Destructor 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a05c9adc323553ed53726acae06fc4c18}\label{class_eigen_1_1_sparse_matrix_a05c9adc323553ed53726acae06fc4c18}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!coeff@{coeff}}
\index{coeff@{coeff}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{coeff()}{coeff()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
Scalar \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::coeff (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{row,  }\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{col }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the value of the matrix at position {\itshape i}, {\itshape j} This function returns Scalar(0) if the element is an explicit {\itshape zero} 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a05c9adc323553ed53726acae06fc4c18}\label{class_eigen_1_1_sparse_matrix_a05c9adc323553ed53726acae06fc4c18}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!coeff@{coeff}}
\index{coeff@{coeff}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{coeff()}{coeff()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
Scalar \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::coeff (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{row,  }\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{col }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the value of the matrix at position {\itshape i}, {\itshape j} This function returns Scalar(0) if the element is an explicit {\itshape zero} 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6e4f970149f1cbab1eecc2a04c291fb1}\label{class_eigen_1_1_sparse_matrix_a6e4f970149f1cbab1eecc2a04c291fb1}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!coeffRef@{coeffRef}}
\index{coeffRef@{coeffRef}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{coeffRef()}{coeffRef()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
Scalar\& \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::coeff\+Ref (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{row,  }\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{col }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a non-\/const reference to the value of the matrix at position {\itshape i}, {\itshape j} 
\end{DoxyReturn}
If the element does not exist then it is inserted via the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ae2d8f72ff86a300b76f9edd67df8d8fd}{insert(\+Index,\+Index)}} function which itself turns the matrix into a non compressed form if that was not the case.

This is a O(log(nnz\+\_\+j)) operation (binary search) plus the cost of \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ae2d8f72ff86a300b76f9edd67df8d8fd}{insert(\+Index,\+Index)}} function if the element does not already exist. \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6e4f970149f1cbab1eecc2a04c291fb1}\label{class_eigen_1_1_sparse_matrix_a6e4f970149f1cbab1eecc2a04c291fb1}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!coeffRef@{coeffRef}}
\index{coeffRef@{coeffRef}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{coeffRef()}{coeffRef()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
Scalar\& \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::coeff\+Ref (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{row,  }\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{col }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a non-\/const reference to the value of the matrix at position {\itshape i}, {\itshape j} 
\end{DoxyReturn}
If the element does not exist then it is inserted via the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ae2d8f72ff86a300b76f9edd67df8d8fd}{insert(\+Index,\+Index)}} function which itself turns the matrix into a non compressed form if that was not the case.

This is a O(log(nnz\+\_\+j)) operation (binary search) plus the cost of \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ae2d8f72ff86a300b76f9edd67df8d8fd}{insert(\+Index,\+Index)}} function if the element does not already exist. \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a36b8cc95234b4e2de38a199b6b2af9fc}\label{class_eigen_1_1_sparse_matrix_a36b8cc95234b4e2de38a199b6b2af9fc}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!cols@{cols}}
\index{cols@{cols}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{cols()}{cols()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::cols (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the number of columns of the matrix 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a36b8cc95234b4e2de38a199b6b2af9fc}\label{class_eigen_1_1_sparse_matrix_a36b8cc95234b4e2de38a199b6b2af9fc}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!cols@{cols}}
\index{cols@{cols}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{cols()}{cols()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::cols (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the number of columns of the matrix 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ab0e43ac03eb34e451e0f16e97ea2afda}\label{class_eigen_1_1_sparse_matrix_ab0e43ac03eb34e451e0f16e97ea2afda}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!conservativeResize@{conservativeResize}}
\index{conservativeResize@{conservativeResize}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{conservativeResize()}{conservativeResize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::conservative\+Resize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{rows,  }\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{cols }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Resizes the matrix to a {\itshape rows} x {\itshape cols} matrix leaving old values untouched.

If the sizes of the matrix are decreased, then the matrix is turned to {\bfseries{uncompressed-\/mode}} and the storage of the out of bounds coefficients is kept and reserved. Call \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6400e6e733a7131f9b776d6386d2ed89}{make\+Compressed()}} to pack the entries and squeeze extra memory.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ad9e36e669468663012b77bf1bff8cc4f}{reserve()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a2feb71dd2ed222057a77ff92b736badc}{set\+Zero()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6400e6e733a7131f9b776d6386d2ed89}{make\+Compressed()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ab0e43ac03eb34e451e0f16e97ea2afda}\label{class_eigen_1_1_sparse_matrix_ab0e43ac03eb34e451e0f16e97ea2afda}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!conservativeResize@{conservativeResize}}
\index{conservativeResize@{conservativeResize}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{conservativeResize()}{conservativeResize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::conservative\+Resize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{rows,  }\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{cols }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Resizes the matrix to a {\itshape rows} x {\itshape cols} matrix leaving old values untouched.

If the sizes of the matrix are decreased, then the matrix is turned to {\bfseries{uncompressed-\/mode}} and the storage of the out of bounds coefficients is kept and reserved. Call \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6400e6e733a7131f9b776d6386d2ed89}{make\+Compressed()}} to pack the entries and squeeze extra memory.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ad9e36e669468663012b77bf1bff8cc4f}{reserve()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a2feb71dd2ed222057a77ff92b736badc}{set\+Zero()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6400e6e733a7131f9b776d6386d2ed89}{make\+Compressed()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ae6f4db56c76e4d374eb8507fbef5bdb5}\label{class_eigen_1_1_sparse_matrix_ae6f4db56c76e4d374eb8507fbef5bdb5}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!diagonal@{diagonal}}
\index{diagonal@{diagonal}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{diagonal()}{diagonal()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{class_eigen_1_1_diagonal}{Diagonal\+Return\+Type}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::diagonal (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a read-\/write expression of the diagonal coefficients. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
If the diagonal entries are written, then all diagonal entries {\bfseries{must}} already exist, otherwise an assertion will be raised. 
\end{DoxyWarning}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ae6f4db56c76e4d374eb8507fbef5bdb5}\label{class_eigen_1_1_sparse_matrix_ae6f4db56c76e4d374eb8507fbef5bdb5}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!diagonal@{diagonal}}
\index{diagonal@{diagonal}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{diagonal()}{diagonal()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{class_eigen_1_1_diagonal}{Diagonal\+Return\+Type}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::diagonal (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a read-\/write expression of the diagonal coefficients. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
If the diagonal entries are written, then all diagonal entries {\bfseries{must}} already exist, otherwise an assertion will be raised. 
\end{DoxyWarning}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a20301b7b657f0948d6a6da68509fb4da}\label{class_eigen_1_1_sparse_matrix_a20301b7b657f0948d6a6da68509fb4da}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!diagonal@{diagonal}}
\index{diagonal@{diagonal}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{diagonal()}{diagonal()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
const \mbox{\hyperlink{class_eigen_1_1_diagonal}{Const\+Diagonal\+Return\+Type}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::diagonal (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a const expression of the diagonal coefficients. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a20301b7b657f0948d6a6da68509fb4da}\label{class_eigen_1_1_sparse_matrix_a20301b7b657f0948d6a6da68509fb4da}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!diagonal@{diagonal}}
\index{diagonal@{diagonal}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{diagonal()}{diagonal()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
const \mbox{\hyperlink{class_eigen_1_1_diagonal}{Const\+Diagonal\+Return\+Type}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::diagonal (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a const expression of the diagonal coefficients. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a0f927d1e7251a78585b12bf451423d4e}\label{class_eigen_1_1_sparse_matrix_a0f927d1e7251a78585b12bf451423d4e}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!innerIndexPtr@{innerIndexPtr}}
\index{innerIndexPtr@{innerIndexPtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{innerIndexPtr()}{innerIndexPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
Storage\+Index$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::inner\+Index\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a non-\/const pointer to the array of inner indices. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a5e9513f7d7336a698a47ff3135d6d555}{value\+Ptr()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6de5655e0e36dfefd9812d65f48092f9}{outer\+Index\+Ptr()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a0f927d1e7251a78585b12bf451423d4e}\label{class_eigen_1_1_sparse_matrix_a0f927d1e7251a78585b12bf451423d4e}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!innerIndexPtr@{innerIndexPtr}}
\index{innerIndexPtr@{innerIndexPtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{innerIndexPtr()}{innerIndexPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
Storage\+Index$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::inner\+Index\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a non-\/const pointer to the array of inner indices. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a5e9513f7d7336a698a47ff3135d6d555}{value\+Ptr()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6de5655e0e36dfefd9812d65f48092f9}{outer\+Index\+Ptr()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ade3e26297390865d80a09d1ce06cc916}\label{class_eigen_1_1_sparse_matrix_ade3e26297390865d80a09d1ce06cc916}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!innerIndexPtr@{innerIndexPtr}}
\index{innerIndexPtr@{innerIndexPtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{innerIndexPtr()}{innerIndexPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
const Storage\+Index$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::inner\+Index\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a const pointer to the array of inner indices. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a5e9513f7d7336a698a47ff3135d6d555}{value\+Ptr()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6de5655e0e36dfefd9812d65f48092f9}{outer\+Index\+Ptr()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ade3e26297390865d80a09d1ce06cc916}\label{class_eigen_1_1_sparse_matrix_ade3e26297390865d80a09d1ce06cc916}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!innerIndexPtr@{innerIndexPtr}}
\index{innerIndexPtr@{innerIndexPtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{innerIndexPtr()}{innerIndexPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
const Storage\+Index$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::inner\+Index\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a const pointer to the array of inner indices. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a5e9513f7d7336a698a47ff3135d6d555}{value\+Ptr()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6de5655e0e36dfefd9812d65f48092f9}{outer\+Index\+Ptr()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a0fa5da473fe96a8ae7fae6f3ca2d5b62}\label{class_eigen_1_1_sparse_matrix_a0fa5da473fe96a8ae7fae6f3ca2d5b62}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!innerNonZeroPtr@{innerNonZeroPtr}}
\index{innerNonZeroPtr@{innerNonZeroPtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{innerNonZeroPtr()}{innerNonZeroPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
Storage\+Index$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::inner\+Non\+Zero\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a non-\/const pointer to the array of the number of non zeros of the inner vectors. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
it returns the null pointer 0 in compressed mode 
\end{DoxyWarning}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a0fa5da473fe96a8ae7fae6f3ca2d5b62}\label{class_eigen_1_1_sparse_matrix_a0fa5da473fe96a8ae7fae6f3ca2d5b62}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!innerNonZeroPtr@{innerNonZeroPtr}}
\index{innerNonZeroPtr@{innerNonZeroPtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{innerNonZeroPtr()}{innerNonZeroPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
Storage\+Index$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::inner\+Non\+Zero\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a non-\/const pointer to the array of the number of non zeros of the inner vectors. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
it returns the null pointer 0 in compressed mode 
\end{DoxyWarning}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a62ba20726a10c2c9d095aed024297a2a}\label{class_eigen_1_1_sparse_matrix_a62ba20726a10c2c9d095aed024297a2a}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!innerNonZeroPtr@{innerNonZeroPtr}}
\index{innerNonZeroPtr@{innerNonZeroPtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{innerNonZeroPtr()}{innerNonZeroPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
const Storage\+Index$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::inner\+Non\+Zero\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a const pointer to the array of the number of non zeros of the inner vectors. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
it returns the null pointer 0 in compressed mode 
\end{DoxyWarning}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a62ba20726a10c2c9d095aed024297a2a}\label{class_eigen_1_1_sparse_matrix_a62ba20726a10c2c9d095aed024297a2a}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!innerNonZeroPtr@{innerNonZeroPtr}}
\index{innerNonZeroPtr@{innerNonZeroPtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{innerNonZeroPtr()}{innerNonZeroPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
const Storage\+Index$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::inner\+Non\+Zero\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a const pointer to the array of the number of non zeros of the inner vectors. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxyWarning}{Warning}
it returns the null pointer 0 in compressed mode 
\end{DoxyWarning}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_aa6411a0a909423d2d843a2e7d8b8e4e7}\label{class_eigen_1_1_sparse_matrix_aa6411a0a909423d2d843a2e7d8b8e4e7}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!innerSize@{innerSize}}
\index{innerSize@{innerSize}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{innerSize()}{innerSize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::inner\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the number of rows (resp. columns) of the matrix if the storage order column major (resp. row major) 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_aa6411a0a909423d2d843a2e7d8b8e4e7}\label{class_eigen_1_1_sparse_matrix_aa6411a0a909423d2d843a2e7d8b8e4e7}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!innerSize@{innerSize}}
\index{innerSize@{innerSize}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{innerSize()}{innerSize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::inner\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the number of rows (resp. columns) of the matrix if the storage order column major (resp. row major) 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ae2d8f72ff86a300b76f9edd67df8d8fd}\label{class_eigen_1_1_sparse_matrix_ae2d8f72ff86a300b76f9edd67df8d8fd}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!insert@{insert}}
\index{insert@{insert}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::Scalar \& \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{row,  }\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{col }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a reference to a novel non zero coefficient with coordinates {\itshape row} x {\itshape col}. The non zero coefficient must {\bfseries{not}} already exist.
\end{DoxyReturn}
If the matrix {\ttfamily $\ast$this} is in compressed mode, then {\ttfamily $\ast$this} is turned into uncompressed mode while reserving room for 2 x this-\/$>$\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_aa6411a0a909423d2d843a2e7d8b8e4e7}{inner\+Size()}} non zeros if \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ad9e36e669468663012b77bf1bff8cc4f}{reserve(\+Index)}} has not been called earlier. In this case, the insertion procedure is optimized for a {\itshape sequential} insertion mode where elements are assumed to be inserted by increasing outer-\/indices.

If that\textquotesingle{}s not the case, then it is strongly recommended to either use a triplet-\/list to assemble the matrix, or to first call reserve(const Sizes\+Type \&) to reserve the appropriate number of non-\/zero elements per inner vector.

Assuming memory has been appropriately reserved, this function performs a sorted insertion in O(1) if the elements of each inner vector are inserted in increasing inner index order, and in O(nnz\+\_\+j) for a random insertion. \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ab3911a1444c1c8afc25c8c205ab7a05c}\label{class_eigen_1_1_sparse_matrix_ab3911a1444c1c8afc25c8c205ab7a05c}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!insert@{insert}}
\index{insert@{insert}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
Scalar\& \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{row,  }\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{col }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a reference to a novel non zero coefficient with coordinates {\itshape row} x {\itshape col}. The non zero coefficient must {\bfseries{not}} already exist.
\end{DoxyReturn}
If the matrix {\ttfamily $\ast$this} is in compressed mode, then {\ttfamily $\ast$this} is turned into uncompressed mode while reserving room for 2 x this-\/$>$\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_aa6411a0a909423d2d843a2e7d8b8e4e7}{inner\+Size()}} non zeros if \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ad9e36e669468663012b77bf1bff8cc4f}{reserve(\+Index)}} has not been called earlier. In this case, the insertion procedure is optimized for a {\itshape sequential} insertion mode where elements are assumed to be inserted by increasing outer-\/indices.

If that\textquotesingle{}s not the case, then it is strongly recommended to either use a triplet-\/list to assemble the matrix, or to first call reserve(const Sizes\+Type \&) to reserve the appropriate number of non-\/zero elements per inner vector.

Assuming memory has been appropriately reserved, this function performs a sorted insertion in O(1) if the elements of each inner vector are inserted in increasing inner index order, and in O(nnz\+\_\+j) for a random insertion. \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a5983337b43e23cf688a00a23e30cfffb}\label{class_eigen_1_1_sparse_matrix_a5983337b43e23cf688a00a23e30cfffb}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!insertFromSortedTriplets@{insertFromSortedTriplets}}
\index{insertFromSortedTriplets@{insertFromSortedTriplets}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{insertFromSortedTriplets()}{insertFromSortedTriplets()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
template$<$typename Input\+Iterators $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::insert\+From\+Sorted\+Triplets (\begin{DoxyParamCaption}\item[{const Input\+Iterators \&}]{begin,  }\item[{const Input\+Iterators \&}]{end }\end{DoxyParamCaption})}

The same as insert\+From\+Triplets but triplets are assumed to be pre-\/sorted. This is faster and requires less temporary storage. Two triplets {\ttfamily a} and {\ttfamily b} are appropriately ordered if\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}}: ((a.col() != b.col()) ? (a.col() < b.col()) : (a.row() < b.row())}
\DoxyCodeLine{\mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}}: ((a.row() != b.row()) ? (a.row() < b.row()) : (a.col() < b.col())}
\end{DoxyCode}
 \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a29f17d24f224a1fb73ab903e2a42aba4}\label{class_eigen_1_1_sparse_matrix_a29f17d24f224a1fb73ab903e2a42aba4}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!insertFromSortedTriplets@{insertFromSortedTriplets}}
\index{insertFromSortedTriplets@{insertFromSortedTriplets}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{insertFromSortedTriplets()}{insertFromSortedTriplets()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
template$<$typename Input\+Iterators , typename Dup\+Functor $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::insert\+From\+Sorted\+Triplets (\begin{DoxyParamCaption}\item[{const Input\+Iterators \&}]{begin,  }\item[{const Input\+Iterators \&}]{end,  }\item[{Dup\+Functor}]{dup\+\_\+func }\end{DoxyParamCaption})}

The same as insert\+From\+Sorted\+Triplets but when duplicates are met the functor {\itshape dup\+\_\+func} is applied\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{value = dup\_func(OldValue, NewValue)}
\end{DoxyCode}
 Here is a C++11 example keeping the latest entry only\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{mat.insertFromSortedTriplets(triplets.begin(), triplets.end(), [] (\textcolor{keyword}{const} Scalar\&,\textcolor{keyword}{const} Scalar \&b) \{ return b; \});}
\end{DoxyCode}
 \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_af5bf43559efce09f5415d6b66aa31d53}\label{class_eigen_1_1_sparse_matrix_af5bf43559efce09f5415d6b66aa31d53}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!insertFromTriplets@{insertFromTriplets}}
\index{insertFromTriplets@{insertFromTriplets}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{insertFromTriplets()}{insertFromTriplets()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
template$<$typename Input\+Iterators $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::insert\+From\+Triplets (\begin{DoxyParamCaption}\item[{const Input\+Iterators \&}]{begin,  }\item[{const Input\+Iterators \&}]{end }\end{DoxyParamCaption})}

Insert a batch of elements into the matrix {\ttfamily $\ast$this} with the list of {\itshape triplets} defined in the half-\/open range from {\itshape begin} to {\itshape end}.

A {\itshape triplet} is a tuple (i,j,value) defining a non-\/zero element. The input list of triplets does not have to be sorted, and may contain duplicated elements. In any case, the result is a {\bfseries{sorted}} and {\bfseries{compressed}} sparse matrix where the duplicates have been summed up. This is a {\itshape O(n)} operation, with {\itshape n} the number of triplet elements. The initial contents of {\ttfamily $\ast$this} are preserved (except for the summation of duplicate elements). The matrix {\ttfamily $\ast$this} must be properly sized beforehand. The sizes are not extracted from the triplet list.

The {\itshape Input\+Iterators} value\+\_\+type must provide the following interface\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Scalar value() \textcolor{keyword}{const}; \textcolor{comment}{// the value}}
\DoxyCodeLine{IndexType \mbox{\hyperlink{group__gtc__matrix__access_ga259e5ebd0f31ec3f83440f8cae7f5dba}{row}}() \textcolor{keyword}{const};   \textcolor{comment}{// the row index i}}
\DoxyCodeLine{IndexType col() \textcolor{keyword}{const};   \textcolor{comment}{// the column index j}}
\end{DoxyCode}
 See for instance the \mbox{\hyperlink{class_eigen_1_1_triplet}{Eigen\+::\+Triplet}} template class.

Here is a typical usage example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{SparseMatrixType m(\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a853a76dd42349fa2f3654a4a61e0f574}{rows}},\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a36b8cc95234b4e2de38a199b6b2af9fc}{cols}}); \textcolor{comment}{// m contains nonzero entries}}
\DoxyCodeLine{\textcolor{keyword}{typedef} Triplet<double> \mbox{\hyperlink{class_eigen_1_1_triplet}{T}};}
\DoxyCodeLine{std::vector<T> tripletList;}
\DoxyCodeLine{tripletList.reserve(estimation\_of\_entries);}
\DoxyCodeLine{\textcolor{keywordflow}{for}(...)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{  tripletList.push\_back(\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}(i,j,v\_ij));}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{m.insertFromTriplets(tripletList.begin(), tripletList.end());}
\DoxyCodeLine{\textcolor{comment}{// m is ready to go!}}
\end{DoxyCode}


\begin{DoxyWarning}{Warning}
The list of triplets is read multiple times (at least twice). Therefore, it is not recommended to define an abstract iterator over a complex data-\/structure that would be expensive to evaluate. The triplets should rather be explicitly stored into a std\+::vector for instance. 
\end{DoxyWarning}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ab452919fafc44dc6f8407fe4e5ffeddd}\label{class_eigen_1_1_sparse_matrix_ab452919fafc44dc6f8407fe4e5ffeddd}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!insertFromTriplets@{insertFromTriplets}}
\index{insertFromTriplets@{insertFromTriplets}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{insertFromTriplets()}{insertFromTriplets()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
template$<$typename Input\+Iterators , typename Dup\+Functor $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::insert\+From\+Triplets (\begin{DoxyParamCaption}\item[{const Input\+Iterators \&}]{begin,  }\item[{const Input\+Iterators \&}]{end,  }\item[{Dup\+Functor}]{dup\+\_\+func }\end{DoxyParamCaption})}

The same as insert\+From\+Triplets but when duplicates are met the functor {\itshape dup\+\_\+func} is applied\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{value = dup\_func(OldValue, NewValue)}
\end{DoxyCode}
 Here is a C++11 example keeping the latest entry only\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{mat.insertFromTriplets(triplets.begin(), triplets.end(), [] (\textcolor{keyword}{const} Scalar\&,\textcolor{keyword}{const} Scalar \&b) \{ return b; \});}
\end{DoxyCode}
 \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ae257333ca0e0b16cf5d3080bbefeaf47}\label{class_eigen_1_1_sparse_matrix_ae257333ca0e0b16cf5d3080bbefeaf47}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!isCompressed@{isCompressed}}
\index{isCompressed@{isCompressed}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{isCompressed()}{isCompressed()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
bool Eigen\+::\+Sparse\+Compressed\+Base\+::is\+Compressed\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
whether {\ttfamily $\ast$this} is in compressed form. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ae257333ca0e0b16cf5d3080bbefeaf47}\label{class_eigen_1_1_sparse_matrix_ae257333ca0e0b16cf5d3080bbefeaf47}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!isCompressed@{isCompressed}}
\index{isCompressed@{isCompressed}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{isCompressed()}{isCompressed()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
bool Eigen\+::\+Sparse\+Compressed\+Base\+::is\+Compressed\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
whether {\ttfamily $\ast$this} is in compressed form. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ae257333ca0e0b16cf5d3080bbefeaf47}\label{class_eigen_1_1_sparse_matrix_ae257333ca0e0b16cf5d3080bbefeaf47}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!isCompressed@{isCompressed}}
\index{isCompressed@{isCompressed}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{isCompressed()}{isCompressed()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
bool Eigen\+::\+Sparse\+Compressed\+Base\+::is\+Compressed\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
whether {\ttfamily $\ast$this} is in compressed form. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ae257333ca0e0b16cf5d3080bbefeaf47}\label{class_eigen_1_1_sparse_matrix_ae257333ca0e0b16cf5d3080bbefeaf47}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!isCompressed@{isCompressed}}
\index{isCompressed@{isCompressed}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{isCompressed()}{isCompressed()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
bool Eigen\+::\+Sparse\+Compressed\+Base\+::is\+Compressed\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
whether {\ttfamily $\ast$this} is in compressed form. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6400e6e733a7131f9b776d6386d2ed89}\label{class_eigen_1_1_sparse_matrix_a6400e6e733a7131f9b776d6386d2ed89}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!makeCompressed@{makeCompressed}}
\index{makeCompressed@{makeCompressed}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{makeCompressed()}{makeCompressed()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::make\+Compressed (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Turns the matrix into the {\itshape compressed} format. \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6400e6e733a7131f9b776d6386d2ed89}\label{class_eigen_1_1_sparse_matrix_a6400e6e733a7131f9b776d6386d2ed89}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!makeCompressed@{makeCompressed}}
\index{makeCompressed@{makeCompressed}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{makeCompressed()}{makeCompressed()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::make\+Compressed (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Turns the matrix into the {\itshape compressed} format. \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ae53743108cd668b8da927ff149631fe0}\label{class_eigen_1_1_sparse_matrix_ae53743108cd668b8da927ff149631fe0}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!nonZeros@{nonZeros}}
\index{nonZeros@{nonZeros}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{nonZeros()}{nonZeros()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} Eigen\+::\+Sparse\+Compressed\+Base\+::non\+Zeros\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the number of non zero coefficients 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ae53743108cd668b8da927ff149631fe0}\label{class_eigen_1_1_sparse_matrix_ae53743108cd668b8da927ff149631fe0}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!nonZeros@{nonZeros}}
\index{nonZeros@{nonZeros}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{nonZeros()}{nonZeros()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} Eigen\+::\+Sparse\+Compressed\+Base\+::non\+Zeros\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the number of non zero coefficients 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ae53743108cd668b8da927ff149631fe0}\label{class_eigen_1_1_sparse_matrix_ae53743108cd668b8da927ff149631fe0}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!nonZeros@{nonZeros}}
\index{nonZeros@{nonZeros}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{nonZeros()}{nonZeros()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} Eigen\+::\+Sparse\+Compressed\+Base\+::non\+Zeros\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the number of non zero coefficients 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ae53743108cd668b8da927ff149631fe0}\label{class_eigen_1_1_sparse_matrix_ae53743108cd668b8da927ff149631fe0}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!nonZeros@{nonZeros}}
\index{nonZeros@{nonZeros}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{nonZeros()}{nonZeros()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} Eigen\+::\+Sparse\+Compressed\+Base\+::non\+Zeros\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the number of non zero coefficients 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6de5655e0e36dfefd9812d65f48092f9}\label{class_eigen_1_1_sparse_matrix_a6de5655e0e36dfefd9812d65f48092f9}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!outerIndexPtr@{outerIndexPtr}}
\index{outerIndexPtr@{outerIndexPtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{outerIndexPtr()}{outerIndexPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
Storage\+Index$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::outer\+Index\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a non-\/const pointer to the array of the starting positions of the inner vectors. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a5e9513f7d7336a698a47ff3135d6d555}{value\+Ptr()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a0f927d1e7251a78585b12bf451423d4e}{inner\+Index\+Ptr()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6de5655e0e36dfefd9812d65f48092f9}\label{class_eigen_1_1_sparse_matrix_a6de5655e0e36dfefd9812d65f48092f9}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!outerIndexPtr@{outerIndexPtr}}
\index{outerIndexPtr@{outerIndexPtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{outerIndexPtr()}{outerIndexPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
Storage\+Index$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::outer\+Index\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a non-\/const pointer to the array of the starting positions of the inner vectors. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a5e9513f7d7336a698a47ff3135d6d555}{value\+Ptr()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a0f927d1e7251a78585b12bf451423d4e}{inner\+Index\+Ptr()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ad2d1a4d9033c2bc0917ea09cdc5c700c}\label{class_eigen_1_1_sparse_matrix_ad2d1a4d9033c2bc0917ea09cdc5c700c}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!outerIndexPtr@{outerIndexPtr}}
\index{outerIndexPtr@{outerIndexPtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{outerIndexPtr()}{outerIndexPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
const Storage\+Index$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::outer\+Index\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a const pointer to the array of the starting positions of the inner vectors. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a5e9513f7d7336a698a47ff3135d6d555}{value\+Ptr()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a0f927d1e7251a78585b12bf451423d4e}{inner\+Index\+Ptr()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ad2d1a4d9033c2bc0917ea09cdc5c700c}\label{class_eigen_1_1_sparse_matrix_ad2d1a4d9033c2bc0917ea09cdc5c700c}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!outerIndexPtr@{outerIndexPtr}}
\index{outerIndexPtr@{outerIndexPtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{outerIndexPtr()}{outerIndexPtr()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
const Storage\+Index$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::outer\+Index\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a const pointer to the array of the starting positions of the inner vectors. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a5e9513f7d7336a698a47ff3135d6d555}{value\+Ptr()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a0f927d1e7251a78585b12bf451423d4e}{inner\+Index\+Ptr()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a47c7cdf3c713ea69d08387aaf78e0c53}\label{class_eigen_1_1_sparse_matrix_a47c7cdf3c713ea69d08387aaf78e0c53}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!outerSize@{outerSize}}
\index{outerSize@{outerSize}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{outerSize()}{outerSize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::outer\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the number of columns (resp. rows) of the matrix if the storage order column major (resp. row major) 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a47c7cdf3c713ea69d08387aaf78e0c53}\label{class_eigen_1_1_sparse_matrix_a47c7cdf3c713ea69d08387aaf78e0c53}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!outerSize@{outerSize}}
\index{outerSize@{outerSize}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{outerSize()}{outerSize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::outer\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the number of columns (resp. rows) of the matrix if the storage order column major (resp. row major) 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_aca3916ec112e13c513380b47fad7954b}\label{class_eigen_1_1_sparse_matrix_aca3916ec112e13c513380b47fad7954b}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!prune@{prune}}
\index{prune@{prune}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{prune()}{prune()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
template$<$typename Keep\+Func $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::prune (\begin{DoxyParamCaption}\item[{const Keep\+Func \&}]{keep = {\ttfamily KeepFunc()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Turns the matrix into compressed format, and suppresses all nonzeros which do not satisfy the predicate {\itshape keep}. The functor type {\itshape Keep\+Func} must implement the following function\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{bool} operator() (\textcolor{keyword}{const} \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}\& \mbox{\hyperlink{group__gtc__matrix__access_ga259e5ebd0f31ec3f83440f8cae7f5dba}{row}}, \textcolor{keyword}{const} \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}\& col, \textcolor{keyword}{const} Scalar\& value) \textcolor{keyword}{const};}
\end{DoxyCode}
 \begin{DoxySeeAlso}{See also}
prune(\+Scalar,\+Real\+Scalar) 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_aca3916ec112e13c513380b47fad7954b}\label{class_eigen_1_1_sparse_matrix_aca3916ec112e13c513380b47fad7954b}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!prune@{prune}}
\index{prune@{prune}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{prune()}{prune()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
template$<$typename Keep\+Func $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::prune (\begin{DoxyParamCaption}\item[{const Keep\+Func \&}]{keep = {\ttfamily KeepFunc()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Turns the matrix into compressed format, and suppresses all nonzeros which do not satisfy the predicate {\itshape keep}. The functor type {\itshape Keep\+Func} must implement the following function\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{bool} operator() (\textcolor{keyword}{const} \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}\& \mbox{\hyperlink{group__gtc__matrix__access_ga259e5ebd0f31ec3f83440f8cae7f5dba}{row}}, \textcolor{keyword}{const} \mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}\& col, \textcolor{keyword}{const} Scalar\& value) \textcolor{keyword}{const};}
\end{DoxyCode}
 \begin{DoxySeeAlso}{See also}
prune(\+Scalar,\+Real\+Scalar) 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ab4b7ffe0c08f653f5c34b02b9b12e6bf}\label{class_eigen_1_1_sparse_matrix_ab4b7ffe0c08f653f5c34b02b9b12e6bf}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!prune@{prune}}
\index{prune@{prune}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{prune()}{prune()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::prune (\begin{DoxyParamCaption}\item[{const Scalar \&}]{reference,  }\item[{const Real\+Scalar \&}]{epsilon = {\ttfamily \mbox{\hyperlink{struct_eigen_1_1_num_traits}{Num\+Traits}}$<$RealScalar$>$\+:\+:dummy\+\_\+precision()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Suppresses all nonzeros which are {\bfseries{much}} {\bfseries{smaller}} {\bfseries{than}} {\itshape reference} under the tolerance {\itshape epsilon} \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ab4b7ffe0c08f653f5c34b02b9b12e6bf}\label{class_eigen_1_1_sparse_matrix_ab4b7ffe0c08f653f5c34b02b9b12e6bf}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!prune@{prune}}
\index{prune@{prune}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{prune()}{prune()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::prune (\begin{DoxyParamCaption}\item[{const Scalar \&}]{reference,  }\item[{const Real\+Scalar \&}]{epsilon = {\ttfamily \mbox{\hyperlink{struct_eigen_1_1_num_traits}{Num\+Traits}}$<$RealScalar$>$\+:\+:dummy\+\_\+precision()} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Suppresses all nonzeros which are {\bfseries{much}} {\bfseries{smaller}} {\bfseries{than}} {\itshape reference} under the tolerance {\itshape epsilon} \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ad9e36e669468663012b77bf1bff8cc4f}\label{class_eigen_1_1_sparse_matrix_ad9e36e669468663012b77bf1bff8cc4f}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!reserve@{reserve}}
\index{reserve@{reserve}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{reserve()}{reserve()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::reserve (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{reserve\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Preallocates {\itshape reserve\+Size} non zeros.

Precondition\+: the matrix must be in compressed mode. \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ad9e36e669468663012b77bf1bff8cc4f}\label{class_eigen_1_1_sparse_matrix_ad9e36e669468663012b77bf1bff8cc4f}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!reserve@{reserve}}
\index{reserve@{reserve}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{reserve()}{reserve()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::reserve (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{reserve\+Size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Preallocates {\itshape reserve\+Size} non zeros.

Precondition\+: the matrix must be in compressed mode. \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a835ae5b304ddbb187eac25d5850b2ced}\label{class_eigen_1_1_sparse_matrix_a835ae5b304ddbb187eac25d5850b2ced}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!resize@{resize}}
\index{resize@{resize}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{resize()}{resize()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::resize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{rows,  }\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{cols }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Resizes the matrix to a {\itshape rows} x {\itshape cols} matrix and initializes it to zero.

This function does not free the currently allocated memory. To release as much as memory as possible, call
\begin{DoxyCode}{0}
\DoxyCodeLine{mat.data().squeeze(); }
\end{DoxyCode}
 after resizing it.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ad9e36e669468663012b77bf1bff8cc4f}{reserve()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a2feb71dd2ed222057a77ff92b736badc}{set\+Zero()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a835ae5b304ddbb187eac25d5850b2ced}\label{class_eigen_1_1_sparse_matrix_a835ae5b304ddbb187eac25d5850b2ced}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!resize@{resize}}
\index{resize@{resize}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{resize()}{resize()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::resize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{rows,  }\item[{\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}}}]{cols }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Resizes the matrix to a {\itshape rows} x {\itshape cols} matrix and initializes it to zero.

This function does not free the currently allocated memory. To release as much as memory as possible, call
\begin{DoxyCode}{0}
\DoxyCodeLine{mat.data().squeeze(); }
\end{DoxyCode}
 after resizing it.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_ad9e36e669468663012b77bf1bff8cc4f}{reserve()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a2feb71dd2ed222057a77ff92b736badc}{set\+Zero()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a853a76dd42349fa2f3654a4a61e0f574}\label{class_eigen_1_1_sparse_matrix_a853a76dd42349fa2f3654a4a61e0f574}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!rows@{rows}}
\index{rows@{rows}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{rows()}{rows()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::rows (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the number of rows of the matrix 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a853a76dd42349fa2f3654a4a61e0f574}\label{class_eigen_1_1_sparse_matrix_a853a76dd42349fa2f3654a4a61e0f574}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!rows@{rows}}
\index{rows@{rows}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{rows()}{rows()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Index}} \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::rows (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
the number of rows of the matrix 
\end{DoxyReturn}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a39c6b1ee045d58ced163b140b9c6bf36}\label{class_eigen_1_1_sparse_matrix_a39c6b1ee045d58ced163b140b9c6bf36}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!setFromSortedTriplets@{setFromSortedTriplets}}
\index{setFromSortedTriplets@{setFromSortedTriplets}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{setFromSortedTriplets()}{setFromSortedTriplets()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
template$<$typename Input\+Iterators $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::set\+From\+Sorted\+Triplets (\begin{DoxyParamCaption}\item[{const Input\+Iterators \&}]{begin,  }\item[{const Input\+Iterators \&}]{end }\end{DoxyParamCaption})}

The same as set\+From\+Triplets but triplets are assumed to be pre-\/sorted. This is faster and requires less temporary storage. Two triplets {\ttfamily a} and {\ttfamily b} are appropriately ordered if\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13a0cbd4bdd0abcfc0224c5fcb5e4f6669a}{ColMajor}}: ((a.col() != b.col()) ? (a.col() < b.col()) : (a.row() < b.row())}
\DoxyCodeLine{\mbox{\hyperlink{group__enums_ggaacded1a18ae58b0f554751f6cdf9eb13acfcde9cd8677c5f7caf6bd603666aae3}{RowMajor}}: ((a.row() != b.row()) ? (a.row() < b.row()) : (a.col() < b.col())}
\end{DoxyCode}
 \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a73841eccfc1066680c7bed8bf98ec3e1}\label{class_eigen_1_1_sparse_matrix_a73841eccfc1066680c7bed8bf98ec3e1}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!setFromSortedTriplets@{setFromSortedTriplets}}
\index{setFromSortedTriplets@{setFromSortedTriplets}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{setFromSortedTriplets()}{setFromSortedTriplets()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
template$<$typename Input\+Iterators , typename Dup\+Functor $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::set\+From\+Sorted\+Triplets (\begin{DoxyParamCaption}\item[{const Input\+Iterators \&}]{begin,  }\item[{const Input\+Iterators \&}]{end,  }\item[{Dup\+Functor}]{dup\+\_\+func }\end{DoxyParamCaption})}

The same as set\+From\+Sorted\+Triplets but when duplicates are met the functor {\itshape dup\+\_\+func} is applied\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{value = dup\_func(OldValue, NewValue)}
\end{DoxyCode}
 Here is a C++11 example keeping the latest entry only\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{mat.setFromSortedTriplets(triplets.begin(), triplets.end(), [] (\textcolor{keyword}{const} Scalar\&,\textcolor{keyword}{const} Scalar \&b) \{ return b; \});}
\end{DoxyCode}
 \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a8f09e3597f37aa8861599260af6a53e0}\label{class_eigen_1_1_sparse_matrix_a8f09e3597f37aa8861599260af6a53e0}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!setFromTriplets@{setFromTriplets}}
\index{setFromTriplets@{setFromTriplets}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{setFromTriplets()}{setFromTriplets()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
template$<$typename Input\+Iterators $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::set\+From\+Triplets (\begin{DoxyParamCaption}\item[{const Input\+Iterators \&}]{begin,  }\item[{const Input\+Iterators \&}]{end }\end{DoxyParamCaption})}

Fill the matrix {\ttfamily $\ast$this} with the list of {\itshape triplets} defined by the iterator range {\itshape begin} -\/ {\itshape end}.

A {\itshape triplet} is a tuple (i,j,value) defining a non-\/zero element. The input list of triplets does not have to be sorted, and can contains duplicated elements. In any case, the result is a {\bfseries{sorted}} and {\bfseries{compressed}} sparse matrix where the duplicates have been summed up. This is a {\itshape O(n)} operation, with {\itshape n} the number of triplet elements. The initial contents of {\ttfamily $\ast$this} is destroyed. The matrix {\ttfamily $\ast$this} must be properly resized beforehand using the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_aa647b5f0462b9986e3c907e9ca7c5984}{Sparse\+Matrix(\+Index,\+Index)}} constructor, or the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a835ae5b304ddbb187eac25d5850b2ced}{resize(\+Index,\+Index)}} method. The sizes are not extracted from the triplet list.

The {\itshape Input\+Iterators} value\+\_\+type must provide the following interface\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Scalar value() \textcolor{keyword}{const}; \textcolor{comment}{// the value}}
\DoxyCodeLine{Scalar \mbox{\hyperlink{group__gtc__matrix__access_ga259e5ebd0f31ec3f83440f8cae7f5dba}{row}}() \textcolor{keyword}{const};   \textcolor{comment}{// the row index i}}
\DoxyCodeLine{Scalar col() \textcolor{keyword}{const};   \textcolor{comment}{// the column index j}}
\end{DoxyCode}
 See for instance the \mbox{\hyperlink{class_eigen_1_1_triplet}{Eigen\+::\+Triplet}} template class.

Here is a typical usage example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} Triplet<double> \mbox{\hyperlink{class_eigen_1_1_triplet}{T}};}
\DoxyCodeLine{std::vector<T> tripletList;}
\DoxyCodeLine{tripletList.reserve(estimation\_of\_entries);}
\DoxyCodeLine{\textcolor{keywordflow}{for}(...)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{  tripletList.push\_back(\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}(i,j,v\_ij));}
\DoxyCodeLine{\}}
\DoxyCodeLine{SparseMatrixType m(\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a853a76dd42349fa2f3654a4a61e0f574}{rows}},\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a36b8cc95234b4e2de38a199b6b2af9fc}{cols}});}
\DoxyCodeLine{m.setFromTriplets(tripletList.begin(), tripletList.end());}
\DoxyCodeLine{\textcolor{comment}{// m is ready to go!}}
\end{DoxyCode}


\begin{DoxyWarning}{Warning}
The list of triplets is read multiple times (at least twice). Therefore, it is not recommended to define an abstract iterator over a complex data-\/structure that would be expensive to evaluate. The triplets should rather be explicitly stored into a std\+::vector for instance.
\end{DoxyWarning}
Fill the matrix {\ttfamily $\ast$this} with the list of {\itshape triplets} defined in the half-\/open range from {\itshape begin} to {\itshape end}.

A {\itshape triplet} is a tuple (i,j,value) defining a non-\/zero element. The input list of triplets does not have to be sorted, and may contain duplicated elements. In any case, the result is a {\bfseries{sorted}} and {\bfseries{compressed}} sparse matrix where the duplicates have been summed up. This is a {\itshape O(n)} operation, with {\itshape n} the number of triplet elements. The initial contents of {\ttfamily $\ast$this} are destroyed. The matrix {\ttfamily $\ast$this} must be properly resized beforehand using the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_aa647b5f0462b9986e3c907e9ca7c5984}{Sparse\+Matrix(\+Index,\+Index)}} constructor, or the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a835ae5b304ddbb187eac25d5850b2ced}{resize(\+Index,\+Index)}} method. The sizes are not extracted from the triplet list.

The {\itshape Input\+Iterators} value\+\_\+type must provide the following interface\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Scalar value() \textcolor{keyword}{const}; \textcolor{comment}{// the value}}
\DoxyCodeLine{IndexType \mbox{\hyperlink{group__gtc__matrix__access_ga259e5ebd0f31ec3f83440f8cae7f5dba}{row}}() \textcolor{keyword}{const};   \textcolor{comment}{// the row index i}}
\DoxyCodeLine{IndexType col() \textcolor{keyword}{const};   \textcolor{comment}{// the column index j}}
\end{DoxyCode}
 See for instance the \mbox{\hyperlink{class_eigen_1_1_triplet}{Eigen\+::\+Triplet}} template class.

Here is a typical usage example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} Triplet<double> \mbox{\hyperlink{class_eigen_1_1_triplet}{T}};}
\DoxyCodeLine{std::vector<T> tripletList;}
\DoxyCodeLine{tripletList.reserve(estimation\_of\_entries);}
\DoxyCodeLine{\textcolor{keywordflow}{for}(...)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{  tripletList.push\_back(\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}(i,j,v\_ij));}
\DoxyCodeLine{\}}
\DoxyCodeLine{SparseMatrixType m(\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a853a76dd42349fa2f3654a4a61e0f574}{rows}},\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a36b8cc95234b4e2de38a199b6b2af9fc}{cols}});}
\DoxyCodeLine{m.setFromTriplets(tripletList.begin(), tripletList.end());}
\DoxyCodeLine{\textcolor{comment}{// m is ready to go!}}
\end{DoxyCode}


\begin{DoxyWarning}{Warning}
The list of triplets is read multiple times (at least twice). Therefore, it is not recommended to define an abstract iterator over a complex data-\/structure that would be expensive to evaluate. The triplets should rather be explicitly stored into a std\+::vector for instance. 
\end{DoxyWarning}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a3e8c96b7dd72d03f14b5cf40f5005d55}\label{class_eigen_1_1_sparse_matrix_a3e8c96b7dd72d03f14b5cf40f5005d55}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!setFromTriplets@{setFromTriplets}}
\index{setFromTriplets@{setFromTriplets}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{setFromTriplets()}{setFromTriplets()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
template$<$typename Input\+Iterators , typename Dup\+Functor $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::set\+From\+Triplets (\begin{DoxyParamCaption}\item[{const Input\+Iterators \&}]{begin,  }\item[{const Input\+Iterators \&}]{end,  }\item[{Dup\+Functor}]{dup\+\_\+func }\end{DoxyParamCaption})}

The same as set\+From\+Triplets but when duplicates are met the functor {\itshape dup\+\_\+func} is applied\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{value = dup\_func(OldValue, NewValue)}
\end{DoxyCode}
 Here is a C++11 example keeping the latest entry only\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{mat.setFromTriplets(triplets.begin(), triplets.end(), [] (\textcolor{keyword}{const} Scalar\&,\textcolor{keyword}{const} Scalar \&b) \{ return b; \});}
\end{DoxyCode}
 \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_aa4064cc1e3a4038cf09ff03af5a3ffb5}\label{class_eigen_1_1_sparse_matrix_aa4064cc1e3a4038cf09ff03af5a3ffb5}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!setIdentity@{setIdentity}}
\index{setIdentity@{setIdentity}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{setIdentity()}{setIdentity()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::set\+Identity (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Sets $\ast$this to the identity matrix. This function also turns the matrix into compressed mode, and drop any reserved memory. \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_aa4064cc1e3a4038cf09ff03af5a3ffb5}\label{class_eigen_1_1_sparse_matrix_aa4064cc1e3a4038cf09ff03af5a3ffb5}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!setIdentity@{setIdentity}}
\index{setIdentity@{setIdentity}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{setIdentity()}{setIdentity()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::set\+Identity (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Sets $\ast$this to the identity matrix. This function also turns the matrix into compressed mode, and drop any reserved memory. \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a2feb71dd2ed222057a77ff92b736badc}\label{class_eigen_1_1_sparse_matrix_a2feb71dd2ed222057a77ff92b736badc}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!setZero@{setZero}}
\index{setZero@{setZero}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{setZero()}{setZero()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::set\+Zero (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Removes all non zeros but keep allocated memory

This function does not free the currently allocated memory. To release as much as memory as possible, call
\begin{DoxyCode}{0}
\DoxyCodeLine{mat.data().squeeze(); }
\end{DoxyCode}
 after resizing it.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a835ae5b304ddbb187eac25d5850b2ced}{resize(\+Index,\+Index)}}, data() 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a2feb71dd2ed222057a77ff92b736badc}\label{class_eigen_1_1_sparse_matrix_a2feb71dd2ed222057a77ff92b736badc}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!setZero@{setZero}}
\index{setZero@{setZero}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{setZero()}{setZero()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::set\+Zero (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Removes all non zeros but keep allocated memory

This function does not free the currently allocated memory. To release as much as memory as possible, call
\begin{DoxyCode}{0}
\DoxyCodeLine{mat.data().squeeze(); }
\end{DoxyCode}
 after resizing it.

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a835ae5b304ddbb187eac25d5850b2ced}{resize(\+Index,\+Index)}}, data() 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_ad2b635a54bf2fe66facd1cb1872aae9f}\label{class_eigen_1_1_sparse_matrix_ad2b635a54bf2fe66facd1cb1872aae9f}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!sum@{sum}}
\index{sum@{sum}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{sum()}{sum()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Index\+\_\+ $>$ \\
\mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}}$<$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Index\+\_\+ $>$ $>$\+::Scalar \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Index\+\_\+ $>$\+::sum}

Overloaded for performance \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a5bfe2c81a8afbd1bf2aa991a673c486d}\label{class_eigen_1_1_sparse_matrix_a5bfe2c81a8afbd1bf2aa991a673c486d}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!sum@{sum}}
\index{sum@{sum}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{sum()}{sum()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
Scalar \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::sum (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Overloaded for performance \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a20eec45a940a4dd7edcacfa21468b328}\label{class_eigen_1_1_sparse_matrix_a20eec45a940a4dd7edcacfa21468b328}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!swap@{swap}}
\index{swap@{swap}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{swap()}{swap()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::swap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Swaps the content of two sparse matrices of the same type. This is a fast operation that simply swaps the underlying pointers and parameters. \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a20eec45a940a4dd7edcacfa21468b328}\label{class_eigen_1_1_sparse_matrix_a20eec45a940a4dd7edcacfa21468b328}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!swap@{swap}}
\index{swap@{swap}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{swap()}{swap()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::swap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$ \&}]{other }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Swaps the content of two sparse matrices of the same type. This is a fast operation that simply swaps the underlying pointers and parameters. \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a542c2a877dcffbd48248b43d3eaf670f}\label{class_eigen_1_1_sparse_matrix_a542c2a877dcffbd48248b43d3eaf670f}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!uncompress@{uncompress}}
\index{uncompress@{uncompress}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{uncompress()}{uncompress()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::uncompress (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Turns the matrix into the uncompressed mode \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a542c2a877dcffbd48248b43d3eaf670f}\label{class_eigen_1_1_sparse_matrix_a542c2a877dcffbd48248b43d3eaf670f}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!uncompress@{uncompress}}
\index{uncompress@{uncompress}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{uncompress()}{uncompress()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
void \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::uncompress (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Turns the matrix into the uncompressed mode \mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a5e9513f7d7336a698a47ff3135d6d555}\label{class_eigen_1_1_sparse_matrix_a5e9513f7d7336a698a47ff3135d6d555}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!valuePtr@{valuePtr}}
\index{valuePtr@{valuePtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{valuePtr()}{valuePtr()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
Scalar$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::value\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a non-\/const pointer to the array of values. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a0f927d1e7251a78585b12bf451423d4e}{inner\+Index\+Ptr()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6de5655e0e36dfefd9812d65f48092f9}{outer\+Index\+Ptr()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a5e9513f7d7336a698a47ff3135d6d555}\label{class_eigen_1_1_sparse_matrix_a5e9513f7d7336a698a47ff3135d6d555}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!valuePtr@{valuePtr}}
\index{valuePtr@{valuePtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{valuePtr()}{valuePtr()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
Scalar$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::value\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a non-\/const pointer to the array of values. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a0f927d1e7251a78585b12bf451423d4e}{inner\+Index\+Ptr()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6de5655e0e36dfefd9812d65f48092f9}{outer\+Index\+Ptr()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6ed99bab9d4f142c629f69a93a2d1efb}\label{class_eigen_1_1_sparse_matrix_a6ed99bab9d4f142c629f69a93a2d1efb}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!valuePtr@{valuePtr}}
\index{valuePtr@{valuePtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{valuePtr()}{valuePtr()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
const Scalar$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::value\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a const pointer to the array of values. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a0f927d1e7251a78585b12bf451423d4e}{inner\+Index\+Ptr()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6de5655e0e36dfefd9812d65f48092f9}{outer\+Index\+Ptr()}} 
\end{DoxySeeAlso}
\mbox{\Hypertarget{class_eigen_1_1_sparse_matrix_a6ed99bab9d4f142c629f69a93a2d1efb}\label{class_eigen_1_1_sparse_matrix_a6ed99bab9d4f142c629f69a93a2d1efb}} 
\index{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}!valuePtr@{valuePtr}}
\index{valuePtr@{valuePtr}!Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$@{Eigen::SparseMatrix$<$ Scalar\_, Options\_, StorageIndex\_ $>$}}
\doxysubsubsection{\texorpdfstring{valuePtr()}{valuePtr()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename Scalar\+\_\+ , int Options\+\_\+, typename Storage\+Index\+\_\+ $>$ \\
const Scalar$\ast$ \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Eigen\+::\+Sparse\+Matrix}}$<$ Scalar\+\_\+, Options\+\_\+, Storage\+Index\+\_\+ $>$\+::value\+Ptr (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

\begin{DoxyReturn}{Returns}
a const pointer to the array of values. This function is aimed at interoperability with other libraries. 
\end{DoxyReturn}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a0f927d1e7251a78585b12bf451423d4e}{inner\+Index\+Ptr()}}, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_a6de5655e0e36dfefd9812d65f48092f9}{outer\+Index\+Ptr()}} 
\end{DoxySeeAlso}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/eigen/\+Eigen/src/\+Sparse\+Core/Sparse\+Matrix.\+h\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/eigen/\+Eigen/src/\+Sparse\+Core/Sparse\+Product.\+h\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/eigen/\+Eigen/src/\+Sparse\+Core/Sparse\+Redux.\+h\end{DoxyCompactItemize}
