\hypertarget{class_steinberg_1_1_i_attributes}{}\doxysection{Steinberg\+::I\+Attributes Class Reference}
\label{class_steinberg_1_1_i_attributes}\index{Steinberg::IAttributes@{Steinberg::IAttributes}}


{\ttfamily \#include $<$ipersistent.\+h$>$}

Inheritance diagram for Steinberg\+::I\+Attributes\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{class_steinberg_1_1_i_attributes}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{Indent}\textbf{ Methods to write attributes}\par
\begin{DoxyCompactItemize}
\item 
virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI \mbox{\hyperlink{class_steinberg_1_1_i_attributes_a121fdb525b5967e17d851daee6e1819f}{set}} (I\+Attr\+ID attr\+ID, const \mbox{\hyperlink{class_steinberg_1_1_f_variant}{F\+Variant}} \&data)=0
\item 
virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI \mbox{\hyperlink{class_steinberg_1_1_i_attributes_abbfa2ff571c383c30b77f2ecb8ed9d32}{queue}} (I\+Attr\+ID list\+ID, const \mbox{\hyperlink{class_steinberg_1_1_f_variant}{F\+Variant}} \&data)=0
\item 
virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI \mbox{\hyperlink{class_steinberg_1_1_i_attributes_af70e3830804d2dd7215693f49216c567}{set\+Binary\+Data}} (I\+Attr\+ID attr\+ID, void $\ast$data, uint32 bytes, bool copy\+Bytes)=0
\end{DoxyCompactItemize}
\end{Indent}
\doxysubsection*{Methods to read attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_steinberg_1_1_i_attributes_aab6bdb9d6e1c2250493f9223bebcc3de}\label{class_steinberg_1_1_i_attributes_aab6bdb9d6e1c2250493f9223bebcc3de}} 
static const \mbox{\hyperlink{class_steinberg_1_1_f_u_i_d}{F\+U\+ID}} {\bfseries iid}
\item 
virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI \mbox{\hyperlink{class_steinberg_1_1_i_attributes_ad690d9a12d947047662295ec80272655}{get}} (I\+Attr\+ID attr\+ID, \mbox{\hyperlink{class_steinberg_1_1_f_variant}{F\+Variant}} \&data)=0
\item 
virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI \mbox{\hyperlink{class_steinberg_1_1_i_attributes_a9cd34832a2f1006605138d8b182e9160}{unqueue}} (I\+Attr\+ID list\+ID, \mbox{\hyperlink{class_steinberg_1_1_f_variant}{F\+Variant}} \&data)=0
\item 
virtual int32 P\+L\+U\+G\+I\+N\+\_\+\+A\+PI \mbox{\hyperlink{class_steinberg_1_1_i_attributes_a90cd08ca9e8b2b058d283f04733d4cb1}{get\+Queue\+Item\+Count}} (I\+Attr\+ID)=0
\item 
virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI \mbox{\hyperlink{class_steinberg_1_1_i_attributes_acc47c4c300e8a09254dd8acbe4519761}{reset\+Queue}} (I\+Attr\+ID attr\+ID)=0
\item 
virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI \mbox{\hyperlink{class_steinberg_1_1_i_attributes_abe70cc8b835e67bab85f0795bb80b2e3}{reset\+All\+Queues}} ()=0
\item 
virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI \mbox{\hyperlink{class_steinberg_1_1_i_attributes_aba18ff2b75f66ad1dd1eedf6528ff22d}{get\+Binary\+Data}} (I\+Attr\+ID attr\+ID, void $\ast$data, uint32 bytes)=0
\item 
virtual uint32 P\+L\+U\+G\+I\+N\+\_\+\+A\+PI \mbox{\hyperlink{class_steinberg_1_1_i_attributes_af63c98545f8021aa31b602c0773297fc}{get\+Binary\+Data\+Size}} (I\+Attr\+ID attr\+ID)=0
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
Object Data Archive Interface.
\begin{DoxyItemize}
\item \mbox{[}host imp\mbox{]}
\item store data/objects/binary/subattributes in the archive
\item read stored data from the archive
\end{DoxyItemize}

All data stored to the archive are identified by a string (I\+Attr\+ID), which must be unique on each I\+Attribute level.

The basic set/get methods make use of the \mbox{\hyperlink{class_steinberg_1_1_f_variant}{F\+Variant}} class defined in \textquotesingle{}\mbox{\hyperlink{funknown_8h_source}{funknown.\+h}}\textquotesingle{}. For a more convenient usage of this interface, you should use the functions defined in namespace P\+Attributes (public.\+sdk/source/common/pattributes.h+cpp) !! 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_steinberg_1_1_i_attributes_ad690d9a12d947047662295ec80272655}\label{class_steinberg_1_1_i_attributes_ad690d9a12d947047662295ec80272655}} 
\index{Steinberg::IAttributes@{Steinberg::IAttributes}!get@{get}}
\index{get@{get}!Steinberg::IAttributes@{Steinberg::IAttributes}}
\doxysubsubsection{\texorpdfstring{get()}{get()}}
{\footnotesize\ttfamily virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI Steinberg\+::\+I\+Attributes\+::get (\begin{DoxyParamCaption}\item[{I\+Attr\+ID}]{attr\+ID,  }\item[{\mbox{\hyperlink{class_steinberg_1_1_f_variant}{F\+Variant}} \&}]{data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Get data previously stored to the archive. \mbox{\Hypertarget{class_steinberg_1_1_i_attributes_aba18ff2b75f66ad1dd1eedf6528ff22d}\label{class_steinberg_1_1_i_attributes_aba18ff2b75f66ad1dd1eedf6528ff22d}} 
\index{Steinberg::IAttributes@{Steinberg::IAttributes}!getBinaryData@{getBinaryData}}
\index{getBinaryData@{getBinaryData}!Steinberg::IAttributes@{Steinberg::IAttributes}}
\doxysubsubsection{\texorpdfstring{getBinaryData()}{getBinaryData()}}
{\footnotesize\ttfamily virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI Steinberg\+::\+I\+Attributes\+::get\+Binary\+Data (\begin{DoxyParamCaption}\item[{I\+Attr\+ID}]{attr\+ID,  }\item[{void $\ast$}]{data,  }\item[{uint32}]{bytes }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Read binary data from the archive. The data is copied into the passed buffer. The size of that buffer must fit the size of data stored in the archive which can be queried via \mbox{\hyperlink{class_steinberg_1_1_i_attributes_af63c98545f8021aa31b602c0773297fc}{I\+Attributes\+::get\+Binary\+Data\+Size}} ~\newline
 \mbox{\Hypertarget{class_steinberg_1_1_i_attributes_af63c98545f8021aa31b602c0773297fc}\label{class_steinberg_1_1_i_attributes_af63c98545f8021aa31b602c0773297fc}} 
\index{Steinberg::IAttributes@{Steinberg::IAttributes}!getBinaryDataSize@{getBinaryDataSize}}
\index{getBinaryDataSize@{getBinaryDataSize}!Steinberg::IAttributes@{Steinberg::IAttributes}}
\doxysubsubsection{\texorpdfstring{getBinaryDataSize()}{getBinaryDataSize()}}
{\footnotesize\ttfamily virtual uint32 P\+L\+U\+G\+I\+N\+\_\+\+A\+PI Steinberg\+::\+I\+Attributes\+::get\+Binary\+Data\+Size (\begin{DoxyParamCaption}\item[{I\+Attr\+ID}]{attr\+ID }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Get the size in bytes of binary data in the archive. \mbox{\Hypertarget{class_steinberg_1_1_i_attributes_a90cd08ca9e8b2b058d283f04733d4cb1}\label{class_steinberg_1_1_i_attributes_a90cd08ca9e8b2b058d283f04733d4cb1}} 
\index{Steinberg::IAttributes@{Steinberg::IAttributes}!getQueueItemCount@{getQueueItemCount}}
\index{getQueueItemCount@{getQueueItemCount}!Steinberg::IAttributes@{Steinberg::IAttributes}}
\doxysubsubsection{\texorpdfstring{getQueueItemCount()}{getQueueItemCount()}}
{\footnotesize\ttfamily virtual int32 P\+L\+U\+G\+I\+N\+\_\+\+A\+PI Steinberg\+::\+I\+Attributes\+::get\+Queue\+Item\+Count (\begin{DoxyParamCaption}\item[{I\+Attr\+ID}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Get the amount of items in a queue. \mbox{\Hypertarget{class_steinberg_1_1_i_attributes_abbfa2ff571c383c30b77f2ecb8ed9d32}\label{class_steinberg_1_1_i_attributes_abbfa2ff571c383c30b77f2ecb8ed9d32}} 
\index{Steinberg::IAttributes@{Steinberg::IAttributes}!queue@{queue}}
\index{queue@{queue}!Steinberg::IAttributes@{Steinberg::IAttributes}}
\doxysubsubsection{\texorpdfstring{queue()}{queue()}}
{\footnotesize\ttfamily virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI Steinberg\+::\+I\+Attributes\+::queue (\begin{DoxyParamCaption}\item[{I\+Attr\+ID}]{list\+ID,  }\item[{const \mbox{\hyperlink{class_steinberg_1_1_f_variant}{F\+Variant}} \&}]{data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Store a list of data in the archive. Please note that the type of data is not mixable! So you can only store a list of integers or a list of doubles/strings/etc. You can also store a list of subattributes or other objects that implement the \mbox{\hyperlink{class_steinberg_1_1_i_persistent}{I\+Persistent}} interface. \mbox{\Hypertarget{class_steinberg_1_1_i_attributes_abe70cc8b835e67bab85f0795bb80b2e3}\label{class_steinberg_1_1_i_attributes_abe70cc8b835e67bab85f0795bb80b2e3}} 
\index{Steinberg::IAttributes@{Steinberg::IAttributes}!resetAllQueues@{resetAllQueues}}
\index{resetAllQueues@{resetAllQueues}!Steinberg::IAttributes@{Steinberg::IAttributes}}
\doxysubsubsection{\texorpdfstring{resetAllQueues()}{resetAllQueues()}}
{\footnotesize\ttfamily virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI Steinberg\+::\+I\+Attributes\+::reset\+All\+Queues (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Reset all queues in the archive. \mbox{\Hypertarget{class_steinberg_1_1_i_attributes_acc47c4c300e8a09254dd8acbe4519761}\label{class_steinberg_1_1_i_attributes_acc47c4c300e8a09254dd8acbe4519761}} 
\index{Steinberg::IAttributes@{Steinberg::IAttributes}!resetQueue@{resetQueue}}
\index{resetQueue@{resetQueue}!Steinberg::IAttributes@{Steinberg::IAttributes}}
\doxysubsubsection{\texorpdfstring{resetQueue()}{resetQueue()}}
{\footnotesize\ttfamily virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI Steinberg\+::\+I\+Attributes\+::reset\+Queue (\begin{DoxyParamCaption}\item[{I\+Attr\+ID}]{attr\+ID }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Reset a queue. If you need to restart reading a queue, you have to reset it. You can reset a queue at any time. \mbox{\Hypertarget{class_steinberg_1_1_i_attributes_a121fdb525b5967e17d851daee6e1819f}\label{class_steinberg_1_1_i_attributes_a121fdb525b5967e17d851daee6e1819f}} 
\index{Steinberg::IAttributes@{Steinberg::IAttributes}!set@{set}}
\index{set@{set}!Steinberg::IAttributes@{Steinberg::IAttributes}}
\doxysubsubsection{\texorpdfstring{set()}{set()}}
{\footnotesize\ttfamily virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI Steinberg\+::\+I\+Attributes\+::set (\begin{DoxyParamCaption}\item[{I\+Attr\+ID}]{attr\+ID,  }\item[{const \mbox{\hyperlink{class_steinberg_1_1_f_variant}{F\+Variant}} \&}]{data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Store any data in the archive. It is even possible to store sub-\/attributes by creating a new \mbox{\hyperlink{class_steinberg_1_1_i_attributes}{I\+Attributes}} instance via the I\+Host\+Classes interface and pass it to the parent in the \mbox{\hyperlink{class_steinberg_1_1_f_variant}{F\+Variant}}. In this case the archive must take the ownership of the newly created object, which is true for all objects that have been created only for storing. You tell the archive to take ownership by adding the F\+Variant\+::k\+Owner flag to the F\+Variant\+::type member (data.\+type $\vert$= F\+Variant\+::k\+Owner). When using the P\+Attributes functions, this is done through a function parameter. \mbox{\Hypertarget{class_steinberg_1_1_i_attributes_af70e3830804d2dd7215693f49216c567}\label{class_steinberg_1_1_i_attributes_af70e3830804d2dd7215693f49216c567}} 
\index{Steinberg::IAttributes@{Steinberg::IAttributes}!setBinaryData@{setBinaryData}}
\index{setBinaryData@{setBinaryData}!Steinberg::IAttributes@{Steinberg::IAttributes}}
\doxysubsubsection{\texorpdfstring{setBinaryData()}{setBinaryData()}}
{\footnotesize\ttfamily virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI Steinberg\+::\+I\+Attributes\+::set\+Binary\+Data (\begin{DoxyParamCaption}\item[{I\+Attr\+ID}]{attr\+ID,  }\item[{void $\ast$}]{data,  }\item[{uint32}]{bytes,  }\item[{bool}]{copy\+Bytes }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Store binary data in the archive. Parameter \textquotesingle{}copy\+Bytes\textquotesingle{} specifies if the passed data should be copied. The archive cannot take the ownership of binary data. Either it just references a buffer in order to write it to a file (copy\+Bytes = false) or it copies the data to its own buffers (copy\+Bytes = true). When binary data should be stored in the default pool for example, you must always copy it! \mbox{\Hypertarget{class_steinberg_1_1_i_attributes_a9cd34832a2f1006605138d8b182e9160}\label{class_steinberg_1_1_i_attributes_a9cd34832a2f1006605138d8b182e9160}} 
\index{Steinberg::IAttributes@{Steinberg::IAttributes}!unqueue@{unqueue}}
\index{unqueue@{unqueue}!Steinberg::IAttributes@{Steinberg::IAttributes}}
\doxysubsubsection{\texorpdfstring{unqueue()}{unqueue()}}
{\footnotesize\ttfamily virtual tresult P\+L\+U\+G\+I\+N\+\_\+\+A\+PI Steinberg\+::\+I\+Attributes\+::unqueue (\begin{DoxyParamCaption}\item[{I\+Attr\+ID}]{list\+ID,  }\item[{\mbox{\hyperlink{class_steinberg_1_1_f_variant}{F\+Variant}} \&}]{data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Get list of data previously stored to the archive. As long as there are queue members the method will return k\+Result\+True. When the queue is empty, the methods returns k\+Result\+False. All lists except from object lists can be reset which means that the items can be read once again. \begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_steinberg_1_1_i_attributes_acc47c4c300e8a09254dd8acbe4519761}{I\+Attributes\+::reset\+Queue}} 
\end{DoxySeeAlso}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+I\+Plug/\+V\+S\+T3\+\_\+\+S\+D\+K/pluginterfaces/base/ipersistent.\+h\end{DoxyCompactItemize}
