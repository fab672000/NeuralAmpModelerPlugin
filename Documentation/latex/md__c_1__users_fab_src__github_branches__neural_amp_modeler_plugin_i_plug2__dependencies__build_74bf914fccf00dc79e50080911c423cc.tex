Using developments done for the Web (Web\+Assembly backends and {\bfseries{libfaust}} library compiled in Web\+Assembly with \href{https://emscripten.org}{\texttt{ Emscripten}}), statically and dynamically \mbox{\hyperlink{struct_faust}{Faust}} generated Web\+Audio nodes can be easily produced and deployed on the Web.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_74bf914fccf00dc79e50080911c423cc_autotoc_md645}{}\doxysection{Deploying statically compiled Faust Web\+Audio nodes}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_74bf914fccf00dc79e50080911c423cc_autotoc_md645}
From a {\bfseries{foo.\+dsp}} source file, Java\+Script and the associated Web\+Assembly files can be produced with the following script\+: \begin{DoxyVerb}faust2wasm -worklet foo.dsp 
\end{DoxyVerb}


This will generate a {\bfseries{foo.\+wasm}} file with the Web\+Assembly module as binary code, as well as a {\bfseries{foo.\+js}} wrapper file containing the code needed to turn the \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} in a fully working Web\+Audio node (using an extended {\bfseries{Audio\+Worklet\+Node}} node). The name of the \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} code file is used to define the final Audio\+Worklet\+Node constructor name. So for instance if {\bfseries{osc.\+dsp}} file is compiled, the {\bfseries{Faustosc}} class will be generated and can be used the following way\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{// Create the Faust generated node}
\DoxyCodeLine{var pluginURL = ".";}
\DoxyCodeLine{var plugin = new Faustosc(audio\_context, pluginURL);}
\DoxyCodeLine{plugin.load().then(node => \{....\});}
\end{DoxyCode}


The resulting node is an extended Audio\+Worklet\+Node, to be used as a regular node (like connected to other Web\+Audio nodes), as well as Java\+Script more specific functions. For instance the following ones will have to be used to control the node\+: \begin{DoxyVerb}var paths = node.getParams(); // get the set of paths to read/write input control parameters
\end{DoxyVerb}


Then knowing the path for a given parameter, the following function is used to change the parameter value\+: \begin{DoxyVerb}node.setParamValue("/Oscillator/freq", 0.6);
\end{DoxyVerb}


A full J\+S\+ON description of the node with the complete \mbox{\hyperlink{class_u_i}{UI}}, can be retrieved with\+: ~\newline
 \begin{DoxyVerb}var json = node.getJSON(); 
\end{DoxyVerb}


The complete usable A\+PI is fully documented in the generated Java\+Script file in the {\itshape Public A\+PI} section. {\bfseries{To properly deallocate ressources at the end of its life, be sure to call the {\itshape destroy} function on the node.}}. Use {\ttfamily faust2wasm -\/h} to see all available options.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_74bf914fccf00dc79e50080911c423cc_autotoc_md646}{}\doxysubsection{A simple example Web page}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_74bf914fccf00dc79e50080911c423cc_autotoc_md646}
A simple Web page using the files generated by {\bfseries{faust2wasm}} on the {\bfseries{noise.\+dsp}} file can be defined with the following parts\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{<!-\/-\/ Load 'faust2wasm' script generated .js file -\/-\/>}
\DoxyCodeLine{<script src="noise.js"></script>}
\end{DoxyCode}


A slider to control the noise volume parameter is defined with\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{<P> Noise volume:}
\DoxyCodeLine{<input type="range" oninput="changeVolume(event) "min="0" max="1" value="0.5" step="0.01"/>}
\end{DoxyCode}


The Web\+Audio context is created and the noise slide hander is defined with\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var isWebKitAudio = (typeof (webkitAudioContext) !== "undefined");}
\DoxyCodeLine{var audio\_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext();}
\DoxyCodeLine{var noise\_dsp = null;}
\DoxyCodeLine{}
\DoxyCodeLine{// Slider handler to change the 'noise' volume}
\DoxyCodeLine{function changeVolume(event)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    noise\_dsp.setParamValue("/Noise/Volume", parseFloat(event.target.value));}
\DoxyCodeLine{\}}
\end{DoxyCode}


A {\bfseries{startnoise}} function which creates the \mbox{\hyperlink{struct_faust}{Faust}} Web\+Audio node is defined with\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{function startnoise()}
\DoxyCodeLine{\{}
\DoxyCodeLine{    // Create the Faust generated node}
\DoxyCodeLine{    var pluginURL = ".";}
\DoxyCodeLine{    var plugin = new Faustnoise(audio\_context, pluginURL);}
\DoxyCodeLine{    plugin.load().then(node => \{}
\DoxyCodeLine{        noise\_dsp = node;}
\DoxyCodeLine{        console.log(noise\_dsp.getJSON());}
\DoxyCodeLine{        // Print path to be used with 'setParamValue'}
\DoxyCodeLine{        console.log(noise\_dsp.getParams());}
\DoxyCodeLine{        // Connect it to output as a regular WebAudio node}
\DoxyCodeLine{        noise\_dsp.connect(audio\_context.destination);}
\DoxyCodeLine{    \});}
\DoxyCodeLine{\}}
\end{DoxyCode}


An finally the load handler is defined to activate the code\+: \begin{DoxyVerb}window.addEventListener("load", startnoise);
\end{DoxyVerb}


Look at the \href{noise-wasm.html}{\texttt{ Noise}} and \href{osc-wasm.html}{\texttt{ O\+SC}} pages for the complete code.

Note that pages loading an additional .wasm file cannot directly be loaded in Chrome. You\textquotesingle{}ll have to start a local server (using the {\itshape python -\/m Simple\+H\+T\+T\+P\+Server} command for instance) and access them with their {\itshape \href{http://}{\texttt{ http\+://}}} based U\+RL. ~\newline
\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_74bf914fccf00dc79e50080911c423cc_autotoc_md647}{}\doxysubsection{Generating Polyphonic Web\+Audio nodes}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_74bf914fccf00dc79e50080911c423cc_autotoc_md647}
Assuming that the compiled \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} file is \href{https://faust.grame.fr/doc/manual/index.html\#midi-polyphony-support}{\texttt{ polyphonic ready}}, a polyphonic ready Web\+Audio node can be created by adding the {\itshape -\/poly} option, and will generate the following class for the node, to be used like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{// Create the Faust generated node with 16 voices}
\DoxyCodeLine{var pluginURL = ".";}
\DoxyCodeLine{var plugin = new FaustorganPoly(audio\_context, 16, pluginURL);}
\DoxyCodeLine{plugin.load().then(node => \{....\});}
\end{DoxyCode}


Polyphonic nodes have an extended A\+PI to be controled with M\+I\+DI messages\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{/**}
\DoxyCodeLine{* Instantiates a new polyphonic voice. }
\DoxyCodeLine{*}
\DoxyCodeLine{* @param channel -\/ the MIDI channel (0..15, not used for now)}
\DoxyCodeLine{* @param pitch -\/ the MIDI pitch (0..127)}
\DoxyCodeLine{* @param velocity -\/ the MIDI velocity (0..127)}
\DoxyCodeLine{*/}
\DoxyCodeLine{keyOn = function (channel, pitch, velocity) }
\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{/**}
\DoxyCodeLine{* De-\/instantiates a polyphonic voice. }
\DoxyCodeLine{*}
\DoxyCodeLine{* @param channel -\/ the MIDI channel (0..15, not used for now)}
\DoxyCodeLine{* @param pitch -\/ the MIDI pitch (0..127)}
\DoxyCodeLine{* @param velocity -\/ the MIDI velocity (0..127)}
\DoxyCodeLine{*/}
\DoxyCodeLine{keyOff = function (channel, pitch, velocity)}
\end{DoxyCode}


\`{}\`{}\`{} /$\ast$$\ast$
\begin{DoxyItemize}
\item Gently terminates all the active voices. $\ast$/ all\+Notes\+Off = function () \`{}\`{}\`{}\`{}
\end{DoxyItemize}

Look at the \href{organ-wasm.html}{\texttt{ Organ}} page for the complete code. Look at the Java\+Script public documentation section for the complete description.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_74bf914fccf00dc79e50080911c423cc_autotoc_md648}{}\doxysection{Deploying Web\+Audio Plugins (\+W\+A\+P)}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_74bf914fccf00dc79e50080911c423cc_autotoc_md648}
The \href{https://github.com/micbuffa/WebAudioPlugins}{\texttt{ Web\+Audio Plugins}} is a plugin format currently developed by a group of researchers and developers. \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} code can be directly compiled for it using the {\itshape -\/wap} parameter, like this\+: \begin{DoxyVerb}faust2wasm -wap osc.dsp 
\end{DoxyVerb}


In this case a generic {\bfseries{main.\+js}} file is created, a {\bfseries{main.\+json}} file to describe the plugin, and an {\bfseries{index.\+html}} file to test it.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_74bf914fccf00dc79e50080911c423cc_autotoc_md649}{}\doxysection{Generating fully working self-\/contained H\+T\+M\+L pages}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_74bf914fccf00dc79e50080911c423cc_autotoc_md649}
The {\bfseries{faust2webaudiowasm}} script can be used to generate a fully working self-\/contained H\+T\+ML page, with a S\+V\+G/\+C\+SS a Graphical User Interface. From the {\bfseries{osc.\+dsp}} \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} source file, it will generate an {\bfseries{osc.\+html}} file\+: \begin{DoxyVerb}faust2webaudiowasm -worklet osc.dsp
\end{DoxyVerb}


Assuming that the compiled \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} file is polyphonic ready, the {\itshape -\/poly} parameter can be used to generate a polyphonic M\+I\+DI controllable instrument, to be used with a M\+I\+DI application or device. Use {\ttfamily faust2webaudiowasm -\/h} to see all available options.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_74bf914fccf00dc79e50080911c423cc_autotoc_md650}{}\doxysection{Deploying dynamically compiled Faust Web\+Audio nodes}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_74bf914fccf00dc79e50080911c423cc_autotoc_md650}
Since the {\bfseries{libfaust}} library is available for the Web, it becomes possible to {\bfseries{embed the complete dynamic compilation chain in a Web page}}, from the \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} source to the executable Web\+Audio node. First the following resources (located on the \mbox{\hyperlink{struct_faust}{Faust}} Git\+Hub in architecture/webaudio folder) have to be loaded in the page\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{<!-\/-\/ Load 'libfaust' library and wrapper code -\/-\/>}
\DoxyCodeLine{<script src="libfaust-\/wasm.js"></script>}
\DoxyCodeLine{<script src="webaudio-\/wasm-\/wrapper.js"></script>}
\end{DoxyCode}


The {\bfseries{faust\+\_\+module}} global is defined in webaudio-\/wasm-\/wrapper.\+js file, {\ttfamily on\+Runtime\+Initialized} will be called when the code is ready. So something like the following line has to be written\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{faust\_module['onRuntimeInitialized'] = init;}
\end{DoxyCode}


The two following functions are then used to generate factories, creating later on {\itshape monophonic} or {\itshape polyphonic} instances (this is necessary because of the way internal Web\+Assembly memory is managed)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{/**}
\DoxyCodeLine{* Create a DSP factory from source code as a string to be used to create monophonic DSP }
\DoxyCodeLine{*}
\DoxyCodeLine{* @param code -\/ the source code as a string}
\DoxyCodeLine{* @param argv -\/ an array of parameters to be given to the Faust compiler}
\DoxyCodeLine{* @param callback -\/ a callback taking the created DSP factory as parameter, or null in case of error}
\DoxyCodeLine{*/}
\DoxyCodeLine{faust.createDSPFactory = function (code, argv, callback) }
\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{/**}
\DoxyCodeLine{* Create a DSP factory from source code as a string to be used to create polyphonic DSP }
\DoxyCodeLine{*}
\DoxyCodeLine{* @param code -\/ the source code as a string}
\DoxyCodeLine{* @param argv -\/ an array of parameters to be given to the Faust compiler}
\DoxyCodeLine{* @param callback -\/ a callback taking the created DSP factory as parameter, or null in case of error}
\DoxyCodeLine{*/}
\DoxyCodeLine{faust.createPolyDSPFactory = function (code, argv, callback) }
\end{DoxyCode}


The two following functions are used to generate {\itshape monophonic} or {\itshape polyphonic} \mbox{\hyperlink{struct_faust}{Faust}} Web\+Audio nodes\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{/**}
\DoxyCodeLine{* Create a AudioWorklet Web Audio object from a factory}
\DoxyCodeLine{*}
\DoxyCodeLine{* @param factory -\/ the DSP factory}
\DoxyCodeLine{* @param context -\/ the Web Audio context}
\DoxyCodeLine{* @param callback -\/ a callback taking the created AudioWorklet as parameter, or null in case of error}
\DoxyCodeLine{*/}
\DoxyCodeLine{faust.createDSPWorkletInstance = function (factory, context, callback) }
\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{/**}
\DoxyCodeLine{* Create a 'polyphonic' AudioWorklet Web Audio object from a factory}
\DoxyCodeLine{*}
\DoxyCodeLine{* @param factory -\/ the DSP factory}
\DoxyCodeLine{* @param context -\/ the Web Audio context}
\DoxyCodeLine{* @param polyphony -\/ the number of polyphonic voices}
\DoxyCodeLine{* @param callback -\/ a callback taking the created AudioWorklet as parameter, or null in case of error}
\DoxyCodeLine{*/}
\DoxyCodeLine{faust.createPolyDSPWorkletInstance = function (factory, context, polyphony, callback) }
\end{DoxyCode}


The resulting nodes have the same A\+PI as statically compiled nodes described in the first section, so can be controlled the same way, including the polyphonic ones. Here is a code example using {\bfseries{faust.\+create\+D\+S\+P\+Factory}} and {\bfseries{faust.\+create\+D\+S\+P\+Worklet\+Instance}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{var isWebKitAudio = (typeof (webkitAudioContext) !== "undefined");}
\DoxyCodeLine{var audio\_context = (isWebKitAudio) ? new webkitAudioContext() : new AudioContext();}
\DoxyCodeLine{var dsp\_code = "import(\(\backslash\)"stdfaust.lib\(\backslash\)"); vol = hslider(\(\backslash\)"volume [unit:dB]\(\backslash\)", 0, -\/96, 0, 0.1) : ba.db2linear : si.smoo; freq = hslider(\(\backslash\)"freq [unit:Hz]\(\backslash\)", 1000, 20, 24000, 1); process = vgroup(\(\backslash\)"Oscillator\(\backslash\)", os.osc(freq) * vol);";}
\DoxyCodeLine{var osc = null;}
\DoxyCodeLine{var libraries\_url = "/modules/libraries/";}
\DoxyCodeLine{}
\DoxyCodeLine{function startosc()}
\DoxyCodeLine{\{}
\DoxyCodeLine{    // Prepare argv list}
\DoxyCodeLine{    var argv = [];}
\DoxyCodeLine{    argv.push("-\/ftz");}
\DoxyCodeLine{    argv.push("2");}
\DoxyCodeLine{    argv.push("-\/I");}
\DoxyCodeLine{    argv.push(libraries\_url);}
\DoxyCodeLine{}
\DoxyCodeLine{    // Dynamically create the Faust generated node from explicit DSP source in 'dsp\_code'}
\DoxyCodeLine{    faust.createDSPFactory(dsp\_code,}
\DoxyCodeLine{                            argv,}
\DoxyCodeLine{                            function (factory) \{}
\DoxyCodeLine{                            faust.createDSPWorkletInstance(factory, audio\_context}
\DoxyCodeLine{                                                            function (node) \{}
\DoxyCodeLine{                                                                osc = node;}
\DoxyCodeLine{                                                                console.log(osc.getJSON());}
\DoxyCodeLine{                                                                // Print paths to be used with 'setParamValue'}
\DoxyCodeLine{                                                                console.log(osc.getParams());}
\DoxyCodeLine{                                                                // Connect it to output as a regular WebAudio node}
\DoxyCodeLine{                                                                osc.connect(audio\_context.destination);}
\DoxyCodeLine{                                                            \})\});}
\DoxyCodeLine{\}}
\end{DoxyCode}


The \href{dynamic-osc-worklet-wasm.html}{\texttt{ Dynamic O\+SC}} page demonstrates the dynamic O\+SC complete code (based on the example seen before). The \href{dynamic-organ-worklet-wasm.html}{\texttt{ Dynamic Organ}} page demonstrates a polyphonic organ instrument, which loads a \mbox{\hyperlink{class_d_s_p}{D\+SP}} from an url, and ready to be controlled with a M\+I\+DI device or application. Look at the \href{faustlive-wasm.html}{\texttt{ Dynamic Faust compiler}} page for a more complete use-\/case of the dynamic compiler.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_74bf914fccf00dc79e50080911c423cc_autotoc_md651}{}\doxysection{Float denormal handling}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_74bf914fccf00dc79e50080911c423cc_autotoc_md651}
A specific problem occurs when audio computation produces denormal float values, which is quite common with recursive filters, and can be extremely costly to compute on some processors like the Intel family for instance. A Flush To Zero (F\+TZ) mode for denormals can usually be set at hardware level, but it not yet available in the Web\+Assembly M\+VP version, which strictly conform to the I\+E\+EE 754 norm 8.

Thus an automatic software strategy which consists in adding F\+TZ code in all recursive loops has been implemented in the \mbox{\hyperlink{struct_faust}{Faust}} compiler. To activate it, the {\itshape -\/ftz} compilation parameter must be used at compilation time.

The {\itshape -\/ftz 1} mode adds a test in each recursive loop which uses the {\itshape fabs} function and a threshold to detect subnormal samples (slower). The {\itshape -\/ftz 2} mode adds a test in each recursive loop which uses a mask to detect subnormal samples (faster).

Use for example the following line to active software denormal handing when using {\bfseries{faust2wasm}} tool\+: \begin{DoxyVerb}faust2wasm -worklet -ftz 2 foo.dsp 
\end{DoxyVerb}


The same for the {\bfseries{faust2webaudiowasm}} tool\+: \begin{DoxyVerb}faust2webaudiowasm -worklet -ftz 2 foo.dsp 
\end{DoxyVerb}


For dynamic compilation, the {\itshape -\/ftz v} flag will have to be added in the {\itshape argv} parameter in {\bfseries{faust.\+create\+D\+S\+P\+Factory}} or {\bfseries{faust.\+create\+Poly\+D\+S\+P\+Factory}}, like for instance\+: \begin{DoxyVerb}faust.createPolyDSPFactory(dsp_code, ['-ftz', '2'], callback);
\end{DoxyVerb}
 