{\ttfamily faust2unity} transforms a \mbox{\hyperlink{struct_faust}{Faust}} \mbox{\hyperlink{class_d_s_p}{D\+SP}} program into a fully working Unity audio plugin, which can be an effect or a synthesiser to perform procedural audio.

The compiled folder is a Unity package (i.\+e. Faust\+Plugin\+\_\+$<$dspname$>$.\+unitypackage) which contains two different types of files \+: \begin{DoxyVerb}- Libraries (in `libFaustPlugin_<dspname>.bundle`) containing the native C++ part.
- Two C# scripts (`FaustPlugin_<dspname>.cs` and `FaustUtilities_<dspname>.cs`) containing the methods and classes which link the native part to the Unity audio system, and manage the plugin inspector interface.
\end{DoxyVerb}


Libraries are available for several platforms and architectures\+: \begin{DoxyVerb}- Windows 32 bits and 64 bits (.dll)
- macOS (.bundle)
- iOS (.a)
- Android armeabi-v7a and x86 (.so)
- Linux (.so).
\end{DoxyVerb}
\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_e85500032a5dec5d8c0d0de2b35652f6_autotoc_md1284}{}\doxysection{How to use}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_e85500032a5dec5d8c0d0de2b35652f6_autotoc_md1284}
{\ttfamily faust2unity} is used with the following command\+:

{\ttfamily faust2unity \mbox{[}-\/w32\mbox{]} \mbox{[}-\/w64\mbox{]}~\mbox{[}-\/osx\mbox{]}~\mbox{[}-\/ios\mbox{]}~\mbox{[}-\/android\mbox{]} \mbox{[}-\/linux\mbox{]} \mbox{[}-\/nvoices $<$num$>$\mbox{]} \mbox{[}-\/source\mbox{]} \mbox{[}-\/unpacked\mbox{]} $<$file1.\+dsp$>$ \mbox{[}$<$file2.\+dsp$>$\mbox{]}}

By default it will create a Unity package containing the C\# script and sub-\/folders with all available architectures. Relevant achitectures can be chosen by including their corresponding options as listed above. Several \mbox{\hyperlink{class_d_s_p}{D\+SP}} files can be compiled at the same time and will be generated in different packages.

The relevant architecture setup should be filled in for each file in the plugin inspector.

Finally, the C\# script {\ttfamily Faust\+Plugin\+\_\+$<$dspname$>$} should be attached to a game object. {\ttfamily Faust\+Plugin\+\_\+$<$dspname$>$.cs} is the public interface and contains the dsp class and methods that allow to access and change the parameters (i.\+e. {\ttfamily get\+Parameter()} and {\ttfamily set\+Parameter()}). {\ttfamily Faust\+Utilities\+\_\+$<$dspname$>$} contains additional code to access the plugin and generate the inspector interface. This file shouldn\textquotesingle{}t be changed.

The source files can be produced with the {\ttfamily -\/source} option.

The {\ttfamily -\/nvoices $<$num$>$} option can be used to produce a polyphonic self-\/contained \mbox{\hyperlink{class_d_s_p}{D\+SP}} with {\ttfamily num} voices, ready to be used with M\+I\+DI. The C\# script will contain key\+On/\+Key\+Off functions to control the instrument.

Unity packages have a specific organization in order to be correctly read by the Unity editor. {\ttfamily faust2unity} calls {\ttfamily encoderunitypackage} to correctly encode the compiled files. The {\ttfamily -\/unpacked} option stops the script before the encoding step, the intermediate folder is named {\ttfamily Faust\+Plugin\+\_\+$<$dspname$>$\+\_\+\+Assets} and organized like the Assets hierarchy of a Unity project. It allows to add additional files to the package before packing it. Then, use the {\ttfamily encoderunitypackage $<$folder$>$} command to encode and pack the folder as a Unity package.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_e85500032a5dec5d8c0d0de2b35652f6_autotoc_md1285}{}\doxysection{Compiler requirements}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_e85500032a5dec5d8c0d0de2b35652f6_autotoc_md1285}
\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_e85500032a5dec5d8c0d0de2b35652f6_autotoc_md1286}{}\doxysubsection{Windows 32 bits and 64 bits}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_e85500032a5dec5d8c0d0de2b35652f6_autotoc_md1286}
The compiler used for Windows libraries is Mingw (\href{http://www.mingw.org}{\texttt{ http\+://www.\+mingw.\+org}}). {\ttfamily i686-\/w64-\/mingw32-\/gcc} (32bits) and {\ttfamily x86\+\_\+64-\/w64-\/mingw32-\/gcc} (64bits) packages have to be installed. On mac\+OS, they are available on \href{https://www.macports.org}{\texttt{ Macports}}.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_e85500032a5dec5d8c0d0de2b35652f6_autotoc_md1287}{}\doxysubsection{Android}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_e85500032a5dec5d8c0d0de2b35652f6_autotoc_md1287}
Android S\+DK (containing Android N\+DK) should be installed to generate Android libraries and the A\+N\+D\+R\+O\+I\+D\+\_\+\+H\+O\+ME environment variable should be defined. It should point on the sdk folder. If the S\+DK has been installed by Android Studio, the path should be {\ttfamily $\sim$/\+Library/\+Android/sdk}. Other architectures are available in the Android N\+DK. To use them, the {\ttfamily achitecture/unity/\+Android/\+Android.\+mk} file should be updated and the A\+P\+P\+\_\+\+A\+BI line should be modified. See \href{https://developer.android.com/ndk/guides/android_mk.html}{\texttt{ Android N\+DK}} for more info. ~\newline
\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_e85500032a5dec5d8c0d0de2b35652f6_autotoc_md1288}{}\doxysection{Options}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_e85500032a5dec5d8c0d0de2b35652f6_autotoc_md1288}
The following options are available \+:


\begin{DoxyItemize}
\item {\ttfamily -\/w32} \+: produces a Windows 32bits library
\item {\ttfamily -\/w64} \+: produces a Windows 64bits library
\item {\ttfamily -\/osx} \+: produces a mac\+OS library
\item {\ttfamily -\/ios} \+: produces an i\+OS library
\item {\ttfamily -\/android} \+: produces Android armeabi-\/v7a and x86 libraries
\item {\ttfamily -\/linux} \+: produces a Linux library
\item {\ttfamily -\/nvoices $<$num$>$}\+: produces a polyphonic self-\/contained \mbox{\hyperlink{class_d_s_p}{D\+SP}} with $<$num$>$ voices, ready to be used with M\+I\+DI
\item {\ttfamily -\/source} \+: produces an uncompressed folder with the selected architecture and the source files used to compile the libraries
\item {\ttfamily -\/unpacked} \+: produces a folder with all selected architectures ordered like the Unity Assets hierarchy (i.\+e. {\ttfamily Assets/\+Plugins/\+Faust\+Plugin\+\_\+$<$dspname$>$/i\+O\+S/lib\+Faust\+Plugin\+\_\+$<$dspname$>$.a}).
\item {\ttfamily -\/help or -\/h} \+: shows different options and comments
\end{DoxyItemize}

{\ttfamily faust2unity} script calls six different commands \+:


\begin{DoxyItemize}
\item {\ttfamily faust2w32unity $<$file.\+dsp$>$}
\item {\ttfamily faust2w64unity $<$file.\+dsp$>$}
\item {\ttfamily faust2osxiosunity \mbox{[}-\/ios\mbox{]} $<$file.\+dsp$>$}
\item {\ttfamily faust2androidunity $<$file.\+dsp$>$}
\item {\ttfamily faust2linuxunity $<$file.\+dsp$>$}
\item {\ttfamily encoderunitypackage $<$folder$>$}
\end{DoxyItemize}

These commands can be called independently and will generate the libraries only (without the C\# files). Specific compilation options can be changed in {\ttfamily faust2$<$platform$>$unity} scripts. 