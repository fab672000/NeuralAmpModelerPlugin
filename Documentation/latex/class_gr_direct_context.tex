\hypertarget{class_gr_direct_context}{}\doxysection{Gr\+Direct\+Context Class Reference}
\label{class_gr_direct_context}\index{GrDirectContext@{GrDirectContext}}
Inheritance diagram for Gr\+Direct\+Context\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6.000000cm]{class_gr_direct_context}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{class_gr_direct_context_1_1_direct_context_i_d}{Direct\+Context\+ID}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{class_gr_direct_context_a53c3539a51361c0483476a9efd247055}{reset\+Context}} (uint32\+\_\+t \mbox{\hyperlink{structstate}{state}}=k\+All\+\_\+\+Gr\+Backend\+State)
\item 
void \mbox{\hyperlink{class_gr_direct_context_ac1f54c0e0566c134841ea94bf5f1e29d}{reset\+G\+L\+Texture\+Bindings}} ()
\item 
void \mbox{\hyperlink{class_gr_direct_context_aeb90c9ad9c8f849f8c09ce965f570a3d}{abandon\+Context}} () override
\item 
bool \mbox{\hyperlink{class_gr_direct_context_a5c1c5c644a82f21ce2af991b4f451348}{abandoned}} () override
\item 
\mbox{\Hypertarget{class_gr_direct_context_a95901720daa8d94387f990b12c7058b9}\label{class_gr_direct_context_a95901720daa8d94387f990b12c7058b9}} 
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_gr_context_thread_safe_proxy}{Gr\+Context\+Thread\+Safe\+Proxy}} $>$ {\bfseries thread\+Safe\+Proxy} ()
\item 
bool \mbox{\hyperlink{class_gr_direct_context_a46cacd2825836fd0305ee183e6fd276e}{oomed}} ()
\item 
void \mbox{\hyperlink{class_gr_direct_context_a585c7eebabd86ec88090d8cdee2d8f59}{release\+Resources\+And\+Abandon\+Context}} ()
\item 
void \mbox{\hyperlink{class_gr_direct_context_ac20d13cd13b25b1aacf12454da4a0af2}{get\+Resource\+Cache\+Limits}} (int $\ast$max\+Resources, size\+\_\+t $\ast$max\+Resource\+Bytes) const
\item 
size\+\_\+t \mbox{\hyperlink{class_gr_direct_context_a41b00959f2ef26e2c1ac2a7b56e666dc}{get\+Resource\+Cache\+Limit}} () const
\item 
void \mbox{\hyperlink{class_gr_direct_context_abc2553f48d12afb0595f6f7920894446}{get\+Resource\+Cache\+Usage}} (int $\ast$resource\+Count, size\+\_\+t $\ast$resource\+Bytes) const
\item 
size\+\_\+t \mbox{\hyperlink{class_gr_direct_context_a1c49050b805e1d24c1cb2fb0266bf982}{get\+Resource\+Cache\+Purgeable\+Bytes}} () const
\item 
void \mbox{\hyperlink{class_gr_direct_context_a05e1728f5c16225c2a6e1a2eb65fa695}{set\+Resource\+Cache\+Limits}} (int max\+Resources, size\+\_\+t max\+Resource\+Bytes)
\item 
void \mbox{\hyperlink{class_gr_direct_context_af972a5f50215ee314c48e5749d6259b9}{set\+Resource\+Cache\+Limit}} (size\+\_\+t max\+Resource\+Bytes)
\item 
void \mbox{\hyperlink{class_gr_direct_context_a3ef10709e240b76201c4ca5a26932890}{free\+Gpu\+Resources}} ()
\item 
void \mbox{\hyperlink{class_gr_direct_context_aae098633b71c877cf97965f0414f17ed}{perform\+Deferred\+Cleanup}} (std\+::chrono\+::milliseconds ms\+Not\+Used, bool scratch\+Resources\+Only=false)
\item 
\mbox{\Hypertarget{class_gr_direct_context_a1024a75ca9e359dc79c6aac1f91dd8f3}\label{class_gr_direct_context_a1024a75ca9e359dc79c6aac1f91dd8f3}} 
void {\bfseries purge\+Resources\+Not\+Used\+In\+Ms} (std\+::chrono\+::milliseconds ms\+Not\+Used)
\item 
void \mbox{\hyperlink{class_gr_direct_context_ada9f27a269e2c41f6530cdb4ad0b4da3}{purge\+Unlocked\+Resources}} (size\+\_\+t bytes\+To\+Purge, bool prefer\+Scratch\+Resources)
\item 
void \mbox{\hyperlink{class_gr_direct_context_a464e8f2af9609a2937d05422eaaab5f7}{purge\+Unlocked\+Resources}} (bool scratch\+Resources\+Only)
\item 
bool \mbox{\hyperlink{class_gr_direct_context_ab84b361801b9493a3d19d8fd761d87fe}{wait}} (int num\+Semaphores, const \mbox{\hyperlink{class_gr_backend_semaphore}{Gr\+Backend\+Semaphore}} $\ast$wait\+Semaphores, bool delete\+Semaphores\+After\+Wait=true)
\item 
void \mbox{\hyperlink{class_gr_direct_context_a5e068da6db37707ee353abedc584ef6f}{flush\+And\+Submit}} (bool sync\+Cpu=false)
\item 
Gr\+Semaphores\+Submitted \mbox{\hyperlink{class_gr_direct_context_a953f6ace921cd53e1333624c7770db54}{flush}} (const \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}} \&info)
\item 
\mbox{\Hypertarget{class_gr_direct_context_abd1b90f3a35d987e95e148c517b8cfd7}\label{class_gr_direct_context_abd1b90f3a35d987e95e148c517b8cfd7}} 
void {\bfseries flush} ()
\item 
bool \mbox{\hyperlink{class_gr_direct_context_a2e6391e15ee021f864a9d4fbef930732}{submit}} (bool sync\+Cpu=false)
\item 
void \mbox{\hyperlink{class_gr_direct_context_a347baddc1feca01526524c6cabdd3c84}{check\+Async\+Work\+Completion}} ()
\item 
void \mbox{\hyperlink{class_gr_direct_context_ac03201b03a0d733d1a0af6a2775cdb00}{dump\+Memory\+Statistics}} (\mbox{\hyperlink{class_sk_trace_memory_dump}{Sk\+Trace\+Memory\+Dump}} $\ast$trace\+Memory\+Dump) const
\item 
\mbox{\Hypertarget{class_gr_direct_context_ae4e77cbb4adc6d85f5087eefeb8f8195}\label{class_gr_direct_context_ae4e77cbb4adc6d85f5087eefeb8f8195}} 
bool {\bfseries supports\+Distance\+Field\+Text} () const
\item 
\mbox{\Hypertarget{class_gr_direct_context_ab098f7299e5b1a9e447be624c9636c51}\label{class_gr_direct_context_ab098f7299e5b1a9e447be624c9636c51}} 
void {\bfseries store\+Vk\+Pipeline\+Cache\+Data} ()
\item 
\mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \mbox{\hyperlink{class_gr_direct_context_a87af0af0e7ed940e4940e132b980aae3}{create\+Backend\+Texture}} (int width, int height, const \mbox{\hyperlink{class_gr_backend_format}{Gr\+Backend\+Format}} \&, Gr\+Mipmapped, Gr\+Renderable, Gr\+Protected=Gr\+Protected\+::k\+No)
\item 
\mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \mbox{\hyperlink{class_gr_direct_context_a334dcc3239840aeec75f3322ae1987d7}{create\+Backend\+Texture}} (int width, int height, Sk\+Color\+Type, Gr\+Mipmapped, Gr\+Renderable, Gr\+Protected=Gr\+Protected\+::k\+No)
\item 
\mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \mbox{\hyperlink{class_gr_direct_context_a60567ade1eab2d44db3a79a76d27b79b}{create\+Backend\+Texture}} (int width, int height, const \mbox{\hyperlink{class_gr_backend_format}{Gr\+Backend\+Format}} \&, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} \&color, Gr\+Mipmapped, Gr\+Renderable, Gr\+Protected=Gr\+Protected\+::k\+No, Gr\+Gpu\+Finished\+Proc finished\+Proc=nullptr, Gr\+Gpu\+Finished\+Context finished\+Context=nullptr)
\item 
\mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \mbox{\hyperlink{class_gr_direct_context_a62f84fdee1cb5b34426002134f6e17c9}{create\+Backend\+Texture}} (int width, int height, Sk\+Color\+Type, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} \&color, Gr\+Mipmapped, Gr\+Renderable, Gr\+Protected=Gr\+Protected\+::k\+No, Gr\+Gpu\+Finished\+Proc finished\+Proc=nullptr, Gr\+Gpu\+Finished\+Context finished\+Context=nullptr)
\item 
\mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \mbox{\hyperlink{class_gr_direct_context_af151abc92b45bdc74b99471a33e2dd24}{create\+Backend\+Texture}} (const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} src\+Data\mbox{[}$\,$\mbox{]}, int num\+Levels, Gr\+Surface\+Origin, Gr\+Renderable, Gr\+Protected, Gr\+Gpu\+Finished\+Proc finished\+Proc=nullptr, Gr\+Gpu\+Finished\+Context finished\+Context=nullptr)
\item 
\mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \mbox{\hyperlink{class_gr_direct_context_af3e96b31af4b591cd147ebba07920ed3}{create\+Backend\+Texture}} (const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} \&src\+Data, Gr\+Surface\+Origin texture\+Origin, Gr\+Renderable renderable, Gr\+Protected is\+Protected, Gr\+Gpu\+Finished\+Proc finished\+Proc=nullptr, Gr\+Gpu\+Finished\+Context finished\+Context=nullptr)
\item 
\mbox{\Hypertarget{class_gr_direct_context_aa6426a89b2441270f7a20034b8f370b1}\label{class_gr_direct_context_aa6426a89b2441270f7a20034b8f370b1}} 
\mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} {\bfseries create\+Backend\+Texture} (const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} src\+Data\mbox{[}$\,$\mbox{]}, int num\+Levels, Gr\+Renderable renderable, Gr\+Protected is\+Protected, Gr\+Gpu\+Finished\+Proc finished\+Proc=nullptr, Gr\+Gpu\+Finished\+Context finished\+Context=nullptr)
\item 
\mbox{\Hypertarget{class_gr_direct_context_ae67d796b9269ed97823c705dc362ee96}\label{class_gr_direct_context_ae67d796b9269ed97823c705dc362ee96}} 
\mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} {\bfseries create\+Backend\+Texture} (const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} \&src\+Data, Gr\+Renderable renderable, Gr\+Protected is\+Protected, Gr\+Gpu\+Finished\+Proc finished\+Proc=nullptr, Gr\+Gpu\+Finished\+Context finished\+Context=nullptr)
\item 
bool \mbox{\hyperlink{class_gr_direct_context_a96e5681a6a452f4fe74920abe1594e55}{update\+Backend\+Texture}} (const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} \&color, Gr\+Gpu\+Finished\+Proc finished\+Proc, Gr\+Gpu\+Finished\+Context finished\+Context)
\item 
bool \mbox{\hyperlink{class_gr_direct_context_a73536ee3f0f47e459f671f5b410b540c}{update\+Backend\+Texture}} (const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&, Sk\+Color\+Type sk\+Color\+Type, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} \&color, Gr\+Gpu\+Finished\+Proc finished\+Proc, Gr\+Gpu\+Finished\+Context finished\+Context)
\item 
bool \mbox{\hyperlink{class_gr_direct_context_afa88d9f58d0aab0f689115c5ce9a358a}{update\+Backend\+Texture}} (const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&, const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} src\+Data\mbox{[}$\,$\mbox{]}, int num\+Levels, Gr\+Surface\+Origin=k\+Top\+Left\+\_\+\+Gr\+Surface\+Origin, Gr\+Gpu\+Finished\+Proc finished\+Proc=nullptr, Gr\+Gpu\+Finished\+Context finished\+Context=nullptr)
\item 
bool \mbox{\hyperlink{class_gr_direct_context_a9a49762726cb726ec868970d75953a3b}{update\+Backend\+Texture}} (const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&texture, const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} \&src\+Data, Gr\+Surface\+Origin texture\+Origin=k\+Top\+Left\+\_\+\+Gr\+Surface\+Origin, Gr\+Gpu\+Finished\+Proc finished\+Proc=nullptr, Gr\+Gpu\+Finished\+Context finished\+Context=nullptr)
\item 
\mbox{\Hypertarget{class_gr_direct_context_ada4c2fbe8b51d6ccdfe6c3812c0e63ec}\label{class_gr_direct_context_ada4c2fbe8b51d6ccdfe6c3812c0e63ec}} 
bool {\bfseries update\+Backend\+Texture} (const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&texture, const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} src\+Data\mbox{[}$\,$\mbox{]}, int num\+Levels, Gr\+Gpu\+Finished\+Proc finished\+Proc, Gr\+Gpu\+Finished\+Context finished\+Context)
\item 
\mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \mbox{\hyperlink{class_gr_direct_context_a12afd59a71e0c36d85259cf800a0f819}{create\+Compressed\+Backend\+Texture}} (int width, int height, const \mbox{\hyperlink{class_gr_backend_format}{Gr\+Backend\+Format}} \&, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} \&color, Gr\+Mipmapped, Gr\+Protected=Gr\+Protected\+::k\+No, Gr\+Gpu\+Finished\+Proc finished\+Proc=nullptr, Gr\+Gpu\+Finished\+Context finished\+Context=nullptr)
\item 
\mbox{\Hypertarget{class_gr_direct_context_a95c5464f00a84bbfa329beb0fda739aa}\label{class_gr_direct_context_a95c5464f00a84bbfa329beb0fda739aa}} 
\mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} {\bfseries create\+Compressed\+Backend\+Texture} (int width, int height, Sk\+Image\+::\+Compression\+Type, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} \&color, Gr\+Mipmapped, Gr\+Protected=Gr\+Protected\+::k\+No, Gr\+Gpu\+Finished\+Proc finished\+Proc=nullptr, Gr\+Gpu\+Finished\+Context finished\+Context=nullptr)
\item 
\mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \mbox{\hyperlink{class_gr_direct_context_aa195f3bbf2c0baf8222cb1bdd40e9cd3}{create\+Compressed\+Backend\+Texture}} (int width, int height, const \mbox{\hyperlink{class_gr_backend_format}{Gr\+Backend\+Format}} \&, const void $\ast$data, size\+\_\+t data\+Size, Gr\+Mipmapped, Gr\+Protected=Gr\+Protected\+::k\+No, Gr\+Gpu\+Finished\+Proc finished\+Proc=nullptr, Gr\+Gpu\+Finished\+Context finished\+Context=nullptr)
\item 
\mbox{\Hypertarget{class_gr_direct_context_a9dd147b48e47fc84f0b82993109fcce2}\label{class_gr_direct_context_a9dd147b48e47fc84f0b82993109fcce2}} 
\mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} {\bfseries create\+Compressed\+Backend\+Texture} (int width, int height, Sk\+Image\+::\+Compression\+Type, const void $\ast$data, size\+\_\+t data\+Size, Gr\+Mipmapped, Gr\+Protected=Gr\+Protected\+::k\+No, Gr\+Gpu\+Finished\+Proc finished\+Proc=nullptr, Gr\+Gpu\+Finished\+Context finished\+Context=nullptr)
\item 
bool \mbox{\hyperlink{class_gr_direct_context_a079adf61ab054bec6a1c8d9a2ec397f7}{update\+Compressed\+Backend\+Texture}} (const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} \&color, Gr\+Gpu\+Finished\+Proc finished\+Proc, Gr\+Gpu\+Finished\+Context finished\+Context)
\item 
bool \mbox{\hyperlink{class_gr_direct_context_aeedaf24edf8574a524dbf6f95fbe46d3}{update\+Compressed\+Backend\+Texture}} (const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&, const void $\ast$data, size\+\_\+t data\+Size, Gr\+Gpu\+Finished\+Proc finished\+Proc, Gr\+Gpu\+Finished\+Context finished\+Context)
\item 
bool \mbox{\hyperlink{class_gr_direct_context_a16bbafa0153d1b0e5e2204693b633612}{set\+Backend\+Texture\+State}} (const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&, const \mbox{\hyperlink{class_gr_backend_surface_mutable_state}{Gr\+Backend\+Surface\+Mutable\+State}} \&, \mbox{\hyperlink{class_gr_backend_surface_mutable_state}{Gr\+Backend\+Surface\+Mutable\+State}} $\ast$previous\+State=nullptr, Gr\+Gpu\+Finished\+Proc finished\+Proc=nullptr, Gr\+Gpu\+Finished\+Context finished\+Context=nullptr)
\item 
\mbox{\Hypertarget{class_gr_direct_context_ad40dff2268a0278ac66368743488dc9c}\label{class_gr_direct_context_ad40dff2268a0278ac66368743488dc9c}} 
bool {\bfseries set\+Backend\+Render\+Target\+State} (const \mbox{\hyperlink{class_gr_backend_render_target}{Gr\+Backend\+Render\+Target}} \&, const \mbox{\hyperlink{class_gr_backend_surface_mutable_state}{Gr\+Backend\+Surface\+Mutable\+State}} \&, \mbox{\hyperlink{class_gr_backend_surface_mutable_state}{Gr\+Backend\+Surface\+Mutable\+State}} $\ast$previous\+State=nullptr, Gr\+Gpu\+Finished\+Proc finished\+Proc=nullptr, Gr\+Gpu\+Finished\+Context finished\+Context=nullptr)
\item 
\mbox{\Hypertarget{class_gr_direct_context_abb38898fe336b7a7492b3fc557e1fce0}\label{class_gr_direct_context_abb38898fe336b7a7492b3fc557e1fce0}} 
void {\bfseries delete\+Backend\+Texture} (\mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}})
\item 
\mbox{\Hypertarget{class_gr_direct_context_a4937ceb605a1a5eb68ba5b46774ab1f3}\label{class_gr_direct_context_a4937ceb605a1a5eb68ba5b46774ab1f3}} 
bool {\bfseries precompile\+Shader} (const \mbox{\hyperlink{class_sk_data}{Sk\+Data}} \&key, const \mbox{\hyperlink{class_sk_data}{Sk\+Data}} \&data)
\item 
\mbox{\Hypertarget{class_gr_direct_context_ac5d83c6a1ebf87e7cb663316618c7b2a}\label{class_gr_direct_context_ac5d83c6a1ebf87e7cb663316618c7b2a}} 
\mbox{\hyperlink{class_gr_direct_context_1_1_direct_context_i_d}{Direct\+Context\+ID}} {\bfseries direct\+Context\+ID} () const
\item 
\mbox{\Hypertarget{class_gr_direct_context_ada720016bb09790a74ef80c0e5c7971a}\label{class_gr_direct_context_ada720016bb09790a74ef80c0e5c7971a}} 
Gr\+Direct\+Context\+Priv {\bfseries priv} ()
\item 
\mbox{\Hypertarget{class_gr_direct_context_ad2df6cb2d6a771e5f55a502260033575}\label{class_gr_direct_context_ad2df6cb2d6a771e5f55a502260033575}} 
const Gr\+Direct\+Context\+Priv {\bfseries priv} () const
\item 
S\+K\+\_\+\+A\+PI int \mbox{\hyperlink{class_gr_direct_context_af480871a350a61af8fbc0fb413f0edec}{max\+Texture\+Size}} () const
\item 
S\+K\+\_\+\+A\+PI int \mbox{\hyperlink{class_gr_direct_context_aa146ee57d29949b62820d89e7f32ab05}{max\+Render\+Target\+Size}} () const
\item 
S\+K\+\_\+\+A\+PI bool \mbox{\hyperlink{class_gr_direct_context_afe5137fe6551394acee186d6be5631d1}{color\+Type\+Supported\+As\+Image}} (Sk\+Color\+Type) const
\item 
S\+K\+\_\+\+A\+PI bool \mbox{\hyperlink{class_gr_direct_context_a2d321e29a1ba933f0e6e538e8095e553}{color\+Type\+Supported\+As\+Surface}} (Sk\+Color\+Type color\+Type) const
\item 
S\+K\+\_\+\+A\+PI int \mbox{\hyperlink{class_gr_direct_context_a8421a291fdc2d1d5072d182eee34661f}{max\+Surface\+Sample\+Count\+For\+Color\+Type}} (Sk\+Color\+Type) const
\item 
S\+K\+\_\+\+A\+PI \mbox{\hyperlink{class_gr_backend_format}{Gr\+Backend\+Format}} \mbox{\hyperlink{class_gr_direct_context_a511bc7524a6d21ac973b2b17ed6cc429}{default\+Backend\+Format}} (Sk\+Color\+Type ct, Gr\+Renderable renderable) const
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_gr_direct_context_a85db11cd8ef1990bd556519f7141b578}\label{class_gr_direct_context_a85db11cd8ef1990bd556519f7141b578}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_gr_direct_context}{Gr\+Direct\+Context}} $>$ {\bfseries Make\+Mock} (const \mbox{\hyperlink{struct_gr_mock_options}{Gr\+Mock\+Options}} $\ast$, const \mbox{\hyperlink{struct_gr_context_options}{Gr\+Context\+Options}} \&)
\item 
\mbox{\Hypertarget{class_gr_direct_context_aaec3fc35ff3ade9c9b204b2854f78459}\label{class_gr_direct_context_aaec3fc35ff3ade9c9b204b2854f78459}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_gr_direct_context}{Gr\+Direct\+Context}} $>$ {\bfseries Make\+Mock} (const \mbox{\hyperlink{struct_gr_mock_options}{Gr\+Mock\+Options}} $\ast$)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_gr_direct_context_a5b129026cae0551b3e3ed8271de82cc7}\label{class_gr_direct_context_a5b129026cae0551b3e3ed8271de82cc7}} 
{\bfseries Gr\+Direct\+Context} (Gr\+Backend\+Api backend, const \mbox{\hyperlink{struct_gr_context_options}{Gr\+Context\+Options}} \&options)
\item 
\mbox{\Hypertarget{class_gr_direct_context_ac4f9af3c32aecfe7313a94e25eff6596}\label{class_gr_direct_context_ac4f9af3c32aecfe7313a94e25eff6596}} 
bool {\bfseries init} () override
\item 
\mbox{\Hypertarget{class_gr_direct_context_a2c14ea4ebf560dc68b961cc4ccacd5b3}\label{class_gr_direct_context_a2c14ea4ebf560dc68b961cc4ccacd5b3}} 
Gr\+Atlas\+Manager $\ast$ {\bfseries on\+Get\+Atlas\+Manager} ()
\item 
\mbox{\Hypertarget{class_gr_direct_context_ab4217add97746bc67a43af937a4154f5}\label{class_gr_direct_context_ab4217add97746bc67a43af937a4154f5}} 
skgpu\+::v1\+::\+Small\+Path\+Atlas\+Mgr $\ast$ {\bfseries on\+Get\+Small\+Path\+Atlas\+Mgr} ()
\item 
\mbox{\Hypertarget{class_gr_direct_context_a0f4f5d9acefdd3b2efffd62d5c56d89b}\label{class_gr_direct_context_a0f4f5d9acefdd3b2efffd62d5c56d89b}} 
\mbox{\hyperlink{class_gr_direct_context}{Gr\+Direct\+Context}} $\ast$ {\bfseries as\+Direct\+Context} () override
\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_gr_direct_context_a016f4a23a99255494f8d2a1a578fc687}\label{class_gr_direct_context_a016f4a23a99255494f8d2a1a578fc687}} 
class {\bfseries Gr\+Direct\+Context\+Priv}
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_gr_direct_context_aeb90c9ad9c8f849f8c09ce965f570a3d}\label{class_gr_direct_context_aeb90c9ad9c8f849f8c09ce965f570a3d}} 
\index{GrDirectContext@{GrDirectContext}!abandonContext@{abandonContext}}
\index{abandonContext@{abandonContext}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{abandonContext()}{abandonContext()}}
{\footnotesize\ttfamily void Gr\+Direct\+Context\+::abandon\+Context (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Abandons all G\+PU resources and assumes the underlying backend 3D A\+PI context is no longer usable. Call this if you have lost the associated G\+PU context, and thus internal texture, buffer, etc. references/\+I\+Ds are now invalid. Calling this ensures that the destructors of the context and any of its created resource objects will not make backend 3D A\+PI calls. Content rendered but not previously flushed may be lost. After this function is called all subsequent calls on the context will fail or be no-\/ops.

The typical use case for this function is that the underlying 3D context was lost and further A\+PI calls may crash.

For Vulkan, even if the device becomes lost, the Vk\+Queue, Vk\+Device, or Vk\+Instance used to create the context must be kept alive even after abandoning the context. Those objects must live for the lifetime of the context object itself. The reason for this is so that we can continue to delete any outstanding Gr\+Backend\+Textures/\+Render\+Targets which must be cleaned up even in a device lost state. 

Reimplemented from \mbox{\hyperlink{class_gr_image_context}{Gr\+Image\+Context}}.

\mbox{\Hypertarget{class_gr_direct_context_a5c1c5c644a82f21ce2af991b4f451348}\label{class_gr_direct_context_a5c1c5c644a82f21ce2af991b4f451348}} 
\index{GrDirectContext@{GrDirectContext}!abandoned@{abandoned}}
\index{abandoned@{abandoned}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{abandoned()}{abandoned()}}
{\footnotesize\ttfamily bool Gr\+Direct\+Context\+::abandoned (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Returns true if the context was abandoned or if the if the backend specific context has gotten into an unrecoverarble, lost state (e.\+g. in Vulkan backend if we\textquotesingle{}ve gotten a V\+K\+\_\+\+E\+R\+R\+O\+R\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+L\+O\+ST). If the backend context is lost, this call will also abandon this context. 

Reimplemented from \mbox{\hyperlink{class_gr_image_context}{Gr\+Image\+Context}}.

\mbox{\Hypertarget{class_gr_direct_context_a347baddc1feca01526524c6cabdd3c84}\label{class_gr_direct_context_a347baddc1feca01526524c6cabdd3c84}} 
\index{GrDirectContext@{GrDirectContext}!checkAsyncWorkCompletion@{checkAsyncWorkCompletion}}
\index{checkAsyncWorkCompletion@{checkAsyncWorkCompletion}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{checkAsyncWorkCompletion()}{checkAsyncWorkCompletion()}}
{\footnotesize\ttfamily void Gr\+Direct\+Context\+::check\+Async\+Work\+Completion (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Checks whether any asynchronous work is complete and if so calls related callbacks. \mbox{\Hypertarget{class_gr_direct_context_afe5137fe6551394acee186d6be5631d1}\label{class_gr_direct_context_afe5137fe6551394acee186d6be5631d1}} 
\index{GrDirectContext@{GrDirectContext}!colorTypeSupportedAsImage@{colorTypeSupportedAsImage}}
\index{colorTypeSupportedAsImage@{colorTypeSupportedAsImage}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{colorTypeSupportedAsImage()}{colorTypeSupportedAsImage()}}
{\footnotesize\ttfamily S\+K\+\_\+\+A\+PI bool Gr\+Recording\+Context\+::color\+Type\+Supported\+As\+Image}

Can a \mbox{\hyperlink{class_sk_image}{Sk\+Image}} be created with the given color type. \mbox{\Hypertarget{class_gr_direct_context_a2d321e29a1ba933f0e6e538e8095e553}\label{class_gr_direct_context_a2d321e29a1ba933f0e6e538e8095e553}} 
\index{GrDirectContext@{GrDirectContext}!colorTypeSupportedAsSurface@{colorTypeSupportedAsSurface}}
\index{colorTypeSupportedAsSurface@{colorTypeSupportedAsSurface}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{colorTypeSupportedAsSurface()}{colorTypeSupportedAsSurface()}}
{\footnotesize\ttfamily S\+K\+\_\+\+A\+PI bool Gr\+Recording\+Context\+::color\+Type\+Supported\+As\+Surface\hspace{0.3cm}{\ttfamily [inline]}}

Can a \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} be created with the given color type. To check whether M\+S\+AA is supported use \mbox{\hyperlink{class_gr_recording_context_a8421a291fdc2d1d5072d182eee34661f}{max\+Surface\+Sample\+Count\+For\+Color\+Type()}}. \mbox{\Hypertarget{class_gr_direct_context_af3e96b31af4b591cd147ebba07920ed3}\label{class_gr_direct_context_af3e96b31af4b591cd147ebba07920ed3}} 
\index{GrDirectContext@{GrDirectContext}!createBackendTexture@{createBackendTexture}}
\index{createBackendTexture@{createBackendTexture}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{createBackendTexture()}{createBackendTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} Gr\+Direct\+Context\+::create\+Backend\+Texture (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} \&}]{src\+Data,  }\item[{Gr\+Surface\+Origin}]{texture\+Origin,  }\item[{Gr\+Renderable}]{renderable,  }\item[{Gr\+Protected}]{is\+Protected,  }\item[{Gr\+Gpu\+Finished\+Proc}]{finished\+Proc = {\ttfamily nullptr},  }\item[{Gr\+Gpu\+Finished\+Context}]{finished\+Context = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Convenience version \mbox{\hyperlink{class_gr_direct_context_a87af0af0e7ed940e4940e132b980aae3}{create\+Backend\+Texture()}} that takes just a base level pixmap. \mbox{\Hypertarget{class_gr_direct_context_af151abc92b45bdc74b99471a33e2dd24}\label{class_gr_direct_context_af151abc92b45bdc74b99471a33e2dd24}} 
\index{GrDirectContext@{GrDirectContext}!createBackendTexture@{createBackendTexture}}
\index{createBackendTexture@{createBackendTexture}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{createBackendTexture()}{createBackendTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} Gr\+Direct\+Context\+::create\+Backend\+Texture (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}}}]{src\+Data\mbox{[}$\,$\mbox{]},  }\item[{int}]{num\+Levels,  }\item[{Gr\+Surface\+Origin}]{,  }\item[{Gr\+Renderable}]{,  }\item[{Gr\+Protected}]{,  }\item[{Gr\+Gpu\+Finished\+Proc}]{finished\+Proc = {\ttfamily nullptr},  }\item[{Gr\+Gpu\+Finished\+Context}]{finished\+Context = {\ttfamily nullptr} }\end{DoxyParamCaption})}

If possible, create a backend texture initialized with the provided pixmap data. The client should ensure that the returned backend texture is valid. The client can pass in a finished\+Proc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call {\ttfamily submit} to send the upload work to the gpu. The finished\+Proc will always get called even if we failed to create the \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}}. If successful, the created backend texture will be compatible with the provided pixmap(s). Compatible, in this case, means that the backend format will be the result of calling default\+Backend\+Format on the base pixmap\textquotesingle{}s colortype. The src data can be deleted when this call returns. If num\+Levels is 1 a non-\/mip\+Mapped texture will result. If a mip\+Mapped texture is desired the data for all the mipmap levels must be provided. In the mipmapped case all the colortypes of the provided pixmaps must be the same. Additionally, all the miplevels must be sized correctly (please see Sk\+Mipmap\+::\+Compute\+Level\+Size and Compute\+Level\+Count). The Gr\+Surface\+Origin controls whether the pixmap data is vertically flipped in the texture. Note\+: the pixmap\textquotesingle{}s alphatypes and colorspaces are ignored. For the Vulkan backend the layout of the created Vk\+Image will be\+: V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+S\+H\+A\+D\+E\+R\+\_\+\+R\+E\+A\+D\+\_\+\+O\+N\+L\+Y\+\_\+\+O\+P\+T\+I\+M\+AL \mbox{\Hypertarget{class_gr_direct_context_a60567ade1eab2d44db3a79a76d27b79b}\label{class_gr_direct_context_a60567ade1eab2d44db3a79a76d27b79b}} 
\index{GrDirectContext@{GrDirectContext}!createBackendTexture@{createBackendTexture}}
\index{createBackendTexture@{createBackendTexture}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{createBackendTexture()}{createBackendTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} Gr\+Direct\+Context\+::create\+Backend\+Texture (\begin{DoxyParamCaption}\item[{int}]{width,  }\item[{int}]{height,  }\item[{const \mbox{\hyperlink{class_gr_backend_format}{Gr\+Backend\+Format}} \&}]{,  }\item[{const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} \&}]{color,  }\item[{Gr\+Mipmapped}]{,  }\item[{Gr\+Renderable}]{,  }\item[{Gr\+Protected}]{ = {\ttfamily GrProtected\+:\+:kNo},  }\item[{Gr\+Gpu\+Finished\+Proc}]{finished\+Proc = {\ttfamily nullptr},  }\item[{Gr\+Gpu\+Finished\+Context}]{finished\+Context = {\ttfamily nullptr} }\end{DoxyParamCaption})}

If possible, create a backend texture initialized to a particular color. The client should ensure that the returned backend texture is valid. The client can pass in a finished\+Proc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call {\ttfamily submit} to send the upload work to the gpu. The finished\+Proc will always get called even if we failed to create the \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}}. For the Vulkan backend the layout of the created Vk\+Image will be\+: V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+S\+H\+A\+D\+E\+R\+\_\+\+R\+E\+A\+D\+\_\+\+O\+N\+L\+Y\+\_\+\+O\+P\+T\+I\+M\+AL \mbox{\Hypertarget{class_gr_direct_context_a87af0af0e7ed940e4940e132b980aae3}\label{class_gr_direct_context_a87af0af0e7ed940e4940e132b980aae3}} 
\index{GrDirectContext@{GrDirectContext}!createBackendTexture@{createBackendTexture}}
\index{createBackendTexture@{createBackendTexture}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{createBackendTexture()}{createBackendTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} Gr\+Direct\+Context\+::create\+Backend\+Texture (\begin{DoxyParamCaption}\item[{int}]{width,  }\item[{int}]{height,  }\item[{const \mbox{\hyperlink{class_gr_backend_format}{Gr\+Backend\+Format}} \&}]{,  }\item[{Gr\+Mipmapped}]{,  }\item[{Gr\+Renderable}]{,  }\item[{Gr\+Protected}]{ = {\ttfamily GrProtected\+:\+:kNo} }\end{DoxyParamCaption})}

The explicitly allocated backend texture A\+PI allows clients to use Skia to create backend objects outside of Skia proper (i.\+e., Skia\textquotesingle{}s caching system will not know about them.)

It is the client\textquotesingle{}s responsibility to delete all these objects (using delete\+Backend\+Texture) before deleting the context used to create them. If the backend is Vulkan, the textures must be deleted before abandoning the context as well. Additionally, clients should only delete these objects on the thread for which that context is active.

The client is responsible for ensuring synchronization between different uses of the backend object (i.\+e., wrapping it in a surface, rendering to it, deleting the surface, rewrapping it in a image and drawing the image will require explicit synchronization on the client\textquotesingle{}s part). If possible, create an uninitialized backend texture. The client should ensure that the returned backend texture is valid. For the Vulkan backend the layout of the created Vk\+Image will be\+: V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+U\+N\+D\+E\+F\+I\+N\+ED. \mbox{\Hypertarget{class_gr_direct_context_a62f84fdee1cb5b34426002134f6e17c9}\label{class_gr_direct_context_a62f84fdee1cb5b34426002134f6e17c9}} 
\index{GrDirectContext@{GrDirectContext}!createBackendTexture@{createBackendTexture}}
\index{createBackendTexture@{createBackendTexture}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{createBackendTexture()}{createBackendTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} Gr\+Direct\+Context\+::create\+Backend\+Texture (\begin{DoxyParamCaption}\item[{int}]{width,  }\item[{int}]{height,  }\item[{Sk\+Color\+Type}]{,  }\item[{const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} \&}]{color,  }\item[{Gr\+Mipmapped}]{,  }\item[{Gr\+Renderable}]{,  }\item[{Gr\+Protected}]{ = {\ttfamily GrProtected\+:\+:kNo},  }\item[{Gr\+Gpu\+Finished\+Proc}]{finished\+Proc = {\ttfamily nullptr},  }\item[{Gr\+Gpu\+Finished\+Context}]{finished\+Context = {\ttfamily nullptr} }\end{DoxyParamCaption})}

If possible, create a backend texture initialized to a particular color. The client should ensure that the returned backend texture is valid. The client can pass in a finished\+Proc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call {\ttfamily submit} to send the upload work to the gpu. The finished\+Proc will always get called even if we failed to create the \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}}. If successful, the created backend texture will be compatible with the provided Sk\+Color\+Type. For the Vulkan backend the layout of the created Vk\+Image will be\+: V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+S\+H\+A\+D\+E\+R\+\_\+\+R\+E\+A\+D\+\_\+\+O\+N\+L\+Y\+\_\+\+O\+P\+T\+I\+M\+AL \mbox{\Hypertarget{class_gr_direct_context_a334dcc3239840aeec75f3322ae1987d7}\label{class_gr_direct_context_a334dcc3239840aeec75f3322ae1987d7}} 
\index{GrDirectContext@{GrDirectContext}!createBackendTexture@{createBackendTexture}}
\index{createBackendTexture@{createBackendTexture}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{createBackendTexture()}{createBackendTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} Gr\+Direct\+Context\+::create\+Backend\+Texture (\begin{DoxyParamCaption}\item[{int}]{width,  }\item[{int}]{height,  }\item[{Sk\+Color\+Type}]{,  }\item[{Gr\+Mipmapped}]{,  }\item[{Gr\+Renderable}]{,  }\item[{Gr\+Protected}]{ = {\ttfamily GrProtected\+:\+:kNo} }\end{DoxyParamCaption})}

If possible, create an uninitialized backend texture. The client should ensure that the returned backend texture is valid. If successful, the created backend texture will be compatible with the provided Sk\+Color\+Type. For the Vulkan backend the layout of the created Vk\+Image will be\+: V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+U\+N\+D\+E\+F\+I\+N\+ED. \mbox{\Hypertarget{class_gr_direct_context_a12afd59a71e0c36d85259cf800a0f819}\label{class_gr_direct_context_a12afd59a71e0c36d85259cf800a0f819}} 
\index{GrDirectContext@{GrDirectContext}!createCompressedBackendTexture@{createCompressedBackendTexture}}
\index{createCompressedBackendTexture@{createCompressedBackendTexture}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{createCompressedBackendTexture()}{createCompressedBackendTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} Gr\+Direct\+Context\+::create\+Compressed\+Backend\+Texture (\begin{DoxyParamCaption}\item[{int}]{width,  }\item[{int}]{height,  }\item[{const \mbox{\hyperlink{class_gr_backend_format}{Gr\+Backend\+Format}} \&}]{,  }\item[{const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} \&}]{color,  }\item[{Gr\+Mipmapped}]{,  }\item[{Gr\+Protected}]{ = {\ttfamily GrProtected\+:\+:kNo},  }\item[{Gr\+Gpu\+Finished\+Proc}]{finished\+Proc = {\ttfamily nullptr},  }\item[{Gr\+Gpu\+Finished\+Context}]{finished\+Context = {\ttfamily nullptr} }\end{DoxyParamCaption})}

If possible, create a compressed backend texture initialized to a particular color. The client should ensure that the returned backend texture is valid. The client can pass in a finished\+Proc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call {\ttfamily submit} to send the upload work to the gpu. The finished\+Proc will always get called even if we failed to create the \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}}. For the Vulkan backend the layout of the created Vk\+Image will be\+: V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+S\+H\+A\+D\+E\+R\+\_\+\+R\+E\+A\+D\+\_\+\+O\+N\+L\+Y\+\_\+\+O\+P\+T\+I\+M\+AL \mbox{\Hypertarget{class_gr_direct_context_aa195f3bbf2c0baf8222cb1bdd40e9cd3}\label{class_gr_direct_context_aa195f3bbf2c0baf8222cb1bdd40e9cd3}} 
\index{GrDirectContext@{GrDirectContext}!createCompressedBackendTexture@{createCompressedBackendTexture}}
\index{createCompressedBackendTexture@{createCompressedBackendTexture}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{createCompressedBackendTexture()}{createCompressedBackendTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} Gr\+Direct\+Context\+::create\+Compressed\+Backend\+Texture (\begin{DoxyParamCaption}\item[{int}]{width,  }\item[{int}]{height,  }\item[{const \mbox{\hyperlink{class_gr_backend_format}{Gr\+Backend\+Format}} \&}]{,  }\item[{const void $\ast$}]{data,  }\item[{size\+\_\+t}]{data\+Size,  }\item[{Gr\+Mipmapped}]{,  }\item[{Gr\+Protected}]{ = {\ttfamily GrProtected\+:\+:kNo},  }\item[{Gr\+Gpu\+Finished\+Proc}]{finished\+Proc = {\ttfamily nullptr},  }\item[{Gr\+Gpu\+Finished\+Context}]{finished\+Context = {\ttfamily nullptr} }\end{DoxyParamCaption})}

If possible, create a backend texture initialized with the provided raw data. The client should ensure that the returned backend texture is valid. The client can pass in a finished\+Proc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call {\ttfamily submit} to send the upload work to the gpu. The finished\+Proc will always get called even if we failed to create the \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} If num\+Levels is 1 a non-\/mip\+Mapped texture will result. If a mip\+Mapped texture is desired the data for all the mipmap levels must be provided. Additionally, all the miplevels must be sized correctly (please see Sk\+Mipmap\+::\+Compute\+Level\+Size and Compute\+Level\+Count). For the Vulkan backend the layout of the created Vk\+Image will be\+: V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+S\+H\+A\+D\+E\+R\+\_\+\+R\+E\+A\+D\+\_\+\+O\+N\+L\+Y\+\_\+\+O\+P\+T\+I\+M\+AL \mbox{\Hypertarget{class_gr_direct_context_a511bc7524a6d21ac973b2b17ed6cc429}\label{class_gr_direct_context_a511bc7524a6d21ac973b2b17ed6cc429}} 
\index{GrDirectContext@{GrDirectContext}!defaultBackendFormat@{defaultBackendFormat}}
\index{defaultBackendFormat@{defaultBackendFormat}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{defaultBackendFormat()}{defaultBackendFormat()}}
{\footnotesize\ttfamily S\+K\+\_\+\+A\+PI \mbox{\hyperlink{class_gr_backend_format}{Gr\+Backend\+Format}} Gr\+Recording\+Context\+::default\+Backend\+Format\hspace{0.3cm}{\ttfamily [inline]}}

Retrieve the default \mbox{\hyperlink{class_gr_backend_format}{Gr\+Backend\+Format}} for a given Sk\+Color\+Type and renderability. It is guaranteed that this backend format will be the one used by the following Sk\+Color\+Type and Sk\+Surface\+Characterization-\/based create\+Backend\+Texture methods.

The caller should check that the returned format is valid. \mbox{\Hypertarget{class_gr_direct_context_ac03201b03a0d733d1a0af6a2775cdb00}\label{class_gr_direct_context_ac03201b03a0d733d1a0af6a2775cdb00}} 
\index{GrDirectContext@{GrDirectContext}!dumpMemoryStatistics@{dumpMemoryStatistics}}
\index{dumpMemoryStatistics@{dumpMemoryStatistics}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{dumpMemoryStatistics()}{dumpMemoryStatistics()}}
{\footnotesize\ttfamily void Gr\+Direct\+Context\+::dump\+Memory\+Statistics (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_trace_memory_dump}{Sk\+Trace\+Memory\+Dump}} $\ast$}]{trace\+Memory\+Dump }\end{DoxyParamCaption}) const}

Enumerates all cached G\+PU resources and dumps their memory to trace\+Memory\+Dump. \mbox{\Hypertarget{class_gr_direct_context_a953f6ace921cd53e1333624c7770db54}\label{class_gr_direct_context_a953f6ace921cd53e1333624c7770db54}} 
\index{GrDirectContext@{GrDirectContext}!flush@{flush}}
\index{flush@{flush}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{flush()}{flush()}}
{\footnotesize\ttfamily Gr\+Semaphores\+Submitted Gr\+Direct\+Context\+::flush (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}} \&}]{info }\end{DoxyParamCaption})}

Call to ensure all drawing to the context has been flushed to underlying 3D A\+PI specific objects. A call to {\ttfamily submit} is always required to ensure work is actually sent to the gpu. Some specific A\+PI details\+: GL\+: Commands are actually sent to the driver, but gl\+Flush is never called. Thus some sync objects from the flush will not be valid until a submission occurs.

Vulkan/\+Metal/\+D3\+D/\+Dawn\+: Commands are recorded to the backend A\+P\+Is corresponding command buffer or encoder objects. However, these objects are not sent to the gpu until a submission occurs.

If the return is Gr\+Semaphores\+Submitted\+::k\+Yes, only initialized Gr\+Backend\+Semaphores will be submitted to the gpu during the next submit call (it is possible Skia failed to create a subset of the semaphores). The client should not wait on these semaphores until after submit has been called, and must keep them alive until then. If this call returns Gr\+Semaphores\+Submitted\+::k\+No, the G\+PU backend will not submit any semaphores to be signaled on the G\+PU. Thus the client should not have the G\+PU wait on any of the semaphores passed in with the \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}}. Regardless of whether semaphores were submitted to the G\+PU or not, the client is still responsible for deleting any initialized semaphores. Regardleess of semaphore submission the context will still be flushed. It should be emphasized that a return value of Gr\+Semaphores\+Submitted\+::k\+No does not mean the flush did not happen. It simply means there were no semaphores submitted to the G\+PU. A caller should only take this as a failure if they passed in semaphores to be submitted. \mbox{\Hypertarget{class_gr_direct_context_a5e068da6db37707ee353abedc584ef6f}\label{class_gr_direct_context_a5e068da6db37707ee353abedc584ef6f}} 
\index{GrDirectContext@{GrDirectContext}!flushAndSubmit@{flushAndSubmit}}
\index{flushAndSubmit@{flushAndSubmit}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{flushAndSubmit()}{flushAndSubmit()}}
{\footnotesize\ttfamily void Gr\+Direct\+Context\+::flush\+And\+Submit (\begin{DoxyParamCaption}\item[{bool}]{sync\+Cpu = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Call to ensure all drawing to the context has been flushed and submitted to the underlying 3D A\+PI. This is equivalent to calling Gr\+Context\+::flush with a default \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}} followed by Gr\+Context\+::submit(sync\+Cpu). \mbox{\Hypertarget{class_gr_direct_context_a3ef10709e240b76201c4ca5a26932890}\label{class_gr_direct_context_a3ef10709e240b76201c4ca5a26932890}} 
\index{GrDirectContext@{GrDirectContext}!freeGpuResources@{freeGpuResources}}
\index{freeGpuResources@{freeGpuResources}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{freeGpuResources()}{freeGpuResources()}}
{\footnotesize\ttfamily void Gr\+Direct\+Context\+::free\+Gpu\+Resources (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Frees G\+PU created by the context. Can be called to reduce G\+PU memory pressure. \mbox{\Hypertarget{class_gr_direct_context_a41b00959f2ef26e2c1ac2a7b56e666dc}\label{class_gr_direct_context_a41b00959f2ef26e2c1ac2a7b56e666dc}} 
\index{GrDirectContext@{GrDirectContext}!getResourceCacheLimit@{getResourceCacheLimit}}
\index{getResourceCacheLimit@{getResourceCacheLimit}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{getResourceCacheLimit()}{getResourceCacheLimit()}}
{\footnotesize\ttfamily size\+\_\+t Gr\+Direct\+Context\+::get\+Resource\+Cache\+Limit (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Return the current G\+PU resource cache limit in bytes. \mbox{\Hypertarget{class_gr_direct_context_ac20d13cd13b25b1aacf12454da4a0af2}\label{class_gr_direct_context_ac20d13cd13b25b1aacf12454da4a0af2}} 
\index{GrDirectContext@{GrDirectContext}!getResourceCacheLimits@{getResourceCacheLimits}}
\index{getResourceCacheLimits@{getResourceCacheLimits}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{getResourceCacheLimits()}{getResourceCacheLimits()}}
{\footnotesize\ttfamily void Gr\+Direct\+Context\+::get\+Resource\+Cache\+Limits (\begin{DoxyParamCaption}\item[{int $\ast$}]{max\+Resources,  }\item[{size\+\_\+t $\ast$}]{max\+Resource\+Bytes }\end{DoxyParamCaption}) const}

D\+E\+P\+R\+E\+C\+A\+T\+ED Return the current G\+PU resource cache limits.


\begin{DoxyParams}{Parameters}
{\em max\+Resources} & If non-\/null, will be set to -\/1. \\
\hline
{\em max\+Resource\+Bytes} & If non-\/null, returns maximum number of bytes of video memory that can be held in the cache. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_gr_direct_context_a1c49050b805e1d24c1cb2fb0266bf982}\label{class_gr_direct_context_a1c49050b805e1d24c1cb2fb0266bf982}} 
\index{GrDirectContext@{GrDirectContext}!getResourceCachePurgeableBytes@{getResourceCachePurgeableBytes}}
\index{getResourceCachePurgeableBytes@{getResourceCachePurgeableBytes}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{getResourceCachePurgeableBytes()}{getResourceCachePurgeableBytes()}}
{\footnotesize\ttfamily size\+\_\+t Gr\+Direct\+Context\+::get\+Resource\+Cache\+Purgeable\+Bytes (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Gets the number of bytes in the cache consumed by purgeable (e.\+g. unlocked) resources. \mbox{\Hypertarget{class_gr_direct_context_abc2553f48d12afb0595f6f7920894446}\label{class_gr_direct_context_abc2553f48d12afb0595f6f7920894446}} 
\index{GrDirectContext@{GrDirectContext}!getResourceCacheUsage@{getResourceCacheUsage}}
\index{getResourceCacheUsage@{getResourceCacheUsage}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{getResourceCacheUsage()}{getResourceCacheUsage()}}
{\footnotesize\ttfamily void Gr\+Direct\+Context\+::get\+Resource\+Cache\+Usage (\begin{DoxyParamCaption}\item[{int $\ast$}]{resource\+Count,  }\item[{size\+\_\+t $\ast$}]{resource\+Bytes }\end{DoxyParamCaption}) const}

Gets the current G\+PU resource cache usage.


\begin{DoxyParams}{Parameters}
{\em resource\+Count} & If non-\/null, returns the number of resources that are held in the cache. \\
\hline
{\em max\+Resource\+Bytes} & If non-\/null, returns the total number of bytes of video memory held in the cache. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_gr_direct_context_aa146ee57d29949b62820d89e7f32ab05}\label{class_gr_direct_context_aa146ee57d29949b62820d89e7f32ab05}} 
\index{GrDirectContext@{GrDirectContext}!maxRenderTargetSize@{maxRenderTargetSize}}
\index{maxRenderTargetSize@{maxRenderTargetSize}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{maxRenderTargetSize()}{maxRenderTargetSize()}}
{\footnotesize\ttfamily S\+K\+\_\+\+A\+PI int Gr\+Recording\+Context\+::max\+Render\+Target\+Size}

Gets the maximum supported render target size. \mbox{\Hypertarget{class_gr_direct_context_a8421a291fdc2d1d5072d182eee34661f}\label{class_gr_direct_context_a8421a291fdc2d1d5072d182eee34661f}} 
\index{GrDirectContext@{GrDirectContext}!maxSurfaceSampleCountForColorType@{maxSurfaceSampleCountForColorType}}
\index{maxSurfaceSampleCountForColorType@{maxSurfaceSampleCountForColorType}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{maxSurfaceSampleCountForColorType()}{maxSurfaceSampleCountForColorType()}}
{\footnotesize\ttfamily S\+K\+\_\+\+A\+PI int Gr\+Recording\+Context\+::max\+Surface\+Sample\+Count\+For\+Color\+Type}

Gets the maximum supported sample count for a color type. 1 is returned if only non-\/\+M\+S\+AA rendering is supported for the color type. 0 is returned if rendering to this color type is not supported at all. \mbox{\Hypertarget{class_gr_direct_context_af480871a350a61af8fbc0fb413f0edec}\label{class_gr_direct_context_af480871a350a61af8fbc0fb413f0edec}} 
\index{GrDirectContext@{GrDirectContext}!maxTextureSize@{maxTextureSize}}
\index{maxTextureSize@{maxTextureSize}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{maxTextureSize()}{maxTextureSize()}}
{\footnotesize\ttfamily S\+K\+\_\+\+A\+PI int Gr\+Recording\+Context\+::max\+Texture\+Size}

Gets the maximum supported texture size. \mbox{\Hypertarget{class_gr_direct_context_a46cacd2825836fd0305ee183e6fd276e}\label{class_gr_direct_context_a46cacd2825836fd0305ee183e6fd276e}} 
\index{GrDirectContext@{GrDirectContext}!oomed@{oomed}}
\index{oomed@{oomed}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{oomed()}{oomed()}}
{\footnotesize\ttfamily bool Gr\+Direct\+Context\+::oomed (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Checks if the underlying 3D A\+PI reported an out-\/of-\/memory error. If this returns true it is reset and will return false until another out-\/of-\/memory error is reported by the 3D A\+PI. If the context is abandoned then this will report false.

Currently this is implemented for\+:

Open\+GL \mbox{[}ES\mbox{]} -\/ Note that client calls to gl\+Get\+Error() may swallow G\+L\+\_\+\+O\+U\+T\+\_\+\+O\+F\+\_\+\+M\+E\+M\+O\+RY errors and therefore hide the error from Skia. Also, it is not advised to use this in combination with enabling Gr\+Context\+Options\+::f\+Skip\+G\+L\+Error\+Checks. That option may prevent the context from ever checking the GL context for O\+OM.

Vulkan -\/ Reports true if V\+K\+\_\+\+E\+R\+R\+O\+R\+\_\+\+O\+U\+T\+\_\+\+O\+F\+\_\+\+H\+O\+S\+T\+\_\+\+M\+E\+M\+O\+RY or V\+K\+\_\+\+E\+R\+R\+O\+R\+\_\+\+O\+U\+T\+\_\+\+O\+F\+\_\+\+D\+E\+V\+I\+C\+E\+\_\+\+M\+E\+M\+O\+RY has occurred. \mbox{\Hypertarget{class_gr_direct_context_aae098633b71c877cf97965f0414f17ed}\label{class_gr_direct_context_aae098633b71c877cf97965f0414f17ed}} 
\index{GrDirectContext@{GrDirectContext}!performDeferredCleanup@{performDeferredCleanup}}
\index{performDeferredCleanup@{performDeferredCleanup}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{performDeferredCleanup()}{performDeferredCleanup()}}
{\footnotesize\ttfamily void Gr\+Direct\+Context\+::perform\+Deferred\+Cleanup (\begin{DoxyParamCaption}\item[{std\+::chrono\+::milliseconds}]{ms\+Not\+Used,  }\item[{bool}]{scratch\+Resources\+Only = {\ttfamily false} }\end{DoxyParamCaption})}

Purge G\+PU resources that haven\textquotesingle{}t been used in the past \textquotesingle{}ms\+Not\+Used\textquotesingle{} milliseconds or are otherwise marked for deletion, regardless of whether the context is under budget.

If \textquotesingle{}scratch\+Resources\+Only\textquotesingle{} is true all unlocked scratch resources older than \textquotesingle{}ms\+Not\+Used\textquotesingle{} will be purged but the unlocked resources with persistent data will remain. If \textquotesingle{}scratch\+Resources\+Only\textquotesingle{} is false then all unlocked resources older than \textquotesingle{}ms\+Not\+Used\textquotesingle{} will be purged.


\begin{DoxyParams}{Parameters}
{\em ms\+Not\+Used} & Only unlocked resources not used in these last milliseconds will be cleaned up. \\
\hline
{\em scratch\+Resources\+Only} & If true only unlocked scratch resources will be purged. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_gr_direct_context_a464e8f2af9609a2937d05422eaaab5f7}\label{class_gr_direct_context_a464e8f2af9609a2937d05422eaaab5f7}} 
\index{GrDirectContext@{GrDirectContext}!purgeUnlockedResources@{purgeUnlockedResources}}
\index{purgeUnlockedResources@{purgeUnlockedResources}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{purgeUnlockedResources()}{purgeUnlockedResources()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Gr\+Direct\+Context\+::purge\+Unlocked\+Resources (\begin{DoxyParamCaption}\item[{bool}]{scratch\+Resources\+Only }\end{DoxyParamCaption})}

This entry point is intended for instances where an app has been backgrounded or suspended. If \textquotesingle{}scratch\+Resources\+Only\textquotesingle{} is true all unlocked scratch resources will be purged but the unlocked resources with persistent data will remain. If \textquotesingle{}scratch\+Resources\+Only\textquotesingle{} is false then all unlocked resources will be purged. In either case, after the unlocked resources are purged a separate pass will be made to ensure that resource usage is under budget (i.\+e., even if \textquotesingle{}scratch\+Resources\+Only\textquotesingle{} is true some resources with persistent data may be purged to be under budget).


\begin{DoxyParams}{Parameters}
{\em scratch\+Resources\+Only} & If true only unlocked scratch resources will be purged prior enforcing the budget requirements. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_gr_direct_context_ada9f27a269e2c41f6530cdb4ad0b4da3}\label{class_gr_direct_context_ada9f27a269e2c41f6530cdb4ad0b4da3}} 
\index{GrDirectContext@{GrDirectContext}!purgeUnlockedResources@{purgeUnlockedResources}}
\index{purgeUnlockedResources@{purgeUnlockedResources}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{purgeUnlockedResources()}{purgeUnlockedResources()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Gr\+Direct\+Context\+::purge\+Unlocked\+Resources (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{bytes\+To\+Purge,  }\item[{bool}]{prefer\+Scratch\+Resources }\end{DoxyParamCaption})}

Purge unlocked resources from the cache until the the provided byte count has been reached or we have purged all unlocked resources. The default policy is to purge in L\+RU order, but can be overridden to prefer purging scratch resources (in L\+RU order) prior to purging other resource types.


\begin{DoxyParams}{Parameters}
{\em max\+Bytes\+To\+Purge} & the desired number of bytes to be purged. \\
\hline
{\em prefer\+Scratch\+Resources} & If true scratch resources will be purged prior to other resource types. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_gr_direct_context_a585c7eebabd86ec88090d8cdee2d8f59}\label{class_gr_direct_context_a585c7eebabd86ec88090d8cdee2d8f59}} 
\index{GrDirectContext@{GrDirectContext}!releaseResourcesAndAbandonContext@{releaseResourcesAndAbandonContext}}
\index{releaseResourcesAndAbandonContext@{releaseResourcesAndAbandonContext}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{releaseResourcesAndAbandonContext()}{releaseResourcesAndAbandonContext()}}
{\footnotesize\ttfamily void Gr\+Direct\+Context\+::release\+Resources\+And\+Abandon\+Context (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

This is similar to \mbox{\hyperlink{class_gr_direct_context_aeb90c9ad9c8f849f8c09ce965f570a3d}{abandon\+Context()}} however the underlying 3D context is not yet lost and the context will cleanup all allocated resources before returning. After returning it will assume that the underlying context may no longer be valid.

The typical use case for this function is that the client is going to destroy the 3D context but can\textquotesingle{}t guarantee that context will be destroyed first (perhaps because it may be ref\textquotesingle{}ed elsewhere by either the client or Skia objects).

For Vulkan, even if the device becomes lost, the Vk\+Queue, Vk\+Device, or Vk\+Instance used to create the context must be alive before calling release\+Resources\+And\+Abandon\+Context. \mbox{\Hypertarget{class_gr_direct_context_a53c3539a51361c0483476a9efd247055}\label{class_gr_direct_context_a53c3539a51361c0483476a9efd247055}} 
\index{GrDirectContext@{GrDirectContext}!resetContext@{resetContext}}
\index{resetContext@{resetContext}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{resetContext()}{resetContext()}}
{\footnotesize\ttfamily void Gr\+Direct\+Context\+::reset\+Context (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{state = {\ttfamily kAll\+\_\+GrBackendState} }\end{DoxyParamCaption})}

The context normally assumes that no outsider is setting state within the underlying 3D A\+PI\textquotesingle{}s context/device/whatever. This call informs the context that the state was modified and it should resend. Shouldn\textquotesingle{}t be called frequently for good performance. The flag bits, state, is dependent on which backend is used by the context, either GL or D3D (possible in future). \mbox{\Hypertarget{class_gr_direct_context_ac1f54c0e0566c134841ea94bf5f1e29d}\label{class_gr_direct_context_ac1f54c0e0566c134841ea94bf5f1e29d}} 
\index{GrDirectContext@{GrDirectContext}!resetGLTextureBindings@{resetGLTextureBindings}}
\index{resetGLTextureBindings@{resetGLTextureBindings}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{resetGLTextureBindings()}{resetGLTextureBindings()}}
{\footnotesize\ttfamily void Gr\+Direct\+Context\+::reset\+G\+L\+Texture\+Bindings (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

If the backend is Gr\+Backend\+Api\+::k\+Open\+GL, then all texture unit/target combinations for which the context has modified the bound texture will have texture id 0 bound. This does not flush the context. Calling \mbox{\hyperlink{class_gr_direct_context_a53c3539a51361c0483476a9efd247055}{reset\+Context()}} does not change the set that will be bound to texture id 0 on the next call to \mbox{\hyperlink{class_gr_direct_context_ac1f54c0e0566c134841ea94bf5f1e29d}{reset\+G\+L\+Texture\+Bindings()}}. After this is called all unit/target combinations are considered to have unmodified bindings until the context subsequently modifies them (meaning if this is called twice in a row with no intervening context usage then the second call is a no-\/op.) \mbox{\Hypertarget{class_gr_direct_context_a16bbafa0153d1b0e5e2204693b633612}\label{class_gr_direct_context_a16bbafa0153d1b0e5e2204693b633612}} 
\index{GrDirectContext@{GrDirectContext}!setBackendTextureState@{setBackendTextureState}}
\index{setBackendTextureState@{setBackendTextureState}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{setBackendTextureState()}{setBackendTextureState()}}
{\footnotesize\ttfamily bool Gr\+Direct\+Context\+::set\+Backend\+Texture\+State (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&}]{,  }\item[{const \mbox{\hyperlink{class_gr_backend_surface_mutable_state}{Gr\+Backend\+Surface\+Mutable\+State}} \&}]{,  }\item[{\mbox{\hyperlink{class_gr_backend_surface_mutable_state}{Gr\+Backend\+Surface\+Mutable\+State}} $\ast$}]{previous\+State = {\ttfamily nullptr},  }\item[{Gr\+Gpu\+Finished\+Proc}]{finished\+Proc = {\ttfamily nullptr},  }\item[{Gr\+Gpu\+Finished\+Context}]{finished\+Context = {\ttfamily nullptr} }\end{DoxyParamCaption})}

Updates the state of the Gr\+Backend\+Texture/\+Render\+Target to have the passed in \mbox{\hyperlink{class_gr_backend_surface_mutable_state}{Gr\+Backend\+Surface\+Mutable\+State}}. All objects that wrap the backend surface (i.\+e. Sk\+Surfaces and Sk\+Images) will also be aware of this state change. This call does not submit the state change to the gpu, but requires the client to call {\ttfamily submit} to send it to the G\+PU. The work for this call is ordered linearly with all other calls that require Gr\+Context\+::submit to be called (e.\+g update\+Backend\+Texture and flush). If finished\+Proc is not null then it will be called with finished\+Context after the state transition is known to have occurred on the G\+PU.

See \mbox{\hyperlink{class_gr_backend_surface_mutable_state}{Gr\+Backend\+Surface\+Mutable\+State}} to see what state can be set via this call.

If the backend A\+PI is Vulkan, the caller can set the \mbox{\hyperlink{class_gr_backend_surface_mutable_state}{Gr\+Backend\+Surface\+Mutable\+State}}\textquotesingle{}s Vk\+Image\+Layout to V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+U\+N\+D\+E\+F\+I\+N\+ED or queue\+Family\+Index to V\+K\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+F\+A\+M\+I\+L\+Y\+\_\+\+I\+G\+N\+O\+R\+ED to tell Skia to not change those respective states.

If previous\+State is not null and this returns true, then Skia will have filled in previous\+State to have the values of the state before this call. \mbox{\Hypertarget{class_gr_direct_context_af972a5f50215ee314c48e5749d6259b9}\label{class_gr_direct_context_af972a5f50215ee314c48e5749d6259b9}} 
\index{GrDirectContext@{GrDirectContext}!setResourceCacheLimit@{setResourceCacheLimit}}
\index{setResourceCacheLimit@{setResourceCacheLimit}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{setResourceCacheLimit()}{setResourceCacheLimit()}}
{\footnotesize\ttfamily void Gr\+Direct\+Context\+::set\+Resource\+Cache\+Limit (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{max\+Resource\+Bytes }\end{DoxyParamCaption})}

Specify the G\+PU resource cache limit. If the cache currently exceeds this limit, it will be purged (L\+RU) to keep the cache within the limit.


\begin{DoxyParams}{Parameters}
{\em max\+Resource\+Bytes} & The maximum number of bytes of video memory that can be held in the cache. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_gr_direct_context_a05e1728f5c16225c2a6e1a2eb65fa695}\label{class_gr_direct_context_a05e1728f5c16225c2a6e1a2eb65fa695}} 
\index{GrDirectContext@{GrDirectContext}!setResourceCacheLimits@{setResourceCacheLimits}}
\index{setResourceCacheLimits@{setResourceCacheLimits}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{setResourceCacheLimits()}{setResourceCacheLimits()}}
{\footnotesize\ttfamily void Gr\+Direct\+Context\+::set\+Resource\+Cache\+Limits (\begin{DoxyParamCaption}\item[{int}]{max\+Resources,  }\item[{size\+\_\+t}]{max\+Resource\+Bytes }\end{DoxyParamCaption})}

D\+E\+P\+R\+E\+C\+A\+T\+ED Specify the G\+PU resource cache limits. If the current cache exceeds the max\+Resource\+Bytes limit, it will be purged (L\+RU) to keep the cache within the limit.


\begin{DoxyParams}{Parameters}
{\em max\+Resources} & Unused. \\
\hline
{\em max\+Resource\+Bytes} & The maximum number of bytes of video memory that can be held in the cache. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_gr_direct_context_a2e6391e15ee021f864a9d4fbef930732}\label{class_gr_direct_context_a2e6391e15ee021f864a9d4fbef930732}} 
\index{GrDirectContext@{GrDirectContext}!submit@{submit}}
\index{submit@{submit}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{submit()}{submit()}}
{\footnotesize\ttfamily bool Gr\+Direct\+Context\+::submit (\begin{DoxyParamCaption}\item[{bool}]{sync\+Cpu = {\ttfamily false} }\end{DoxyParamCaption})}

Submit outstanding work to the gpu from all previously un-\/submitted flushes. The return value of the submit will indicate whether or not the submission to the G\+PU was successful.

If the call returns true, all previously passed in semaphores in flush calls will have been submitted to the G\+PU and they can safely be waited on. The caller should wait on those semaphores or perform some other global synchronization before deleting the semaphores.

If it returns false, then those same semaphores will not have been submitted and we will not try to submit them again. The caller is free to delete the semaphores at any time.

If the sync\+Cpu flag is true this function will return once the gpu has finished with all submitted work. \mbox{\Hypertarget{class_gr_direct_context_a96e5681a6a452f4fe74920abe1594e55}\label{class_gr_direct_context_a96e5681a6a452f4fe74920abe1594e55}} 
\index{GrDirectContext@{GrDirectContext}!updateBackendTexture@{updateBackendTexture}}
\index{updateBackendTexture@{updateBackendTexture}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{updateBackendTexture()}{updateBackendTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily bool Gr\+Direct\+Context\+::update\+Backend\+Texture (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&}]{,  }\item[{const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} \&}]{color,  }\item[{Gr\+Gpu\+Finished\+Proc}]{finished\+Proc,  }\item[{Gr\+Gpu\+Finished\+Context}]{finished\+Context }\end{DoxyParamCaption})}

If possible, updates a backend texture to be filled to a particular color. The client should check the return value to see if the update was successful. The client can pass in a finished\+Proc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call {\ttfamily submit} to send the upload work to the gpu. The finished\+Proc will always get called even if we failed to update the \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}}. For the Vulkan backend after a successful update the layout of the created Vk\+Image will be\+: V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+S\+H\+A\+D\+E\+R\+\_\+\+R\+E\+A\+D\+\_\+\+O\+N\+L\+Y\+\_\+\+O\+P\+T\+I\+M\+AL \mbox{\Hypertarget{class_gr_direct_context_afa88d9f58d0aab0f689115c5ce9a358a}\label{class_gr_direct_context_afa88d9f58d0aab0f689115c5ce9a358a}} 
\index{GrDirectContext@{GrDirectContext}!updateBackendTexture@{updateBackendTexture}}
\index{updateBackendTexture@{updateBackendTexture}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{updateBackendTexture()}{updateBackendTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily bool Gr\+Direct\+Context\+::update\+Backend\+Texture (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&}]{,  }\item[{const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}}}]{src\+Data\mbox{[}$\,$\mbox{]},  }\item[{int}]{num\+Levels,  }\item[{Gr\+Surface\+Origin}]{ = {\ttfamily kTopLeft\+\_\+GrSurfaceOrigin},  }\item[{Gr\+Gpu\+Finished\+Proc}]{finished\+Proc = {\ttfamily nullptr},  }\item[{Gr\+Gpu\+Finished\+Context}]{finished\+Context = {\ttfamily nullptr} }\end{DoxyParamCaption})}

If possible, updates a backend texture filled with the provided pixmap data. The client should check the return value to see if the update was successful. The client can pass in a finished\+Proc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call {\ttfamily submit} to send the upload work to the gpu. The finished\+Proc will always get called even if we failed to create the \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}}. The backend texture must be compatible with the provided pixmap(s). Compatible, in this case, means that the backend format is compatible with the base pixmap\textquotesingle{}s colortype. The src data can be deleted when this call returns. If the backend texture is mip mapped, the data for all the mipmap levels must be provided. In the mipmapped case all the colortypes of the provided pixmaps must be the same. Additionally, all the miplevels must be sized correctly (please see Sk\+Mipmap\+::\+Compute\+Level\+Size and Compute\+Level\+Count). The Gr\+Surface\+Origin controls whether the pixmap data is vertically flipped in the texture. Note\+: the pixmap\textquotesingle{}s alphatypes and colorspaces are ignored. For the Vulkan backend after a successful update the layout of the created Vk\+Image will be\+: V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+S\+H\+A\+D\+E\+R\+\_\+\+R\+E\+A\+D\+\_\+\+O\+N\+L\+Y\+\_\+\+O\+P\+T\+I\+M\+AL \mbox{\Hypertarget{class_gr_direct_context_a73536ee3f0f47e459f671f5b410b540c}\label{class_gr_direct_context_a73536ee3f0f47e459f671f5b410b540c}} 
\index{GrDirectContext@{GrDirectContext}!updateBackendTexture@{updateBackendTexture}}
\index{updateBackendTexture@{updateBackendTexture}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{updateBackendTexture()}{updateBackendTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily bool Gr\+Direct\+Context\+::update\+Backend\+Texture (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&}]{,  }\item[{Sk\+Color\+Type}]{sk\+Color\+Type,  }\item[{const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} \&}]{color,  }\item[{Gr\+Gpu\+Finished\+Proc}]{finished\+Proc,  }\item[{Gr\+Gpu\+Finished\+Context}]{finished\+Context }\end{DoxyParamCaption})}

If possible, updates a backend texture to be filled to a particular color. The data in \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} and passed in color is interpreted with respect to the passed in Sk\+Color\+Type. The client should check the return value to see if the update was successful. The client can pass in a finished\+Proc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call {\ttfamily submit} to send the upload work to the gpu. The finished\+Proc will always get called even if we failed to update the \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}}. For the Vulkan backend after a successful update the layout of the created Vk\+Image will be\+: V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+S\+H\+A\+D\+E\+R\+\_\+\+R\+E\+A\+D\+\_\+\+O\+N\+L\+Y\+\_\+\+O\+P\+T\+I\+M\+AL \mbox{\Hypertarget{class_gr_direct_context_a9a49762726cb726ec868970d75953a3b}\label{class_gr_direct_context_a9a49762726cb726ec868970d75953a3b}} 
\index{GrDirectContext@{GrDirectContext}!updateBackendTexture@{updateBackendTexture}}
\index{updateBackendTexture@{updateBackendTexture}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{updateBackendTexture()}{updateBackendTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily bool Gr\+Direct\+Context\+::update\+Backend\+Texture (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&}]{texture,  }\item[{const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} \&}]{src\+Data,  }\item[{Gr\+Surface\+Origin}]{texture\+Origin = {\ttfamily kTopLeft\+\_\+GrSurfaceOrigin},  }\item[{Gr\+Gpu\+Finished\+Proc}]{finished\+Proc = {\ttfamily nullptr},  }\item[{Gr\+Gpu\+Finished\+Context}]{finished\+Context = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Convenience version of update\+Backend\+Texture that takes just a base level pixmap. \mbox{\Hypertarget{class_gr_direct_context_a079adf61ab054bec6a1c8d9a2ec397f7}\label{class_gr_direct_context_a079adf61ab054bec6a1c8d9a2ec397f7}} 
\index{GrDirectContext@{GrDirectContext}!updateCompressedBackendTexture@{updateCompressedBackendTexture}}
\index{updateCompressedBackendTexture@{updateCompressedBackendTexture}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{updateCompressedBackendTexture()}{updateCompressedBackendTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool Gr\+Direct\+Context\+::update\+Compressed\+Backend\+Texture (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&}]{,  }\item[{const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} \&}]{color,  }\item[{Gr\+Gpu\+Finished\+Proc}]{finished\+Proc,  }\item[{Gr\+Gpu\+Finished\+Context}]{finished\+Context }\end{DoxyParamCaption})}

If possible, updates a backend texture filled with the provided color. If the texture is mipmapped, all levels of the mip chain will be updated to have the supplied color. The client should check the return value to see if the update was successful. The client can pass in a finished\+Proc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call {\ttfamily submit} to send the upload work to the gpu. The finished\+Proc will always get called even if we failed to create the \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}}. For the Vulkan backend after a successful update the layout of the created Vk\+Image will be\+: V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+S\+H\+A\+D\+E\+R\+\_\+\+R\+E\+A\+D\+\_\+\+O\+N\+L\+Y\+\_\+\+O\+P\+T\+I\+M\+AL \mbox{\Hypertarget{class_gr_direct_context_aeedaf24edf8574a524dbf6f95fbe46d3}\label{class_gr_direct_context_aeedaf24edf8574a524dbf6f95fbe46d3}} 
\index{GrDirectContext@{GrDirectContext}!updateCompressedBackendTexture@{updateCompressedBackendTexture}}
\index{updateCompressedBackendTexture@{updateCompressedBackendTexture}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{updateCompressedBackendTexture()}{updateCompressedBackendTexture()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool Gr\+Direct\+Context\+::update\+Compressed\+Backend\+Texture (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&}]{,  }\item[{const void $\ast$}]{data,  }\item[{size\+\_\+t}]{data\+Size,  }\item[{Gr\+Gpu\+Finished\+Proc}]{finished\+Proc,  }\item[{Gr\+Gpu\+Finished\+Context}]{finished\+Context }\end{DoxyParamCaption})}

If possible, updates a backend texture filled with the provided raw data. The client should check the return value to see if the update was successful. The client can pass in a finished\+Proc to be notified when the data has been uploaded by the gpu and the texture can be deleted. The client is required to call {\ttfamily submit} to send the upload work to the gpu. The finished\+Proc will always get called even if we failed to create the \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}}. If a mip\+Mapped texture is passed in, the data for all the mipmap levels must be provided. Additionally, all the miplevels must be sized correctly (please see Sk\+Mip\+Map\+::\+Compute\+Level\+Size and Compute\+Level\+Count). For the Vulkan backend after a successful update the layout of the created Vk\+Image will be\+: V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+S\+H\+A\+D\+E\+R\+\_\+\+R\+E\+A\+D\+\_\+\+O\+N\+L\+Y\+\_\+\+O\+P\+T\+I\+M\+AL \mbox{\Hypertarget{class_gr_direct_context_ab84b361801b9493a3d19d8fd761d87fe}\label{class_gr_direct_context_ab84b361801b9493a3d19d8fd761d87fe}} 
\index{GrDirectContext@{GrDirectContext}!wait@{wait}}
\index{wait@{wait}!GrDirectContext@{GrDirectContext}}
\doxysubsubsection{\texorpdfstring{wait()}{wait()}}
{\footnotesize\ttfamily bool Gr\+Direct\+Context\+::wait (\begin{DoxyParamCaption}\item[{int}]{num\+Semaphores,  }\item[{const \mbox{\hyperlink{class_gr_backend_semaphore}{Gr\+Backend\+Semaphore}} $\ast$}]{wait\+Semaphores,  }\item[{bool}]{delete\+Semaphores\+After\+Wait = {\ttfamily true} }\end{DoxyParamCaption})}

Inserts a list of G\+PU semaphores that the current G\+P\+U-\/backed A\+PI must wait on before executing any more commands on the G\+PU. If this call returns false, then the G\+PU back-\/end will not wait on any passed in semaphores, and the client will still own the semaphores, regardless of the value of delete\+Semaphores\+After\+Wait.

If delete\+Semaphores\+After\+Wait is false then Skia will not delete the semaphores. In this case it is the client\textquotesingle{}s responsibility to not destroy or attempt to reuse the semaphores until it knows that Skia has finished waiting on them. This can be done by using finished\+Procs on flush calls. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/include/gpu/Gr\+Direct\+Context.\+h\end{DoxyCompactItemize}
