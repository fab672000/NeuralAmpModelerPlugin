\hypertarget{class_sk_reflected}{}\doxysection{Sk\+Reflected Class Reference}
\label{class_sk_reflected}\index{SkReflected@{SkReflected}}


{\ttfamily \#include $<$Sk\+Reflected.\+h$>$}

Inheritance diagram for Sk\+Reflected\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4.274809cm]{class_sk_reflected}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_sk_reflected_1_1_type}{Type}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_reflected_a50027ccbc65a1131cd3a5807f661969f}\label{class_sk_reflected_a50027ccbc65a1131cd3a5807f661969f}} 
typedef \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_reflected}{Sk\+Reflected}} $>$($\ast$ {\bfseries Factory}) ()
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_reflected_a3ea848837ceed830f07bdb6307134157}\label{class_sk_reflected_a3ea848837ceed830f07bdb6307134157}} 
virtual const \mbox{\hyperlink{struct_sk_reflected_1_1_type}{Type}} $\ast$ {\bfseries get\+Type} () const =0
\item 
\mbox{\Hypertarget{class_sk_reflected_a5457b7a53514a92fc931032b4fa7df5c}\label{class_sk_reflected_a5457b7a53514a92fc931032b4fa7df5c}} 
bool {\bfseries is\+Of\+Type} (const \mbox{\hyperlink{struct_sk_reflected_1_1_type}{Type}} $\ast$t) const
\item 
\mbox{\Hypertarget{class_sk_reflected_ada45e6a6fb815cadc516c65d68a074f7}\label{class_sk_reflected_ada45e6a6fb815cadc516c65d68a074f7}} 
virtual void {\bfseries visit\+Fields} (\mbox{\hyperlink{class_sk_field_visitor}{Sk\+Field\+Visitor}} $\ast$)=0
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_reflected_a1667b9329de4aff22a62ef1e4c0b7240}\label{class_sk_reflected_a1667b9329de4aff22a62ef1e4c0b7240}} 
static const \mbox{\hyperlink{struct_sk_reflected_1_1_type}{Type}} $\ast$ {\bfseries Get\+Type} ()
\item 
\mbox{\Hypertarget{class_sk_reflected_a5f9529dfb040e4f292f89d2a1778606c}\label{class_sk_reflected_a5f9529dfb040e4f292f89d2a1778606c}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_reflected}{Sk\+Reflected}} $>$ {\bfseries Create\+Instance} (const char $\ast$name)
\item 
\mbox{\Hypertarget{class_sk_reflected_abdf292af92d02eb1d5b8c8ac63b14014}\label{class_sk_reflected_abdf292af92d02eb1d5b8c8ac63b14014}} 
static void {\bfseries Visit\+Types} (std\+::function$<$ void(const \mbox{\hyperlink{struct_sk_reflected_1_1_type}{Type}} $\ast$)$>$ visitor)
\end{DoxyCompactItemize}
\doxysubsection*{Static Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_reflected_a0f3faaba5f55c424e258d32e128ca6df}\label{class_sk_reflected_a0f3faaba5f55c424e258d32e128ca6df}} 
static void {\bfseries Register\+Once} (\mbox{\hyperlink{struct_sk_reflected_1_1_type}{Type}} $\ast$type)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Classes and macros for a lightweight reflection system.

Classes that derive from \mbox{\hyperlink{class_sk_reflected}{Sk\+Reflected}} have several features\+:
\begin{DoxyItemize}
\item Access to an \mbox{\hyperlink{struct_sk_reflected_1_1_type}{Sk\+Reflected\+::\+Type}} instance, via static Get\+Type() or virtual get\+Type() The \mbox{\hyperlink{struct_sk_reflected_1_1_type}{Type}} instance can be used to create additional instances (f\+Factory), get the name of the type, and answer queries of the form \char`\"{}is X derived from Y\char`\"{}.
\item Given a string containing a type name, \mbox{\hyperlink{class_sk_reflected}{Sk\+Reflected}} can create an instance of that type.
\item Sk\+Reflected\+::\+Visit\+Types can be used to enumerate all Types.
\end{DoxyItemize}

Together, this simplifies the implementation of serialization and other dynamic type factories.

Finally, all Sk\+Reflected-\/derived types must implement visit\+Fields, which provides field-\/level reflection, in conjunction with \mbox{\hyperlink{class_sk_field_visitor}{Sk\+Field\+Visitor}}. See \mbox{\hyperlink{class_sk_field_visitor}{Sk\+Field\+Visitor}}, below.

To create a new reflected class\+:
\begin{DoxyItemize}
\item Derive the class (directly or indirectly) from \mbox{\hyperlink{class_sk_reflected}{Sk\+Reflected}}.
\item Ensure that the class can be default constructed.
\item In the public area of the class declaration, add R\+E\+F\+L\+E\+C\+T\+E\+D($<$\+Class\+Name$>$, $<$\+Base\+Class\+Name$>$). If the class is abstract, use R\+E\+F\+L\+E\+C\+T\+E\+D\+\_\+\+A\+B\+S\+T\+R\+A\+C\+T($<$\+Class\+Name$>$, $<$\+Base\+Class\+Name$>$) instead.
\item Add a one-\/time call to R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+R\+E\+F\+L\+E\+C\+T\+E\+D($<$\+Class\+Name$>$) at initialization time.
\item Implement visit\+Fields(), as described below. 
\end{DoxyItemize}

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/modules/particles/include/Sk\+Reflected.\+h\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/modules/particles/src/Sk\+Reflected.\+cpp\end{DoxyCompactItemize}
