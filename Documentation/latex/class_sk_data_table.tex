\hypertarget{class_sk_data_table}{}\doxysection{Sk\+Data\+Table Class Reference}
\label{class_sk_data_table}\index{SkDataTable@{SkDataTable}}


{\ttfamily \#include $<$Sk\+Data\+Table.\+h$>$}

Inheritance diagram for Sk\+Data\+Table\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{class_sk_data_table}
\end{center}
\end{figure}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_data_table_af171fcb3f1d6b5c6b8db3e7638753453}\label{class_sk_data_table_af171fcb3f1d6b5c6b8db3e7638753453}} 
typedef void($\ast$ {\bfseries Free\+Proc}) (void $\ast$context)
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{class_sk_data_table_abc238bf88c6c0bae23712547d46ebb53}{is\+Empty}} () const
\item 
int \mbox{\hyperlink{class_sk_data_table_a0cd4b2f8f2d144f97beeb084d093e57d}{count}} () const
\item 
size\+\_\+t \mbox{\hyperlink{class_sk_data_table_af0741127396b72f2feb24e770c11d96b}{at\+Size}} (int index) const
\item 
const void $\ast$ \mbox{\hyperlink{class_sk_data_table_a448b1fe4c5c2d3d5a2140d76fbcc5225}{at}} (int index, size\+\_\+t $\ast$size=nullptr) const
\item 
\mbox{\Hypertarget{class_sk_data_table_acb9ebbbf7a6d6590ab762e7ac2a443bc}\label{class_sk_data_table_acb9ebbbf7a6d6590ab762e7ac2a443bc}} 
{\footnotesize template$<$typename T $>$ }\\const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ {\bfseries atT} (int index, size\+\_\+t $\ast$size=nullptr) const
\item 
const char $\ast$ \mbox{\hyperlink{class_sk_data_table_a8ce1f59e63e423d595816f348d57f903}{at\+Str}} (int index) const
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_data_table_a9c53df025b804aff55e443d2e49ab773}\label{class_sk_data_table_a9c53df025b804aff55e443d2e49ab773}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data_table}{Sk\+Data\+Table}} $>$ {\bfseries Make\+Empty} ()
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data_table}{Sk\+Data\+Table}} $>$ \mbox{\hyperlink{class_sk_data_table_acfd3599ecdbc1f1f852f81ba8fa4ae70}{Make\+Copy\+Arrays}} (const void $\ast$const $\ast$ptrs, const size\+\_\+t sizes\mbox{[}$\,$\mbox{]}, int \mbox{\hyperlink{class_sk_data_table_a0cd4b2f8f2d144f97beeb084d093e57d}{count}})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data_table}{Sk\+Data\+Table}} $>$ \mbox{\hyperlink{class_sk_data_table_a3c08d1fef6d22b118e4be6f8e13299b2}{Make\+Copy\+Array}} (const void $\ast$array, size\+\_\+t elem\+Size, int \mbox{\hyperlink{class_sk_data_table_a0cd4b2f8f2d144f97beeb084d093e57d}{count}})
\item 
\mbox{\Hypertarget{class_sk_data_table_a765fed5e7e3db02f00bafaab2728766c}\label{class_sk_data_table_a765fed5e7e3db02f00bafaab2728766c}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data_table}{Sk\+Data\+Table}} $>$ {\bfseries Make\+Array\+Proc} (const void $\ast$array, size\+\_\+t elem\+Size, int \mbox{\hyperlink{class_sk_data_table_a0cd4b2f8f2d144f97beeb084d093e57d}{count}}, Free\+Proc proc, void $\ast$context)
\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_data_table_a22c90f6eed2fe6fc13e23eb006a4f21f}\label{class_sk_data_table_a22c90f6eed2fe6fc13e23eb006a4f21f}} 
class {\bfseries Sk\+Data\+Table\+Builder}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Like \mbox{\hyperlink{class_sk_data}{Sk\+Data}}, \mbox{\hyperlink{class_sk_data_table}{Sk\+Data\+Table}} holds an immutable data buffer. The data buffer is organized into a table of entries, each with a length, so the entries are not required to all be the same size. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_data_table_a448b1fe4c5c2d3d5a2140d76fbcc5225}\label{class_sk_data_table_a448b1fe4c5c2d3d5a2140d76fbcc5225}} 
\index{SkDataTable@{SkDataTable}!at@{at}}
\index{at@{at}!SkDataTable@{SkDataTable}}
\doxysubsubsection{\texorpdfstring{at()}{at()}}
{\footnotesize\ttfamily const void $\ast$ Sk\+Data\+Table\+::at (\begin{DoxyParamCaption}\item[{int}]{index,  }\item[{size\+\_\+t $\ast$}]{size = {\ttfamily nullptr} }\end{DoxyParamCaption}) const}

Return a pointer to the data of the index\textquotesingle{}th entry in the table. The caller must ensure that index is valid for this table.


\begin{DoxyParams}{Parameters}
{\em size} & If non-\/null, this returns the byte size of this entry. This will be the same value that at\+Size(index) would return. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_data_table_af0741127396b72f2feb24e770c11d96b}\label{class_sk_data_table_af0741127396b72f2feb24e770c11d96b}} 
\index{SkDataTable@{SkDataTable}!atSize@{atSize}}
\index{atSize@{atSize}!SkDataTable@{SkDataTable}}
\doxysubsubsection{\texorpdfstring{atSize()}{atSize()}}
{\footnotesize\ttfamily size\+\_\+t Sk\+Data\+Table\+::at\+Size (\begin{DoxyParamCaption}\item[{int}]{index }\end{DoxyParamCaption}) const}

Return the size of the index\textquotesingle{}th entry in the table. The caller must ensure that index is valid for this table. \mbox{\Hypertarget{class_sk_data_table_a8ce1f59e63e423d595816f348d57f903}\label{class_sk_data_table_a8ce1f59e63e423d595816f348d57f903}} 
\index{SkDataTable@{SkDataTable}!atStr@{atStr}}
\index{atStr@{atStr}!SkDataTable@{SkDataTable}}
\doxysubsubsection{\texorpdfstring{atStr()}{atStr()}}
{\footnotesize\ttfamily const char$\ast$ Sk\+Data\+Table\+::at\+Str (\begin{DoxyParamCaption}\item[{int}]{index }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the index\textquotesingle{}th entry as a c-\/string, and assumes that the trailing null byte had been copied into the table as well. \mbox{\Hypertarget{class_sk_data_table_a0cd4b2f8f2d144f97beeb084d093e57d}\label{class_sk_data_table_a0cd4b2f8f2d144f97beeb084d093e57d}} 
\index{SkDataTable@{SkDataTable}!count@{count}}
\index{count@{count}!SkDataTable@{SkDataTable}}
\doxysubsubsection{\texorpdfstring{count()}{count()}}
{\footnotesize\ttfamily int Sk\+Data\+Table\+::count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return the number of entries in the table. 0 for an empty table \mbox{\Hypertarget{class_sk_data_table_abc238bf88c6c0bae23712547d46ebb53}\label{class_sk_data_table_abc238bf88c6c0bae23712547d46ebb53}} 
\index{SkDataTable@{SkDataTable}!isEmpty@{isEmpty}}
\index{isEmpty@{isEmpty}!SkDataTable@{SkDataTable}}
\doxysubsubsection{\texorpdfstring{isEmpty()}{isEmpty()}}
{\footnotesize\ttfamily bool Sk\+Data\+Table\+::is\+Empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns true if the table is empty (i.\+e. has no entries). \mbox{\Hypertarget{class_sk_data_table_a3c08d1fef6d22b118e4be6f8e13299b2}\label{class_sk_data_table_a3c08d1fef6d22b118e4be6f8e13299b2}} 
\index{SkDataTable@{SkDataTable}!MakeCopyArray@{MakeCopyArray}}
\index{MakeCopyArray@{MakeCopyArray}!SkDataTable@{SkDataTable}}
\doxysubsubsection{\texorpdfstring{MakeCopyArray()}{MakeCopyArray()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data_table}{Sk\+Data\+Table}} $>$ Sk\+Data\+Table\+::\+Make\+Copy\+Array (\begin{DoxyParamCaption}\item[{const void $\ast$}]{array,  }\item[{size\+\_\+t}]{elem\+Size,  }\item[{int}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Return a new table that contains a copy of the data in array.


\begin{DoxyParams}{Parameters}
{\em array} & contiguous array of data for all elements to be copied. \\
\hline
{\em elem\+Size} & byte-\/length for a given element. \\
\hline
{\em count} & the number of entries to be copied out of array. The number of bytes that will be copied is count $\ast$ elem\+Size. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_data_table_acfd3599ecdbc1f1f852f81ba8fa4ae70}\label{class_sk_data_table_acfd3599ecdbc1f1f852f81ba8fa4ae70}} 
\index{SkDataTable@{SkDataTable}!MakeCopyArrays@{MakeCopyArrays}}
\index{MakeCopyArrays@{MakeCopyArrays}!SkDataTable@{SkDataTable}}
\doxysubsubsection{\texorpdfstring{MakeCopyArrays()}{MakeCopyArrays()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data_table}{Sk\+Data\+Table}} $>$ Sk\+Data\+Table\+::\+Make\+Copy\+Arrays (\begin{DoxyParamCaption}\item[{const void $\ast$const $\ast$}]{ptrs,  }\item[{const size\+\_\+t}]{sizes\mbox{[}$\,$\mbox{]},  }\item[{int}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Return a new Data\+Table that contains a copy of the data stored in each \char`\"{}array\char`\"{}.


\begin{DoxyParams}{Parameters}
{\em ptrs} & array of points to each element to be copied into the table. \\
\hline
{\em sizes} & array of byte-\/lengths for each entry in the corresponding ptrs\mbox{[}\mbox{]} array. \\
\hline
{\em count} & the number of array elements in ptrs\mbox{[}\mbox{]} and sizes\mbox{[}\mbox{]} to copy. \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/include/core/Sk\+Data\+Table.\+h\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Data\+Table.\+cpp\end{DoxyCompactItemize}
