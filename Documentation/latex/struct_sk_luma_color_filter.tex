\hypertarget{struct_sk_luma_color_filter}{}\doxysection{Sk\+Luma\+Color\+Filter Struct Reference}
\label{struct_sk_luma_color_filter}\index{SkLumaColorFilter@{SkLumaColorFilter}}


{\ttfamily \#include $<$Sk\+Luma\+Color\+Filter.\+h$>$}

\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{struct_sk_luma_color_filter_a05fb9c2bc341c26e631d6d98d647e15c}\label{struct_sk_luma_color_filter_a05fb9c2bc341c26e631d6d98d647e15c}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_filter}{Sk\+Color\+Filter}} $>$ {\bfseries Make} ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\mbox{\hyperlink{struct_sk_luma_color_filter}{Sk\+Luma\+Color\+Filter}} multiplies the luma of its input into the alpha channel, and sets the red, green, and blue channels to zero.

\mbox{\hyperlink{struct_sk_luma_color_filter}{Sk\+Luma\+Color\+Filter(r,g,b,a)}} = \{0,0,0, a $\ast$ luma(r,g,b)\}

This is similar to a luminance\+To\+Alpha fe\+Color\+Matrix, but note how this filter folds in the previous alpha, something an fe\+Color\+Matrix cannot do.

fe\+Color\+Matrix(luminance\+To\+Alpha; r,g,b,a) = \{0,0,0, luma(r,g,b)\}

(Despite its name, an fe\+Color\+Matrix using luminance\+To\+Alpha does actually compute luma, a dot-\/product of gamma-\/encoded color channels, not luminance, a dot-\/product of linear color channels. So at least \mbox{\hyperlink{struct_sk_luma_color_filter}{Sk\+Luma\+Color\+Filter}} and fe\+Color\+Matrix+luminance\+To\+Alpha agree there.) 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/include/effects/Sk\+Luma\+Color\+Filter.\+h\end{DoxyCompactItemize}
