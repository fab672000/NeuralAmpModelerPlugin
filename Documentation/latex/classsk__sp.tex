\hypertarget{classsk__sp}{}\doxysection{sk\+\_\+sp$<$ T $>$ Class Template Reference}
\label{classsk__sp}\index{sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}}


{\ttfamily \#include $<$Sk\+Ref\+Cnt.\+h$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classsk__sp_ae64833fdb2a4ffc350633f42cda62808}\label{classsk__sp_ae64833fdb2a4ffc350633f42cda62808}} 
using {\bfseries element\+\_\+type} = \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{classsk__sp_ac052bce1a68cc10132d8f3d6c8fabb0f}\label{classsk__sp_ac052bce1a68cc10132d8f3d6c8fabb0f}} 
constexpr {\bfseries sk\+\_\+sp} (std\+::nullptr\+\_\+t)
\item 
\mbox{\hyperlink{classsk__sp_ae96403fbbf42791ccc531b8f4b723650}{sk\+\_\+sp}} (const \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ \&that)
\item 
\mbox{\Hypertarget{classsk__sp_a7cee4691f054f240b330419b2a5c4f1d}\label{classsk__sp_a7cee4691f054f240b330419b2a5c4f1d}} 
{\footnotesize template$<$typename U , typename  = typename std\+::enable\+\_\+if$<$std\+::is\+\_\+convertible$<$\+U$\ast$, T$\ast$$>$\+::value$>$\+::type$>$ }\\{\bfseries sk\+\_\+sp} (const \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ U $>$ \&that)
\item 
\mbox{\hyperlink{classsk__sp_af8ac8b9af866b393d3d351d7d05b42ca}{sk\+\_\+sp}} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ \&\&that)
\item 
\mbox{\Hypertarget{classsk__sp_a6cf1a36d48b06b0a64e989841b3fd1e5}\label{classsk__sp_a6cf1a36d48b06b0a64e989841b3fd1e5}} 
{\footnotesize template$<$typename U , typename  = typename std\+::enable\+\_\+if$<$std\+::is\+\_\+convertible$<$\+U$\ast$, T$\ast$$>$\+::value$>$\+::type$>$ }\\{\bfseries sk\+\_\+sp} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ U $>$ \&\&that)
\item 
\mbox{\hyperlink{classsk__sp_a29d406508ddf7adc6f035b72684948c0}{sk\+\_\+sp}} (\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$obj)
\item 
\mbox{\hyperlink{classsk__sp_afb9b52bdd6b09f6f82a9a925f2ade744}{$\sim$sk\+\_\+sp}} ()
\item 
\mbox{\Hypertarget{classsk__sp_acc18dd26a775b77cdeb5323db95163a9}\label{classsk__sp_acc18dd26a775b77cdeb5323db95163a9}} 
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ \& {\bfseries operator=} (std\+::nullptr\+\_\+t)
\item 
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ \& \mbox{\hyperlink{classsk__sp_abf87bf6424759ba4b86d495164f9776a}{operator=}} (const \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ \&that)
\item 
\mbox{\Hypertarget{classsk__sp_ab0f35c0a287cc527a2d36338ef963e16}\label{classsk__sp_ab0f35c0a287cc527a2d36338ef963e16}} 
{\footnotesize template$<$typename U , typename  = typename std\+::enable\+\_\+if$<$std\+::is\+\_\+convertible$<$\+U$\ast$, T$\ast$$>$\+::value$>$\+::type$>$ }\\\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ \& {\bfseries operator=} (const \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ U $>$ \&that)
\item 
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ \& \mbox{\hyperlink{classsk__sp_add518d1729c6bde4d6b1c5e91157dd91}{operator=}} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ \&\&that)
\item 
\mbox{\Hypertarget{classsk__sp_a50810c861e90f149ffe2a5d8e0eb7dfe}\label{classsk__sp_a50810c861e90f149ffe2a5d8e0eb7dfe}} 
{\footnotesize template$<$typename U , typename  = typename std\+::enable\+\_\+if$<$std\+::is\+\_\+convertible$<$\+U$\ast$, T$\ast$$>$\+::value$>$\+::type$>$ }\\\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ \& {\bfseries operator=} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ U $>$ \&\&that)
\item 
\mbox{\Hypertarget{classsk__sp_a0eb566803134cfbac5105b8beda6e48e}\label{classsk__sp_a0eb566803134cfbac5105b8beda6e48e}} 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& {\bfseries operator$\ast$} () const
\item 
\mbox{\Hypertarget{classsk__sp_a21527b74dacac9b3d929b6a85800f93c}\label{classsk__sp_a21527b74dacac9b3d929b6a85800f93c}} 
{\bfseries operator bool} () const
\item 
\mbox{\Hypertarget{classsk__sp_a7a592ac96492fa9c633b4398450f0b27}\label{classsk__sp_a7a592ac96492fa9c633b4398450f0b27}} 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ {\bfseries get} () const
\item 
\mbox{\Hypertarget{classsk__sp_a9991a3387acca0fd4a76abb8f7cb296e}\label{classsk__sp_a9991a3387acca0fd4a76abb8f7cb296e}} 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ {\bfseries operator-\/$>$} () const
\item 
void \mbox{\hyperlink{classsk__sp_adc602dd3002196c27d90caaafc15be8f}{reset}} (\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ptr=nullptr)
\item 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$S\+K\+\_\+\+W\+A\+R\+N\+\_\+\+U\+N\+U\+S\+E\+D\+\_\+\+R\+E\+S\+U\+LT \mbox{\hyperlink{classsk__sp_a991a8781dfdf1c007f56079717abe1a6}{release}} ()
\item 
\mbox{\Hypertarget{classsk__sp_a1ccdaa038b64f40595433f3baeceb26b}\label{classsk__sp_a1ccdaa038b64f40595433f3baeceb26b}} 
void {\bfseries swap} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ \&that)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename T$>$\newline
class sk\+\_\+sp$<$ T $>$}

Shared pointer class to wrap classes that support a ref()/unref() interface.

This can be used for classes inheriting from \mbox{\hyperlink{class_sk_ref_cnt}{Sk\+Ref\+Cnt}}, but it also works for other classes that match the interface, but have different internal choices\+: e.\+g. the hosted class may have its ref/unref be thread-\/safe, but that is not assumed/imposed by \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classsk__sp_ae96403fbbf42791ccc531b8f4b723650}\label{classsk__sp_ae96403fbbf42791ccc531b8f4b723650}} 
\index{sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}!sk\_sp@{sk\_sp}}
\index{sk\_sp@{sk\_sp}!sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{sk\_sp()}{sk\_sp()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$\+::\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ \&}]{that }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Shares the underlying object by calling ref(), so that both the argument and the newly created \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}} both have a reference to it. \mbox{\Hypertarget{classsk__sp_af8ac8b9af866b393d3d351d7d05b42ca}\label{classsk__sp_af8ac8b9af866b393d3d351d7d05b42ca}} 
\index{sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}!sk\_sp@{sk\_sp}}
\index{sk\_sp@{sk\_sp}!sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{sk\_sp()}{sk\_sp()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$\+::\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ \&\&}]{that }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Move the underlying object from the argument to the newly created \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}. Afterwards only the new \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}} will have a reference to the object, and the argument will point to null. No call to ref() or unref() will be made. \mbox{\Hypertarget{classsk__sp_a29d406508ddf7adc6f035b72684948c0}\label{classsk__sp_a29d406508ddf7adc6f035b72684948c0}} 
\index{sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}!sk\_sp@{sk\_sp}}
\index{sk\_sp@{sk\_sp}!sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{sk\_sp()}{sk\_sp()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$\+::\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$}]{obj }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}

Adopt the bare pointer into the newly created \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}. No call to ref() or unref() will be made. \mbox{\Hypertarget{classsk__sp_afb9b52bdd6b09f6f82a9a925f2ade744}\label{classsk__sp_afb9b52bdd6b09f6f82a9a925f2ade744}} 
\index{sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}!````~sk\_sp@{$\sim$sk\_sp}}
\index{````~sk\_sp@{$\sim$sk\_sp}!sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{$\sim$sk\_sp()}{~sk\_sp()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$\+::$\sim$\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Calls unref() on the underlying object pointer. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{classsk__sp_abf87bf6424759ba4b86d495164f9776a}\label{classsk__sp_abf87bf6424759ba4b86d495164f9776a}} 
\index{sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}!operator=@{operator=}}
\index{operator=@{operator=}!sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}$>$\& \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$\+::operator= (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ \&}]{that }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Shares the underlying object referenced by the argument by calling ref() on it. If this \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}} previously had a reference to an object (i.\+e. not null) it will call unref() on that object. \mbox{\Hypertarget{classsk__sp_add518d1729c6bde4d6b1c5e91157dd91}\label{classsk__sp_add518d1729c6bde4d6b1c5e91157dd91}} 
\index{sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}!operator=@{operator=}}
\index{operator=@{operator=}!sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}$>$\& \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$\+::operator= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ \&\&}]{that }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Move the underlying object from the argument to the \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}. If the \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}} previously held a reference to another object, unref() will be called on that object. No call to ref() will be made. \mbox{\Hypertarget{classsk__sp_a991a8781dfdf1c007f56079717abe1a6}\label{classsk__sp_a991a8781dfdf1c007f56079717abe1a6}} 
\index{sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}!release@{release}}
\index{release@{release}!sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{release()}{release()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}$\ast$ S\+K\+\_\+\+W\+A\+R\+N\+\_\+\+U\+N\+U\+S\+E\+D\+\_\+\+R\+E\+S\+U\+LT \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$\+::release (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Return the bare pointer, and set the internal object pointer to nullptr. The caller must assume ownership of the object, and manage its reference count directly. No call to unref() will be made. \mbox{\Hypertarget{classsk__sp_adc602dd3002196c27d90caaafc15be8f}\label{classsk__sp_adc602dd3002196c27d90caaafc15be8f}} 
\index{sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}!reset@{reset}}
\index{reset@{reset}!sk\_sp$<$ T $>$@{sk\_sp$<$ T $>$}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$\+::reset (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$}]{ptr = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Adopt the new bare pointer, and call unref() on any previously held object (if not null). No call to ref() will be made. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/include/core/Sk\+Ref\+Cnt.\+h\end{DoxyCompactItemize}
