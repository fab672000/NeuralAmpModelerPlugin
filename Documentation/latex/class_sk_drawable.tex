\hypertarget{class_sk_drawable}{}\doxysection{Sk\+Drawable Class Reference}
\label{class_sk_drawable}\index{SkDrawable@{SkDrawable}}


{\ttfamily \#include $<$Sk\+Drawable.\+h$>$}

Inheritance diagram for Sk\+Drawable\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=5.000000cm]{class_sk_drawable}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{class_sk_drawable_1_1_gpu_draw_handler}{Gpu\+Draw\+Handler}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{class_sk_drawable_ade63adbce24872944c202e3cb619359b}{draw}} (\mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} $\ast$, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$=nullptr)
\item 
\mbox{\Hypertarget{class_sk_drawable_a4b638bc7393f4e196db0ffaaa5444f4f}\label{class_sk_drawable_a4b638bc7393f4e196db0ffaaa5444f4f}} 
void {\bfseries draw} (\mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} $\ast$, Sk\+Scalar x, Sk\+Scalar y)
\item 
std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{class_sk_drawable_1_1_gpu_draw_handler}{Gpu\+Draw\+Handler}} $>$ \mbox{\hyperlink{class_sk_drawable_a0adaf18de0972a821b596bffe4d3dd1b}{snap\+Gpu\+Draw\+Handler}} (Gr\+Backend\+Api backend\+Api, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} \&matrix, const \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} \&clip\+Bounds, const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&buffer\+Info)
\item 
\mbox{\Hypertarget{class_sk_drawable_a0ea2cfdc095e46f981c06084fe7bfe62}\label{class_sk_drawable_a0ea2cfdc095e46f981c06084fe7bfe62}} 
\mbox{\hyperlink{class_sk_picture}{Sk\+Picture}} $\ast$ {\bfseries new\+Picture\+Snapshot} ()
\item 
uint32\+\_\+t \mbox{\hyperlink{class_sk_drawable_a0db203b05d8222fc151b34ed12210d56}{get\+Generation\+ID}} ()
\item 
\mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \mbox{\hyperlink{class_sk_drawable_a767d4865790d457c0df8744b5b974fb7}{get\+Bounds}} ()
\item 
void \mbox{\hyperlink{class_sk_drawable_a0cac52e61be3e3bf2ee2779460e9bc3c}{notify\+Drawing\+Changed}} ()
\item 
\mbox{\Hypertarget{class_sk_drawable_a17c4bd219cdc553af4e5f547432b521f}\label{class_sk_drawable_a17c4bd219cdc553af4e5f547432b521f}} 
Sk\+Flattenable\+::\+Type {\bfseries get\+Flattenable\+Type} () const override
\item 
Factory \mbox{\hyperlink{class_sk_drawable_adfd6e7a9c0f0511e94449a88270fa178}{get\+Factory}} () const override
\item 
const char $\ast$ \mbox{\hyperlink{class_sk_drawable_ac9cb373e9ee5e6d8848eb46259b23a04}{get\+Type\+Name}} () const override
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_drawable_a65bffbff3de63dc135109b604a45b92d}\label{class_sk_drawable_a65bffbff3de63dc135109b604a45b92d}} 
static Sk\+Flattenable\+::\+Type {\bfseries Get\+Flattenable\+Type} ()
\item 
\mbox{\Hypertarget{class_sk_drawable_ab2d975dec905473360695805032094db}\label{class_sk_drawable_ab2d975dec905473360695805032094db}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_drawable}{Sk\+Drawable}} $>$ {\bfseries Deserialize} (const void $\ast$data, size\+\_\+t size, const \mbox{\hyperlink{struct_sk_deserial_procs}{Sk\+Deserial\+Procs}} $\ast$procs=nullptr)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_drawable_a2b78bba96c0eadd6ef36fc67a7fce593}\label{class_sk_drawable_a2b78bba96c0eadd6ef36fc67a7fce593}} 
virtual \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} {\bfseries on\+Get\+Bounds} ()=0
\item 
\mbox{\Hypertarget{class_sk_drawable_aadf26ff8453a581f0001c48875dbb0b0}\label{class_sk_drawable_aadf26ff8453a581f0001c48875dbb0b0}} 
virtual void {\bfseries on\+Draw} (\mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} $\ast$)=0
\item 
\mbox{\Hypertarget{class_sk_drawable_a53db3383ea5116764b2515d644a50d14}\label{class_sk_drawable_a53db3383ea5116764b2515d644a50d14}} 
virtual std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{class_sk_drawable_1_1_gpu_draw_handler}{Gpu\+Draw\+Handler}} $>$ {\bfseries on\+Snap\+Gpu\+Draw\+Handler} (Gr\+Backend\+Api, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} \&, const \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} \&, const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&)
\item 
\mbox{\Hypertarget{class_sk_drawable_a93a68e8bd9d2874ae481cede50eac268}\label{class_sk_drawable_a93a68e8bd9d2874ae481cede50eac268}} 
virtual std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{class_sk_drawable_1_1_gpu_draw_handler}{Gpu\+Draw\+Handler}} $>$ {\bfseries on\+Snap\+Gpu\+Draw\+Handler} (Gr\+Backend\+Api, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} \&)
\item 
virtual \mbox{\hyperlink{class_sk_picture}{Sk\+Picture}} $\ast$ \mbox{\hyperlink{class_sk_drawable_ad7c47d51705a40431e76f14337b3e3aa}{on\+New\+Picture\+Snapshot}} ()
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
Base-\/class for objects that draw into \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}}.

The object has a generation ID, which is guaranteed to be unique across all drawables. To allow for clients of the drawable that may want to cache the results, the drawable must change its generation ID whenever its internal state changes such that it will draw differently. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_drawable_ade63adbce24872944c202e3cb619359b}\label{class_sk_drawable_ade63adbce24872944c202e3cb619359b}} 
\index{SkDrawable@{SkDrawable}!draw@{draw}}
\index{draw@{draw}!SkDrawable@{SkDrawable}}
\doxysubsubsection{\texorpdfstring{draw()}{draw()}}
{\footnotesize\ttfamily void Sk\+Drawable\+::draw (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} $\ast$}]{canvas,  }\item[{const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$}]{matrix = {\ttfamily nullptr} }\end{DoxyParamCaption})}

Draws into the specified content. The drawing sequence will be balanced upon return (i.\+e. the save\+Level() on the canvas will match what it was when \mbox{\hyperlink{class_sk_drawable_ade63adbce24872944c202e3cb619359b}{draw()}} was called, and the current matrix and clip settings will not be changed. \mbox{\Hypertarget{class_sk_drawable_a767d4865790d457c0df8744b5b974fb7}\label{class_sk_drawable_a767d4865790d457c0df8744b5b974fb7}} 
\index{SkDrawable@{SkDrawable}!getBounds@{getBounds}}
\index{getBounds@{getBounds}!SkDrawable@{SkDrawable}}
\doxysubsubsection{\texorpdfstring{getBounds()}{getBounds()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} Sk\+Drawable\+::get\+Bounds (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Return the (conservative) bounds of what the drawable will draw. If the drawable can change what it draws (e.\+g. animation or in response to some external change), then this must return a bounds that is always valid for all possible states. \mbox{\Hypertarget{class_sk_drawable_adfd6e7a9c0f0511e94449a88270fa178}\label{class_sk_drawable_adfd6e7a9c0f0511e94449a88270fa178}} 
\index{SkDrawable@{SkDrawable}!getFactory@{getFactory}}
\index{getFactory@{getFactory}!SkDrawable@{SkDrawable}}
\doxysubsubsection{\texorpdfstring{getFactory()}{getFactory()}}
{\footnotesize\ttfamily Factory Sk\+Drawable\+::get\+Factory (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}

Implement this to return a factory function pointer that can be called to recreate your class given a buffer (previously written to by your override of \mbox{\hyperlink{class_sk_flattenable_a12ed60c16e646c9d2acdcb7c47bb5cd0}{flatten()}}. 

Implements \mbox{\hyperlink{class_sk_flattenable_afe739ff6d2a6737b05dad084f523cd87}{Sk\+Flattenable}}.

\mbox{\Hypertarget{class_sk_drawable_a0db203b05d8222fc151b34ed12210d56}\label{class_sk_drawable_a0db203b05d8222fc151b34ed12210d56}} 
\index{SkDrawable@{SkDrawable}!getGenerationID@{getGenerationID}}
\index{getGenerationID@{getGenerationID}!SkDrawable@{SkDrawable}}
\doxysubsubsection{\texorpdfstring{getGenerationID()}{getGenerationID()}}
{\footnotesize\ttfamily uint32\+\_\+t Sk\+Drawable\+::get\+Generation\+ID (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Return a unique value for this instance. If two calls to this return the same value, it is presumed that calling the \mbox{\hyperlink{class_sk_drawable_ade63adbce24872944c202e3cb619359b}{draw()}} method will render the same thing as well.

Subclasses that change their state should call \mbox{\hyperlink{class_sk_drawable_a0cac52e61be3e3bf2ee2779460e9bc3c}{notify\+Drawing\+Changed()}} to ensure that a new value will be returned the next time it is called. \mbox{\Hypertarget{class_sk_drawable_ac9cb373e9ee5e6d8848eb46259b23a04}\label{class_sk_drawable_ac9cb373e9ee5e6d8848eb46259b23a04}} 
\index{SkDrawable@{SkDrawable}!getTypeName@{getTypeName}}
\index{getTypeName@{getTypeName}!SkDrawable@{SkDrawable}}
\doxysubsubsection{\texorpdfstring{getTypeName()}{getTypeName()}}
{\footnotesize\ttfamily const char$\ast$ Sk\+Drawable\+::get\+Type\+Name (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}

Returns the name of the object\textquotesingle{}s class. 

Implements \mbox{\hyperlink{class_sk_flattenable_a307ef2a249668fc3d6eeb23ba4418dbf}{Sk\+Flattenable}}.

\mbox{\Hypertarget{class_sk_drawable_a0cac52e61be3e3bf2ee2779460e9bc3c}\label{class_sk_drawable_a0cac52e61be3e3bf2ee2779460e9bc3c}} 
\index{SkDrawable@{SkDrawable}!notifyDrawingChanged@{notifyDrawingChanged}}
\index{notifyDrawingChanged@{notifyDrawingChanged}!SkDrawable@{SkDrawable}}
\doxysubsubsection{\texorpdfstring{notifyDrawingChanged()}{notifyDrawingChanged()}}
{\footnotesize\ttfamily void Sk\+Drawable\+::notify\+Drawing\+Changed (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Calling this invalidates the previous generation ID, and causes a new one to be computed the next time \mbox{\hyperlink{class_sk_drawable_a0db203b05d8222fc151b34ed12210d56}{get\+Generation\+I\+D()}} is called. Typically this is called by the object itself, in response to its internal state changing. \mbox{\Hypertarget{class_sk_drawable_ad7c47d51705a40431e76f14337b3e3aa}\label{class_sk_drawable_ad7c47d51705a40431e76f14337b3e3aa}} 
\index{SkDrawable@{SkDrawable}!onNewPictureSnapshot@{onNewPictureSnapshot}}
\index{onNewPictureSnapshot@{onNewPictureSnapshot}!SkDrawable@{SkDrawable}}
\doxysubsubsection{\texorpdfstring{onNewPictureSnapshot()}{onNewPictureSnapshot()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_sk_picture}{Sk\+Picture}} $\ast$ Sk\+Drawable\+::on\+New\+Picture\+Snapshot (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}

Default implementation calls on\+Draw() with a canvas that records into a picture. Subclasses may override if they have a more efficient way to return a picture for the current state of their drawable. Note\+: this picture must draw the same as what would be drawn from on\+Draw(). 

Reimplemented in \mbox{\hyperlink{class_sk_recorded_drawable_adf53905a1593f3ac44ad955fb0f1ba9d}{Sk\+Recorded\+Drawable}}.

\mbox{\Hypertarget{class_sk_drawable_a0adaf18de0972a821b596bffe4d3dd1b}\label{class_sk_drawable_a0adaf18de0972a821b596bffe4d3dd1b}} 
\index{SkDrawable@{SkDrawable}!snapGpuDrawHandler@{snapGpuDrawHandler}}
\index{snapGpuDrawHandler@{snapGpuDrawHandler}!SkDrawable@{SkDrawable}}
\doxysubsubsection{\texorpdfstring{snapGpuDrawHandler()}{snapGpuDrawHandler()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$\mbox{\hyperlink{class_sk_drawable_1_1_gpu_draw_handler}{Gpu\+Draw\+Handler}}$>$ Sk\+Drawable\+::snap\+Gpu\+Draw\+Handler (\begin{DoxyParamCaption}\item[{Gr\+Backend\+Api}]{backend\+Api,  }\item[{const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} \&}]{matrix,  }\item[{const \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} \&}]{clip\+Bounds,  }\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{buffer\+Info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Snaps off a \mbox{\hyperlink{class_sk_drawable_1_1_gpu_draw_handler}{Gpu\+Draw\+Handler}} to represent the state of the \mbox{\hyperlink{class_sk_drawable}{Sk\+Drawable}} at the time the snap is called. This is used for executing G\+PU backend specific draws intermixed with normal Skia G\+PU draws. The G\+PU A\+PI, which will be used for the draw, as well as the full matrix, device clip bounds and image\+Info of the target buffer are passed in as inputs. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/include/core/Sk\+Drawable.\+h\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Drawable.\+cpp\end{DoxyCompactItemize}
