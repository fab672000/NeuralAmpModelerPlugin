\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_5ab05608e705b1aba3c711003887b790_autotoc_md506}{}\doxysection{Latency from Resampling}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_5ab05608e705b1aba3c711003887b790_autotoc_md506}
There are two components of the latency. The resampler itself, and a buffer that is used to adapt the block sizes.

1) The resampler is an F\+IR running at the target sample rate. So its latency is the number of taps. From Multi\+Channel\+Resampler.\+cpp, num\+Taps is \begin{DoxyVerb}Fastest: 2
Low: 4
Medium: 8
High: 16
Best: 32
\end{DoxyVerb}


For output, the device sampling rate is used, which is typically 48000.\+For input, the app sampling rate is used.

2) There is a block size adapter~that collects odd sized blocks into larger blocks of the correct size.

The adapter contains one burst of frames, from get\+Frames\+Per\+Burst(). But if the app specifies a particular size using set\+Frames\+Per\+Callback() then that size will be used. Here is some pseudo-\/code to calculate the latency. \begin{DoxyVerb}latencyMillis = 0
targetRate = isOutput ? deviceRate : applicationRate
// Add latency from FIR
latencyMillis += numTaps * 1000.0 / targetRate
// Add latency from block size adaptation
adapterSize = (callbackSize > 0) ? callbackSize : burstSize
if (isOutput && isCallbackUsed) latencyMillis += adapterSize * 1000.0 / deviceRate
else if (isInput && isCallbackUsed) latencyMillis += adapterSize * 1000.0 / applicationRate
else if (isInput && !isCallbackUsed) latencyMillis += adapterSize * 1000.0 / deviceRate
\end{DoxyVerb}
 