\hypertarget{class_sk_surface}{}\doxysection{Sk\+Surface Class Reference}
\label{class_sk_surface}\index{SkSurface@{SkSurface}}


{\ttfamily \#include $<$Sk\+Surface.\+h$>$}

Inheritance diagram for Sk\+Surface\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{class_sk_surface}
\end{center}
\end{figure}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538}{Content\+Change\+Mode}} \{ \mbox{\hyperlink{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538a14b5a82c953bee6eb475b860005ae341}{k\+Discard\+\_\+\+Content\+Change\+Mode}}, 
\mbox{\hyperlink{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538a61df574700828a9f039c6cd8ec4c39df}{k\+Retain\+\_\+\+Content\+Change\+Mode}}
 \}
\item 
enum \mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209}{Backend\+Handle\+Access}} \{ \mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209a2061b9bbc92672b5168fbd018b47ec7a}{k\+Flush\+Read\+\_\+\+Backend\+Handle\+Access}}, 
\mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209a2c2b35a88238afbf7e7b79ff52048db4}{k\+Flush\+Write\+\_\+\+Backend\+Handle\+Access}}, 
\mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209a265463cfb4ba17bb7948556f12c73b95}{k\+Discard\+Write\+\_\+\+Backend\+Handle\+Access}}
 \}
\item 
enum \mbox{\hyperlink{class_sk_surface_acfaaa14115fc8fcb3e6074e3d9240c21}{Backend\+Surface\+Access}} \{ \mbox{\hyperlink{class_sk_surface_acfaaa14115fc8fcb3e6074e3d9240c21af5d6f15f85f8db76149a52e2f4a2aa70}{Backend\+Surface\+Access\+::k\+No\+Access}}, 
\mbox{\hyperlink{class_sk_surface_acfaaa14115fc8fcb3e6074e3d9240c21a019665dfbd21bc633282967ea7b6d5b8}{Backend\+Surface\+Access\+::k\+Present}}
 \}
\item 
typedef void $\ast$ \mbox{\hyperlink{class_sk_surface_ae91b4f130cbb53ecde3a1d9261eadc54}{Release\+Context}}
\item 
typedef void($\ast$ \mbox{\hyperlink{class_sk_surface_a45233f6282af6774d6175485cc327e0c}{Render\+Target\+Release\+Proc}}) (\mbox{\hyperlink{class_sk_surface_ae91b4f130cbb53ecde3a1d9261eadc54}{Release\+Context}} release\+Context)
\item 
typedef void($\ast$ \mbox{\hyperlink{class_sk_surface_a0e552eaf3124ef4e6fbb3490b321ea60}{Texture\+Release\+Proc}}) (\mbox{\hyperlink{class_sk_surface_ae91b4f130cbb53ecde3a1d9261eadc54}{Release\+Context}} release\+Context)
\item 
\mbox{\Hypertarget{class_sk_surface_a4adeb48872dbe98ea996ac682edf95eb}\label{class_sk_surface_a4adeb48872dbe98ea996ac682edf95eb}} 
using {\bfseries Async\+Read\+Result} = \mbox{\hyperlink{class_sk_image_1_1_async_read_result}{Sk\+Image\+::\+Async\+Read\+Result}}
\item 
using \mbox{\hyperlink{class_sk_surface_af503b9dfb01853ec8baf91953d750d20}{Read\+Pixels\+Context}} = void $\ast$
\item 
using \mbox{\hyperlink{class_sk_surface_a238d34561a4e6ac34b037135cff08555}{Read\+Pixels\+Callback}} = void(\mbox{\hyperlink{class_sk_surface_af503b9dfb01853ec8baf91953d750d20}{Read\+Pixels\+Context}}, std\+::unique\+\_\+ptr$<$ const \mbox{\hyperlink{class_sk_image_1_1_async_read_result}{Async\+Read\+Result}} $>$)
\item 
using \mbox{\hyperlink{class_sk_surface_a6bfc34aaf34209ab66e083c1f284cd41}{Rescale\+Gamma}} = Sk\+Image\+::\+Rescale\+Gamma
\item 
\mbox{\Hypertarget{class_sk_surface_a91fe86f1ecced96979cbd18a8e69d810}\label{class_sk_surface_a91fe86f1ecced96979cbd18a8e69d810}} 
using {\bfseries Rescale\+Mode} = Sk\+Image\+::\+Rescale\+Mode
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{class_sk_surface_a68f8dfb17ce83f40180acefb844c6352}{is\+Compatible}} (const \mbox{\hyperlink{class_sk_surface_characterization}{Sk\+Surface\+Characterization}} \&characterization) const
\item 
int \mbox{\hyperlink{class_sk_surface_a351ef72e03fba91865a321e8e081a842}{width}} () const
\item 
int \mbox{\hyperlink{class_sk_surface_aa30771352bbeb37532669127fa16494e}{height}} () const
\item 
\mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \mbox{\hyperlink{class_sk_surface_a2f86fa89d5cf1706c31d10c8845c2000}{image\+Info}} ()
\item 
uint32\+\_\+t \mbox{\hyperlink{class_sk_surface_af977ef6c5da6bc9b95747e5961672433}{generation\+ID}} ()
\item 
void \mbox{\hyperlink{class_sk_surface_ae577c5cac83c670f87c51eddab87aa9f}{notify\+Content\+Will\+Change}} (\mbox{\hyperlink{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538}{Content\+Change\+Mode}} mode)
\item 
\mbox{\hyperlink{class_gr_recording_context}{Gr\+Recording\+Context}} $\ast$ \mbox{\hyperlink{class_sk_surface_a7e10b31a98c0b93e6d6fb23b32b8519f}{recording\+Context}} ()
\item 
\mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \mbox{\hyperlink{class_sk_surface_a285a711149f69823597c3763eab03dd1}{get\+Backend\+Texture}} (\mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209}{Backend\+Handle\+Access}} backend\+Handle\+Access)
\item 
\mbox{\hyperlink{class_gr_backend_render_target}{Gr\+Backend\+Render\+Target}} \mbox{\hyperlink{class_sk_surface_a38e996e7dafe610f933830c22196eff1}{get\+Backend\+Render\+Target}} (\mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209}{Backend\+Handle\+Access}} backend\+Handle\+Access)
\item 
bool \mbox{\hyperlink{class_sk_surface_a6335b4e9e654c197aa9802bf74facc5b}{replace\+Backend\+Texture}} (const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&backend\+Texture, Gr\+Surface\+Origin origin, \mbox{\hyperlink{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538}{Content\+Change\+Mode}} mode=\mbox{\hyperlink{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538a61df574700828a9f039c6cd8ec4c39df}{k\+Retain\+\_\+\+Content\+Change\+Mode}}, \mbox{\hyperlink{class_sk_surface_a0e552eaf3124ef4e6fbb3490b321ea60}{Texture\+Release\+Proc}} texture\+Release\+Proc=nullptr, \mbox{\hyperlink{class_sk_surface_ae91b4f130cbb53ecde3a1d9261eadc54}{Release\+Context}} release\+Context=nullptr)
\item 
\mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} $\ast$ \mbox{\hyperlink{class_sk_surface_aedab202bc98dad9a0d089b85274435aa}{get\+Canvas}} ()
\item 
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} $>$ \mbox{\hyperlink{class_sk_surface_a56ed11229ed16cbb2b9d377deac2ca08}{make\+Surface}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&\mbox{\hyperlink{class_sk_surface_a2f86fa89d5cf1706c31d10c8845c2000}{image\+Info}})
\item 
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} $>$ \mbox{\hyperlink{class_sk_surface_a925f99aeda52481cdedc9bc5e24ea57a}{make\+Surface}} (int \mbox{\hyperlink{class_sk_surface_a351ef72e03fba91865a321e8e081a842}{width}}, int \mbox{\hyperlink{class_sk_surface_aa30771352bbeb37532669127fa16494e}{height}})
\item 
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image}{Sk\+Image}} $>$ \mbox{\hyperlink{class_sk_surface_a9e0831e582fff299df12786801fbd2bf}{make\+Image\+Snapshot}} ()
\item 
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image}{Sk\+Image}} $>$ \mbox{\hyperlink{class_sk_surface_af6b4058c4d8708cae31993d41f7c377f}{make\+Image\+Snapshot}} (const \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} \&bounds)
\item 
void \mbox{\hyperlink{class_sk_surface_a6df6eac244797f29fedd501ce66e4b8c}{draw}} (\mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} $\ast$canvas, Sk\+Scalar x, Sk\+Scalar y, const \mbox{\hyperlink{struct_sk_sampling_options}{Sk\+Sampling\+Options}} \&sampling, const \mbox{\hyperlink{class_sk_paint}{Sk\+Paint}} $\ast$paint)
\item 
\mbox{\Hypertarget{class_sk_surface_a85dfe72438211bcb0d0c3139ad36fba4}\label{class_sk_surface_a85dfe72438211bcb0d0c3139ad36fba4}} 
void {\bfseries draw} (\mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} $\ast$canvas, Sk\+Scalar x, Sk\+Scalar y, const \mbox{\hyperlink{class_sk_paint}{Sk\+Paint}} $\ast$paint=nullptr)
\item 
bool \mbox{\hyperlink{class_sk_surface_a8de5913a3bca21fccd77e92755b26432}{peek\+Pixels}} (\mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} $\ast$pixmap)
\item 
bool \mbox{\hyperlink{class_sk_surface_af3fe3696a898f644c0b3136d94771588}{read\+Pixels}} (const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} \&dst, int srcX, int srcY)
\item 
bool \mbox{\hyperlink{class_sk_surface_a1fbe87fec06fb10cc5f2ea34b6bff55e}{read\+Pixels}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&dst\+Info, void $\ast$dst\+Pixels, size\+\_\+t dst\+Row\+Bytes, int srcX, int srcY)
\item 
bool \mbox{\hyperlink{class_sk_surface_abf11d4d743be6d2d94007e8d923c987c}{read\+Pixels}} (const \mbox{\hyperlink{class_sk_bitmap}{Sk\+Bitmap}} \&dst, int srcX, int srcY)
\item 
void \mbox{\hyperlink{class_sk_surface_a757d32ec2ef6749a848e6b6510c6ff52}{async\+Rescale\+And\+Read\+Pixels}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&info, const \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} \&src\+Rect, \mbox{\hyperlink{class_sk_surface_a6bfc34aaf34209ab66e083c1f284cd41}{Rescale\+Gamma}} rescale\+Gamma, Rescale\+Mode rescale\+Mode, \mbox{\hyperlink{class_sk_surface_a238d34561a4e6ac34b037135cff08555}{Read\+Pixels\+Callback}} callback, \mbox{\hyperlink{class_sk_surface_af503b9dfb01853ec8baf91953d750d20}{Read\+Pixels\+Context}} context)
\item 
void \mbox{\hyperlink{class_sk_surface_ac733f55bd42631443bc4332902c65ab4}{async\+Rescale\+And\+Read\+Pixels\+Y\+U\+V420}} (Sk\+Y\+U\+V\+Color\+Space yuv\+Color\+Space, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$ dst\+Color\+Space, const \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} \&src\+Rect, const \mbox{\hyperlink{struct_sk_i_size}{Sk\+I\+Size}} \&dst\+Size, \mbox{\hyperlink{class_sk_surface_a6bfc34aaf34209ab66e083c1f284cd41}{Rescale\+Gamma}} rescale\+Gamma, Rescale\+Mode rescale\+Mode, \mbox{\hyperlink{class_sk_surface_a238d34561a4e6ac34b037135cff08555}{Read\+Pixels\+Callback}} callback, \mbox{\hyperlink{class_sk_surface_af503b9dfb01853ec8baf91953d750d20}{Read\+Pixels\+Context}} context)
\item 
void \mbox{\hyperlink{class_sk_surface_ae22a0f49d435f78820918fbf06c0dd61}{write\+Pixels}} (const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} \&src, int dstX, int dstY)
\item 
void \mbox{\hyperlink{class_sk_surface_a59a898652100042350bce30cb348c781}{write\+Pixels}} (const \mbox{\hyperlink{class_sk_bitmap}{Sk\+Bitmap}} \&src, int dstX, int dstY)
\item 
const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} \& \mbox{\hyperlink{class_sk_surface_a0a3c4c19cc65a7eb602cb196b1c40556}{props}} () const
\item 
void \mbox{\hyperlink{class_sk_surface_a0b204d1ac715f3c6efe29ed4576517ec}{flush\+And\+Submit}} (bool sync\+Cpu=false)
\item 
Gr\+Semaphores\+Submitted \mbox{\hyperlink{class_sk_surface_ac63598d1fc23ac43eb4e39ae330fb7af}{flush}} (\mbox{\hyperlink{class_sk_surface_acfaaa14115fc8fcb3e6074e3d9240c21}{Backend\+Surface\+Access}} \mbox{\hyperlink{structaccess}{access}}, const \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}} \&info)
\item 
Gr\+Semaphores\+Submitted \mbox{\hyperlink{class_sk_surface_a7e98a032ac0291743ad97a3b54db6b22}{flush}} (const \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}} \&info, const \mbox{\hyperlink{class_gr_backend_surface_mutable_state}{Gr\+Backend\+Surface\+Mutable\+State}} $\ast$new\+State=nullptr)
\item 
\mbox{\Hypertarget{class_sk_surface_ab41ac73b5f6a0a59c9ce1cfb2520c39a}\label{class_sk_surface_ab41ac73b5f6a0a59c9ce1cfb2520c39a}} 
void {\bfseries flush} ()
\item 
bool \mbox{\hyperlink{class_sk_surface_aebf60b11a45f03386aecc5f673d36bac}{wait}} (int num\+Semaphores, const \mbox{\hyperlink{class_gr_backend_semaphore}{Gr\+Backend\+Semaphore}} $\ast$wait\+Semaphores, bool delete\+Semaphores\+After\+Wait=true)
\item 
bool \mbox{\hyperlink{class_sk_surface_a0ffe89cb0d9217a40223e0d37abd28b0}{characterize}} (\mbox{\hyperlink{class_sk_surface_characterization}{Sk\+Surface\+Characterization}} $\ast$characterization) const
\item 
bool \mbox{\hyperlink{class_sk_surface_aa135fac4a1536ef0885b0279eb7382c7}{draw}} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ const \mbox{\hyperlink{class_sk_deferred_display_list}{Sk\+Deferred\+Display\+List}} $>$ deferred\+Display\+List, int x\+Offset=0, int y\+Offset=0)
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} $>$ \mbox{\hyperlink{class_sk_surface_af025ece3e61fea154e5bc303f76e78b1}{Make\+Raster\+Direct}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&\mbox{\hyperlink{class_sk_surface_a2f86fa89d5cf1706c31d10c8845c2000}{image\+Info}}, void $\ast$pixels, size\+\_\+t row\+Bytes, const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$surface\+Props=nullptr)
\item 
\mbox{\Hypertarget{class_sk_surface_a83da5d273aca02285c5a07a5af18ce81}\label{class_sk_surface_a83da5d273aca02285c5a07a5af18ce81}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} $>$ {\bfseries Make\+Raster\+Direct} (const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} \&pm, const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$\mbox{\hyperlink{class_sk_surface_a0a3c4c19cc65a7eb602cb196b1c40556}{props}}=nullptr)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} $>$ \mbox{\hyperlink{class_sk_surface_aa000cb9fdcb3b5ec5bf92408fd0df3a0}{Make\+Raster\+Direct\+Release\+Proc}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&\mbox{\hyperlink{class_sk_surface_a2f86fa89d5cf1706c31d10c8845c2000}{image\+Info}}, void $\ast$pixels, size\+\_\+t row\+Bytes, void($\ast$release\+Proc)(void $\ast$pixels, void $\ast$context), void $\ast$context, const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$surface\+Props=nullptr)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} $>$ \mbox{\hyperlink{class_sk_surface_ae4ed88112b3622f7a7474e9e2b771004}{Make\+Raster}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&\mbox{\hyperlink{class_sk_surface_a2f86fa89d5cf1706c31d10c8845c2000}{image\+Info}}, size\+\_\+t row\+Bytes, const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$surface\+Props)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} $>$ \mbox{\hyperlink{class_sk_surface_a99b9671ebd493fdb8185e118d7691c50}{Make\+Raster}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&\mbox{\hyperlink{class_sk_surface_a2f86fa89d5cf1706c31d10c8845c2000}{image\+Info}}, const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$\mbox{\hyperlink{class_sk_surface_a0a3c4c19cc65a7eb602cb196b1c40556}{props}}=nullptr)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} $>$ \mbox{\hyperlink{class_sk_surface_a8ac34d6cf6f05d76db8d27b3e811e01c}{Make\+Raster\+N32\+Premul}} (int \mbox{\hyperlink{class_sk_surface_a351ef72e03fba91865a321e8e081a842}{width}}, int \mbox{\hyperlink{class_sk_surface_aa30771352bbeb37532669127fa16494e}{height}}, const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$surface\+Props=nullptr)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} $>$ \mbox{\hyperlink{class_sk_surface_a71d1d58f5e13f77d94697d6e408cdfad}{Make\+From\+Backend\+Texture}} (\mbox{\hyperlink{class_gr_recording_context}{Gr\+Recording\+Context}} $\ast$context, const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&backend\+Texture, Gr\+Surface\+Origin origin, int sample\+Cnt, Sk\+Color\+Type color\+Type, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$ color\+Space, const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$surface\+Props, \mbox{\hyperlink{class_sk_surface_a0e552eaf3124ef4e6fbb3490b321ea60}{Texture\+Release\+Proc}} texture\+Release\+Proc=nullptr, \mbox{\hyperlink{class_sk_surface_ae91b4f130cbb53ecde3a1d9261eadc54}{Release\+Context}} release\+Context=nullptr)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} $>$ \mbox{\hyperlink{class_sk_surface_a5e5ba93640ce8e65a7cb401d5554e84c}{Make\+From\+Backend\+Render\+Target}} (\mbox{\hyperlink{class_gr_recording_context}{Gr\+Recording\+Context}} $\ast$context, const \mbox{\hyperlink{class_gr_backend_render_target}{Gr\+Backend\+Render\+Target}} \&backend\+Render\+Target, Gr\+Surface\+Origin origin, Sk\+Color\+Type color\+Type, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$ color\+Space, const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$surface\+Props, \mbox{\hyperlink{class_sk_surface_a45233f6282af6774d6175485cc327e0c}{Render\+Target\+Release\+Proc}} release\+Proc=nullptr, \mbox{\hyperlink{class_sk_surface_ae91b4f130cbb53ecde3a1d9261eadc54}{Release\+Context}} release\+Context=nullptr)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} $>$ \mbox{\hyperlink{class_sk_surface_aa32278bea58b9f229190c45b59f01548}{Make\+Render\+Target}} (\mbox{\hyperlink{class_gr_recording_context}{Gr\+Recording\+Context}} $\ast$context, \mbox{\hyperlink{_sk_types_8h_a66f73362220ea988583a7980b6634374}{Sk\+Budgeted}} budgeted, const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&\mbox{\hyperlink{class_sk_surface_a2f86fa89d5cf1706c31d10c8845c2000}{image\+Info}}, int sample\+Count, Gr\+Surface\+Origin surface\+Origin, const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$surface\+Props, bool should\+Create\+With\+Mips=false)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} $>$ \mbox{\hyperlink{class_sk_surface_a71929ad95b166b7b98df684056724e1e}{Make\+Render\+Target}} (\mbox{\hyperlink{class_gr_recording_context}{Gr\+Recording\+Context}} $\ast$context, \mbox{\hyperlink{_sk_types_8h_a66f73362220ea988583a7980b6634374}{Sk\+Budgeted}} budgeted, const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&\mbox{\hyperlink{class_sk_surface_a2f86fa89d5cf1706c31d10c8845c2000}{image\+Info}}, int sample\+Count, const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$surface\+Props)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} $>$ \mbox{\hyperlink{class_sk_surface_ad836deaf72354a6eebe21565e9906f67}{Make\+Render\+Target}} (\mbox{\hyperlink{class_gr_recording_context}{Gr\+Recording\+Context}} $\ast$context, \mbox{\hyperlink{_sk_types_8h_a66f73362220ea988583a7980b6634374}{Sk\+Budgeted}} budgeted, const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&\mbox{\hyperlink{class_sk_surface_a2f86fa89d5cf1706c31d10c8845c2000}{image\+Info}})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} $>$ \mbox{\hyperlink{class_sk_surface_a13494920609f783f66d3246a6ea26236}{Make\+Render\+Target}} (\mbox{\hyperlink{class_gr_recording_context}{Gr\+Recording\+Context}} $\ast$context, const \mbox{\hyperlink{class_sk_surface_characterization}{Sk\+Surface\+Characterization}} \&characterization, \mbox{\hyperlink{_sk_types_8h_a66f73362220ea988583a7980b6634374}{Sk\+Budgeted}} budgeted)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} $>$ \mbox{\hyperlink{class_sk_surface_a8eed158c914df86a8855919974421a3f}{Make\+Null}} (int \mbox{\hyperlink{class_sk_surface_a351ef72e03fba91865a321e8e081a842}{width}}, int \mbox{\hyperlink{class_sk_surface_aa30771352bbeb37532669127fa16494e}{height}})
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const \mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209}{Backend\+Handle\+Access}} \mbox{\hyperlink{class_sk_surface_a87371ae0497a248a1f9567950670b709}{k\+Flush\+Read\+\_\+\+Texture\+Handle\+Access}}
\item 
static const \mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209}{Backend\+Handle\+Access}} \mbox{\hyperlink{class_sk_surface_a13c51fc4193e7e91806b109af59d242f}{k\+Flush\+Write\+\_\+\+Texture\+Handle\+Access}}
\item 
static const \mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209}{Backend\+Handle\+Access}} \mbox{\hyperlink{class_sk_surface_a1ff636605c412060f5ffe6bc0a5039e1}{k\+Discard\+Write\+\_\+\+Texture\+Handle\+Access}}
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_surface_ae1561ab052cb86c3718ffa152c869cd3}\label{class_sk_surface_ae1561ab052cb86c3718ffa152c869cd3}} 
{\bfseries Sk\+Surface} (int \mbox{\hyperlink{class_sk_surface_a351ef72e03fba91865a321e8e081a842}{width}}, int \mbox{\hyperlink{class_sk_surface_aa30771352bbeb37532669127fa16494e}{height}}, const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$surface\+Props)
\item 
\mbox{\Hypertarget{class_sk_surface_a9d28ffb38af5890b1c353e768bcfebec}\label{class_sk_surface_a9d28ffb38af5890b1c353e768bcfebec}} 
{\bfseries Sk\+Surface} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&\mbox{\hyperlink{class_sk_surface_a2f86fa89d5cf1706c31d10c8845c2000}{image\+Info}}, const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$surface\+Props)
\item 
\mbox{\Hypertarget{class_sk_surface_a03b2bdea7327716d78b5d690fbeb99f0}\label{class_sk_surface_a03b2bdea7327716d78b5d690fbeb99f0}} 
void {\bfseries dirty\+Generation\+ID} ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is responsible for managing the pixels that a canvas draws into. The pixels can be allocated either in C\+PU memory (a raster surface) or on the G\+PU (a Gr\+Render\+Target surface). \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} takes care of allocating a \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} that will draw into the surface. Call surface-\/$>$\mbox{\hyperlink{class_sk_surface_aedab202bc98dad9a0d089b85274435aa}{get\+Canvas()}} to use that canvas (but don\textquotesingle{}t delete it, it is owned by the surface). \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} always has non-\/zero dimensions. If there is a request for a new surface, and either of the requested dimensions are zero, then nullptr will be returned. 

\doxysubsection{Member Typedef Documentation}
\mbox{\Hypertarget{class_sk_surface_a238d34561a4e6ac34b037135cff08555}\label{class_sk_surface_a238d34561a4e6ac34b037135cff08555}} 
\index{SkSurface@{SkSurface}!ReadPixelsCallback@{ReadPixelsCallback}}
\index{ReadPixelsCallback@{ReadPixelsCallback}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{ReadPixelsCallback}{ReadPixelsCallback}}
{\footnotesize\ttfamily using \mbox{\hyperlink{class_sk_surface_a238d34561a4e6ac34b037135cff08555}{Sk\+Surface\+::\+Read\+Pixels\+Callback}} =  void(\mbox{\hyperlink{class_sk_surface_af503b9dfb01853ec8baf91953d750d20}{Read\+Pixels\+Context}}, std\+::unique\+\_\+ptr$<$const \mbox{\hyperlink{class_sk_image_1_1_async_read_result}{Async\+Read\+Result}}$>$)}

Client-\/provided callback to \mbox{\hyperlink{class_sk_surface_a757d32ec2ef6749a848e6b6510c6ff52}{async\+Rescale\+And\+Read\+Pixels()}} or \mbox{\hyperlink{class_sk_surface_ac733f55bd42631443bc4332902c65ab4}{async\+Rescale\+And\+Read\+Pixels\+Y\+U\+V420()}} that is called when read result is ready or on failure. \mbox{\Hypertarget{class_sk_surface_af503b9dfb01853ec8baf91953d750d20}\label{class_sk_surface_af503b9dfb01853ec8baf91953d750d20}} 
\index{SkSurface@{SkSurface}!ReadPixelsContext@{ReadPixelsContext}}
\index{ReadPixelsContext@{ReadPixelsContext}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{ReadPixelsContext}{ReadPixelsContext}}
{\footnotesize\ttfamily using \mbox{\hyperlink{class_sk_surface_af503b9dfb01853ec8baf91953d750d20}{Sk\+Surface\+::\+Read\+Pixels\+Context}} =  void$\ast$}

Client-\/provided context that is passed to client-\/provided Read\+Pixels\+Context. \mbox{\Hypertarget{class_sk_surface_ae91b4f130cbb53ecde3a1d9261eadc54}\label{class_sk_surface_ae91b4f130cbb53ecde3a1d9261eadc54}} 
\index{SkSurface@{SkSurface}!ReleaseContext@{ReleaseContext}}
\index{ReleaseContext@{ReleaseContext}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{ReleaseContext}{ReleaseContext}}
{\footnotesize\ttfamily typedef void$\ast$ \mbox{\hyperlink{class_sk_surface_ae91b4f130cbb53ecde3a1d9261eadc54}{Sk\+Surface\+::\+Release\+Context}}}

Caller data passed to Render\+Target/\+Texture\+Release\+Proc; may be nullptr. \mbox{\Hypertarget{class_sk_surface_a45233f6282af6774d6175485cc327e0c}\label{class_sk_surface_a45233f6282af6774d6175485cc327e0c}} 
\index{SkSurface@{SkSurface}!RenderTargetReleaseProc@{RenderTargetReleaseProc}}
\index{RenderTargetReleaseProc@{RenderTargetReleaseProc}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{RenderTargetReleaseProc}{RenderTargetReleaseProc}}
{\footnotesize\ttfamily typedef void($\ast$ Sk\+Surface\+::\+Render\+Target\+Release\+Proc) (\mbox{\hyperlink{class_sk_surface_ae91b4f130cbb53ecde3a1d9261eadc54}{Release\+Context}} release\+Context)}

User function called when supplied render target may be deleted. \mbox{\Hypertarget{class_sk_surface_a6bfc34aaf34209ab66e083c1f284cd41}\label{class_sk_surface_a6bfc34aaf34209ab66e083c1f284cd41}} 
\index{SkSurface@{SkSurface}!RescaleGamma@{RescaleGamma}}
\index{RescaleGamma@{RescaleGamma}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{RescaleGamma}{RescaleGamma}}
{\footnotesize\ttfamily using Sk\+Surface\+::\+Rescale\+Gamma =  Sk\+Image\+::\+Rescale\+Gamma}

Controls the gamma that rescaling occurs in for \mbox{\hyperlink{class_sk_surface_a757d32ec2ef6749a848e6b6510c6ff52}{async\+Rescale\+And\+Read\+Pixels()}} and \mbox{\hyperlink{class_sk_surface_ac733f55bd42631443bc4332902c65ab4}{async\+Rescale\+And\+Read\+Pixels\+Y\+U\+V420()}}. \mbox{\Hypertarget{class_sk_surface_a0e552eaf3124ef4e6fbb3490b321ea60}\label{class_sk_surface_a0e552eaf3124ef4e6fbb3490b321ea60}} 
\index{SkSurface@{SkSurface}!TextureReleaseProc@{TextureReleaseProc}}
\index{TextureReleaseProc@{TextureReleaseProc}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{TextureReleaseProc}{TextureReleaseProc}}
{\footnotesize\ttfamily typedef void($\ast$ Sk\+Surface\+::\+Texture\+Release\+Proc) (\mbox{\hyperlink{class_sk_surface_ae91b4f130cbb53ecde3a1d9261eadc54}{Release\+Context}} release\+Context)}

User function called when supplied texture may be deleted. 

\doxysubsection{Member Enumeration Documentation}
\mbox{\Hypertarget{class_sk_surface_ae68c874f3e621291d54c5b62f3165209}\label{class_sk_surface_ae68c874f3e621291d54c5b62f3165209}} 
\index{SkSurface@{SkSurface}!BackendHandleAccess@{BackendHandleAccess}}
\index{BackendHandleAccess@{BackendHandleAccess}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{BackendHandleAccess}{BackendHandleAccess}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209}{Sk\+Surface\+::\+Backend\+Handle\+Access}}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kFlushRead\_BackendHandleAccess@{kFlushRead\_BackendHandleAccess}!SkSurface@{SkSurface}}\index{SkSurface@{SkSurface}!kFlushRead\_BackendHandleAccess@{kFlushRead\_BackendHandleAccess}}}\mbox{\Hypertarget{class_sk_surface_ae68c874f3e621291d54c5b62f3165209a2061b9bbc92672b5168fbd018b47ec7a}\label{class_sk_surface_ae68c874f3e621291d54c5b62f3165209a2061b9bbc92672b5168fbd018b47ec7a}} 
k\+Flush\+Read\+\_\+\+Backend\+Handle\+Access&back-\/end object is readable \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kFlushWrite\_BackendHandleAccess@{kFlushWrite\_BackendHandleAccess}!SkSurface@{SkSurface}}\index{SkSurface@{SkSurface}!kFlushWrite\_BackendHandleAccess@{kFlushWrite\_BackendHandleAccess}}}\mbox{\Hypertarget{class_sk_surface_ae68c874f3e621291d54c5b62f3165209a2c2b35a88238afbf7e7b79ff52048db4}\label{class_sk_surface_ae68c874f3e621291d54c5b62f3165209a2c2b35a88238afbf7e7b79ff52048db4}} 
k\+Flush\+Write\+\_\+\+Backend\+Handle\+Access&back-\/end object is writable \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kDiscardWrite\_BackendHandleAccess@{kDiscardWrite\_BackendHandleAccess}!SkSurface@{SkSurface}}\index{SkSurface@{SkSurface}!kDiscardWrite\_BackendHandleAccess@{kDiscardWrite\_BackendHandleAccess}}}\mbox{\Hypertarget{class_sk_surface_ae68c874f3e621291d54c5b62f3165209a265463cfb4ba17bb7948556f12c73b95}\label{class_sk_surface_ae68c874f3e621291d54c5b62f3165209a265463cfb4ba17bb7948556f12c73b95}} 
k\+Discard\+Write\+\_\+\+Backend\+Handle\+Access&back-\/end object must be overwritten \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{class_sk_surface_acfaaa14115fc8fcb3e6074e3d9240c21}\label{class_sk_surface_acfaaa14115fc8fcb3e6074e3d9240c21}} 
\index{SkSurface@{SkSurface}!BackendSurfaceAccess@{BackendSurfaceAccess}}
\index{BackendSurfaceAccess@{BackendSurfaceAccess}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{BackendSurfaceAccess}{BackendSurfaceAccess}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{class_sk_surface_acfaaa14115fc8fcb3e6074e3d9240c21}{Sk\+Surface\+::\+Backend\+Surface\+Access}}\hspace{0.3cm}{\ttfamily [strong]}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kNoAccess@{kNoAccess}!SkSurface@{SkSurface}}\index{SkSurface@{SkSurface}!kNoAccess@{kNoAccess}}}\mbox{\Hypertarget{class_sk_surface_acfaaa14115fc8fcb3e6074e3d9240c21af5d6f15f85f8db76149a52e2f4a2aa70}\label{class_sk_surface_acfaaa14115fc8fcb3e6074e3d9240c21af5d6f15f85f8db76149a52e2f4a2aa70}} 
k\+No\+Access&back-\/end object will not be used by client \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kPresent@{kPresent}!SkSurface@{SkSurface}}\index{SkSurface@{SkSurface}!kPresent@{kPresent}}}\mbox{\Hypertarget{class_sk_surface_acfaaa14115fc8fcb3e6074e3d9240c21a019665dfbd21bc633282967ea7b6d5b8}\label{class_sk_surface_acfaaa14115fc8fcb3e6074e3d9240c21a019665dfbd21bc633282967ea7b6d5b8}} 
k\+Present&back-\/end surface will be used for presenting to screen \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538}\label{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538}} 
\index{SkSurface@{SkSurface}!ContentChangeMode@{ContentChangeMode}}
\index{ContentChangeMode@{ContentChangeMode}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{ContentChangeMode}{ContentChangeMode}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538}{Sk\+Surface\+::\+Content\+Change\+Mode}}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kDiscard\_ContentChangeMode@{kDiscard\_ContentChangeMode}!SkSurface@{SkSurface}}\index{SkSurface@{SkSurface}!kDiscard\_ContentChangeMode@{kDiscard\_ContentChangeMode}}}\mbox{\Hypertarget{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538a14b5a82c953bee6eb475b860005ae341}\label{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538a14b5a82c953bee6eb475b860005ae341}} 
k\+Discard\+\_\+\+Content\+Change\+Mode&discards surface on change \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kRetain\_ContentChangeMode@{kRetain\_ContentChangeMode}!SkSurface@{SkSurface}}\index{SkSurface@{SkSurface}!kRetain\_ContentChangeMode@{kRetain\_ContentChangeMode}}}\mbox{\Hypertarget{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538a61df574700828a9f039c6cd8ec4c39df}\label{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538a61df574700828a9f039c6cd8ec4c39df}} 
k\+Retain\+\_\+\+Content\+Change\+Mode&preserves surface on change \\
\hline

\end{DoxyEnumFields}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_surface_a757d32ec2ef6749a848e6b6510c6ff52}\label{class_sk_surface_a757d32ec2ef6749a848e6b6510c6ff52}} 
\index{SkSurface@{SkSurface}!asyncRescaleAndReadPixels@{asyncRescaleAndReadPixels}}
\index{asyncRescaleAndReadPixels@{asyncRescaleAndReadPixels}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{asyncRescaleAndReadPixels()}{asyncRescaleAndReadPixels()}}
{\footnotesize\ttfamily void Sk\+Surface\+::async\+Rescale\+And\+Read\+Pixels (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{info,  }\item[{const \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} \&}]{src\+Rect,  }\item[{\mbox{\hyperlink{class_sk_surface_a6bfc34aaf34209ab66e083c1f284cd41}{Rescale\+Gamma}}}]{rescale\+Gamma,  }\item[{Rescale\+Mode}]{rescale\+Mode,  }\item[{\mbox{\hyperlink{class_sk_surface_a238d34561a4e6ac34b037135cff08555}{Read\+Pixels\+Callback}}}]{callback,  }\item[{\mbox{\hyperlink{class_sk_surface_af503b9dfb01853ec8baf91953d750d20}{Read\+Pixels\+Context}}}]{context }\end{DoxyParamCaption})}

Makes surface pixel data available to caller, possibly asynchronously. It can also rescale the surface pixels.

Currently asynchronous reads are only supported on the G\+PU backend and only when the underlying 3D A\+PI supports transfer buffers and C\+P\+U/\+G\+PU synchronization primitives. In all other cases this operates synchronously.

Data is read from the source sub-\/rectangle, is optionally converted to a linear gamma, is rescaled to the size indicated by \textquotesingle{}info\textquotesingle{}, is then converted to the color space, color type, and alpha type of \textquotesingle{}info\textquotesingle{}. A \textquotesingle{}src\+Rect\textquotesingle{} that is not contained by the bounds of the surface causes failure.

When the pixel data is ready the caller\textquotesingle{}s Read\+Pixels\+Callback is called with a Async\+Read\+Result containing pixel data in the requested color type, alpha type, and color space. The Async\+Read\+Result will have count() == 1. Upon failure the callback is called with nullptr for Async\+Read\+Result. For a G\+PU surface this flushes work but a submit must occur to guarantee a finite time before the callback is called.

The data is valid for the lifetime of Async\+Read\+Result with the exception that if the \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is G\+P\+U-\/backed the data is immediately invalidated if the context is abandoned or destroyed.


\begin{DoxyParams}{Parameters}
{\em info} & info of the requested pixels \\
\hline
{\em src\+Rect} & subrectangle of surface to read \\
\hline
{\em rescale\+Gamma} & controls whether rescaling is done in the surface\textquotesingle{}s gamma or whether the source data is transformed to a linear gamma before rescaling. \\
\hline
{\em rescale\+Mode} & controls the technique of the rescaling \\
\hline
{\em callback} & function to call with result of the read \\
\hline
{\em context} & passed to callback \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_surface_ac733f55bd42631443bc4332902c65ab4}\label{class_sk_surface_ac733f55bd42631443bc4332902c65ab4}} 
\index{SkSurface@{SkSurface}!asyncRescaleAndReadPixelsYUV420@{asyncRescaleAndReadPixelsYUV420}}
\index{asyncRescaleAndReadPixelsYUV420@{asyncRescaleAndReadPixelsYUV420}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{asyncRescaleAndReadPixelsYUV420()}{asyncRescaleAndReadPixelsYUV420()}}
{\footnotesize\ttfamily void Sk\+Surface\+::async\+Rescale\+And\+Read\+Pixels\+Y\+U\+V420 (\begin{DoxyParamCaption}\item[{Sk\+Y\+U\+V\+Color\+Space}]{yuv\+Color\+Space,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$}]{dst\+Color\+Space,  }\item[{const \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} \&}]{src\+Rect,  }\item[{const \mbox{\hyperlink{struct_sk_i_size}{Sk\+I\+Size}} \&}]{dst\+Size,  }\item[{\mbox{\hyperlink{class_sk_surface_a6bfc34aaf34209ab66e083c1f284cd41}{Rescale\+Gamma}}}]{rescale\+Gamma,  }\item[{Rescale\+Mode}]{rescale\+Mode,  }\item[{\mbox{\hyperlink{class_sk_surface_a238d34561a4e6ac34b037135cff08555}{Read\+Pixels\+Callback}}}]{callback,  }\item[{\mbox{\hyperlink{class_sk_surface_af503b9dfb01853ec8baf91953d750d20}{Read\+Pixels\+Context}}}]{context }\end{DoxyParamCaption})}

Similar to async\+Rescale\+And\+Read\+Pixels but performs an additional conversion to Y\+UV. The R\+G\+B-\/$>$Y\+UV conversion is controlled by \textquotesingle{}yuv\+Color\+Space\textquotesingle{}. The Y\+UV data is returned as three planes ordered y, u, v. The u and v planes are half the width and height of the resized rectangle. The y, u, and v values are single bytes. Currently this fails if \textquotesingle{}dst\+Size\textquotesingle{} width and height are not even. A \textquotesingle{}src\+Rect\textquotesingle{} that is not contained by the bounds of the surface causes failure.

When the pixel data is ready the caller\textquotesingle{}s Read\+Pixels\+Callback is called with a Async\+Read\+Result containing the planar data. The Async\+Read\+Result will have count() == 3. Upon failure the callback is called with nullptr for Async\+Read\+Result. For a G\+PU surface this flushes work but a submit must occur to guarantee a finite time before the callback is called.

The data is valid for the lifetime of Async\+Read\+Result with the exception that if the \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is G\+P\+U-\/backed the data is immediately invalidated if the context is abandoned or destroyed.


\begin{DoxyParams}{Parameters}
{\em yuv\+Color\+Space} & The transformation from R\+GB to Y\+UV. Applied to the resized image after it is converted to dst\+Color\+Space. \\
\hline
{\em dst\+Color\+Space} & The color space to convert the resized image to, after rescaling. \\
\hline
{\em src\+Rect} & The portion of the surface to rescale and convert to Y\+UV planes. \\
\hline
{\em dst\+Size} & The size to rescale src\+Rect to \\
\hline
{\em rescale\+Gamma} & controls whether rescaling is done in the surface\textquotesingle{}s gamma or whether the source data is transformed to a linear gamma before rescaling. \\
\hline
{\em rescale\+Mode} & controls the sampling technique of the rescaling \\
\hline
{\em callback} & function to call with the planar read result \\
\hline
{\em context} & passed to callback \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_surface_a0ffe89cb0d9217a40223e0d37abd28b0}\label{class_sk_surface_a0ffe89cb0d9217a40223e0d37abd28b0}} 
\index{SkSurface@{SkSurface}!characterize@{characterize}}
\index{characterize@{characterize}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{characterize()}{characterize()}}
{\footnotesize\ttfamily bool Sk\+Surface\+::characterize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_surface_characterization}{Sk\+Surface\+Characterization}} $\ast$}]{characterization }\end{DoxyParamCaption}) const}

Initializes \mbox{\hyperlink{class_sk_surface_characterization}{Sk\+Surface\+Characterization}} that can be used to perform G\+PU back-\/end processing in a separate thread. Typically this is used to divide drawing into multiple tiles. \mbox{\hyperlink{class_sk_deferred_display_list_recorder}{Sk\+Deferred\+Display\+List\+Recorder}} records the drawing commands for each tile.

Return true if \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} supports characterization. raster surface returns false.


\begin{DoxyParams}{Parameters}
{\em characterization} & properties for parallel drawing \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if supported
\end{DoxyReturn}
example\+: \href{https://fiddle.skia.org/c/@Surface_characterize}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Surface\+\_\+characterize}} \mbox{\Hypertarget{class_sk_surface_aa135fac4a1536ef0885b0279eb7382c7}\label{class_sk_surface_aa135fac4a1536ef0885b0279eb7382c7}} 
\index{SkSurface@{SkSurface}!draw@{draw}}
\index{draw@{draw}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{draw()}{draw()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily bool Sk\+Surface\+::draw (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ const \mbox{\hyperlink{class_sk_deferred_display_list}{Sk\+Deferred\+Display\+List}} $>$}]{deferred\+Display\+List,  }\item[{int}]{x\+Offset = {\ttfamily 0},  }\item[{int}]{y\+Offset = {\ttfamily 0} }\end{DoxyParamCaption})}

Draws the deferred display list created via a \mbox{\hyperlink{class_sk_deferred_display_list_recorder}{Sk\+Deferred\+Display\+List\+Recorder}}. If the deferred display list is not compatible with this \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}, the draw is skipped and false is return.

The x\+Offset and y\+Offset parameters are experimental and, if not both zero, will cause the draw to be ignored. When implemented, if x\+Offset or y\+Offset are non-\/zero, the D\+DL will be drawn offset by that amount into the surface.


\begin{DoxyParams}{Parameters}
{\em deferred\+Display\+List} & drawing commands \\
\hline
{\em x\+Offset} & x-\/offset at which to draw the D\+DL \\
\hline
{\em y\+Offset} & y-\/offset at which to draw the D\+DL \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
false if deferred\+Display\+List is not compatible
\end{DoxyReturn}
example\+: \href{https://fiddle.skia.org/c/@Surface_draw_2}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Surface\+\_\+draw\+\_\+2}} \mbox{\Hypertarget{class_sk_surface_a6df6eac244797f29fedd501ce66e4b8c}\label{class_sk_surface_a6df6eac244797f29fedd501ce66e4b8c}} 
\index{SkSurface@{SkSurface}!draw@{draw}}
\index{draw@{draw}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{draw()}{draw()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Sk\+Surface\+::draw (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} $\ast$}]{canvas,  }\item[{Sk\+Scalar}]{x,  }\item[{Sk\+Scalar}]{y,  }\item[{const \mbox{\hyperlink{struct_sk_sampling_options}{Sk\+Sampling\+Options}} \&}]{sampling,  }\item[{const \mbox{\hyperlink{class_sk_paint}{Sk\+Paint}} $\ast$}]{paint }\end{DoxyParamCaption})}

Draws \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} contents to canvas, with its top-\/left corner at (x, y).

If \mbox{\hyperlink{class_sk_paint}{Sk\+Paint}} paint is not nullptr, apply \mbox{\hyperlink{class_sk_color_filter}{Sk\+Color\+Filter}}, alpha, \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}, and Sk\+Blend\+Mode.


\begin{DoxyParams}{Parameters}
{\em canvas} & \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} drawn into \\
\hline
{\em x} & horizontal offset in \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} \\
\hline
{\em y} & vertical offset in \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} \\
\hline
{\em sampling} & what technique to use when sampling the surface pixels \\
\hline
{\em paint} & \mbox{\hyperlink{class_sk_paint}{Sk\+Paint}} containing Sk\+Blend\+Mode, \mbox{\hyperlink{class_sk_color_filter}{Sk\+Color\+Filter}}, \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}, and so on; or nullptr\\
\hline
\end{DoxyParams}
example\+: \href{https://fiddle.skia.org/c/@Surface_draw}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Surface\+\_\+draw}} \mbox{\Hypertarget{class_sk_surface_ac63598d1fc23ac43eb4e39ae330fb7af}\label{class_sk_surface_ac63598d1fc23ac43eb4e39ae330fb7af}} 
\index{SkSurface@{SkSurface}!flush@{flush}}
\index{flush@{flush}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{flush()}{flush()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily Gr\+Semaphores\+Submitted Sk\+Surface\+::flush (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_surface_acfaaa14115fc8fcb3e6074e3d9240c21}{Backend\+Surface\+Access}}}]{access,  }\item[{const \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}} \&}]{info }\end{DoxyParamCaption})}

Issues pending \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} commands to the G\+P\+U-\/backed A\+PI objects and resolves any \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} M\+S\+AA. A call to \mbox{\hyperlink{class_gr_direct_context_a2e6391e15ee021f864a9d4fbef930732}{Gr\+Direct\+Context\+::submit}} is always required to ensure work is actually sent to the gpu. Some specific A\+PI details\+: GL\+: Commands are actually sent to the driver, but gl\+Flush is never called. Thus some sync objects from the flush will not be valid until a submission occurs.

Vulkan/\+Metal/\+D3\+D/\+Dawn\+: Commands are recorded to the backend A\+P\+Is corresponding command buffer or encoder objects. However, these objects are not sent to the gpu until a submission occurs.

The work that is submitted to the G\+PU will be dependent on the Backend\+Surface\+Access that is passed in.

If \mbox{\hyperlink{class_sk_surface_acfaaa14115fc8fcb3e6074e3d9240c21af5d6f15f85f8db76149a52e2f4a2aa70}{Backend\+Surface\+Access\+::k\+No\+Access}} is passed in all commands will be issued to the G\+PU.

If \mbox{\hyperlink{class_sk_surface_acfaaa14115fc8fcb3e6074e3d9240c21a019665dfbd21bc633282967ea7b6d5b8}{Backend\+Surface\+Access\+::k\+Present}} is passed in and the backend A\+PI is not Vulkan, it is treated the same as k\+No\+Access. If the backend A\+PI is Vulkan, the Vk\+Image that backs the \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} will be transferred back to its original queue. If the \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} was created by wrapping a Vk\+Image, the queue will be set to the queue which was originally passed in on the \mbox{\hyperlink{struct_gr_vk_image_info}{Gr\+Vk\+Image\+Info}}. Additionally, if the original queue was not external or foreign the layout of the Vk\+Image will be set to V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+P\+R\+E\+S\+E\+N\+T\+\_\+\+S\+R\+C\+\_\+\+K\+HR.

The \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}} describes additional options to flush. Please see documentation at \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}} for more info.

If the return is Gr\+Semaphores\+Submitted\+::k\+Yes, only initialized Gr\+Backend\+Semaphores will be submitted to the gpu during the next submit call (it is possible Skia failed to create a subset of the semaphores). The client should not wait on these semaphores until after submit has been called, but must keep them alive until then. If a submit flag was passed in with the flush these valid semaphores can we waited on immediately. If this call returns Gr\+Semaphores\+Submitted\+::k\+No, the G\+PU backend will not submit any semaphores to be signaled on the G\+PU. Thus the client should not have the G\+PU wait on any of the semaphores passed in with the \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}}. Regardless of whether semaphores were submitted to the G\+PU or not, the client is still responsible for deleting any initialized semaphores. Regardleess of semaphore submission the context will still be flushed. It should be emphasized that a return value of Gr\+Semaphores\+Submitted\+::k\+No does not mean the flush did not happen. It simply means there were no semaphores submitted to the G\+PU. A caller should only take this as a failure if they passed in semaphores to be submitted.

Pending surface commands are flushed regardless of the return result.


\begin{DoxyParams}{Parameters}
{\em access} & type of access the call will do on the backend object after flush \\
\hline
{\em info} & flush options \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_surface_a7e98a032ac0291743ad97a3b54db6b22}\label{class_sk_surface_a7e98a032ac0291743ad97a3b54db6b22}} 
\index{SkSurface@{SkSurface}!flush@{flush}}
\index{flush@{flush}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{flush()}{flush()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily Gr\+Semaphores\+Submitted Sk\+Surface\+::flush (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}} \&}]{info,  }\item[{const \mbox{\hyperlink{class_gr_backend_surface_mutable_state}{Gr\+Backend\+Surface\+Mutable\+State}} $\ast$}]{new\+State = {\ttfamily nullptr} }\end{DoxyParamCaption})}

Issues pending \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} commands to the G\+P\+U-\/backed A\+PI objects and resolves any \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} M\+S\+AA. A call to \mbox{\hyperlink{class_gr_direct_context_a2e6391e15ee021f864a9d4fbef930732}{Gr\+Direct\+Context\+::submit}} is always required to ensure work is actually sent to the gpu. Some specific A\+PI details\+: GL\+: Commands are actually sent to the driver, but gl\+Flush is never called. Thus some sync objects from the flush will not be valid until a submission occurs.

Vulkan/\+Metal/\+D3\+D/\+Dawn\+: Commands are recorded to the backend A\+P\+Is corresponding command buffer or encoder objects. However, these objects are not sent to the gpu until a submission occurs.

The \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}} describes additional options to flush. Please see documentation at \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}} for more info.

If a \mbox{\hyperlink{class_gr_backend_surface_mutable_state}{Gr\+Backend\+Surface\+Mutable\+State}} is passed in, at the end of the flush we will transition the surface to be in the state requested by the \mbox{\hyperlink{class_gr_backend_surface_mutable_state}{Gr\+Backend\+Surface\+Mutable\+State}}. If the surface (or \mbox{\hyperlink{class_sk_image}{Sk\+Image}} or Gr\+Backend\+Surface wrapping the same backend object) is used again after this flush the state may be changed and no longer match what is requested here. This is often used if the surface will be used for presenting or external use and the client wants backend object to be prepped for that use. A finished\+Proc or semaphore on the \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}} will also include the work for any requested state change.

If the backend A\+PI is Vulkan, the caller can set the \mbox{\hyperlink{class_gr_backend_surface_mutable_state}{Gr\+Backend\+Surface\+Mutable\+State}}\textquotesingle{}s Vk\+Image\+Layout to V\+K\+\_\+\+I\+M\+A\+G\+E\+\_\+\+L\+A\+Y\+O\+U\+T\+\_\+\+U\+N\+D\+E\+F\+I\+N\+ED or queue\+Family\+Index to V\+K\+\_\+\+Q\+U\+E\+U\+E\+\_\+\+F\+A\+M\+I\+L\+Y\+\_\+\+I\+G\+N\+O\+R\+ED to tell Skia to not change those respective states.

If the return is Gr\+Semaphores\+Submitted\+::k\+Yes, only initialized Gr\+Backend\+Semaphores will be submitted to the gpu during the next submit call (it is possible Skia failed to create a subset of the semaphores). The client should not wait on these semaphores until after submit has been called, but must keep them alive until then. If a submit flag was passed in with the flush these valid semaphores can we waited on immediately. If this call returns Gr\+Semaphores\+Submitted\+::k\+No, the G\+PU backend will not submit any semaphores to be signaled on the G\+PU. Thus the client should not have the G\+PU wait on any of the semaphores passed in with the \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}}. Regardless of whether semaphores were submitted to the G\+PU or not, the client is still responsible for deleting any initialized semaphores. Regardleess of semaphore submission the context will still be flushed. It should be emphasized that a return value of Gr\+Semaphores\+Submitted\+::k\+No does not mean the flush did not happen. It simply means there were no semaphores submitted to the G\+PU. A caller should only take this as a failure if they passed in semaphores to be submitted.

Pending surface commands are flushed regardless of the return result.


\begin{DoxyParams}{Parameters}
{\em info} & flush options \\
\hline
{\em access} & optional state change request after flush \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_surface_a0b204d1ac715f3c6efe29ed4576517ec}\label{class_sk_surface_a0b204d1ac715f3c6efe29ed4576517ec}} 
\index{SkSurface@{SkSurface}!flushAndSubmit@{flushAndSubmit}}
\index{flushAndSubmit@{flushAndSubmit}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{flushAndSubmit()}{flushAndSubmit()}}
{\footnotesize\ttfamily void Sk\+Surface\+::flush\+And\+Submit (\begin{DoxyParamCaption}\item[{bool}]{sync\+Cpu = {\ttfamily false} }\end{DoxyParamCaption})}

Call to ensure all reads/writes of the surface have been issued to the underlying 3D A\+PI. Skia will correctly order its own draws and pixel operations. This must to be used to ensure correct ordering when the surface backing store is accessed outside Skia (e.\+g. direct use of the 3D A\+PI or a windowing system). \mbox{\hyperlink{class_gr_direct_context}{Gr\+Direct\+Context}} has additional flush and submit methods that apply to all surfaces and images created from a \mbox{\hyperlink{class_gr_direct_context}{Gr\+Direct\+Context}}. This is equivalent to calling \mbox{\hyperlink{class_sk_surface_ac63598d1fc23ac43eb4e39ae330fb7af}{Sk\+Surface\+::flush}} with a default \mbox{\hyperlink{struct_gr_flush_info}{Gr\+Flush\+Info}} followed by Gr\+Direct\+Context\+::submit(sync\+Cpu). \mbox{\Hypertarget{class_sk_surface_af977ef6c5da6bc9b95747e5961672433}\label{class_sk_surface_af977ef6c5da6bc9b95747e5961672433}} 
\index{SkSurface@{SkSurface}!generationID@{generationID}}
\index{generationID@{generationID}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{generationID()}{generationID()}}
{\footnotesize\ttfamily uint32\+\_\+t Sk\+Surface\+::generation\+ID (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns unique value identifying the content of \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}. Returned value changes each time the content changes. Content is changed by drawing, or by calling \mbox{\hyperlink{class_sk_surface_ae577c5cac83c670f87c51eddab87aa9f}{notify\+Content\+Will\+Change()}}.

\begin{DoxyReturn}{Returns}
unique content identifier
\end{DoxyReturn}
example\+: \href{https://fiddle.skia.org/c/@Surface_notifyContentWillChange}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Surface\+\_\+notify\+Content\+Will\+Change}} \mbox{\Hypertarget{class_sk_surface_a38e996e7dafe610f933830c22196eff1}\label{class_sk_surface_a38e996e7dafe610f933830c22196eff1}} 
\index{SkSurface@{SkSurface}!getBackendRenderTarget@{getBackendRenderTarget}}
\index{getBackendRenderTarget@{getBackendRenderTarget}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{getBackendRenderTarget()}{getBackendRenderTarget()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_gr_backend_render_target}{Gr\+Backend\+Render\+Target}} Sk\+Surface\+::get\+Backend\+Render\+Target (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209}{Backend\+Handle\+Access}}}]{backend\+Handle\+Access }\end{DoxyParamCaption})}

Retrieves the back-\/end render target. If \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} has no back-\/end render target, an invalid object is returned. Call Gr\+Backend\+Render\+Target\+::is\+Valid to determine if the result is valid.

The returned \mbox{\hyperlink{class_gr_backend_render_target}{Gr\+Backend\+Render\+Target}} should be discarded if the \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is drawn to or deleted.

\begin{DoxyReturn}{Returns}
G\+PU render target reference; invalid on failure 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_a285a711149f69823597c3763eab03dd1}\label{class_sk_surface_a285a711149f69823597c3763eab03dd1}} 
\index{SkSurface@{SkSurface}!getBackendTexture@{getBackendTexture}}
\index{getBackendTexture@{getBackendTexture}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{getBackendTexture()}{getBackendTexture()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} Sk\+Surface\+::get\+Backend\+Texture (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209}{Backend\+Handle\+Access}}}]{backend\+Handle\+Access }\end{DoxyParamCaption})}

Retrieves the back-\/end texture. If \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} has no back-\/end texture, an invalid object is returned. Call Gr\+Backend\+Texture\+::is\+Valid to determine if the result is valid.

The returned \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} should be discarded if the \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is drawn to or deleted.

\begin{DoxyReturn}{Returns}
G\+PU texture reference; invalid on failure 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_aedab202bc98dad9a0d089b85274435aa}\label{class_sk_surface_aedab202bc98dad9a0d089b85274435aa}} 
\index{SkSurface@{SkSurface}!getCanvas@{getCanvas}}
\index{getCanvas@{getCanvas}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{getCanvas()}{getCanvas()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}}$\ast$ Sk\+Surface\+::get\+Canvas (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} that draws into \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}. Subsequent calls return the same \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}}. \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} returned is managed and owned by \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}, and is deleted when \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is deleted.

\begin{DoxyReturn}{Returns}
drawing \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} for \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}
\end{DoxyReturn}
example\+: \href{https://fiddle.skia.org/c/@Surface_getCanvas}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Surface\+\_\+get\+Canvas}} \mbox{\Hypertarget{class_sk_surface_aa30771352bbeb37532669127fa16494e}\label{class_sk_surface_aa30771352bbeb37532669127fa16494e}} 
\index{SkSurface@{SkSurface}!height@{height}}
\index{height@{height}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{height()}{height()}}
{\footnotesize\ttfamily int Sk\+Surface\+::height (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns pixel row count; may be zero or greater.

\begin{DoxyReturn}{Returns}
number of pixel rows 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_a2f86fa89d5cf1706c31d10c8845c2000}\label{class_sk_surface_a2f86fa89d5cf1706c31d10c8845c2000}} 
\index{SkSurface@{SkSurface}!imageInfo@{imageInfo}}
\index{imageInfo@{imageInfo}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{imageInfo()}{imageInfo()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} Sk\+Surface\+::image\+Info (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns an Image\+Info describing the surface. \mbox{\Hypertarget{class_sk_surface_a68f8dfb17ce83f40180acefb844c6352}\label{class_sk_surface_a68f8dfb17ce83f40180acefb844c6352}} 
\index{SkSurface@{SkSurface}!isCompatible@{isCompatible}}
\index{isCompatible@{isCompatible}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{isCompatible()}{isCompatible()}}
{\footnotesize\ttfamily bool Sk\+Surface\+::is\+Compatible (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_surface_characterization}{Sk\+Surface\+Characterization}} \&}]{characterization }\end{DoxyParamCaption}) const}

Is this surface compatible with the provided characterization?

This method can be used to determine if an existing \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is a viable destination for an \mbox{\hyperlink{class_sk_deferred_display_list}{Sk\+Deferred\+Display\+List}}.


\begin{DoxyParams}{Parameters}
{\em characterization} & The characterization for which a compatibility check is desired \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if this surface is compatible with the characterization; false otherwise 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_a5e5ba93640ce8e65a7cb401d5554e84c}\label{class_sk_surface_a5e5ba93640ce8e65a7cb401d5554e84c}} 
\index{SkSurface@{SkSurface}!MakeFromBackendRenderTarget@{MakeFromBackendRenderTarget}}
\index{MakeFromBackendRenderTarget@{MakeFromBackendRenderTarget}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{MakeFromBackendRenderTarget()}{MakeFromBackendRenderTarget()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}$>$ Sk\+Surface\+::\+Make\+From\+Backend\+Render\+Target (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_gr_recording_context}{Gr\+Recording\+Context}} $\ast$}]{context,  }\item[{const \mbox{\hyperlink{class_gr_backend_render_target}{Gr\+Backend\+Render\+Target}} \&}]{backend\+Render\+Target,  }\item[{Gr\+Surface\+Origin}]{origin,  }\item[{Sk\+Color\+Type}]{color\+Type,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$}]{color\+Space,  }\item[{const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$}]{surface\+Props,  }\item[{\mbox{\hyperlink{class_sk_surface_a45233f6282af6774d6175485cc327e0c}{Render\+Target\+Release\+Proc}}}]{release\+Proc = {\ttfamily nullptr},  }\item[{\mbox{\hyperlink{class_sk_surface_ae91b4f130cbb53ecde3a1d9261eadc54}{Release\+Context}}}]{release\+Context = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Wraps a G\+P\+U-\/backed buffer into \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}. Caller must ensure backend\+Render\+Target is valid for the lifetime of returned \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}.

\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is returned if all parameters are valid. backend\+Render\+Target is valid if its pixel configuration agrees with color\+Space and context; for instance, if backend\+Render\+Target has an s\+R\+GB configuration, then context must support s\+R\+GB, and color\+Space must be present. Further, backend\+Render\+Target width and height must not exceed context capabilities, and the context must be able to support back-\/end render targets.

Upon success release\+Proc is called when it is safe to delete the render target in the backend A\+PI (accounting only for use of the render target by this surface). If \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} creation fails release\+Proc is called before this function returns.

If S\+K\+\_\+\+S\+U\+P\+P\+O\+R\+T\+\_\+\+G\+PU is defined as zero, has no effect and returns nullptr.


\begin{DoxyParams}{Parameters}
{\em context} & G\+PU context \\
\hline
{\em backend\+Render\+Target} & G\+PU intermediate memory buffer \\
\hline
{\em color\+Space} & range of colors \\
\hline
{\em surface\+Props} & L\+CD striping orientation and setting for device independent fonts; may be nullptr \\
\hline
{\em release\+Proc} & function called when backend\+Render\+Target can be released \\
\hline
{\em release\+Context} & state passed to release\+Proc \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} if all parameters are valid; otherwise, nullptr 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_a71d1d58f5e13f77d94697d6e408cdfad}\label{class_sk_surface_a71d1d58f5e13f77d94697d6e408cdfad}} 
\index{SkSurface@{SkSurface}!MakeFromBackendTexture@{MakeFromBackendTexture}}
\index{MakeFromBackendTexture@{MakeFromBackendTexture}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{MakeFromBackendTexture()}{MakeFromBackendTexture()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}$>$ Sk\+Surface\+::\+Make\+From\+Backend\+Texture (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_gr_recording_context}{Gr\+Recording\+Context}} $\ast$}]{context,  }\item[{const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&}]{backend\+Texture,  }\item[{Gr\+Surface\+Origin}]{origin,  }\item[{int}]{sample\+Cnt,  }\item[{Sk\+Color\+Type}]{color\+Type,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$}]{color\+Space,  }\item[{const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$}]{surface\+Props,  }\item[{\mbox{\hyperlink{class_sk_surface_a0e552eaf3124ef4e6fbb3490b321ea60}{Texture\+Release\+Proc}}}]{texture\+Release\+Proc = {\ttfamily nullptr},  }\item[{\mbox{\hyperlink{class_sk_surface_ae91b4f130cbb53ecde3a1d9261eadc54}{Release\+Context}}}]{release\+Context = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Wraps a G\+P\+U-\/backed texture into \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}. Caller must ensure the texture is valid for the lifetime of returned \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}. If sample\+Cnt greater than zero, creates an intermediate M\+S\+AA \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} which is used for drawing backend\+Texture.

\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is returned if all parameters are valid. backend\+Texture is valid if its pixel configuration agrees with color\+Space and context; for instance, if backend\+Texture has an s\+R\+GB configuration, then context must support s\+R\+GB, and color\+Space must be present. Further, backend\+Texture width and height must not exceed context capabilities, and the context must be able to support back-\/end textures.

Upon success texture\+Release\+Proc is called when it is safe to delete the texture in the backend A\+PI (accounting only for use of the texture by this surface). If \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} creation fails texture\+Release\+Proc is called before this function returns.

If S\+K\+\_\+\+S\+U\+P\+P\+O\+R\+T\+\_\+\+G\+PU is defined as zero, has no effect and returns nullptr.


\begin{DoxyParams}{Parameters}
{\em context} & G\+PU context \\
\hline
{\em backend\+Texture} & texture residing on G\+PU \\
\hline
{\em sample\+Cnt} & samples per pixel, or 0 to disable full scene anti-\/aliasing \\
\hline
{\em color\+Space} & range of colors; may be nullptr \\
\hline
{\em surface\+Props} & L\+CD striping orientation and setting for device independent fonts; may be nullptr \\
\hline
{\em texture\+Release\+Proc} & function called when texture can be released \\
\hline
{\em release\+Context} & state passed to texture\+Release\+Proc \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} if all parameters are valid; otherwise, nullptr 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_a9e0831e582fff299df12786801fbd2bf}\label{class_sk_surface_a9e0831e582fff299df12786801fbd2bf}} 
\index{SkSurface@{SkSurface}!makeImageSnapshot@{makeImageSnapshot}}
\index{makeImageSnapshot@{makeImageSnapshot}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{makeImageSnapshot()}{makeImageSnapshot()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image}{Sk\+Image}}$>$ Sk\+Surface\+::make\+Image\+Snapshot (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns \mbox{\hyperlink{class_sk_image}{Sk\+Image}} capturing \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} contents. Subsequent drawing to \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} contents are not captured. \mbox{\hyperlink{class_sk_image}{Sk\+Image}} allocation is accounted for if \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} was created with Sk\+Budgeted\+::k\+Yes.

\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_sk_image}{Sk\+Image}} initialized with \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} contents
\end{DoxyReturn}
example\+: \href{https://fiddle.skia.org/c/@Surface_makeImageSnapshot}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Surface\+\_\+make\+Image\+Snapshot}} \mbox{\Hypertarget{class_sk_surface_af6b4058c4d8708cae31993d41f7c377f}\label{class_sk_surface_af6b4058c4d8708cae31993d41f7c377f}} 
\index{SkSurface@{SkSurface}!makeImageSnapshot@{makeImageSnapshot}}
\index{makeImageSnapshot@{makeImageSnapshot}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{makeImageSnapshot()}{makeImageSnapshot()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image}{Sk\+Image}}$>$ Sk\+Surface\+::make\+Image\+Snapshot (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} \&}]{bounds }\end{DoxyParamCaption})}

Like the no-\/parameter version, this returns an image of the current surface contents. This variant takes a rectangle specifying the subset of the surface that is of interest. These bounds will be sanitized before being used.
\begin{DoxyItemize}
\item If bounds extends beyond the surface, it will be trimmed to just the intersection of it and the surface.
\item If bounds does not intersect the surface, then this returns nullptr.
\item If bounds == the surface, then this is the same as calling the no-\/parameter variant.
\end{DoxyItemize}

example\+: \href{https://fiddle.skia.org/c/@Surface_makeImageSnapshot_2}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Surface\+\_\+make\+Image\+Snapshot\+\_\+2}} \mbox{\Hypertarget{class_sk_surface_a8eed158c914df86a8855919974421a3f}\label{class_sk_surface_a8eed158c914df86a8855919974421a3f}} 
\index{SkSurface@{SkSurface}!MakeNull@{MakeNull}}
\index{MakeNull@{MakeNull}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{MakeNull()}{MakeNull()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}$>$ Sk\+Surface\+::\+Make\+Null (\begin{DoxyParamCaption}\item[{int}]{width,  }\item[{int}]{height }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} without backing pixels. Drawing to \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} returned from \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} has no effect. Calling \mbox{\hyperlink{class_sk_surface_a9e0831e582fff299df12786801fbd2bf}{make\+Image\+Snapshot()}} on returned \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} returns nullptr.


\begin{DoxyParams}{Parameters}
{\em width} & one or greater \\
\hline
{\em height} & one or greater \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} if width and height are positive; otherwise, nullptr
\end{DoxyReturn}
example\+: \href{https://fiddle.skia.org/c/@Surface_MakeNull}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Surface\+\_\+\+Make\+Null}} \mbox{\Hypertarget{class_sk_surface_a99b9671ebd493fdb8185e118d7691c50}\label{class_sk_surface_a99b9671ebd493fdb8185e118d7691c50}} 
\index{SkSurface@{SkSurface}!MakeRaster@{MakeRaster}}
\index{MakeRaster@{MakeRaster}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{MakeRaster()}{MakeRaster()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}$>$ Sk\+Surface\+::\+Make\+Raster (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{image\+Info,  }\item[{const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$}]{props = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Allocates raster \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}. \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} returned by \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} draws directly into pixels. Allocates and zeroes pixel memory. \mbox{\hyperlink{struct_pixel}{Pixel}} memory size is image\+Info.\+height() times image\+Info.\+min\+Row\+Bytes(). \mbox{\hyperlink{struct_pixel}{Pixel}} memory is deleted when \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is deleted.

\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is returned if all parameters are valid. Valid parameters include\+: info dimensions are greater than zero; info contains Sk\+Color\+Type and Sk\+Alpha\+Type supported by raster surface.


\begin{DoxyParams}{Parameters}
{\em image\+Info} & width, height, Sk\+Color\+Type, Sk\+Alpha\+Type, \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}}, of raster surface; width and height must be greater than zero \\
\hline
{\em props} & L\+CD striping orientation and setting for device independent fonts; may be nullptr \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} if all parameters are valid; otherwise, nullptr 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_ae4ed88112b3622f7a7474e9e2b771004}\label{class_sk_surface_ae4ed88112b3622f7a7474e9e2b771004}} 
\index{SkSurface@{SkSurface}!MakeRaster@{MakeRaster}}
\index{MakeRaster@{MakeRaster}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{MakeRaster()}{MakeRaster()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}$>$ Sk\+Surface\+::\+Make\+Raster (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{image\+Info,  }\item[{size\+\_\+t}]{row\+Bytes,  }\item[{const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$}]{surface\+Props }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Allocates raster \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}. \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} returned by \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} draws directly into pixels. Allocates and zeroes pixel memory. \mbox{\hyperlink{struct_pixel}{Pixel}} memory size is image\+Info.\+height() times row\+Bytes, or times image\+Info.\+min\+Row\+Bytes() if row\+Bytes is zero. \mbox{\hyperlink{struct_pixel}{Pixel}} memory is deleted when \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is deleted.

\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is returned if all parameters are valid. Valid parameters include\+: info dimensions are greater than zero; info contains Sk\+Color\+Type and Sk\+Alpha\+Type supported by raster surface; row\+Bytes is large enough to contain info width pixels of Sk\+Color\+Type, or is zero.

If row\+Bytes is zero, a suitable value will be chosen internally.


\begin{DoxyParams}{Parameters}
{\em image\+Info} & width, height, Sk\+Color\+Type, Sk\+Alpha\+Type, \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}}, of raster surface; width and height must be greater than zero \\
\hline
{\em row\+Bytes} & interval from one \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} row to the next; may be zero \\
\hline
{\em surface\+Props} & L\+CD striping orientation and setting for device independent fonts; may be nullptr \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} if all parameters are valid; otherwise, nullptr 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_af025ece3e61fea154e5bc303f76e78b1}\label{class_sk_surface_af025ece3e61fea154e5bc303f76e78b1}} 
\index{SkSurface@{SkSurface}!MakeRasterDirect@{MakeRasterDirect}}
\index{MakeRasterDirect@{MakeRasterDirect}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{MakeRasterDirect()}{MakeRasterDirect()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}$>$ Sk\+Surface\+::\+Make\+Raster\+Direct (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{image\+Info,  }\item[{void $\ast$}]{pixels,  }\item[{size\+\_\+t}]{row\+Bytes,  }\item[{const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$}]{surface\+Props = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Allocates raster \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}. \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} returned by \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} draws directly into pixels.

\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is returned if all parameters are valid. Valid parameters include\+: info dimensions are greater than zero; info contains Sk\+Color\+Type and Sk\+Alpha\+Type supported by raster surface; pixels is not nullptr; row\+Bytes is large enough to contain info width pixels of Sk\+Color\+Type.

\mbox{\hyperlink{struct_pixel}{Pixel}} buffer size should be info height times computed row\+Bytes. Pixels are not initialized. To access pixels after drawing, \mbox{\hyperlink{class_sk_surface_a8de5913a3bca21fccd77e92755b26432}{peek\+Pixels()}} or \mbox{\hyperlink{class_sk_surface_af3fe3696a898f644c0b3136d94771588}{read\+Pixels()}}.


\begin{DoxyParams}{Parameters}
{\em image\+Info} & width, height, Sk\+Color\+Type, Sk\+Alpha\+Type, \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}}, of raster surface; width and height must be greater than zero \\
\hline
{\em pixels} & pointer to destination pixels buffer \\
\hline
{\em row\+Bytes} & interval from one \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} row to the next \\
\hline
{\em surface\+Props} & L\+CD striping orientation and setting for device independent fonts; may be nullptr \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} if all parameters are valid; otherwise, nullptr 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_aa000cb9fdcb3b5ec5bf92408fd0df3a0}\label{class_sk_surface_aa000cb9fdcb3b5ec5bf92408fd0df3a0}} 
\index{SkSurface@{SkSurface}!MakeRasterDirectReleaseProc@{MakeRasterDirectReleaseProc}}
\index{MakeRasterDirectReleaseProc@{MakeRasterDirectReleaseProc}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{MakeRasterDirectReleaseProc()}{MakeRasterDirectReleaseProc()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}$>$ Sk\+Surface\+::\+Make\+Raster\+Direct\+Release\+Proc (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{image\+Info,  }\item[{void $\ast$}]{pixels,  }\item[{size\+\_\+t}]{row\+Bytes,  }\item[{void($\ast$)(void $\ast$pixels, void $\ast$context)}]{release\+Proc,  }\item[{void $\ast$}]{context,  }\item[{const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$}]{surface\+Props = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Allocates raster \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}. \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} returned by \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} draws directly into pixels. release\+Proc is called with pixels and context when \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is deleted.

\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is returned if all parameters are valid. Valid parameters include\+: info dimensions are greater than zero; info contains Sk\+Color\+Type and Sk\+Alpha\+Type supported by raster surface; pixels is not nullptr; row\+Bytes is large enough to contain info width pixels of Sk\+Color\+Type.

\mbox{\hyperlink{struct_pixel}{Pixel}} buffer size should be info height times computed row\+Bytes. Pixels are not initialized. To access pixels after drawing, call flush() or \mbox{\hyperlink{class_sk_surface_a8de5913a3bca21fccd77e92755b26432}{peek\+Pixels()}}.


\begin{DoxyParams}{Parameters}
{\em image\+Info} & width, height, Sk\+Color\+Type, Sk\+Alpha\+Type, \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}}, of raster surface; width and height must be greater than zero \\
\hline
{\em pixels} & pointer to destination pixels buffer \\
\hline
{\em row\+Bytes} & interval from one \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} row to the next \\
\hline
{\em release\+Proc} & called when \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is deleted; may be nullptr \\
\hline
{\em context} & passed to release\+Proc; may be nullptr \\
\hline
{\em surface\+Props} & L\+CD striping orientation and setting for device independent fonts; may be nullptr \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} if all parameters are valid; otherwise, nullptr 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_a8ac34d6cf6f05d76db8d27b3e811e01c}\label{class_sk_surface_a8ac34d6cf6f05d76db8d27b3e811e01c}} 
\index{SkSurface@{SkSurface}!MakeRasterN32Premul@{MakeRasterN32Premul}}
\index{MakeRasterN32Premul@{MakeRasterN32Premul}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{MakeRasterN32Premul()}{MakeRasterN32Premul()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}$>$ Sk\+Surface\+::\+Make\+Raster\+N32\+Premul (\begin{DoxyParamCaption}\item[{int}]{width,  }\item[{int}]{height,  }\item[{const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$}]{surface\+Props = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Allocates raster \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}. \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} returned by \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} draws directly into pixels. Allocates and zeroes pixel memory. \mbox{\hyperlink{struct_pixel}{Pixel}} memory size is height times width times four. \mbox{\hyperlink{struct_pixel}{Pixel}} memory is deleted when \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is deleted.

Internally, sets \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} to width, height, native color type, and k\+Premul\+\_\+\+Sk\+Alpha\+Type.

\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is returned if width and height are greater than zero.

Use to create \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} that matches Sk\+P\+M\+Color, the native pixel arrangement on the platform. \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} drawn to output device skips converting its pixel format.


\begin{DoxyParams}{Parameters}
{\em width} & pixel column count; must be greater than zero \\
\hline
{\em height} & pixel row count; must be greater than zero \\
\hline
{\em surface\+Props} & L\+CD striping orientation and setting for device independent fonts; may be nullptr \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} if all parameters are valid; otherwise, nullptr 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_a13494920609f783f66d3246a6ea26236}\label{class_sk_surface_a13494920609f783f66d3246a6ea26236}} 
\index{SkSurface@{SkSurface}!MakeRenderTarget@{MakeRenderTarget}}
\index{MakeRenderTarget@{MakeRenderTarget}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{MakeRenderTarget()}{MakeRenderTarget()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}$>$ Sk\+Surface\+::\+Make\+Render\+Target (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_gr_recording_context}{Gr\+Recording\+Context}} $\ast$}]{context,  }\item[{const \mbox{\hyperlink{class_sk_surface_characterization}{Sk\+Surface\+Characterization}} \&}]{characterization,  }\item[{\mbox{\hyperlink{_sk_types_8h_a66f73362220ea988583a7980b6634374}{Sk\+Budgeted}}}]{budgeted }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} on G\+PU indicated by context that is compatible with the provided characterization. budgeted selects whether allocation for pixels is tracked by context.


\begin{DoxyParams}{Parameters}
{\em context} & G\+PU context \\
\hline
{\em characterization} & description of the desired \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} if all parameters are valid; otherwise, nullptr 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_ad836deaf72354a6eebe21565e9906f67}\label{class_sk_surface_ad836deaf72354a6eebe21565e9906f67}} 
\index{SkSurface@{SkSurface}!MakeRenderTarget@{MakeRenderTarget}}
\index{MakeRenderTarget@{MakeRenderTarget}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{MakeRenderTarget()}{MakeRenderTarget()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}$>$ Sk\+Surface\+::\+Make\+Render\+Target (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_gr_recording_context}{Gr\+Recording\+Context}} $\ast$}]{context,  }\item[{\mbox{\hyperlink{_sk_types_8h_a66f73362220ea988583a7980b6634374}{Sk\+Budgeted}}}]{budgeted,  }\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{image\+Info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Returns \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} on G\+PU indicated by context. Allocates memory for pixels, based on the width, height, and Sk\+Color\+Type in \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}}. budgeted selects whether allocation for pixels is tracked by context. image\+Info describes the pixel format in Sk\+Color\+Type, and transparency in Sk\+Alpha\+Type, and color matching in \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}}.

\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} bottom-\/left corner is pinned to the origin.


\begin{DoxyParams}{Parameters}
{\em context} & G\+PU context \\
\hline
{\em image\+Info} & width, height, Sk\+Color\+Type, Sk\+Alpha\+Type, \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}}, of raster surface; width, or height, or both, may be zero \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} if all parameters are valid; otherwise, nullptr 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_a71929ad95b166b7b98df684056724e1e}\label{class_sk_surface_a71929ad95b166b7b98df684056724e1e}} 
\index{SkSurface@{SkSurface}!MakeRenderTarget@{MakeRenderTarget}}
\index{MakeRenderTarget@{MakeRenderTarget}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{MakeRenderTarget()}{MakeRenderTarget()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}$>$ Sk\+Surface\+::\+Make\+Render\+Target (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_gr_recording_context}{Gr\+Recording\+Context}} $\ast$}]{context,  }\item[{\mbox{\hyperlink{_sk_types_8h_a66f73362220ea988583a7980b6634374}{Sk\+Budgeted}}}]{budgeted,  }\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{image\+Info,  }\item[{int}]{sample\+Count,  }\item[{const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$}]{surface\+Props }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Returns \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} on G\+PU indicated by context. Allocates memory for pixels, based on the width, height, and Sk\+Color\+Type in \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}}. budgeted selects whether allocation for pixels is tracked by context. image\+Info describes the pixel format in Sk\+Color\+Type, and transparency in Sk\+Alpha\+Type, and color matching in \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}}.

sample\+Count requests the number of samples per pixel. Pass zero to disable multi-\/sample anti-\/aliasing. The request is rounded up to the next supported count, or rounded down if it is larger than the maximum supported count.

\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} bottom-\/left corner is pinned to the origin.


\begin{DoxyParams}{Parameters}
{\em context} & G\+PU context \\
\hline
{\em image\+Info} & width, height, Sk\+Color\+Type, Sk\+Alpha\+Type, \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}}, of raster surface; width, or height, or both, may be zero \\
\hline
{\em sample\+Count} & samples per pixel, or 0 to disable multi-\/sample anti-\/aliasing \\
\hline
{\em surface\+Props} & L\+CD striping orientation and setting for device independent fonts; may be nullptr \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} if all parameters are valid; otherwise, nullptr 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_aa32278bea58b9f229190c45b59f01548}\label{class_sk_surface_aa32278bea58b9f229190c45b59f01548}} 
\index{SkSurface@{SkSurface}!MakeRenderTarget@{MakeRenderTarget}}
\index{MakeRenderTarget@{MakeRenderTarget}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{MakeRenderTarget()}{MakeRenderTarget()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}$>$ Sk\+Surface\+::\+Make\+Render\+Target (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_gr_recording_context}{Gr\+Recording\+Context}} $\ast$}]{context,  }\item[{\mbox{\hyperlink{_sk_types_8h_a66f73362220ea988583a7980b6634374}{Sk\+Budgeted}}}]{budgeted,  }\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{image\+Info,  }\item[{int}]{sample\+Count,  }\item[{Gr\+Surface\+Origin}]{surface\+Origin,  }\item[{const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} $\ast$}]{surface\+Props,  }\item[{bool}]{should\+Create\+With\+Mips = {\ttfamily false} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} on G\+PU indicated by context. Allocates memory for pixels, based on the width, height, and Sk\+Color\+Type in \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}}. budgeted selects whether allocation for pixels is tracked by context. image\+Info describes the pixel format in Sk\+Color\+Type, and transparency in Sk\+Alpha\+Type, and color matching in \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}}.

sample\+Count requests the number of samples per pixel. Pass zero to disable multi-\/sample anti-\/aliasing. The request is rounded up to the next supported count, or rounded down if it is larger than the maximum supported count.

surface\+Origin pins either the top-\/left or the bottom-\/left corner to the origin.

should\+Create\+With\+Mips hints that \mbox{\hyperlink{class_sk_image}{Sk\+Image}} returned by \mbox{\hyperlink{class_sk_surface_a9e0831e582fff299df12786801fbd2bf}{make\+Image\+Snapshot()}} is mip map.

If S\+K\+\_\+\+S\+U\+P\+P\+O\+R\+T\+\_\+\+G\+PU is defined as zero, has no effect and returns nullptr.


\begin{DoxyParams}{Parameters}
{\em context} & G\+PU context \\
\hline
{\em image\+Info} & width, height, Sk\+Color\+Type, Sk\+Alpha\+Type, \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}}; width, or height, or both, may be zero \\
\hline
{\em sample\+Count} & samples per pixel, or 0 to disable full scene anti-\/aliasing \\
\hline
{\em surface\+Props} & L\+CD striping orientation and setting for device independent fonts; may be nullptr \\
\hline
{\em should\+Create\+With\+Mips} & hint that \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} will host mip map images \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} if all parameters are valid; otherwise, nullptr 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_a56ed11229ed16cbb2b9d377deac2ca08}\label{class_sk_surface_a56ed11229ed16cbb2b9d377deac2ca08}} 
\index{SkSurface@{SkSurface}!makeSurface@{makeSurface}}
\index{makeSurface@{makeSurface}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{makeSurface()}{makeSurface()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}$>$ Sk\+Surface\+::make\+Surface (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{image\+Info }\end{DoxyParamCaption})}

Returns a compatible \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}, or nullptr. Returned \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} contains the same raster, G\+PU, or null properties as the original. Returned \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} does not share the same pixels.

Returns nullptr if image\+Info width or height are zero, or if image\+Info is incompatible with \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}.


\begin{DoxyParams}{Parameters}
{\em image\+Info} & width, height, Sk\+Color\+Type, Sk\+Alpha\+Type, \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}}, of \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}; width and height must be greater than zero \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
compatible \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} or nullptr
\end{DoxyReturn}
example\+: \href{https://fiddle.skia.org/c/@Surface_makeSurface}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Surface\+\_\+make\+Surface}} \mbox{\Hypertarget{class_sk_surface_a925f99aeda52481cdedc9bc5e24ea57a}\label{class_sk_surface_a925f99aeda52481cdedc9bc5e24ea57a}} 
\index{SkSurface@{SkSurface}!makeSurface@{makeSurface}}
\index{makeSurface@{makeSurface}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{makeSurface()}{makeSurface()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}$>$ Sk\+Surface\+::make\+Surface (\begin{DoxyParamCaption}\item[{int}]{width,  }\item[{int}]{height }\end{DoxyParamCaption})}

Calls make\+Surface(\+Image\+Info) with the same Image\+Info as this surface, but with the specified width and height. \mbox{\Hypertarget{class_sk_surface_ae577c5cac83c670f87c51eddab87aa9f}\label{class_sk_surface_ae577c5cac83c670f87c51eddab87aa9f}} 
\index{SkSurface@{SkSurface}!notifyContentWillChange@{notifyContentWillChange}}
\index{notifyContentWillChange@{notifyContentWillChange}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{notifyContentWillChange()}{notifyContentWillChange()}}
{\footnotesize\ttfamily void Sk\+Surface\+::notify\+Content\+Will\+Change (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538}{Content\+Change\+Mode}}}]{mode }\end{DoxyParamCaption})}

Notifies that \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} contents will be changed by code outside of Skia. Subsequent calls to \mbox{\hyperlink{class_sk_surface_af977ef6c5da6bc9b95747e5961672433}{generation\+I\+D()}} return a different value.

T\+O\+DO\+: Can k\+Retain\+\_\+\+Content\+Change\+Mode be deprecated?

example\+: \href{https://fiddle.skia.org/c/@Surface_notifyContentWillChange}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Surface\+\_\+notify\+Content\+Will\+Change}} \mbox{\Hypertarget{class_sk_surface_a8de5913a3bca21fccd77e92755b26432}\label{class_sk_surface_a8de5913a3bca21fccd77e92755b26432}} 
\index{SkSurface@{SkSurface}!peekPixels@{peekPixels}}
\index{peekPixels@{peekPixels}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{peekPixels()}{peekPixels()}}
{\footnotesize\ttfamily bool Sk\+Surface\+::peek\+Pixels (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} $\ast$}]{pixmap }\end{DoxyParamCaption})}

Copies \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} pixel address, row bytes, and \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} to \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}}, if address is available, and returns true. If pixel address is not available, return false and leave \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} unchanged.

pixmap contents become invalid on any future change to \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}.


\begin{DoxyParams}{Parameters}
{\em pixmap} & storage for pixel state if pixels are readable; otherwise, ignored \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} has direct access to pixels
\end{DoxyReturn}
example\+: \href{https://fiddle.skia.org/c/@Surface_peekPixels}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Surface\+\_\+peek\+Pixels}} \mbox{\Hypertarget{class_sk_surface_a0a3c4c19cc65a7eb602cb196b1c40556}\label{class_sk_surface_a0a3c4c19cc65a7eb602cb196b1c40556}} 
\index{SkSurface@{SkSurface}!props@{props}}
\index{props@{props}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{props()}{props()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}}\& Sk\+Surface\+::props (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns \mbox{\hyperlink{class_sk_surface_props}{Sk\+Surface\+Props}} for surface.

\begin{DoxyReturn}{Returns}
L\+CD striping orientation and setting for device independent fonts 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_abf11d4d743be6d2d94007e8d923c987c}\label{class_sk_surface_abf11d4d743be6d2d94007e8d923c987c}} 
\index{SkSurface@{SkSurface}!readPixels@{readPixels}}
\index{readPixels@{readPixels}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{readPixels()}{readPixels()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily bool Sk\+Surface\+::read\+Pixels (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_bitmap}{Sk\+Bitmap}} \&}]{dst,  }\item[{int}]{srcX,  }\item[{int}]{srcY }\end{DoxyParamCaption})}

Copies \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} of pixels from \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} into bitmap.

Source \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} corners are (srcX, srcY) and \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} (\mbox{\hyperlink{class_sk_surface_a351ef72e03fba91865a321e8e081a842}{width()}}, \mbox{\hyperlink{class_sk_surface_aa30771352bbeb37532669127fa16494e}{height()}}). Destination \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} corners are (0, 0) and (bitmap.\+width(), bitmap.\+height()). Copies each readable pixel intersecting both rectangles, without scaling, converting to bitmap.\+color\+Type() and bitmap.\+alpha\+Type() if required.

Pixels are readable when \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is raster, or backed by a G\+PU.

The destination pixel storage must be allocated by the caller.

\mbox{\hyperlink{struct_pixel}{Pixel}} values are converted only if Sk\+Color\+Type and Sk\+Alpha\+Type do not match. Only pixels within both source and destination rectangles are copied. dst contents outside \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} intersection are unchanged.

Pass negative values for srcX or srcY to offset pixels across or down destination.

Does not copy, and returns false if\+:
\begin{DoxyItemize}
\item Source and destination rectangles do not intersect.
\item \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} pixels could not be converted to dst.\+color\+Type() or dst.\+alpha\+Type().
\item dst pixels could not be allocated.
\item dst.\+row\+Bytes() is too small to contain one row of pixels.
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em dst} & storage for pixels copied from \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} \\
\hline
{\em srcX} & offset into readable pixels on x-\/axis; may be negative \\
\hline
{\em srcY} & offset into readable pixels on y-\/axis; may be negative \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if pixels were copied
\end{DoxyReturn}
example\+: \href{https://fiddle.skia.org/c/@Surface_readPixels_3}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Surface\+\_\+read\+Pixels\+\_\+3}} \mbox{\Hypertarget{class_sk_surface_a1fbe87fec06fb10cc5f2ea34b6bff55e}\label{class_sk_surface_a1fbe87fec06fb10cc5f2ea34b6bff55e}} 
\index{SkSurface@{SkSurface}!readPixels@{readPixels}}
\index{readPixels@{readPixels}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{readPixels()}{readPixels()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily bool Sk\+Surface\+::read\+Pixels (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{dst\+Info,  }\item[{void $\ast$}]{dst\+Pixels,  }\item[{size\+\_\+t}]{dst\+Row\+Bytes,  }\item[{int}]{srcX,  }\item[{int}]{srcY }\end{DoxyParamCaption})}

Copies \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} of pixels from \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} into dst\+Pixels.

Source \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} corners are (srcX, srcY) and \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} (\mbox{\hyperlink{class_sk_surface_a351ef72e03fba91865a321e8e081a842}{width()}}, \mbox{\hyperlink{class_sk_surface_aa30771352bbeb37532669127fa16494e}{height()}}). Destination \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} corners are (0, 0) and (dst\+Info.\+width(), dst\+Info.\+height()). Copies each readable pixel intersecting both rectangles, without scaling, converting to dst\+Info.\+color\+Type() and dst\+Info.\+alpha\+Type() if required.

Pixels are readable when \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is raster, or backed by a G\+PU.

The destination pixel storage must be allocated by the caller.

\mbox{\hyperlink{struct_pixel}{Pixel}} values are converted only if Sk\+Color\+Type and Sk\+Alpha\+Type do not match. Only pixels within both source and destination rectangles are copied. dst\+Pixels contents outside \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} intersection are unchanged.

Pass negative values for srcX or srcY to offset pixels across or down destination.

Does not copy, and returns false if\+:
\begin{DoxyItemize}
\item Source and destination rectangles do not intersect.
\item \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} pixels could not be converted to dst\+Info.\+color\+Type() or dst\+Info.\+alpha\+Type().
\item dst\+Row\+Bytes is too small to contain one row of pixels.
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em dst\+Info} & width, height, Sk\+Color\+Type, and Sk\+Alpha\+Type of dst\+Pixels \\
\hline
{\em dst\+Pixels} & storage for pixels; dst\+Info.\+height() times dst\+Row\+Bytes, or larger \\
\hline
{\em dst\+Row\+Bytes} & size of one destination row; dst\+Info.\+width() times pixel size, or larger \\
\hline
{\em srcX} & offset into readable pixels on x-\/axis; may be negative \\
\hline
{\em srcY} & offset into readable pixels on y-\/axis; may be negative \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if pixels were copied 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_af3fe3696a898f644c0b3136d94771588}\label{class_sk_surface_af3fe3696a898f644c0b3136d94771588}} 
\index{SkSurface@{SkSurface}!readPixels@{readPixels}}
\index{readPixels@{readPixels}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{readPixels()}{readPixels()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily bool Sk\+Surface\+::read\+Pixels (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} \&}]{dst,  }\item[{int}]{srcX,  }\item[{int}]{srcY }\end{DoxyParamCaption})}

Copies \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} of pixels to dst.

Source \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} corners are (srcX, srcY) and \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} (\mbox{\hyperlink{class_sk_surface_a351ef72e03fba91865a321e8e081a842}{width()}}, \mbox{\hyperlink{class_sk_surface_aa30771352bbeb37532669127fa16494e}{height()}}). Destination \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} corners are (0, 0) and (dst.\+width(), dst.\+height()). Copies each readable pixel intersecting both rectangles, without scaling, converting to dst.\+color\+Type() and dst.\+alpha\+Type() if required.

Pixels are readable when \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} is raster, or backed by a G\+PU.

The destination pixel storage must be allocated by the caller.

\mbox{\hyperlink{struct_pixel}{Pixel}} values are converted only if Sk\+Color\+Type and Sk\+Alpha\+Type do not match. Only pixels within both source and destination rectangles are copied. dst contents outside \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} intersection are unchanged.

Pass negative values for srcX or srcY to offset pixels across or down destination.

Does not copy, and returns false if\+:
\begin{DoxyItemize}
\item Source and destination rectangles do not intersect.
\item \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} pixels could not be allocated.
\item dst.\+row\+Bytes() is too small to contain one row of pixels.
\end{DoxyItemize}


\begin{DoxyParams}{Parameters}
{\em dst} & storage for pixels copied from \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} \\
\hline
{\em srcX} & offset into readable pixels on x-\/axis; may be negative \\
\hline
{\em srcY} & offset into readable pixels on y-\/axis; may be negative \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if pixels were copied
\end{DoxyReturn}
example\+: \href{https://fiddle.skia.org/c/@Surface_readPixels}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Surface\+\_\+read\+Pixels}} \mbox{\Hypertarget{class_sk_surface_a7e10b31a98c0b93e6d6fb23b32b8519f}\label{class_sk_surface_a7e10b31a98c0b93e6d6fb23b32b8519f}} 
\index{SkSurface@{SkSurface}!recordingContext@{recordingContext}}
\index{recordingContext@{recordingContext}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{recordingContext()}{recordingContext()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_gr_recording_context}{Gr\+Recording\+Context}}$\ast$ Sk\+Surface\+::recording\+Context (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns the recording context being used by the \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}.

\begin{DoxyReturn}{Returns}
the recording context, if available; nullptr otherwise 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_a6335b4e9e654c197aa9802bf74facc5b}\label{class_sk_surface_a6335b4e9e654c197aa9802bf74facc5b}} 
\index{SkSurface@{SkSurface}!replaceBackendTexture@{replaceBackendTexture}}
\index{replaceBackendTexture@{replaceBackendTexture}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{replaceBackendTexture()}{replaceBackendTexture()}}
{\footnotesize\ttfamily bool Sk\+Surface\+::replace\+Backend\+Texture (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_gr_backend_texture}{Gr\+Backend\+Texture}} \&}]{backend\+Texture,  }\item[{Gr\+Surface\+Origin}]{origin,  }\item[{\mbox{\hyperlink{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538}{Content\+Change\+Mode}}}]{mode = {\ttfamily \mbox{\hyperlink{class_sk_surface_a09e73a19d8d3d1ea85c38a515fc48538a61df574700828a9f039c6cd8ec4c39df}{k\+Retain\+\_\+\+Content\+Change\+Mode}}},  }\item[{\mbox{\hyperlink{class_sk_surface_a0e552eaf3124ef4e6fbb3490b321ea60}{Texture\+Release\+Proc}}}]{texture\+Release\+Proc = {\ttfamily nullptr},  }\item[{\mbox{\hyperlink{class_sk_surface_ae91b4f130cbb53ecde3a1d9261eadc54}{Release\+Context}}}]{release\+Context = {\ttfamily nullptr} }\end{DoxyParamCaption})}

If the surface was made via Make\+From\+Backend\+Texture then it\textquotesingle{}s backing texture may be substituted with a different texture. The contents of the previous backing texture are copied into the new texture. \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} state is preserved. The original sample count is used. The \mbox{\hyperlink{class_gr_backend_format}{Gr\+Backend\+Format}} and dimensions of replacement texture must match that of the original.

Upon success texture\+Release\+Proc is called when it is safe to delete the texture in the backend A\+PI (accounting only for use of the texture by this surface). If \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} creation fails texture\+Release\+Proc is called before this function returns.


\begin{DoxyParams}{Parameters}
{\em backend\+Texture} & the new backing texture for the surface \\
\hline
{\em mode} & Retain or discard current Content \\
\hline
{\em texture\+Release\+Proc} & function called when texture can be released \\
\hline
{\em release\+Context} & state passed to texture\+Release\+Proc \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_surface_aebf60b11a45f03386aecc5f673d36bac}\label{class_sk_surface_aebf60b11a45f03386aecc5f673d36bac}} 
\index{SkSurface@{SkSurface}!wait@{wait}}
\index{wait@{wait}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{wait()}{wait()}}
{\footnotesize\ttfamily bool Sk\+Surface\+::wait (\begin{DoxyParamCaption}\item[{int}]{num\+Semaphores,  }\item[{const \mbox{\hyperlink{class_gr_backend_semaphore}{Gr\+Backend\+Semaphore}} $\ast$}]{wait\+Semaphores,  }\item[{bool}]{delete\+Semaphores\+After\+Wait = {\ttfamily true} }\end{DoxyParamCaption})}

Inserts a list of G\+PU semaphores that the current G\+P\+U-\/backed A\+PI must wait on before executing any more commands on the G\+PU for this surface. If this call returns false, then the G\+PU back-\/end will not wait on any passed in semaphores, and the client will still own the semaphores, regardless of the value of delete\+Semaphores\+After\+Wait.

If delete\+Semaphores\+After\+Wait is false then Skia will not delete the semaphores. In this case it is the client\textquotesingle{}s responsibility to not destroy or attempt to reuse the semaphores until it knows that Skia has finished waiting on them. This can be done by using finished\+Procs on flush calls.


\begin{DoxyParams}{Parameters}
{\em num\+Semaphores} & size of wait\+Semaphores array \\
\hline
{\em wait\+Semaphores} & array of semaphore containers @paramm delete\+Semaphores\+After\+Wait who owns and should delete the semaphores \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if G\+PU is waiting on semaphores 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_a351ef72e03fba91865a321e8e081a842}\label{class_sk_surface_a351ef72e03fba91865a321e8e081a842}} 
\index{SkSurface@{SkSurface}!width@{width}}
\index{width@{width}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{width()}{width()}}
{\footnotesize\ttfamily int Sk\+Surface\+::width (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns pixel count in each row; may be zero or greater.

\begin{DoxyReturn}{Returns}
number of pixel columns 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_surface_a59a898652100042350bce30cb348c781}\label{class_sk_surface_a59a898652100042350bce30cb348c781}} 
\index{SkSurface@{SkSurface}!writePixels@{writePixels}}
\index{writePixels@{writePixels}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{writePixels()}{writePixels()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Sk\+Surface\+::write\+Pixels (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_bitmap}{Sk\+Bitmap}} \&}]{src,  }\item[{int}]{dstX,  }\item[{int}]{dstY }\end{DoxyParamCaption})}

Copies \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} of pixels from the src \mbox{\hyperlink{class_sk_bitmap}{Sk\+Bitmap}} to the \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}.

Source \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} corners are (0, 0) and (src.\+width(), src.\+height()). Destination \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} corners are (dstX, dstY) and (dstX + Surface \mbox{\hyperlink{class_sk_surface_a351ef72e03fba91865a321e8e081a842}{width()}}, dstY + Surface \mbox{\hyperlink{class_sk_surface_aa30771352bbeb37532669127fa16494e}{height()}}).

Copies each readable pixel intersecting both rectangles, without scaling, converting to \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} color\+Type() and \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} alpha\+Type() if required.


\begin{DoxyParams}{Parameters}
{\em src} & storage for pixels to copy to \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} \\
\hline
{\em dstX} & x-\/axis position relative to \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} to begin copy; may be negative \\
\hline
{\em dstY} & y-\/axis position relative to \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} to begin copy; may be negative\\
\hline
\end{DoxyParams}
example\+: \href{https://fiddle.skia.org/c/@Surface_writePixels_2}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Surface\+\_\+write\+Pixels\+\_\+2}} \mbox{\Hypertarget{class_sk_surface_ae22a0f49d435f78820918fbf06c0dd61}\label{class_sk_surface_ae22a0f49d435f78820918fbf06c0dd61}} 
\index{SkSurface@{SkSurface}!writePixels@{writePixels}}
\index{writePixels@{writePixels}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{writePixels()}{writePixels()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Sk\+Surface\+::write\+Pixels (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} \&}]{src,  }\item[{int}]{dstX,  }\item[{int}]{dstY }\end{DoxyParamCaption})}

Copies \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} of pixels from the src \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} to the \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}}.

Source \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} corners are (0, 0) and (src.\+width(), src.\+height()). Destination \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} corners are (dstX, dstY) and (dstX + Surface \mbox{\hyperlink{class_sk_surface_a351ef72e03fba91865a321e8e081a842}{width()}}, dstY + Surface \mbox{\hyperlink{class_sk_surface_aa30771352bbeb37532669127fa16494e}{height()}}).

Copies each readable pixel intersecting both rectangles, without scaling, converting to \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} color\+Type() and \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} alpha\+Type() if required.


\begin{DoxyParams}{Parameters}
{\em src} & storage for pixels to copy to \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} \\
\hline
{\em dstX} & x-\/axis position relative to \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} to begin copy; may be negative \\
\hline
{\em dstY} & y-\/axis position relative to \mbox{\hyperlink{class_sk_surface}{Sk\+Surface}} to begin copy; may be negative\\
\hline
\end{DoxyParams}
example\+: \href{https://fiddle.skia.org/c/@Surface_writePixels}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Surface\+\_\+write\+Pixels}} 

\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{class_sk_surface_a1ff636605c412060f5ffe6bc0a5039e1}\label{class_sk_surface_a1ff636605c412060f5ffe6bc0a5039e1}} 
\index{SkSurface@{SkSurface}!kDiscardWrite\_TextureHandleAccess@{kDiscardWrite\_TextureHandleAccess}}
\index{kDiscardWrite\_TextureHandleAccess@{kDiscardWrite\_TextureHandleAccess}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{kDiscardWrite\_TextureHandleAccess}{kDiscardWrite\_TextureHandleAccess}}
{\footnotesize\ttfamily const \mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209}{Backend\+Handle\+Access}} Sk\+Surface\+::k\+Discard\+Write\+\_\+\+Texture\+Handle\+Access\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{=}
\DoxyCodeLine{            \mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209a265463cfb4ba17bb7948556f12c73b95}{kDiscardWrite\_BackendHandleAccess}}}

\end{DoxyCode}
Deprecated. \mbox{\Hypertarget{class_sk_surface_a87371ae0497a248a1f9567950670b709}\label{class_sk_surface_a87371ae0497a248a1f9567950670b709}} 
\index{SkSurface@{SkSurface}!kFlushRead\_TextureHandleAccess@{kFlushRead\_TextureHandleAccess}}
\index{kFlushRead\_TextureHandleAccess@{kFlushRead\_TextureHandleAccess}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{kFlushRead\_TextureHandleAccess}{kFlushRead\_TextureHandleAccess}}
{\footnotesize\ttfamily const \mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209}{Backend\+Handle\+Access}} Sk\+Surface\+::k\+Flush\+Read\+\_\+\+Texture\+Handle\+Access\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{=}
\DoxyCodeLine{            \mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209a2061b9bbc92672b5168fbd018b47ec7a}{kFlushRead\_BackendHandleAccess}}}

\end{DoxyCode}
Deprecated. \mbox{\Hypertarget{class_sk_surface_a13c51fc4193e7e91806b109af59d242f}\label{class_sk_surface_a13c51fc4193e7e91806b109af59d242f}} 
\index{SkSurface@{SkSurface}!kFlushWrite\_TextureHandleAccess@{kFlushWrite\_TextureHandleAccess}}
\index{kFlushWrite\_TextureHandleAccess@{kFlushWrite\_TextureHandleAccess}!SkSurface@{SkSurface}}
\doxysubsubsection{\texorpdfstring{kFlushWrite\_TextureHandleAccess}{kFlushWrite\_TextureHandleAccess}}
{\footnotesize\ttfamily const \mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209}{Backend\+Handle\+Access}} Sk\+Surface\+::k\+Flush\+Write\+\_\+\+Texture\+Handle\+Access\hspace{0.3cm}{\ttfamily [static]}}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{=}
\DoxyCodeLine{            \mbox{\hyperlink{class_sk_surface_ae68c874f3e621291d54c5b62f3165209a2c2b35a88238afbf7e7b79ff52048db4}{kFlushWrite\_BackendHandleAccess}}}

\end{DoxyCode}
Deprecated. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/include/core/Sk\+Surface.\+h\end{DoxyCompactItemize}
