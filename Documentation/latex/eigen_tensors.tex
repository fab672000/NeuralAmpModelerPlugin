Tensors are multidimensional arrays of elements. Elements are typically scalars, but more complex types such as strings are also supported.\hypertarget{eigen_tensors_autotoc_md1432}{}\doxysection{Tensor Classes}\label{eigen_tensors_autotoc_md1432}
You can manipulate a tensor with one of the following classes. They all are in the namespace {\ttfamily \mbox{\hyperlink{namespace_eigen}{Eigen}}.}\hypertarget{eigen_tensors_autotoc_md1433}{}\doxysubsection{Class Tensor$<$data\+\_\+type, rank$>$}\label{eigen_tensors_autotoc_md1433}
This is the class to use to create a tensor and allocate memory for it. The class is templatized with the tensor datatype, such as float or int, and the tensor rank. The rank is the number of dimensions, for example rank 2 is a matrix.

Tensors of this class are resizable. For example, if you assign a tensor of a different size to a Tensor, that tensor is resized to match its new value.\hypertarget{eigen_tensors_autotoc_md1434}{}\doxysubsubsection{Constructor Tensor$<$data\+\_\+type, rank$>$(size0, size1, ...)}\label{eigen_tensors_autotoc_md1434}
Constructor for a Tensor. The constructor must be passed {\ttfamily rank} integers indicating the sizes of the instance along each of the the {\ttfamily rank} dimensions. \begin{DoxyVerb}// Create a tensor of rank 3 of sizes 2, 3, 4.  This tensor owns
// memory to hold 24 floating point values (24 = 2 x 3 x 4).
Tensor<float, 3> t_3d(2, 3, 4);

// Resize t_3d by assigning a tensor of different sizes, but same rank.
t_3d = Tensor<float, 3>(3, 4, 3);
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1435}{}\doxysubsubsection{Constructor Tensor$<$data\+\_\+type, rank$>$(size\+\_\+array)}\label{eigen_tensors_autotoc_md1435}
Constructor where the sizes for the constructor are specified as an array of values instead of an explicitly list of parameters. The array type to use is {\ttfamily Eigen\+::array$<$\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Eigen\+::\+Index}}$>$}. The array can be constructed automatically from an initializer list. \begin{DoxyVerb}// Create a tensor of strings of rank 2 with sizes 5, 7.
Tensor<string, 2> t_2d({5, 7});
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1436}{}\doxysubsection{Class Tensor\+Fixed\+Size$<$data\+\_\+type, Sizes$<$size0, size1, ...$>$$>$}\label{eigen_tensors_autotoc_md1436}
Class to use for tensors of fixed size, where the size is known at compile time. Fixed sized tensors can provide very fast computations because all their dimensions are known by the compiler. Fixed\+Size tensors are not resizable.

If the total number of elements in a fixed size tensor is small enough the tensor data is held onto the stack and does not cause heap allocation and free. \begin{DoxyVerb}// Create a 4 x 3 tensor of floats.
TensorFixedSize<float, Sizes<4, 3>> t_4x3;
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1437}{}\doxysubsection{Class Tensor\+Map$<$\+Tensor$<$data\+\_\+type, rank$>$$>$}\label{eigen_tensors_autotoc_md1437}
This is the class to use to create a tensor on top of memory allocated and owned by another part of your code. It allows to view any piece of allocated memory as a Tensor. Instances of this class do not own the memory where the data are stored.

A Tensor\+Map is not resizable because it does not own the memory where its data are stored.\hypertarget{eigen_tensors_autotoc_md1438}{}\doxysubsubsection{Constructor Tensor\+Map$<$\+Tensor$<$data\+\_\+type, rank$>$$>$(data, size0, size1, ...)}\label{eigen_tensors_autotoc_md1438}
Constructor for a Tensor. The constructor must be passed a pointer to the storage for the data, and \char`\"{}rank\char`\"{} size attributes. The storage has to be large enough to hold all the data. \begin{DoxyVerb}// Map a tensor of ints on top of stack-allocated storage.
int storage[128];  // 2 x 4 x 2 x 8 = 128
TensorMap<Tensor<int, 4>> t_4d(storage, 2, 4, 2, 8);

// The same storage can be viewed as a different tensor.
// You can also pass the sizes as an array.
TensorMap<Tensor<int, 2>> t_2d(storage, 16, 8);

// You can also map fixed-size tensors.  Here we get a 1d view of
// the 2d fixed-size tensor.
TensorFixedSize<float, Sizes<4, 3>> t_4x3;
TensorMap<Tensor<float, 1>> t_12(t_4x3.data(), 12);
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1439}{}\doxysubsubsection{Class Tensor\+Ref}\label{eigen_tensors_autotoc_md1439}
See Assigning to a Tensor\+Ref below.\hypertarget{eigen_tensors_autotoc_md1440}{}\doxysection{Accessing Tensor Elements}\label{eigen_tensors_autotoc_md1440}
\hypertarget{eigen_tensors_autotoc_md1441}{}\doxysubsubsection{$<$data\+\_\+type$>$ tensor(index0, index1...)}\label{eigen_tensors_autotoc_md1441}
Return the element at position {\ttfamily (index0, index1...)} in tensor {\ttfamily tensor}. You must pass as many parameters as the rank of {\ttfamily tensor}. The expression can be used as an l-\/value to set the value of the element at the specified position. The value returned is of the datatype of the tensor. \begin{DoxyVerb}// Set the value of the element at position (0, 1, 0);
Tensor<float, 3> t_3d(2, 3, 4);
t_3d(0, 1, 0) = 12.0f;

// Initialize all elements to random values.
for (int i = 0; i < 2; ++i) {
  for (int j = 0; j < 3; ++j) {
    for (int k = 0; k < 4; ++k) {
      t_3d(i, j, k) = ...some random value...;
    }
  }
}

// Print elements of a tensor.
for (int i = 0; i < 2; ++i) {
  LOG(INFO) << t_3d(i, 0, 0);
}
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1442}{}\doxysection{Tensor\+Layout}\label{eigen_tensors_autotoc_md1442}
The tensor library supports 2 layouts\+: {\ttfamily Col\+Major} (the default) and {\ttfamily Row\+Major}.

The layout of a tensor is optionally specified as part of its type. If not specified explicitly column major is assumed. \begin{DoxyVerb}Tensor<float, 3, ColMajor> col_major;  // equivalent to Tensor<float, 3>
TensorMap<Tensor<float, 3, RowMajor> > row_major(data, ...);
\end{DoxyVerb}


All the arguments to an expression must use the same layout. Attempting to mix different layouts will result in a compilation error.

It is possible to change the layout of a tensor or an expression using the {\ttfamily swap\+\_\+layout()} method. Note that this will also reverse the order of the dimensions. \begin{DoxyVerb}Tensor<float, 2, ColMajor> col_major(2, 4);
Tensor<float, 2, RowMajor> row_major(2, 4);

Tensor<float, 2> col_major_result = col_major;  // ok, layouts match
Tensor<float, 2> col_major_result = row_major;  // will not compile

// Simple layout swap
col_major_result = row_major.swap_layout();
eigen_assert(col_major_result.dimension(0) == 4);
eigen_assert(col_major_result.dimension(1) == 2);

// Swap the layout and preserve the order of the dimensions
array<int, 2> shuffle(1, 0);
col_major_result = row_major.swap_layout().shuffle(shuffle);
eigen_assert(col_major_result.dimension(0) == 2);
eigen_assert(col_major_result.dimension(1) == 4);
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1443}{}\doxysection{Tensor Operations}\label{eigen_tensors_autotoc_md1443}
The \mbox{\hyperlink{namespace_eigen}{Eigen}} Tensor library provides a vast library of operations on Tensors\+: numerical operations such as addition and multiplication, geometry operations such as slicing and shuffling, etc. These operations are available as methods of the Tensor classes, and in some cases as operator overloads. For example the following code computes the elementwise addition of two tensors\+: \begin{DoxyVerb}Tensor<float, 3> t1(2, 3, 4);
...set some values in t1...
Tensor<float, 3> t2(2, 3, 4);
...set some values in t2...
// Set t3 to the element wise sum of t1 and t2
Tensor<float, 3> t3 = t1 + t2;
\end{DoxyVerb}


While the code above looks easy enough, it is important to understand that the expression {\ttfamily t1 + t2} is not actually adding the values of the tensors. The expression instead constructs a \char`\"{}tensor operator\char`\"{} object of the class Tensor\+Cwise\+Binary\+Op$<$scalar\+\_\+sum$>$, which has references to the tensors {\ttfamily t1} and {\ttfamily t2}. This is a small C++ object that knows how to add {\ttfamily t1} and {\ttfamily t2}. It is only when the value of the expression is assigned to the tensor {\ttfamily t3} that the addition is actually performed. Technically, this happens through the overloading of {\ttfamily operator=()} in the Tensor class.

This mechanism for computing tensor expressions allows for lazy evaluation and optimizations which are what make the tensor library very fast.

Of course, the tensor operators do nest, and the expression {\ttfamily t1 + t2 $\ast$ 0.\+3f} is actually represented with the (approximate) tree of operators\+: \begin{DoxyVerb}TensorCwiseBinaryOp<scalar_sum>(t1, TensorCwiseUnaryOp<scalar_mul>(t2, 0.3f))
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1444}{}\doxysubsection{Tensor Operations and C++ \char`\"{}auto\char`\"{}}\label{eigen_tensors_autotoc_md1444}
Because Tensor operations create tensor operators, the C++ {\ttfamily auto} keyword does not have its intuitive meaning. Consider these 2 lines of code\+: \begin{DoxyVerb}Tensor<float, 3> t3 = t1 + t2;
auto t4 = t1 + t2;
\end{DoxyVerb}


In the first line we allocate the tensor {\ttfamily t3} and it will contain the result of the addition of {\ttfamily t1} and {\ttfamily t2}. In the second line, {\ttfamily t4} is actually the tree of tensor operators that will compute the addition of {\ttfamily t1} and {\ttfamily t2}. In fact, {\ttfamily t4} is {\itshape not} a tensor and you cannot get the values of its elements\+: \begin{DoxyVerb}Tensor<float, 3> t3 = t1 + t2;
cout << t3(0, 0, 0);  // OK prints the value of t1(0, 0, 0) + t2(0, 0, 0)

auto t4 = t1 + t2;
cout << t4(0, 0, 0);  // Compilation error!
\end{DoxyVerb}


When you use {\ttfamily auto} you do not get a Tensor as a result but instead a non-\/evaluated expression. So only use {\ttfamily auto} to delay evaluation.

Unfortunately, there is no single underlying concrete type for holding non-\/evaluated expressions, hence you have to use auto in the case when you do want to hold non-\/evaluated expressions.

When you need the results of set of tensor computations you have to assign the result to a Tensor that will be capable of holding onto them. This can be either a normal Tensor, a fixed size Tensor, or a Tensor\+Map on an existing piece of memory. All the following will work\+: \begin{DoxyVerb}auto t4 = t1 + t2;

Tensor<float, 3> result = t4;  // Could also be: result(t4);
cout << result(0, 0, 0);

TensorMap<float, 4> result(<a float* with enough space>, <size0>, ...) = t4;
cout << result(0, 0, 0);

TensorFixedSize<float, Sizes<size0, ...>> result = t4;
cout << result(0, 0, 0);
\end{DoxyVerb}


Until you need the results, you can keep the operation around, and even reuse it for additional operations. As long as you keep the expression as an operation, no computation is performed. \begin{DoxyVerb}// One way to compute exp((t1 + t2) * 0.2f);
auto t3 = t1 + t2;
auto t4 = t3 * 0.2f;
auto t5 = t4.exp();
Tensor<float, 3> result = t5;

// Another way, exactly as efficient as the previous one:
Tensor<float, 3> result = ((t1 + t2) * 0.2f).exp();
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1445}{}\doxysubsection{Controlling When Expression are Evaluated}\label{eigen_tensors_autotoc_md1445}
There are several ways to control when expressions are evaluated\+:


\begin{DoxyItemize}
\item Assignment to a Tensor, Tensor\+Fixed\+Size, or Tensor\+Map.
\item Use of the eval() method.
\item Assignment to a Tensor\+Ref.
\end{DoxyItemize}\hypertarget{eigen_tensors_autotoc_md1446}{}\doxysubsubsection{Assigning to a Tensor, Tensor\+Fixed\+Size, or Tensor\+Map.}\label{eigen_tensors_autotoc_md1446}
The most common way to evaluate an expression is to assign it to a Tensor. In the example below, the {\ttfamily auto} declarations make the intermediate values \char`\"{}\+Operations\char`\"{}, not Tensors, and do not cause the expressions to be evaluated. The assignment to the Tensor {\ttfamily result} causes the evaluation of all the operations. \begin{DoxyVerb}auto t3 = t1 + t2;             // t3 is an Operation.
auto t4 = t3 * 0.2f;           // t4 is an Operation.
auto t5 = t4.exp();            // t5 is an Operation.
Tensor<float, 3> result = t5;  // The operations are evaluated.
\end{DoxyVerb}


If you know the ranks and sizes of the Operation value you can assign the Operation to a Tensor\+Fixed\+Size instead of a Tensor, which is a bit more efficient. \begin{DoxyVerb}// We know that the result is a 4x4x2 tensor!
TensorFixedSize<float, Sizes<4, 4, 2>> result = t5;
\end{DoxyVerb}


Simiarly, assigning an expression to a Tensor\+Map causes its evaluation. Like tensors of type Tensor\+Fixed\+Size, Tensor\+Maps cannot be resized so they have to have the rank and sizes of the expression that are assigned to them.\hypertarget{eigen_tensors_autotoc_md1447}{}\doxysubsubsection{Calling eval().}\label{eigen_tensors_autotoc_md1447}
When you compute large composite expressions, you sometimes want to tell \mbox{\hyperlink{namespace_eigen}{Eigen}} that an intermediate value in the expression tree is worth evaluating ahead of time. This is done by inserting a call to the {\ttfamily eval()} method of the expression Operation. \begin{DoxyVerb}// The previous example could have been written:
Tensor<float, 3> result = ((t1 + t2) * 0.2f).exp();

// If you want to compute (t1 + t2) once ahead of time you can write:
Tensor<float, 3> result = ((t1 + t2).eval() * 0.2f).exp();
\end{DoxyVerb}


Semantically, calling {\ttfamily eval()} is equivalent to materializing the value of the expression in a temporary Tensor of the right size. The code above in effect does\+: \begin{DoxyVerb}// .eval() knows the size!
TensorFixedSize<float, Sizes<4, 4, 2>> tmp = t1 + t2;
Tensor<float, 3> result = (tmp * 0.2f).exp();
\end{DoxyVerb}


Note that the return value of {\ttfamily eval()} is itself an Operation, so the following code does not do what you may think\+: \begin{DoxyVerb}// Here t3 is an evaluation Operation.  t3 has not been evaluated yet.
auto t3 = (t1 + t2).eval();

// You can use t3 in another expression.  Still no evaluation.
auto t4 = (t3 * 0.2f).exp();

// The value is evaluated when you assign the Operation to a Tensor, using
// an intermediate tensor to represent t3.x
Tensor<float, 3> result = t4;
\end{DoxyVerb}


While in the examples above calling {\ttfamily eval()} does not make a difference in performance, in other cases it can make a huge difference. In the expression below the {\ttfamily broadcast()} expression causes the {\ttfamily X.\+maximum()} expression to be evaluated many times\+: \begin{DoxyVerb}Tensor<...> X ...;
Tensor<...> Y = ((X - X.maximum(depth_dim).reshape(dims2d).broadcast(bcast))
                 * beta).exp();
\end{DoxyVerb}


Inserting a call to {\ttfamily eval()} between the {\ttfamily maximum()} and {\ttfamily reshape()} calls guarantees that maximum() is only computed once and greatly speeds-\/up execution\+: \begin{DoxyVerb}Tensor<...> Y =
  ((X - X.maximum(depth_dim).eval().reshape(dims2d).broadcast(bcast))
    * beta).exp();
\end{DoxyVerb}


In the other example below, the tensor {\ttfamily Y} is both used in the expression and its assignment. This is an aliasing problem and if the evaluation is not done in the right order Y will be updated incrementally during the evaluation resulting in bogus results\+: \begin{DoxyVerb} Tensor<...> Y ...;
 Y = Y / (Y.sum(depth_dim).reshape(dims2d).broadcast(bcast));
\end{DoxyVerb}


Inserting a call to {\ttfamily eval()} between the {\ttfamily sum()} and {\ttfamily reshape()} expressions ensures that the sum is computed before any updates to {\ttfamily Y} are done. \begin{DoxyVerb} Y = Y / (Y.sum(depth_dim).eval().reshape(dims2d).broadcast(bcast));
\end{DoxyVerb}


Note that an eval around the full right hand side expression is not needed because the generated has to compute the i-\/th value of the right hand side before assigning it to the left hand side.

However, if you were assigning the expression value to a shuffle of {\ttfamily Y} then you would need to force an eval for correctness by adding an {\ttfamily eval()} call for the right hand side\+: \begin{DoxyVerb} Y.shuffle(...) =
    (Y / (Y.sum(depth_dim).eval().reshape(dims2d).broadcast(bcast))).eval();
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1448}{}\doxysubsubsection{Assigning to a Tensor\+Ref.}\label{eigen_tensors_autotoc_md1448}
If you need to access only a few elements from the value of an expression you can avoid materializing the value in a full tensor by using a Tensor\+Ref.

A Tensor\+Ref is a small wrapper class for any \mbox{\hyperlink{namespace_eigen}{Eigen}} Operation. It provides overloads for the {\ttfamily ()} operator that let you access individual values in the expression. Tensor\+Ref is convenient, because the Operation themselves do not provide a way to access individual elements. \begin{DoxyVerb}// Create a TensorRef for the expression.  The expression is not
// evaluated yet.
TensorRef<Tensor<float, 3> > ref = ((t1 + t2) * 0.2f).exp();

// Use "ref" to access individual elements.  The expression is evaluated
// on the fly.
float at_0 = ref(0, 0, 0);
cout << ref(0, 1, 0);
\end{DoxyVerb}


Only use Tensor\+Ref when you need a subset of the values of the expression. Tensor\+Ref only computes the values you access. However note that if you are going to access all the values it will be much faster to materialize the results in a Tensor first.

In some cases, if the full Tensor result would be very large, you may save memory by accessing it as a Tensor\+Ref. But not always. So don\textquotesingle{}t count on it.\hypertarget{eigen_tensors_autotoc_md1449}{}\doxysubsection{Controlling How Expressions Are Evaluated}\label{eigen_tensors_autotoc_md1449}
The tensor library provides several implementations of the various operations such as contractions and convolutions. The implementations are optimized for different environments\+: single threaded on C\+PU, multi threaded on C\+PU, or on a G\+PU using cuda. Additional implementations may be added later.

You can choose which implementation to use with the {\ttfamily device()} call. If you do not choose an implementation explicitly the default implementation that uses a single thread on the C\+PU is used.

The default implementation has been optimized for recent Intel C\+P\+Us, taking advantage of S\+SE, A\+VX, and F\+MA instructions. Work is ongoing to tune the library on A\+RM C\+P\+Us. Note that you need to pass compiler-\/dependent flags to enable the use of S\+SE, A\+VX, and other instructions.

For example, the following code adds two tensors using the default single-\/threaded C\+PU implementation\+: \begin{DoxyVerb}Tensor<float, 2> a(30, 40);
Tensor<float, 2> b(30, 40);
Tensor<float, 2> c = a + b;
\end{DoxyVerb}


To choose a different implementation you have to insert a {\ttfamily device()} call before the assignment of the result. For technical C++ reasons this requires that the Tensor for the result be declared on its own. This means that you have to know the size of the result. \begin{DoxyVerb}Eigen::Tensor<float, 2> c(30, 40);
c.device(...) = a + b;
\end{DoxyVerb}


The call to {\ttfamily device()} must be the last call on the left of the operator=.

You must pass to the {\ttfamily device()} call an \mbox{\hyperlink{namespace_eigen}{Eigen}} device object. There are presently three devices you can use\+: Default\+Device, Thread\+Pool\+Device and Gpu\+Device.\hypertarget{eigen_tensors_autotoc_md1450}{}\doxysubsubsection{Evaluating With the Default\+Device}\label{eigen_tensors_autotoc_md1450}
This is exactly the same as not inserting a {\ttfamily device()} call. \begin{DoxyVerb}DefaultDevice my_device;
c.device(my_device) = a + b;
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1451}{}\doxysubsubsection{Evaluating with a Thread Pool}\label{eigen_tensors_autotoc_md1451}
\begin{DoxyVerb}// Create the Eigen ThreadPool
Eigen::ThreadPool pool(8 /* number of threads in pool */)

// Create the Eigen ThreadPoolDevice.
Eigen::ThreadPoolDevice my_device(&pool, 4 /* number of threads to use */);

// Now just use the device when evaluating expressions.
Eigen::Tensor<float, 2> c(30, 50);
c.device(my_device) = a.contract(b, dot_product_dims);
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1452}{}\doxysubsubsection{Evaluating On G\+PU}\label{eigen_tensors_autotoc_md1452}
This is presently a bit more complicated than just using a thread pool device. You need to create a G\+PU device but you also need to explicitly allocate the memory for tensors with cuda.\hypertarget{eigen_tensors_autotoc_md1453}{}\doxysection{A\+P\+I Reference}\label{eigen_tensors_autotoc_md1453}
\hypertarget{eigen_tensors_autotoc_md1454}{}\doxysubsection{Datatypes}\label{eigen_tensors_autotoc_md1454}
In the documentation of the tensor methods and Operation we mention datatypes that are tensor-\/type specific\+:\hypertarget{eigen_tensors_autotoc_md1455}{}\doxysubsubsection{$<$\+Tensor-\/\+Type$>$\+::\+Dimensions}\label{eigen_tensors_autotoc_md1455}
Acts like an array of ints. Has an {\ttfamily int size} attribute, and can be indexed like an array to access individual values. Used to represent the dimensions of a tensor. See {\ttfamily dimensions()}.\hypertarget{eigen_tensors_autotoc_md1456}{}\doxysubsubsection{$<$\+Tensor-\/\+Type$>$\+::\+Index}\label{eigen_tensors_autotoc_md1456}
Acts like an {\ttfamily int}. Used for indexing tensors along their dimensions. See {\ttfamily operator()}, {\ttfamily dimension()}, and {\ttfamily size()}.\hypertarget{eigen_tensors_autotoc_md1457}{}\doxysubsubsection{$<$\+Tensor-\/\+Type$>$\+::\+Scalar}\label{eigen_tensors_autotoc_md1457}
Represents the datatype of individual tensor elements. For example, for a {\ttfamily Tensor$<$float$>$}, {\ttfamily Scalar} is the type {\ttfamily float}. See {\ttfamily set\+Constant()}.\hypertarget{eigen_tensors_autotoc_md1458}{}\doxysubsubsection{$<$\+Operation$>$}\label{eigen_tensors_autotoc_md1458}
We use this pseudo type to indicate that a tensor Operation is returned by a method. We indicate in the text the type and dimensions of the tensor that the Operation returns after evaluation.

The Operation will have to be evaluated, for example by assigning it to a tensor, before you can access the values of the resulting tensor. You can also access the values through a Tensor\+Ref.\hypertarget{eigen_tensors_autotoc_md1459}{}\doxysection{Built-\/in Tensor Methods}\label{eigen_tensors_autotoc_md1459}
These are usual C++ methods that act on tensors immediately. They are not Operations which provide delayed evaluation of their results. Unless specified otherwise, all the methods listed below are available on all tensor classes\+: Tensor, Tensor\+Fixed\+Size, and Tensor\+Map.\hypertarget{eigen_tensors_autotoc_md1460}{}\doxysection{Metadata}\label{eigen_tensors_autotoc_md1460}
\hypertarget{eigen_tensors_autotoc_md1461}{}\doxysubsection{int Num\+Dimensions}\label{eigen_tensors_autotoc_md1461}
Constant value indicating the number of dimensions of a Tensor. This is also known as the tensor \char`\"{}rank\char`\"{}. \begin{DoxyVerb}  Eigen::Tensor<float, 2> a(3, 4);
  cout << "Dims " << a.NumDimensions;
  => Dims 2
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1462}{}\doxysubsection{Dimensions dimensions()}\label{eigen_tensors_autotoc_md1462}
Returns an array-\/like object representing the dimensions of the tensor. The actual type of the {\ttfamily dimensions()} result is {\ttfamily $<$Tensor-\/\+Type$>$\+::}{\ttfamily Dimensions}. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(3, 4);
const Eigen::Tensor<float, 2>::Dimensions& d = a.dimensions();
cout << "Dim size: " << d.size << ", dim 0: " << d[0]
     << ", dim 1: " << d[1];
=> Dim size: 2, dim 0: 3, dim 1: 4
\end{DoxyVerb}


If you use a C++11 compiler, you can use {\ttfamily auto} to simplify the code\+: \begin{DoxyVerb}const auto& d = a.dimensions();
cout << "Dim size: " << d.size << ", dim 0: " << d[0]
     << ", dim 1: " << d[1];
=> Dim size: 2, dim 0: 3, dim 1: 4
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1463}{}\doxysubsection{Index dimension(\+Index n)}\label{eigen_tensors_autotoc_md1463}
Returns the n-\/th dimension of the tensor. The actual type of the {\ttfamily dimension()} result is {\ttfamily $<$Tensor-\/\+Type$>$\+::}{\ttfamily Index}, but you can always use it like an int. \begin{DoxyVerb}  Eigen::Tensor<float, 2> a(3, 4);
  int dim1 = a.dimension(1);
  cout << "Dim 1: " << dim1;
  => Dim 1: 4
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1464}{}\doxysubsection{Index size()}\label{eigen_tensors_autotoc_md1464}
Returns the total number of elements in the tensor. This is the product of all the tensor dimensions. The actual type of the {\ttfamily size()} result is {\ttfamily $<$Tensor-\/\+Type$>$\+::}{\ttfamily Index}, but you can always use it like an int. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(3, 4);
cout << "Size: " << a.size();
=> Size: 12
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1465}{}\doxysubsection{Getting Dimensions From An Operation}\label{eigen_tensors_autotoc_md1465}
A few operations provide {\ttfamily dimensions()} directly, e.\+g. {\ttfamily Tensor\+Reslicing\+Op}. Most operations defer calculating dimensions until the operation is being evaluated. If you need access to the dimensions of a deferred operation, you can wrap it in a Tensor\+Ref (see Assigning to a Tensor\+Ref above), which provides {\ttfamily dimensions()} and {\ttfamily dimension()} as above.

Tensor\+Ref can also wrap the plain Tensor types, so this is a useful idiom in templated contexts where the underlying object could be either a raw Tensor or some deferred operation (e.\+g. a slice of a Tensor). In this case, the template code can wrap the object in a Tensor\+Ref and reason about its dimensionality while remaining agnostic to the underlying type.\hypertarget{eigen_tensors_autotoc_md1466}{}\doxysection{Constructors}\label{eigen_tensors_autotoc_md1466}
\hypertarget{eigen_tensors_autotoc_md1467}{}\doxysubsection{Tensor}\label{eigen_tensors_autotoc_md1467}
Creates a tensor of the specified size. The number of arguments must be equal to the rank of the tensor. The content of the tensor is not initialized. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(3, 4);
cout << "NumRows: " << a.dimension(0) << " NumCols: " << a.dimension(1) << endl;
=> NumRows: 3 NumCols: 4
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1468}{}\doxysubsection{Tensor\+Fixed\+Size}\label{eigen_tensors_autotoc_md1468}
Creates a tensor of the specified size. The number of arguments in the Sizes$<$$>$ template parameter determines the rank of the tensor. The content of the tensor is not initialized. \begin{DoxyVerb}Eigen::TensorFixedSize<float, Sizes<3, 4>> a;
cout << "Rank: " << a.rank() << endl;
=> Rank: 2
cout << "NumRows: " << a.dimension(0) << " NumCols: " << a.dimension(1) << endl;
=> NumRows: 3 NumCols: 4
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1469}{}\doxysubsection{Tensor\+Map}\label{eigen_tensors_autotoc_md1469}
Creates a tensor mapping an existing array of data. The data must not be freed until the Tensor\+Map is discarded, and the size of the data must be large enough to accommodate the coefficients of the tensor. \begin{DoxyVerb}float data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
Eigen::TensorMap<Tensor<float, 2>> a(data, 3, 4);
cout << "NumRows: " << a.dimension(0) << " NumCols: " << a.dimension(1) << endl;
=> NumRows: 3 NumCols: 4
cout << "a(1, 2): " << a(1, 2) << endl;
=> a(1, 2): 7
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1470}{}\doxysection{Contents Initialization}\label{eigen_tensors_autotoc_md1470}
When a new Tensor or a new Tensor\+Fixed\+Size are created, memory is allocated to hold all the tensor elements, but the memory is not initialized. Similarly, when a new Tensor\+Map is created on top of non-\/initialized memory the memory its contents are not initialized.

You can use one of the methods below to initialize the tensor memory. These have an immediate effect on the tensor and return the tensor itself as a result. These are not tensor Operations which delay evaluation.\hypertarget{eigen_tensors_autotoc_md1471}{}\doxysubsection{$<$\+Tensor-\/\+Type$>$ set\+Constant(const Scalar\& val)}\label{eigen_tensors_autotoc_md1471}
Sets all elements of the tensor to the constant value {\ttfamily val}. {\ttfamily Scalar} is the type of data stored in the tensor. You can pass any value that is convertible to that type.

Returns the tensor itself in case you want to chain another call. \begin{DoxyVerb}a.setConstant(12.3f);
cout << "Constant: " << endl << a << endl << endl;
=>
Constant:
12.3 12.3 12.3 12.3
12.3 12.3 12.3 12.3
12.3 12.3 12.3 12.3
\end{DoxyVerb}


Note that {\ttfamily set\+Constant()} can be used on any tensor where the element type has a copy constructor and an {\ttfamily operator=()}\+: \begin{DoxyVerb}Eigen::Tensor<string, 2> a(2, 3);
a.setConstant("yolo");
cout << "String tensor: " << endl << a << endl << endl;
=>
String tensor:
yolo yolo yolo
yolo yolo yolo
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1472}{}\doxysubsection{$<$\+Tensor-\/\+Type$>$ set\+Zero()}\label{eigen_tensors_autotoc_md1472}
Fills the tensor with zeros. Equivalent to {\ttfamily set\+Constant(\+Scalar(0))}. Returns the tensor itself in case you want to chain another call. \begin{DoxyVerb}a.setZero();
cout << "Zeros: " << endl << a << endl << endl;
=>
Zeros:
0 0 0 0
0 0 0 0
0 0 0 0
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1473}{}\doxysubsection{$<$\+Tensor-\/\+Type$>$ set\+Values(\{..\+initializer\+\_\+list\})}\label{eigen_tensors_autotoc_md1473}
Fills the tensor with explicit values specified in a std\+::initializer\+\_\+list. The type of the initializer list depends on the type and rank of the tensor.

If the tensor has rank N, the initializer list must be nested N times. The most deeply nested lists must contains P scalars of the Tensor type where P is the size of the last dimension of the Tensor.

For example, for a {\ttfamily Tensor\+Fixed\+Size$<$float, 2, 3$>$} the initializer list must contains 2 lists of 3 floats each.

{\ttfamily set\+Values()} returns the tensor itself in case you want to chain another call. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(2, 3);
a.setValues({{0.0f, 1.0f, 2.0f}, {3.0f, 4.0f, 5.0f}});
cout << "a" << endl << a << endl << endl;
=>
a
0 1 2
3 4 5
\end{DoxyVerb}


If a list is too short, the corresponding elements of the tensor will not be changed. This is valid at each level of nesting. For example the following code only sets the values of the first row of the tensor. \begin{DoxyVerb}Eigen::Tensor<int, 2> a(2, 3);
a.setConstant(1000);
a.setValues({{10, 20, 30}});
cout << "a" << endl << a << endl << endl;
=>
a
10   20   30
1000 1000 1000
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1474}{}\doxysubsection{$<$\+Tensor-\/\+Type$>$ set\+Random()}\label{eigen_tensors_autotoc_md1474}
Fills the tensor with random values. Returns the tensor itself in case you want to chain another call. \begin{DoxyVerb}a.setRandom();
cout << "Random: " << endl << a << endl << endl;
=>
Random:
  0.680375    0.59688  -0.329554    0.10794
 -0.211234   0.823295   0.536459 -0.0452059
  0.566198  -0.604897  -0.444451   0.257742
\end{DoxyVerb}


You can customize {\ttfamily set\+Random()} by providing your own random number generator as a template argument\+: \begin{DoxyVerb}a.setRandom<MyRandomGenerator>();
\end{DoxyVerb}


Here, {\ttfamily My\+Random\+Generator} must be a struct with the following member functions, where Scalar and Index are the same as {\ttfamily $<$Tensor-\/\+Type$>$\+::}{\ttfamily Scalar} and {\ttfamily $<$Tensor-\/\+Type$>$\+::}{\ttfamily Index}.

See {\ttfamily struct Uniform\+Random\+Generator} in Tensor\+Functors.\+h for an example. \begin{DoxyVerb}// Custom number generator for use with setRandom().
struct MyRandomGenerator {
  // Default and copy constructors. Both are needed
  MyRandomGenerator() { }
  MyRandomGenerator(const MyRandomGenerator& ) { }

  // Return a random value to be used.  "element_location" is the
  // location of the entry to set in the tensor, it can typically
  // be ignored.
  Scalar operator()(Eigen::DenseIndex element_location,
                    Eigen::DenseIndex /*unused*/ = 0) const {
    return <randomly generated value of type T>;
  }

  // Same as above but generates several numbers at a time.
  typename internal::packet_traits<Scalar>::type packetOp(
      Eigen::DenseIndex packet_location, Eigen::DenseIndex /*unused*/ = 0) const {
    return <a packet of randomly generated values>;
  }
};
\end{DoxyVerb}


You can also use one of the 2 random number generators that are part of the tensor library\+:
\begin{DoxyItemize}
\item Uniform\+Random\+Generator
\item Normal\+Random\+Generator
\end{DoxyItemize}\hypertarget{eigen_tensors_autotoc_md1475}{}\doxysection{Data Access}\label{eigen_tensors_autotoc_md1475}
The Tensor, Tensor\+Fixed\+Size, and Tensor\+Ref classes provide the following accessors to access the tensor coefficients\+: \begin{DoxyVerb}const Scalar& operator()(const array<Index, NumIndices>& indices)
const Scalar& operator()(Index firstIndex, IndexTypes... otherIndices)
Scalar& operator()(const array<Index, NumIndices>& indices)
Scalar& operator()(Index firstIndex, IndexTypes... otherIndices)
\end{DoxyVerb}


The number of indices must be equal to the rank of the tensor. Moreover, these accessors are not available on tensor expressions. In order to access the values of a tensor expression, the expression must either be evaluated or wrapped in a Tensor\+Ref.\hypertarget{eigen_tensors_autotoc_md1476}{}\doxysubsection{Scalar$\ast$ data() and const Scalar$\ast$ data() const}\label{eigen_tensors_autotoc_md1476}
Returns a pointer to the storage for the tensor. The pointer is const if the tensor was const. This allows direct access to the data. The layout of the data depends on the tensor layout\+: Row\+Major or Col\+Major.

This access is usually only needed for special cases, for example when mixing \mbox{\hyperlink{namespace_eigen}{Eigen}} Tensor code with other libraries.

Scalar is the type of data stored in the tensor. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(3, 4);
float* a_data = a.data();
a_data[0] = 123.45f;
cout << "a(0, 0): " << a(0, 0);
=> a(0, 0): 123.45
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1477}{}\doxysection{Tensor Operations}\label{eigen_tensors_autotoc_md1477}
All the methods documented below return non evaluated tensor {\ttfamily Operations}. These can be chained\+: you can apply another Tensor Operation to the value returned by the method.

The chain of Operation is evaluated lazily, typically when it is assigned to a tensor. See \char`\"{}\+Controlling when Expression are Evaluated\char`\"{} for more details about their evaluation.\hypertarget{eigen_tensors_autotoc_md1478}{}\doxysubsection{$<$\+Operation$>$ constant(const Scalar\& val)}\label{eigen_tensors_autotoc_md1478}
Returns a tensor of the same type and dimensions as the original tensor but where all elements have the value {\ttfamily val}.

This is useful, for example, when you want to add or subtract a constant from a tensor, or multiply every element of a tensor by a scalar. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(2, 3);
a.setConstant(1.0f);
Eigen::Tensor<float, 2> b = a + a.constant(2.0f);
Eigen::Tensor<float, 2> c = b * b.constant(0.2f);
cout << "a" << endl << a << endl << endl;
cout << "b" << endl << b << endl << endl;
cout << "c" << endl << c << endl << endl;
=>
a
1 1 1
1 1 1

b
3 3 3
3 3 3

c
0.6 0.6 0.6
0.6 0.6 0.6
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1479}{}\doxysubsection{$<$\+Operation$>$ random()}\label{eigen_tensors_autotoc_md1479}
Returns a tensor of the same type and dimensions as the current tensor but where all elements have random values.

This is for example useful to add random values to an existing tensor. The generation of random values can be customized in the same manner as for {\ttfamily set\+Random()}. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(2, 3);
a.setConstant(1.0f);
Eigen::Tensor<float, 2> b = a + a.random();
cout << "a" << endl << a << endl << endl;
cout << "b" << endl << b << endl << endl;
=>
a
1 1 1
1 1 1

b
1.68038   1.5662  1.82329
0.788766  1.59688 0.395103
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1480}{}\doxysection{Unary Element Wise Operations}\label{eigen_tensors_autotoc_md1480}
All these operations take a single input tensor as argument and return a tensor of the same type and dimensions as the tensor to which they are applied. The requested operations are applied to each element independently.\hypertarget{eigen_tensors_autotoc_md1481}{}\doxysubsection{$<$\+Operation$>$ operator-\/()}\label{eigen_tensors_autotoc_md1481}
Returns a tensor of the same type and dimensions as the original tensor containing the opposite values of the original tensor. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(2, 3);
a.setConstant(1.0f);
Eigen::Tensor<float, 2> b = -a;
cout << "a" << endl << a << endl << endl;
cout << "b" << endl << b << endl << endl;
=>
a
1 1 1
1 1 1

b
-1 -1 -1
-1 -1 -1
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1482}{}\doxysubsection{$<$\+Operation$>$ sqrt()}\label{eigen_tensors_autotoc_md1482}
Returns a tensor of the same type and dimensions as the original tensor containing the square roots of the original tensor.\hypertarget{eigen_tensors_autotoc_md1483}{}\doxysubsection{$<$\+Operation$>$ rsqrt()}\label{eigen_tensors_autotoc_md1483}
Returns a tensor of the same type and dimensions as the original tensor containing the inverse square roots of the original tensor.\hypertarget{eigen_tensors_autotoc_md1484}{}\doxysubsection{$<$\+Operation$>$ square()}\label{eigen_tensors_autotoc_md1484}
Returns a tensor of the same type and dimensions as the original tensor containing the squares of the original tensor values.\hypertarget{eigen_tensors_autotoc_md1485}{}\doxysubsection{$<$\+Operation$>$ inverse()}\label{eigen_tensors_autotoc_md1485}
Returns a tensor of the same type and dimensions as the original tensor containing the inverse of the original tensor values.\hypertarget{eigen_tensors_autotoc_md1486}{}\doxysubsection{$<$\+Operation$>$ exp()}\label{eigen_tensors_autotoc_md1486}
Returns a tensor of the same type and dimensions as the original tensor containing the exponential of the original tensor.\hypertarget{eigen_tensors_autotoc_md1487}{}\doxysubsection{$<$\+Operation$>$ log()}\label{eigen_tensors_autotoc_md1487}
Returns a tensor of the same type and dimensions as the original tensor containing the natural logarithms of the original tensor.\hypertarget{eigen_tensors_autotoc_md1488}{}\doxysubsection{$<$\+Operation$>$ abs()}\label{eigen_tensors_autotoc_md1488}
Returns a tensor of the same type and dimensions as the original tensor containing the absolute values of the original tensor.\hypertarget{eigen_tensors_autotoc_md1489}{}\doxysubsection{$<$\+Operation$>$ arg()}\label{eigen_tensors_autotoc_md1489}
Returns a tensor with the same dimensions as the original tensor containing the complex argument (phase angle) of the values of the original tensor.\hypertarget{eigen_tensors_autotoc_md1490}{}\doxysubsection{$<$\+Operation$>$ real()}\label{eigen_tensors_autotoc_md1490}
Returns a tensor with the same dimensions as the original tensor containing the real part of the complex values of the original tensor.\hypertarget{eigen_tensors_autotoc_md1491}{}\doxysubsection{$<$\+Operation$>$ imag()}\label{eigen_tensors_autotoc_md1491}
Returns a tensor with the same dimensions as the orginal tensor containing the imaginary part of the complex values of the original tensor.\hypertarget{eigen_tensors_autotoc_md1492}{}\doxysubsection{$<$\+Operation$>$ pow(\+Scalar exponent)}\label{eigen_tensors_autotoc_md1492}
Returns a tensor of the same type and dimensions as the original tensor containing the coefficients of the original tensor to the power of the exponent.

The type of the exponent, Scalar, is always the same as the type of the tensor coefficients. For example, only integer exponents can be used in conjuntion with tensors of integer values.

You can use cast() to lift this restriction. For example this computes cubic roots of an int Tensor\+: \begin{DoxyVerb}Eigen::Tensor<int, 2> a(2, 3);
a.setValues({{0, 1, 8}, {27, 64, 125}});
Eigen::Tensor<double, 2> b = a.cast<double>().pow(1.0 / 3.0);
cout << "a" << endl << a << endl << endl;
cout << "b" << endl << b << endl << endl;
=>
a
0   1   8
27  64 125

b
0 1 2
3 4 5
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1493}{}\doxysubsection{$<$\+Operation$>$  operator $\ast$ (\+Scalar scale)}\label{eigen_tensors_autotoc_md1493}
Multiplies all the coefficients of the input tensor by the provided scale.\hypertarget{eigen_tensors_autotoc_md1494}{}\doxysubsection{$<$\+Operation$>$  cwise\+Max(\+Scalar threshold)}\label{eigen_tensors_autotoc_md1494}
T\+O\+DO\hypertarget{eigen_tensors_autotoc_md1495}{}\doxysubsection{$<$\+Operation$>$  cwise\+Min(\+Scalar threshold)}\label{eigen_tensors_autotoc_md1495}
T\+O\+DO\hypertarget{eigen_tensors_autotoc_md1496}{}\doxysubsection{$<$\+Operation$>$  unary\+Expr(const Custom\+Unary\+Op\& func)}\label{eigen_tensors_autotoc_md1496}
T\+O\+DO\hypertarget{eigen_tensors_autotoc_md1497}{}\doxysection{Binary Element Wise Operations}\label{eigen_tensors_autotoc_md1497}
These operations take two input tensors as arguments. The 2 input tensors should be of the same type and dimensions. The result is a tensor of the same dimensions as the tensors to which they are applied, and unless otherwise specified it is also of the same type. The requested operations are applied to each pair of elements independently.\hypertarget{eigen_tensors_autotoc_md1498}{}\doxysubsection{$<$\+Operation$>$ operator+(const Other\+Derived\& other)}\label{eigen_tensors_autotoc_md1498}
Returns a tensor of the same type and dimensions as the input tensors containing the coefficient wise sums of the inputs.\hypertarget{eigen_tensors_autotoc_md1499}{}\doxysubsection{$<$\+Operation$>$ operator-\/(const Other\+Derived\& other)}\label{eigen_tensors_autotoc_md1499}
Returns a tensor of the same type and dimensions as the input tensors containing the coefficient wise differences of the inputs.\hypertarget{eigen_tensors_autotoc_md1500}{}\doxysubsection{$<$\+Operation$>$ operator$\ast$(const Other\+Derived\& other)}\label{eigen_tensors_autotoc_md1500}
Returns a tensor of the same type and dimensions as the input tensors containing the coefficient wise products of the inputs.\hypertarget{eigen_tensors_autotoc_md1501}{}\doxysubsection{$<$\+Operation$>$ operator/(const Other\+Derived\& other)}\label{eigen_tensors_autotoc_md1501}
Returns a tensor of the same type and dimensions as the input tensors containing the coefficient wise quotients of the inputs.

This operator is not supported for integer types.\hypertarget{eigen_tensors_autotoc_md1502}{}\doxysubsection{$<$\+Operation$>$ cwise\+Max(const Other\+Derived\& other)}\label{eigen_tensors_autotoc_md1502}
Returns a tensor of the same type and dimensions as the input tensors containing the coefficient wise maximums of the inputs.\hypertarget{eigen_tensors_autotoc_md1503}{}\doxysubsection{$<$\+Operation$>$ cwise\+Min(const Other\+Derived\& other)}\label{eigen_tensors_autotoc_md1503}
Returns a tensor of the same type and dimensions as the input tensors containing the coefficient wise mimimums of the inputs.\hypertarget{eigen_tensors_autotoc_md1504}{}\doxysubsection{$<$\+Operation$>$ Logical operators}\label{eigen_tensors_autotoc_md1504}
The following logical operators are supported as well\+:


\begin{DoxyItemize}
\item operator\&\&(const Other\+Derived\& other)
\item operator$\vert$$\vert$(const Other\+Derived\& other)
\item operator$<$(const Other\+Derived\& other)
\item operator$<$=(const Other\+Derived\& other)
\item operator$>$(const Other\+Derived\& other)
\item operator$>$=(const Other\+Derived\& other)
\item operator==(const Other\+Derived\& other)
\item operator!=(const Other\+Derived\& other)
\end{DoxyItemize}

They all return a tensor of boolean values.\hypertarget{eigen_tensors_autotoc_md1505}{}\doxysection{Selection (select(const Then\+Derived\& then\+Tensor, const Else\+Derived\& else\+Tensor)}\label{eigen_tensors_autotoc_md1505}
Selection is a coefficient-\/wise ternary operator that is the tensor equivalent to the if-\/then-\/else operation. \begin{DoxyVerb}Tensor<bool, 3> if = ...;
Tensor<float, 3> then = ...;
Tensor<float, 3> else = ...;
Tensor<float, 3> result = if.select(then, else);
\end{DoxyVerb}


The 3 arguments must be of the same dimensions, which will also be the dimension of the result. The \textquotesingle{}if\textquotesingle{} tensor must be of type boolean, the \textquotesingle{}then\textquotesingle{} and the \textquotesingle{}else\textquotesingle{} tensor must be of the same type, which will also be the type of the result.

Each coefficient in the result is equal to the corresponding coefficient in the \textquotesingle{}then\textquotesingle{} tensor if the corresponding value in the \textquotesingle{}if\textquotesingle{} tensor is true. If not, the resulting coefficient will come from the \textquotesingle{}else\textquotesingle{} tensor.\hypertarget{eigen_tensors_autotoc_md1506}{}\doxysection{Contraction}\label{eigen_tensors_autotoc_md1506}
Tensor {\itshape contractions} are a generalization of the matrix product to the multidimensional case. \begin{DoxyVerb}// Create 2 matrices using tensors of rank 2
Eigen::Tensor<int, 2> a(2, 3);
a.setValues({{1, 2, 3}, {6, 5, 4}});
Eigen::Tensor<int, 2> b(3, 2);
b.setValues({{1, 2}, {4, 5}, {5, 6}});

// Compute the traditional matrix product
Eigen::array<Eigen::IndexPair<int>, 1> product_dims = { Eigen::IndexPair<int>(1, 0) };
Eigen::Tensor<int, 2> AB = a.contract(b, product_dims);

// Compute the product of the transpose of the matrices
Eigen::array<Eigen::IndexPair<int>, 1> transposed_product_dims = { Eigen::IndexPair<int>(0, 1) };
Eigen::Tensor<int, 2> AtBt = a.contract(b, transposed_product_dims);

// Contraction to scalar value using a double contraction.
// First coordinate of both tensors are contracted as well as both second coordinates, i.e., this computes the sum of the squares of the elements.
Eigen::array<Eigen::IndexPair<int>, 2> double_contraction_product_dims = { Eigen::IndexPair<int>(0, 0), Eigen::IndexPair<int>(1, 1) };
Eigen::Tensor<int, 0> AdoubleContractedA = a.contract(a, double_contraction_product_dims);

// Extracting the scalar value of the tensor contraction for further usage
int value = AdoubleContractedA(0);
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1507}{}\doxysection{Reduction Operations}\label{eigen_tensors_autotoc_md1507}
A {\itshape Reduction} operation returns a tensor with fewer dimensions than the original tensor. The values in the returned tensor are computed by applying a {\itshape reduction operator} to slices of values from the original tensor. You specify the dimensions along which the slices are made.

The \mbox{\hyperlink{namespace_eigen}{Eigen}} Tensor library provides a set of predefined reduction operators such as {\ttfamily maximum()} and {\ttfamily sum()} and lets you define additional operators by implementing a few methods from a reductor template.\hypertarget{eigen_tensors_autotoc_md1508}{}\doxysubsection{Reduction Dimensions}\label{eigen_tensors_autotoc_md1508}
All reduction operations take a single parameter of type {\ttfamily $<$Tensor\+Type$>$\+::}{\ttfamily Dimensions} which can always be specified as an array of ints. These are called the \char`\"{}reduction dimensions.\char`\"{} The values are the indices of the dimensions of the input tensor over which the reduction is done. The parameter can have at most as many element as the rank of the input tensor; each element must be less than the tensor rank, as it indicates one of the dimensions to reduce.

Each dimension of the input tensor should occur at most once in the reduction dimensions as the implementation does not remove duplicates.

The order of the values in the reduction dimensions does not affect the results, but the code may execute faster if you list the dimensions in increasing order.

Example\+: Reduction along one dimension. \begin{DoxyVerb}// Create a tensor of 2 dimensions
Eigen::Tensor<int, 2> a(2, 3);
a.setValues({{1, 2, 3}, {6, 5, 4}});
// Reduce it along the second dimension (1)...
Eigen::array<int, 1> dims({1 /* dimension to reduce */});
// ...using the "maximum" operator.
// The result is a tensor with one dimension.  The size of
// that dimension is the same as the first (non-reduced) dimension of a.
Eigen::Tensor<int, 1> b = a.maximum(dims);
cout << "a" << endl << a << endl << endl;
cout << "b" << endl << b << endl << endl;
=>
a
1 2 3
6 5 4

b
3
6
\end{DoxyVerb}


Example\+: Reduction along two dimensions. \begin{DoxyVerb}Eigen::Tensor<float, 3, Eigen::ColMajor> a(2, 3, 4);
a.setValues({{{0.0f, 1.0f, 2.0f, 3.0f},
              {7.0f, 6.0f, 5.0f, 4.0f},
              {8.0f, 9.0f, 10.0f, 11.0f}},
             {{12.0f, 13.0f, 14.0f, 15.0f},
              {19.0f, 18.0f, 17.0f, 16.0f},
              {20.0f, 21.0f, 22.0f, 23.0f}}});
// The tensor a has 3 dimensions.  We reduce along the
// first 2, resulting in a tensor with a single dimension
// of size 4 (the last dimension of a.)
// Note that we pass the array of reduction dimensions
// directly to the maximum() call.
Eigen::Tensor<float, 1, Eigen::ColMajor> b =
    a.maximum(Eigen::array<int, 2>({0, 1}));
cout << "b" << endl << b << endl << endl;
=>
b
20
21
22
23
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1509}{}\doxysubsubsection{Reduction along all dimensions}\label{eigen_tensors_autotoc_md1509}
As a special case, if you pass no parameter to a reduction operation the original tensor is reduced along {\itshape all} its dimensions. The result is a scalar, represented as a zero-\/dimension tensor. \begin{DoxyVerb}Eigen::Tensor<float, 3> a(2, 3, 4);
a.setValues({{{0.0f, 1.0f, 2.0f, 3.0f},
              {7.0f, 6.0f, 5.0f, 4.0f},
              {8.0f, 9.0f, 10.0f, 11.0f}},
             {{12.0f, 13.0f, 14.0f, 15.0f},
              {19.0f, 18.0f, 17.0f, 16.0f},
              {20.0f, 21.0f, 22.0f, 23.0f}}});
// Reduce along all dimensions using the sum() operator.
Eigen::Tensor<float, 0> b = a.sum();
cout << "b" << endl << b << endl << endl;
=>
b
276
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1510}{}\doxysubsection{$<$\+Operation$>$ sum(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1510}
\hypertarget{eigen_tensors_autotoc_md1511}{}\doxysubsection{$<$\+Operation$>$ sum()}\label{eigen_tensors_autotoc_md1511}
Reduce a tensor using the sum() operator. The resulting values are the sum of the reduced values.\hypertarget{eigen_tensors_autotoc_md1512}{}\doxysubsection{$<$\+Operation$>$ mean(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1512}
\hypertarget{eigen_tensors_autotoc_md1513}{}\doxysubsection{$<$\+Operation$>$ mean()}\label{eigen_tensors_autotoc_md1513}
Reduce a tensor using the mean() operator. The resulting values are the mean of the reduced values.\hypertarget{eigen_tensors_autotoc_md1514}{}\doxysubsection{$<$\+Operation$>$ maximum(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1514}
\hypertarget{eigen_tensors_autotoc_md1515}{}\doxysubsection{$<$\+Operation$>$ maximum()}\label{eigen_tensors_autotoc_md1515}
Reduce a tensor using the maximum() operator. The resulting values are the largest of the reduced values.\hypertarget{eigen_tensors_autotoc_md1516}{}\doxysubsection{$<$\+Operation$>$ minimum(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1516}
\hypertarget{eigen_tensors_autotoc_md1517}{}\doxysubsection{$<$\+Operation$>$ minimum()}\label{eigen_tensors_autotoc_md1517}
Reduce a tensor using the minimum() operator. The resulting values are the smallest of the reduced values.\hypertarget{eigen_tensors_autotoc_md1518}{}\doxysubsection{$<$\+Operation$>$ prod(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1518}
\hypertarget{eigen_tensors_autotoc_md1519}{}\doxysubsection{$<$\+Operation$>$ prod()}\label{eigen_tensors_autotoc_md1519}
Reduce a tensor using the prod() operator. The resulting values are the product of the reduced values.\hypertarget{eigen_tensors_autotoc_md1520}{}\doxysubsection{$<$\+Operation$>$ all(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1520}
\hypertarget{eigen_tensors_autotoc_md1521}{}\doxysubsection{$<$\+Operation$>$ all()}\label{eigen_tensors_autotoc_md1521}
Reduce a tensor using the all() operator. Casts tensor to bool and then checks whether all elements are true. Runs through all elements rather than short-\/circuiting, so may be significantly inefficient.\hypertarget{eigen_tensors_autotoc_md1522}{}\doxysubsection{$<$\+Operation$>$ any(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1522}
\hypertarget{eigen_tensors_autotoc_md1523}{}\doxysubsection{$<$\+Operation$>$ any()}\label{eigen_tensors_autotoc_md1523}
Reduce a tensor using the \mbox{\hyperlink{group__core__func__vector__relational_ga632a2644532d9332011c8860400d30b2}{any()}} operator. Casts tensor to bool and then checks whether any element is true. Runs through all elements rather than short-\/circuiting, so may be significantly inefficient.\hypertarget{eigen_tensors_autotoc_md1524}{}\doxysubsection{$<$\+Operation$>$ reduce(const Dimensions\& new\+\_\+dims, const Reducer\& reducer)}\label{eigen_tensors_autotoc_md1524}
Reduce a tensor using a user-\/defined reduction operator. See {\ttfamily Sum\+Reducer} in Tensor\+Functors.\+h for information on how to implement a reduction operator.\hypertarget{eigen_tensors_autotoc_md1525}{}\doxysection{Trace}\label{eigen_tensors_autotoc_md1525}
A {\itshape \mbox{\hyperlink{class_trace}{Trace}}} operation returns a tensor with fewer dimensions than the original tensor. It returns a tensor whose elements are the sum of the elements of the original tensor along the main diagonal for a list of specified dimensions, the \char`\"{}trace dimensions\char`\"{}. Similar to the {\ttfamily Reduction Dimensions}, the trace dimensions are passed as an input parameter to the operation, are of type {\ttfamily $<$Tensor\+Type$>$\+::}{\ttfamily Dimensions} , and have the same requirements when passed as an input parameter. In addition, the trace dimensions must have the same size.

Example\+: \mbox{\hyperlink{class_trace}{Trace}} along 2 dimensions. \begin{DoxyVerb}// Create a tensor of 3 dimensions
Eigen::Tensor<int, 3> a(2, 2, 3);
a.setValues({{{1, 2, 3}, {4, 5, 6}}, {{7, 8, 9}, {10, 11, 12}}});
// Specify the dimensions along which the trace will be computed.
// In this example, the trace can only be computed along the dimensions
// with indices 0 and 1
Eigen::array<int, 2> dims({0, 1});
// The output tensor contains all but the trace dimensions.
Tensor<int, 1> a_trace = a.trace(dims);
cout << "a_trace:" << endl;
cout << a_trace << endl;
=>
a_trace:
11
13
15
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1526}{}\doxysubsection{$<$\+Operation$>$ trace(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1526}
\hypertarget{eigen_tensors_autotoc_md1527}{}\doxysubsection{$<$\+Operation$>$ trace()}\label{eigen_tensors_autotoc_md1527}
As a special case, if no parameter is passed to the operation, trace is computed along {\itshape all} dimensions of the input tensor.

Example\+: \mbox{\hyperlink{class_trace}{Trace}} along all dimensions. \begin{DoxyVerb}// Create a tensor of 3 dimensions, with all dimensions having the same size.
Eigen::Tensor<int, 3> a(3, 3, 3);
a.setValues({{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},
            {{10, 11, 12}, {13, 14, 15}, {16, 17, 18}},
            {{19, 20, 21}, {22, 23, 24}, {25, 26, 27}}});
// Result is a zero dimension tensor
Tensor<int, 0> a_trace = a.trace();
cout<<"a_trace:"<<endl;
cout<<a_trace<<endl;
=>
a_trace:
42
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1528}{}\doxysection{Scan Operations}\label{eigen_tensors_autotoc_md1528}
A {\itshape Scan} operation returns a tensor with the same dimensions as the original tensor. The operation performs an inclusive scan along the specified axis, which means it computes a running total along the axis for a given reduction operation. If the reduction operation corresponds to summation, then this computes the prefix sum of the tensor along the given axis.

Example\+: dd a comment to this line \begin{DoxyVerb}// Create a tensor of 2 dimensions
Eigen::Tensor<int, 2> a(2, 3);
a.setValues({{1, 2, 3}, {4, 5, 6}});
// Scan it along the second dimension (1) using summation
Eigen::Tensor<int, 2> b = a.cumsum(1);
// The result is a tensor with the same size as the input
cout << "a" << endl << a << endl << endl;
cout << "b" << endl << b << endl << endl;
=>
a
1 2 3
4 5 6

b
1  3  6
4  9 15
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1529}{}\doxysubsection{$<$\+Operation$>$ cumsum(const Index\& axis)}\label{eigen_tensors_autotoc_md1529}
Perform a scan by summing consecutive entries.\hypertarget{eigen_tensors_autotoc_md1530}{}\doxysubsection{$<$\+Operation$>$ cumprod(const Index\& axis)}\label{eigen_tensors_autotoc_md1530}
Perform a scan by multiplying consecutive entries.\hypertarget{eigen_tensors_autotoc_md1531}{}\doxysection{Convolutions}\label{eigen_tensors_autotoc_md1531}
\hypertarget{eigen_tensors_autotoc_md1532}{}\doxysubsection{$<$\+Operation$>$ convolve(const Kernel\& kernel, const Dimensions\& dims)}\label{eigen_tensors_autotoc_md1532}
Returns a tensor that is the output of the convolution of the input tensor with the kernel, along the specified dimensions of the input tensor. The dimension size for dimensions of the output tensor which were part of the convolution will be reduced by the formula\+: output\+\_\+dim\+\_\+size = input\+\_\+dim\+\_\+size -\/ kernel\+\_\+dim\+\_\+size + 1 (requires\+: input\+\_\+dim\+\_\+size $>$= kernel\+\_\+dim\+\_\+size). The dimension sizes for dimensions that were not part of the convolution will remain the same. Performance of the convolution can depend on the length of the stride(s) of the input tensor dimension(s) along which the convolution is computed (the first dimension has the shortest stride for Col\+Major, whereas Row\+Major\textquotesingle{}s shortest stride is for the last dimension). \begin{DoxyVerb}// Compute convolution along the second and third dimension.
Tensor<float, 4, DataLayout> input(3, 3, 7, 11);
Tensor<float, 2, DataLayout> kernel(2, 2);
Tensor<float, 4, DataLayout> output(3, 2, 6, 11);
input.setRandom();
kernel.setRandom();

Eigen::array<ptrdiff_t, 2> dims({1, 2});  // Specify second and third dimension for convolution.
output = input.convolve(kernel, dims);

for (int i = 0; i < 3; ++i) {
  for (int j = 0; j < 2; ++j) {
    for (int k = 0; k < 6; ++k) {
      for (int l = 0; l < 11; ++l) {
        const float result = output(i,j,k,l);
        const float expected = input(i,j+0,k+0,l) * kernel(0,0) +
                               input(i,j+1,k+0,l) * kernel(1,0) +
                               input(i,j+0,k+1,l) * kernel(0,1) +
                               input(i,j+1,k+1,l) * kernel(1,1);
        VERIFY_IS_APPROX(result, expected);
      }
    }
  }
}
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1533}{}\doxysection{Geometrical Operations}\label{eigen_tensors_autotoc_md1533}
These operations return a Tensor with different dimensions than the original Tensor. They can be used to access slices of tensors, see them with different dimensions, or pad tensors with additional data.\hypertarget{eigen_tensors_autotoc_md1534}{}\doxysubsection{$<$\+Operation$>$ reshape(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1534}
Returns a view of the input tensor that has been reshaped to the specified new dimensions. The argument new\+\_\+dims is an array of Index values. The rank of the resulting tensor is equal to the number of elements in new\+\_\+dims.

The product of all the sizes in the new dimension array must be equal to the number of elements in the input tensor. \begin{DoxyVerb}// Increase the rank of the input tensor by introducing a new dimension
// of size 1.
Tensor<float, 2> input(7, 11);
array<int, 3> three_dims{{7, 11, 1}};
Tensor<float, 3> result = input.reshape(three_dims);

// Decrease the rank of the input tensor by merging 2 dimensions;
array<int, 1> one_dim{{7 * 11}};
Tensor<float, 1> result = input.reshape(one_dim);
\end{DoxyVerb}


This operation does not move any data in the input tensor, so the resulting contents of a reshaped Tensor depend on the data layout of the original Tensor.

For example this is what happens when you {\ttfamily reshape()} a 2D Col\+Major tensor to one dimension\+: \begin{DoxyVerb}Eigen::Tensor<float, 2, Eigen::ColMajor> a(2, 3);
a.setValues({{0.0f, 100.0f, 200.0f}, {300.0f, 400.0f, 500.0f}});
Eigen::array<Eigen::DenseIndex, 1> one_dim({3 * 2});
Eigen::Tensor<float, 1, Eigen::ColMajor> b = a.reshape(one_dim);
cout << "b" << endl << b << endl;
=>
b
  0
300
100
400
200
500
\end{DoxyVerb}


This is what happens when the 2D Tensor is Row\+Major\+: \begin{DoxyVerb}Eigen::Tensor<float, 2, Eigen::RowMajor> a(2, 3);
a.setValues({{0.0f, 100.0f, 200.0f}, {300.0f, 400.0f, 500.0f}});
Eigen::array<Eigen::DenseIndex, 1> one_dim({3 * 2});
Eigen::Tensor<float, 1, Eigen::RowMajor> b = a.reshape(one_dim);
cout << "b" << endl << b << endl;
=>
b
  0
100
200
300
400
500
\end{DoxyVerb}


The reshape operation is a lvalue. In other words, it can be used on the left side of the assignment operator.

The previous example can be rewritten as follow\+: \begin{DoxyVerb}Eigen::Tensor<float, 2, Eigen::ColMajor> a(2, 3);
a.setValues({{0.0f, 100.0f, 200.0f}, {300.0f, 400.0f, 500.0f}});
Eigen::array<Eigen::DenseIndex, 2> two_dim({2, 3});
Eigen::Tensor<float, 1, Eigen::ColMajor> b(6);
b.reshape(two_dim) = a;
cout << "b" << endl << b << endl;
=>
b
  0
300
100
400
200
500
\end{DoxyVerb}


Note that \char`\"{}b\char`\"{} itself was not reshaped but that instead the assignment is done to the reshape view of b.\hypertarget{eigen_tensors_autotoc_md1535}{}\doxysubsection{$<$\+Operation$>$ shuffle(const Shuffle\& shuffle)}\label{eigen_tensors_autotoc_md1535}
Returns a copy of the input tensor whose dimensions have been reordered according to the specified permutation. The argument shuffle is an array of Index values. Its size is the rank of the input tensor. It must contain a permutation of 0, 1, ..., rank -\/ 1. The i-\/th dimension of the output tensor equals to the size of the shuffle\mbox{[}i\mbox{]}-\/th dimension of the input tensor. For example\+: \begin{DoxyVerb}// Shuffle all dimensions to the left by 1.
Tensor<float, 3> input(20, 30, 50);
// ... set some values in input.
Tensor<float, 3> output = input.shuffle({1, 2, 0})

eigen_assert(output.dimension(0) == 30);
eigen_assert(output.dimension(1) == 50);
eigen_assert(output.dimension(2) == 20);
\end{DoxyVerb}


Indices into the output tensor are shuffled accordingly to formulate indices into the input tensor. For example, one can assert in the above code snippet that\+: \begin{DoxyVerb}eigen_assert(output(3, 7, 11) == input(11, 3, 7));
\end{DoxyVerb}


In general, one can assert that \begin{DoxyVerb}eigen_assert(output(..., indices[shuffle[i]], ...) ==
             input(..., indices[i], ...))
\end{DoxyVerb}


The shuffle operation results in a lvalue, which means that it can be assigned to. In other words, it can be used on the left side of the assignment operator.

Let\textquotesingle{}s rewrite the previous example to take advantage of this feature\+: \begin{DoxyVerb}// Shuffle all dimensions to the left by 1.
Tensor<float, 3> input(20, 30, 50);
// ... set some values in input.
Tensor<float, 3> output(30, 50, 20);
output.shuffle({2, 0, 1}) = input;
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1536}{}\doxysubsection{$<$\+Operation$>$ stride(const Strides\& strides)}\label{eigen_tensors_autotoc_md1536}
Returns a view of the input tensor that strides (skips stride-\/1 elements) along each of the dimensions. The argument strides is an array of Index values. The dimensions of the resulting tensor are ceil(input\+\_\+dimensions\mbox{[}i\mbox{]} / strides\mbox{[}i\mbox{]}).

For example this is what happens when you {\ttfamily stride()} a 2D tensor\+: \begin{DoxyVerb}Eigen::Tensor<int, 2> a(4, 3);
a.setValues({{0, 100, 200}, {300, 400, 500}, {600, 700, 800}, {900, 1000, 1100}});
Eigen::array<Eigen::DenseIndex, 2> strides({3, 2});
Eigen::Tensor<int, 2> b = a.stride(strides);
cout << "b" << endl << b << endl;
=>
b
   0   200
 900  1100
\end{DoxyVerb}


It is possible to assign a tensor to a stride\+: Tensor$<$float, 3$>$ input(20, 30, 50); // ... set some values in input. Tensor$<$float, 3$>$ output(40, 90, 200); output.\+stride(\{2, 3, 4\}) = input;\hypertarget{eigen_tensors_autotoc_md1537}{}\doxysubsection{$<$\+Operation$>$ slice(const Start\+Indices\& offsets, const Sizes\& extents)}\label{eigen_tensors_autotoc_md1537}
Returns a sub-\/tensor of the given tensor. For each dimension i, the slice is made of the coefficients stored between offset\mbox{[}i\mbox{]} and offset\mbox{[}i\mbox{]} + extents\mbox{[}i\mbox{]} in the input tensor. \begin{DoxyVerb}Eigen::Tensor<int, 2> a(4, 3);
a.setValues({{0, 100, 200}, {300, 400, 500},
             {600, 700, 800}, {900, 1000, 1100}});
Eigen::array<Eigen::Index, 2> offsets = {1, 0};
Eigen::array<Eigen::Index, 2> extents = {2, 2};
Eigen::Tensor<int, 2> slice = a.slice(offsets, extents);
cout << "a" << endl << a << endl;
=>
a
   0   100   200
 300   400   500
 600   700   800
 900  1000  1100
cout << "slice" << endl << slice << endl;
=>
slice
 300   400
 600   700
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1538}{}\doxysubsection{$<$\+Operation$>$ chip(const Index offset, const Index dim)}\label{eigen_tensors_autotoc_md1538}
A chip is a special kind of slice. It is the subtensor at the given offset in the dimension dim. The returned tensor has one fewer dimension than the input tensor\+: the dimension dim is removed.

For example, a matrix chip would be either a row or a column of the input matrix. \begin{DoxyVerb}Eigen::Tensor<int, 2> a(4, 3);
a.setValues({{0, 100, 200}, {300, 400, 500},
             {600, 700, 800}, {900, 1000, 1100}});
Eigen::Tensor<int, 1> row_3 = a.chip(2, 0);
Eigen::Tensor<int, 1> col_2 = a.chip(1, 1);
cout << "a" << endl << a << endl;
=>
a
   0   100   200
 300   400   500
 600   700   800
 900  1000  1100
cout << "row_3" << endl << row_3 << endl;
=>
row_3
   600   700   800
cout << "col_2" << endl << col_2 << endl;
=>
col_2
   100   400   700    1000
\end{DoxyVerb}


It is possible to assign values to a tensor chip since the chip operation is a lvalue. For example\+: \begin{DoxyVerb}Eigen::Tensor<int, 1> a(3);
a.setValues({{100, 200, 300}});
Eigen::Tensor<int, 2> b(2, 3);
b.setZero();
b.chip(0, 0) = a;
cout << "a" << endl << a << endl;
=>
a
 100
 200
 300
cout << "b" << endl << b << endl;
=>
b
   100   200   300
     0     0     0
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1539}{}\doxysubsection{$<$\+Operation$>$ reverse(const Reverse\+Dimensions\& reverse)}\label{eigen_tensors_autotoc_md1539}
Returns a view of the input tensor that reverses the order of the coefficients along a subset of the dimensions. The argument reverse is an array of boolean values that indicates whether or not the order of the coefficients should be reversed along each of the dimensions. This operation preserves the dimensions of the input tensor.

For example this is what happens when you {\ttfamily reverse()} the first dimension of a 2D tensor\+: \begin{DoxyVerb}Eigen::Tensor<int, 2> a(4, 3);
a.setValues({{0, 100, 200}, {300, 400, 500},
            {600, 700, 800}, {900, 1000, 1100}});
Eigen::array<bool, 2> reverse({true, false});
Eigen::Tensor<int, 2> b = a.reverse(reverse);
cout << "a" << endl << a << endl << "b" << endl << b << endl;
=>
a
   0   100   200
 300   400   500
 600   700   800
 900  1000  1100
b
 900  1000  1100
 600   700   800
 300   400   500
   0   100   200
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1540}{}\doxysubsection{$<$\+Operation$>$ broadcast(const Broadcast\& broadcast)}\label{eigen_tensors_autotoc_md1540}
Returns a view of the input tensor in which the input is replicated one to many times. The broadcast argument specifies how many copies of the input tensor need to be made in each of the dimensions. \begin{DoxyVerb}Eigen::Tensor<int, 2> a(2, 3);
a.setValues({{0, 100, 200}, {300, 400, 500}});
Eigen::array<int, 2> bcast({3, 2});
Eigen::Tensor<int, 2> b = a.broadcast(bcast);
cout << "a" << endl << a << endl << "b" << endl << b << endl;
=>
a
   0   100   200
 300   400   500
b
   0   100   200    0   100   200
 300   400   500  300   400   500
   0   100   200    0   100   200
 300   400   500  300   400   500
   0   100   200    0   100   200
 300   400   500  300   400   500
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1541}{}\doxysubsection{$<$\+Operation$>$ concatenate(const Other\+Derived\& other, Axis axis)}\label{eigen_tensors_autotoc_md1541}
T\+O\+DO\hypertarget{eigen_tensors_autotoc_md1542}{}\doxysubsection{$<$\+Operation$>$  pad(const Padding\+Dimensions\& padding)}\label{eigen_tensors_autotoc_md1542}
Returns a view of the input tensor in which the input is padded with zeros. \begin{DoxyVerb}Eigen::Tensor<int, 2> a(2, 3);
a.setValues({{0, 100, 200}, {300, 400, 500}});
Eigen::array<pair<int, int>, 2> paddings;
paddings[0] = make_pair(0, 1);
paddings[1] = make_pair(2, 3);
Eigen::Tensor<int, 2> b = a.pad(paddings);
cout << "a" << endl << a << endl << "b" << endl << b << endl;
=>
a
   0   100   200
 300   400   500
b
   0     0     0    0
   0     0     0    0
   0   100   200    0
 300   400   500    0
   0     0     0    0
   0     0     0    0
   0     0     0    0
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1543}{}\doxysubsection{$<$\+Operation$>$  extract\+\_\+patches(const Patch\+Dims\& patch\+\_\+dims)}\label{eigen_tensors_autotoc_md1543}
Returns a tensor of coefficient patches extracted from the input tensor, where each patch is of dimension specified by \textquotesingle{}patch\+\_\+dims\textquotesingle{}. The returned tensor has one greater dimension than the input tensor, which is used to index each patch. The patch index in the output tensor depends on the data layout of the input tensor\+: the patch index is the last dimension Col\+Major layout, and the first dimension in Row\+Major layout.

For example, given the following input tensor\+: \begin{DoxyVerb}Eigen::Tensor<float, 2, DataLayout> tensor(3,4);
tensor.setValues({{0.0f, 1.0f, 2.0f, 3.0f},
                  {4.0f, 5.0f, 6.0f, 7.0f},
                  {8.0f, 9.0f, 10.0f, 11.0f}});

cout << "tensor: " << endl << tensor << endl;
=>
tensor:
 0   1   2   3
 4   5   6   7
 8   9  10  11
\end{DoxyVerb}


Six 2x2 patches can be extracted and indexed using the following code\+: \begin{DoxyVerb}Eigen::Tensor<float, 3, DataLayout> patch;
Eigen::array<ptrdiff_t, 2> patch_dims;
patch_dims[0] = 2;
patch_dims[1] = 2;
patch = tensor.extract_patches(patch_dims);
for (int k = 0; k < 6; ++k) {
  cout << "patch index: " << k << endl;
  for (int i = 0; i < 2; ++i) {
    for (int j = 0; j < 2; ++j) {
      if (DataLayout == ColMajor) {
        cout << patch(i, j, k) << " ";
      } else {
        cout << patch(k, i, j) << " ";
      }
    }
    cout << endl;
  }
}
\end{DoxyVerb}


This code results in the following output when the data layout is Col\+Major\+: \begin{DoxyVerb}patch index: 0
0 1
4 5
patch index: 1
4 5
8 9
patch index: 2
1 2
5 6
patch index: 3
5 6
9 10
patch index: 4
2 3
6 7
patch index: 5
6 7
10 11
\end{DoxyVerb}


This code results in the following output when the data layout is Row\+Major\+: (N\+O\+TE\+: the set of patches is the same as in Col\+Major, but are indexed differently). \begin{DoxyVerb}patch index: 0
0 1
4 5
patch index: 1
1 2
5 6
patch index: 2
2 3
6 7
patch index: 3
4 5
8 9
patch index: 4
5 6
9 10
patch index: 5
6 7
10 11
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1544}{}\doxysubsection{$<$\+Operation$>$  extract\+\_\+image\+\_\+patches(const Index patch\+\_\+rows, const Index patch\+\_\+cols, const Index row\+\_\+stride, const Index col\+\_\+stride, const Padding\+Type padding\+\_\+type)}\label{eigen_tensors_autotoc_md1544}
Returns a tensor of coefficient image patches extracted from the input tensor, which is expected to have dimensions ordered as follows (depending on the data layout of the input tensor, and the number of additional dimensions \textquotesingle{}N\textquotesingle{})\+:

$\ast$) Col\+Major 1st dimension\+: channels (of size d) 2nd dimension\+: rows (of size r) 3rd dimension\+: columns (of size c) 4th-\/\+Nth dimension\+: time (for video) or batch (for bulk processing).

$\ast$) Row\+Major (reverse order of Col\+Major) 1st-\/\+Nth dimension\+: time (for video) or batch (for bulk processing). N+1\textquotesingle{}th dimension\+: columns (of size c) N+2\textquotesingle{}th dimension\+: rows (of size r) N+3\textquotesingle{}th dimension\+: channels (of size d)

The returned tensor has one greater dimension than the input tensor, which is used to index each patch. The patch index in the output tensor depends on the data layout of the input tensor\+: the patch index is the 4\textquotesingle{}th dimension in Col\+Major layout, and the 4\textquotesingle{}th from the last dimension in Row\+Major layout.

For example, given the following input tensor with the following dimension sizes\+: $\ast$) depth\+: 2 $\ast$) rows\+: 3 $\ast$) columns\+: 5 $\ast$) batch\+: 7

Tensor$<$float, 4$>$ tensor(2,3,5,7); Tensor$<$float, 4, Row\+Major$>$ tensor\+\_\+row\+\_\+major = tensor.\+swap\+\_\+layout();

2x2 image patches can be extracted and indexed using the following code\+:

$\ast$) 2D patch\+: Col\+Major (patch indexed by second-\/to-\/last dimension) \begin{DoxyVerb}Tensor<float, 5> twod_patch;
twod_patch = tensor.extract_image_patches<2, 2>();
// twod_patch.dimension(0) == 2
// twod_patch.dimension(1) == 2
// twod_patch.dimension(2) == 2
// twod_patch.dimension(3) == 3*5
// twod_patch.dimension(4) == 7
\end{DoxyVerb}


$\ast$) 2D patch\+: Row\+Major (patch indexed by the second dimension) \begin{DoxyVerb}Tensor<float, 5, RowMajor> twod_patch_row_major;
twod_patch_row_major = tensor_row_major.extract_image_patches<2, 2>();
// twod_patch_row_major.dimension(0) == 7
// twod_patch_row_major.dimension(1) == 3*5
// twod_patch_row_major.dimension(2) == 2
// twod_patch_row_major.dimension(3) == 2
// twod_patch_row_major.dimension(4) == 2
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1545}{}\doxysection{Special Operations}\label{eigen_tensors_autotoc_md1545}
\hypertarget{eigen_tensors_autotoc_md1546}{}\doxysubsection{$<$\+Operation$>$ cast$<$\+T$>$()}\label{eigen_tensors_autotoc_md1546}
Returns a tensor of type T with the same dimensions as the original tensor. The returned tensor contains the values of the original tensor converted to type T. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(2, 3);
Eigen::Tensor<int, 2> b = a.cast<int>();
\end{DoxyVerb}


This can be useful for example if you need to do element-\/wise division of Tensors of integers. This is not currently supported by the Tensor library but you can easily cast the tensors to floats to do the division\+: \begin{DoxyVerb}Eigen::Tensor<int, 2> a(2, 3);
a.setValues({{0, 1, 2}, {3, 4, 5}});
Eigen::Tensor<int, 2> b =
    (a.cast<float>() / a.constant(2).cast<float>()).cast<int>();
cout << "a" << endl << a << endl << endl;
cout << "b" << endl << b << endl << endl;
=>
a
0 1 2
3 4 5

b
0 0 1
1 2 2
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1547}{}\doxysubsection{$<$\+Operation$>$     eval()}\label{eigen_tensors_autotoc_md1547}
T\+O\+DO\hypertarget{eigen_tensors_autotoc_md1548}{}\doxysection{Tensor Printing}\label{eigen_tensors_autotoc_md1548}
Tensors can be printed into a stream object (e.\+g. {\ttfamily std\+::cout}) using different formatting options. \begin{DoxyVerb}Eigen::Tensor<float, 3> tensor3d = {4, 3, 2};
tensor3d.setValues( {{{1, 2}, {3, 4}, {5, 6}}, {{7, 8}, {9, 10}, {11, 12}}, {{13, 14}, {15, 16}, {17, 18}}, {{19, 20}, {21, 22}, {23, 24}}} );
std::cout << tensor3d.format(Eigen::TensorIOFormat::Plain()) << std::endl;
==>
 1  2 
 3  4 
 5  6 

 7  8 
 9 10
11 12

13 14
15 16
17 18

19 20
21 22
23 24
\end{DoxyVerb}


In the example, we used the predefined format {\ttfamily Eigen\+::\+Tensor\+I\+O\+Format\+::\+Plain}. Here is the list of all predefined formats from which you can choose\+:
\begin{DoxyItemize}
\item {\ttfamily Eigen\+::\+Tensor\+I\+O\+Format\+::\+Plain()} for a plain output without braces. Different submatrices are separated by a blank line.
\item {\ttfamily Eigen\+::\+Tensor\+I\+O\+Format\+::\+Numpy()} for numpy-\/like output.
\item {\ttfamily Eigen\+::\+Tensor\+I\+O\+Format\+::\+Native()} for a {\ttfamily c++} like output which can be directly copy-\/pasted to set\+Values().
\item {\ttfamily Eigen\+::\+Tensor\+I\+O\+Format\+::\+Legacy()} for a backwards compatible printing of tensors.
\end{DoxyItemize}

If you send the tensor directly to the stream the default format is called which is {\ttfamily Eigen\+::\+I\+O\+Formats\+::\+Plain()}.

You can define your own format by explicitly providing a {\ttfamily \mbox{\hyperlink{struct_eigen_1_1_tensor_i_o_format}{Eigen\+::\+Tensor\+I\+O\+Format}}} class instance. Here, you can specify\+:
\begin{DoxyItemize}
\item The overall prefix and suffix with {\ttfamily std\+::string ten\+Prefix} and {\ttfamily std\+::string ten\+Suffix}
\item The prefix, separator and suffix for each new element, row, matrix, 3d subtensor, ... with {\ttfamily std\+::vector$<$std\+::string$>$ prefix}, {\ttfamily std\+::vector$<$std\+::string$>$ separator} and {\ttfamily std\+::vector$<$std\+::string$>$ suffix}. Note that the first entry in each of the vectors refer to the last dimension of the tensor, e.\+g. {\ttfamily separator\mbox{[}0\mbox{]}} will be printed between adjacent elements, {\ttfamily separator\mbox{[}1\mbox{]}} will be printed between adjacent matrices, ...
\item {\ttfamily char fill}\+: character which will be placed if the elements are aligned.
\item {\ttfamily int precision}
\item {\ttfamily int flags}\+: an O\+R-\/ed combination of flags, the default value is 0, the only currently available flag is {\ttfamily Eigen\+::\+Dont\+Align\+Cols} which allows to disable the alignment of columns, resulting in faster code.
\end{DoxyItemize}\hypertarget{eigen_tensors_autotoc_md1549}{}\doxysection{Representation of scalar values}\label{eigen_tensors_autotoc_md1549}
Scalar values are often represented by tensors of size 1 and rank 0.\+For example Tensor$<$\+T, N$>$\+::maximum() currently returns a Tensor$<$\+T, 0$>$. Similarly, the inner product of 2 1d tensors (through contractions) returns a 0d tensor.\hypertarget{eigen_tensors_autotoc_md1550}{}\doxysection{Limitations}\label{eigen_tensors_autotoc_md1550}

\begin{DoxyItemize}
\item The number of tensor dimensions is currently limited to 250 when using a compiler that supports cxx11. It is limited to only 5 for older compilers.
\item The Index\+List class requires a cxx11 compliant compiler. You can use an array of indices instead if you don\textquotesingle{}t have access to a modern compiler.
\item On G\+P\+Us only floating point values are properly tested and optimized for.
\end{DoxyItemize}

Tensors are multidimensional arrays of elements. Elements are typically scalars, but more complex types such as strings are also supported.\hypertarget{eigen_tensors_autotoc_md1567}{}\doxysection{Tensor Classes}\label{eigen_tensors_autotoc_md1567}
You can manipulate a tensor with one of the following classes. They all are in the namespace {\ttfamily \mbox{\hyperlink{namespace_eigen}{Eigen}}.}\hypertarget{eigen_tensors_autotoc_md1568}{}\doxysubsection{Class Tensor$<$data\+\_\+type, rank$>$}\label{eigen_tensors_autotoc_md1568}
This is the class to use to create a tensor and allocate memory for it. The class is templatized with the tensor datatype, such as float or int, and the tensor rank. The rank is the number of dimensions, for example rank 2 is a matrix.

Tensors of this class are resizable. For example, if you assign a tensor of a different size to a Tensor, that tensor is resized to match its new value.\hypertarget{eigen_tensors_autotoc_md1569}{}\doxysubsubsection{Constructor Tensor$<$data\+\_\+type, rank$>$(size0, size1, ...)}\label{eigen_tensors_autotoc_md1569}
Constructor for a Tensor. The constructor must be passed {\ttfamily rank} integers indicating the sizes of the instance along each of the the {\ttfamily rank} dimensions. \begin{DoxyVerb}// Create a tensor of rank 3 of sizes 2, 3, 4.  This tensor owns
// memory to hold 24 floating point values (24 = 2 x 3 x 4).
Tensor<float, 3> t_3d(2, 3, 4);

// Resize t_3d by assigning a tensor of different sizes, but same rank.
t_3d = Tensor<float, 3>(3, 4, 3);
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1570}{}\doxysubsubsection{Constructor Tensor$<$data\+\_\+type, rank$>$(size\+\_\+array)}\label{eigen_tensors_autotoc_md1570}
Constructor where the sizes for the constructor are specified as an array of values instead of an explicitly list of parameters. The array type to use is {\ttfamily Eigen\+::array$<$\mbox{\hyperlink{namespace_eigen_a62e77e0933482dafde8fe197d9a2cfde}{Eigen\+::\+Index}}$>$}. The array can be constructed automatically from an initializer list. \begin{DoxyVerb}// Create a tensor of strings of rank 2 with sizes 5, 7.
Tensor<string, 2> t_2d({5, 7});
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1571}{}\doxysubsection{Class Tensor\+Fixed\+Size$<$data\+\_\+type, Sizes$<$size0, size1, ...$>$$>$}\label{eigen_tensors_autotoc_md1571}
Class to use for tensors of fixed size, where the size is known at compile time. Fixed sized tensors can provide very fast computations because all their dimensions are known by the compiler. Fixed\+Size tensors are not resizable.

If the total number of elements in a fixed size tensor is small enough the tensor data is held onto the stack and does not cause heap allocation and free. \begin{DoxyVerb}// Create a 4 x 3 tensor of floats.
TensorFixedSize<float, Sizes<4, 3>> t_4x3;
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1572}{}\doxysubsection{Class Tensor\+Map$<$\+Tensor$<$data\+\_\+type, rank$>$$>$}\label{eigen_tensors_autotoc_md1572}
This is the class to use to create a tensor on top of memory allocated and owned by another part of your code. It allows to view any piece of allocated memory as a Tensor. Instances of this class do not own the memory where the data are stored.

A Tensor\+Map is not resizable because it does not own the memory where its data are stored.\hypertarget{eigen_tensors_autotoc_md1573}{}\doxysubsubsection{Constructor Tensor\+Map$<$\+Tensor$<$data\+\_\+type, rank$>$$>$(data, size0, size1, ...)}\label{eigen_tensors_autotoc_md1573}
Constructor for a Tensor. The constructor must be passed a pointer to the storage for the data, and \char`\"{}rank\char`\"{} size attributes. The storage has to be large enough to hold all the data. \begin{DoxyVerb}// Map a tensor of ints on top of stack-allocated storage.
int storage[128];  // 2 x 4 x 2 x 8 = 128
TensorMap<Tensor<int, 4>> t_4d(storage, 2, 4, 2, 8);

// The same storage can be viewed as a different tensor.
// You can also pass the sizes as an array.
TensorMap<Tensor<int, 2>> t_2d(storage, 16, 8);

// You can also map fixed-size tensors.  Here we get a 1d view of
// the 2d fixed-size tensor.
TensorFixedSize<float, Sizes<4, 3>> t_4x3;
TensorMap<Tensor<float, 1>> t_12(t_4x3.data(), 12);
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1574}{}\doxysubsubsection{Class Tensor\+Ref}\label{eigen_tensors_autotoc_md1574}
See Assigning to a Tensor\+Ref below.\hypertarget{eigen_tensors_autotoc_md1575}{}\doxysection{Accessing Tensor Elements}\label{eigen_tensors_autotoc_md1575}
\hypertarget{eigen_tensors_autotoc_md1576}{}\doxysubsubsection{$<$data\+\_\+type$>$ tensor(index0, index1...)}\label{eigen_tensors_autotoc_md1576}
Return the element at position {\ttfamily (index0, index1...)} in tensor {\ttfamily tensor}. You must pass as many parameters as the rank of {\ttfamily tensor}. The expression can be used as an l-\/value to set the value of the element at the specified position. The value returned is of the datatype of the tensor. \begin{DoxyVerb}// Set the value of the element at position (0, 1, 0);
Tensor<float, 3> t_3d(2, 3, 4);
t_3d(0, 1, 0) = 12.0f;

// Initialize all elements to random values.
for (int i = 0; i < 2; ++i) {
  for (int j = 0; j < 3; ++j) {
    for (int k = 0; k < 4; ++k) {
      t_3d(i, j, k) = ...some random value...;
    }
  }
}

// Print elements of a tensor.
for (int i = 0; i < 2; ++i) {
  LOG(INFO) << t_3d(i, 0, 0);
}
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1577}{}\doxysection{Tensor\+Layout}\label{eigen_tensors_autotoc_md1577}
The tensor library supports 2 layouts\+: {\ttfamily Col\+Major} (the default) and {\ttfamily Row\+Major}.

The layout of a tensor is optionally specified as part of its type. If not specified explicitly column major is assumed. \begin{DoxyVerb}Tensor<float, 3, ColMajor> col_major;  // equivalent to Tensor<float, 3>
TensorMap<Tensor<float, 3, RowMajor> > row_major(data, ...);
\end{DoxyVerb}


All the arguments to an expression must use the same layout. Attempting to mix different layouts will result in a compilation error.

It is possible to change the layout of a tensor or an expression using the {\ttfamily swap\+\_\+layout()} method. Note that this will also reverse the order of the dimensions. \begin{DoxyVerb}Tensor<float, 2, ColMajor> col_major(2, 4);
Tensor<float, 2, RowMajor> row_major(2, 4);

Tensor<float, 2> col_major_result = col_major;  // ok, layouts match
Tensor<float, 2> col_major_result = row_major;  // will not compile

// Simple layout swap
col_major_result = row_major.swap_layout();
eigen_assert(col_major_result.dimension(0) == 4);
eigen_assert(col_major_result.dimension(1) == 2);

// Swap the layout and preserve the order of the dimensions
array<int, 2> shuffle(1, 0);
col_major_result = row_major.swap_layout().shuffle(shuffle);
eigen_assert(col_major_result.dimension(0) == 2);
eigen_assert(col_major_result.dimension(1) == 4);
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1578}{}\doxysection{Tensor Operations}\label{eigen_tensors_autotoc_md1578}
The \mbox{\hyperlink{namespace_eigen}{Eigen}} Tensor library provides a vast library of operations on Tensors\+: numerical operations such as addition and multiplication, geometry operations such as slicing and shuffling, etc. These operations are available as methods of the Tensor classes, and in some cases as operator overloads. For example the following code computes the elementwise addition of two tensors\+: \begin{DoxyVerb}Tensor<float, 3> t1(2, 3, 4);
...set some values in t1...
Tensor<float, 3> t2(2, 3, 4);
...set some values in t2...
// Set t3 to the element wise sum of t1 and t2
Tensor<float, 3> t3 = t1 + t2;
\end{DoxyVerb}


While the code above looks easy enough, it is important to understand that the expression {\ttfamily t1 + t2} is not actually adding the values of the tensors. The expression instead constructs a \char`\"{}tensor operator\char`\"{} object of the class Tensor\+Cwise\+Binary\+Op$<$scalar\+\_\+sum$>$, which has references to the tensors {\ttfamily t1} and {\ttfamily t2}. This is a small C++ object that knows how to add {\ttfamily t1} and {\ttfamily t2}. It is only when the value of the expression is assigned to the tensor {\ttfamily t3} that the addition is actually performed. Technically, this happens through the overloading of {\ttfamily operator=()} in the Tensor class.

This mechanism for computing tensor expressions allows for lazy evaluation and optimizations which are what make the tensor library very fast.

Of course, the tensor operators do nest, and the expression {\ttfamily t1 + t2 $\ast$ 0.\+3f} is actually represented with the (approximate) tree of operators\+: \begin{DoxyVerb}TensorCwiseBinaryOp<scalar_sum>(t1, TensorCwiseUnaryOp<scalar_mul>(t2, 0.3f))
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1579}{}\doxysubsection{Tensor Operations and C++ \char`\"{}auto\char`\"{}}\label{eigen_tensors_autotoc_md1579}
Because Tensor operations create tensor operators, the C++ {\ttfamily auto} keyword does not have its intuitive meaning. Consider these 2 lines of code\+: \begin{DoxyVerb}Tensor<float, 3> t3 = t1 + t2;
auto t4 = t1 + t2;
\end{DoxyVerb}


In the first line we allocate the tensor {\ttfamily t3} and it will contain the result of the addition of {\ttfamily t1} and {\ttfamily t2}. In the second line, {\ttfamily t4} is actually the tree of tensor operators that will compute the addition of {\ttfamily t1} and {\ttfamily t2}. In fact, {\ttfamily t4} is {\itshape not} a tensor and you cannot get the values of its elements\+: \begin{DoxyVerb}Tensor<float, 3> t3 = t1 + t2;
cout << t3(0, 0, 0);  // OK prints the value of t1(0, 0, 0) + t2(0, 0, 0)

auto t4 = t1 + t2;
cout << t4(0, 0, 0);  // Compilation error!
\end{DoxyVerb}


When you use {\ttfamily auto} you do not get a Tensor as a result but instead a non-\/evaluated expression. So only use {\ttfamily auto} to delay evaluation.

Unfortunately, there is no single underlying concrete type for holding non-\/evaluated expressions, hence you have to use auto in the case when you do want to hold non-\/evaluated expressions.

When you need the results of set of tensor computations you have to assign the result to a Tensor that will be capable of holding onto them. This can be either a normal Tensor, a fixed size Tensor, or a Tensor\+Map on an existing piece of memory. All the following will work\+: \begin{DoxyVerb}auto t4 = t1 + t2;

Tensor<float, 3> result = t4;  // Could also be: result(t4);
cout << result(0, 0, 0);

TensorMap<float, 4> result(<a float* with enough space>, <size0>, ...) = t4;
cout << result(0, 0, 0);

TensorFixedSize<float, Sizes<size0, ...>> result = t4;
cout << result(0, 0, 0);
\end{DoxyVerb}


Until you need the results, you can keep the operation around, and even reuse it for additional operations. As long as you keep the expression as an operation, no computation is performed. \begin{DoxyVerb}// One way to compute exp((t1 + t2) * 0.2f);
auto t3 = t1 + t2;
auto t4 = t3 * 0.2f;
auto t5 = t4.exp();
Tensor<float, 3> result = t5;

// Another way, exactly as efficient as the previous one:
Tensor<float, 3> result = ((t1 + t2) * 0.2f).exp();
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1580}{}\doxysubsection{Controlling When Expression are Evaluated}\label{eigen_tensors_autotoc_md1580}
There are several ways to control when expressions are evaluated\+:


\begin{DoxyItemize}
\item Assignment to a Tensor, Tensor\+Fixed\+Size, or Tensor\+Map.
\item Use of the eval() method.
\item Assignment to a Tensor\+Ref.
\end{DoxyItemize}\hypertarget{eigen_tensors_autotoc_md1581}{}\doxysubsubsection{Assigning to a Tensor, Tensor\+Fixed\+Size, or Tensor\+Map.}\label{eigen_tensors_autotoc_md1581}
The most common way to evaluate an expression is to assign it to a Tensor. In the example below, the {\ttfamily auto} declarations make the intermediate values \char`\"{}\+Operations\char`\"{}, not Tensors, and do not cause the expressions to be evaluated. The assignment to the Tensor {\ttfamily result} causes the evaluation of all the operations. \begin{DoxyVerb}auto t3 = t1 + t2;             // t3 is an Operation.
auto t4 = t3 * 0.2f;           // t4 is an Operation.
auto t5 = t4.exp();            // t5 is an Operation.
Tensor<float, 3> result = t5;  // The operations are evaluated.
\end{DoxyVerb}


If you know the ranks and sizes of the Operation value you can assign the Operation to a Tensor\+Fixed\+Size instead of a Tensor, which is a bit more efficient. \begin{DoxyVerb}// We know that the result is a 4x4x2 tensor!
TensorFixedSize<float, Sizes<4, 4, 2>> result = t5;
\end{DoxyVerb}


Simiarly, assigning an expression to a Tensor\+Map causes its evaluation. Like tensors of type Tensor\+Fixed\+Size, Tensor\+Maps cannot be resized so they have to have the rank and sizes of the expression that are assigned to them.\hypertarget{eigen_tensors_autotoc_md1582}{}\doxysubsubsection{Calling eval().}\label{eigen_tensors_autotoc_md1582}
When you compute large composite expressions, you sometimes want to tell \mbox{\hyperlink{namespace_eigen}{Eigen}} that an intermediate value in the expression tree is worth evaluating ahead of time. This is done by inserting a call to the {\ttfamily eval()} method of the expression Operation. \begin{DoxyVerb}// The previous example could have been written:
Tensor<float, 3> result = ((t1 + t2) * 0.2f).exp();

// If you want to compute (t1 + t2) once ahead of time you can write:
Tensor<float, 3> result = ((t1 + t2).eval() * 0.2f).exp();
\end{DoxyVerb}


Semantically, calling {\ttfamily eval()} is equivalent to materializing the value of the expression in a temporary Tensor of the right size. The code above in effect does\+: \begin{DoxyVerb}// .eval() knows the size!
TensorFixedSize<float, Sizes<4, 4, 2>> tmp = t1 + t2;
Tensor<float, 3> result = (tmp * 0.2f).exp();
\end{DoxyVerb}


Note that the return value of {\ttfamily eval()} is itself an Operation, so the following code does not do what you may think\+: \begin{DoxyVerb}// Here t3 is an evaluation Operation.  t3 has not been evaluated yet.
auto t3 = (t1 + t2).eval();

// You can use t3 in another expression.  Still no evaluation.
auto t4 = (t3 * 0.2f).exp();

// The value is evaluated when you assign the Operation to a Tensor, using
// an intermediate tensor to represent t3.x
Tensor<float, 3> result = t4;
\end{DoxyVerb}


While in the examples above calling {\ttfamily eval()} does not make a difference in performance, in other cases it can make a huge difference. In the expression below the {\ttfamily broadcast()} expression causes the {\ttfamily X.\+maximum()} expression to be evaluated many times\+: \begin{DoxyVerb}Tensor<...> X ...;
Tensor<...> Y = ((X - X.maximum(depth_dim).reshape(dims2d).broadcast(bcast))
                 * beta).exp();
\end{DoxyVerb}


Inserting a call to {\ttfamily eval()} between the {\ttfamily maximum()} and {\ttfamily reshape()} calls guarantees that maximum() is only computed once and greatly speeds-\/up execution\+: \begin{DoxyVerb}Tensor<...> Y =
  ((X - X.maximum(depth_dim).eval().reshape(dims2d).broadcast(bcast))
    * beta).exp();
\end{DoxyVerb}


In the other example below, the tensor {\ttfamily Y} is both used in the expression and its assignment. This is an aliasing problem and if the evaluation is not done in the right order Y will be updated incrementally during the evaluation resulting in bogus results\+: \begin{DoxyVerb} Tensor<...> Y ...;
 Y = Y / (Y.sum(depth_dim).reshape(dims2d).broadcast(bcast));
\end{DoxyVerb}


Inserting a call to {\ttfamily eval()} between the {\ttfamily sum()} and {\ttfamily reshape()} expressions ensures that the sum is computed before any updates to {\ttfamily Y} are done. \begin{DoxyVerb} Y = Y / (Y.sum(depth_dim).eval().reshape(dims2d).broadcast(bcast));
\end{DoxyVerb}


Note that an eval around the full right hand side expression is not needed because the generated has to compute the i-\/th value of the right hand side before assigning it to the left hand side.

However, if you were assigning the expression value to a shuffle of {\ttfamily Y} then you would need to force an eval for correctness by adding an {\ttfamily eval()} call for the right hand side\+: \begin{DoxyVerb} Y.shuffle(...) =
    (Y / (Y.sum(depth_dim).eval().reshape(dims2d).broadcast(bcast))).eval();
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1583}{}\doxysubsubsection{Assigning to a Tensor\+Ref.}\label{eigen_tensors_autotoc_md1583}
If you need to access only a few elements from the value of an expression you can avoid materializing the value in a full tensor by using a Tensor\+Ref.

A Tensor\+Ref is a small wrapper class for any \mbox{\hyperlink{namespace_eigen}{Eigen}} Operation. It provides overloads for the {\ttfamily ()} operator that let you access individual values in the expression. Tensor\+Ref is convenient, because the Operation themselves do not provide a way to access individual elements. \begin{DoxyVerb}// Create a TensorRef for the expression.  The expression is not
// evaluated yet.
TensorRef<Tensor<float, 3> > ref = ((t1 + t2) * 0.2f).exp();

// Use "ref" to access individual elements.  The expression is evaluated
// on the fly.
float at_0 = ref(0, 0, 0);
cout << ref(0, 1, 0);
\end{DoxyVerb}


Only use Tensor\+Ref when you need a subset of the values of the expression. Tensor\+Ref only computes the values you access. However note that if you are going to access all the values it will be much faster to materialize the results in a Tensor first.

In some cases, if the full Tensor result would be very large, you may save memory by accessing it as a Tensor\+Ref. But not always. So don\textquotesingle{}t count on it.\hypertarget{eigen_tensors_autotoc_md1584}{}\doxysubsection{Controlling How Expressions Are Evaluated}\label{eigen_tensors_autotoc_md1584}
The tensor library provides several implementations of the various operations such as contractions and convolutions. The implementations are optimized for different environments\+: single threaded on C\+PU, multi threaded on C\+PU, or on a G\+PU using cuda. Additional implementations may be added later.

You can choose which implementation to use with the {\ttfamily device()} call. If you do not choose an implementation explicitly the default implementation that uses a single thread on the C\+PU is used.

The default implementation has been optimized for recent Intel C\+P\+Us, taking advantage of S\+SE, A\+VX, and F\+MA instructions. Work is ongoing to tune the library on A\+RM C\+P\+Us. Note that you need to pass compiler-\/dependent flags to enable the use of S\+SE, A\+VX, and other instructions.

For example, the following code adds two tensors using the default single-\/threaded C\+PU implementation\+: \begin{DoxyVerb}Tensor<float, 2> a(30, 40);
Tensor<float, 2> b(30, 40);
Tensor<float, 2> c = a + b;
\end{DoxyVerb}


To choose a different implementation you have to insert a {\ttfamily device()} call before the assignment of the result. For technical C++ reasons this requires that the Tensor for the result be declared on its own. This means that you have to know the size of the result. \begin{DoxyVerb}Eigen::Tensor<float, 2> c(30, 40);
c.device(...) = a + b;
\end{DoxyVerb}


The call to {\ttfamily device()} must be the last call on the left of the operator=.

You must pass to the {\ttfamily device()} call an \mbox{\hyperlink{namespace_eigen}{Eigen}} device object. There are presently three devices you can use\+: Default\+Device, Thread\+Pool\+Device and Gpu\+Device.\hypertarget{eigen_tensors_autotoc_md1585}{}\doxysubsubsection{Evaluating With the Default\+Device}\label{eigen_tensors_autotoc_md1585}
This is exactly the same as not inserting a {\ttfamily device()} call. \begin{DoxyVerb}DefaultDevice my_device;
c.device(my_device) = a + b;
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1586}{}\doxysubsubsection{Evaluating with a Thread Pool}\label{eigen_tensors_autotoc_md1586}
\begin{DoxyVerb}// Create the Eigen ThreadPool
Eigen::ThreadPool pool(8 /* number of threads in pool */)

// Create the Eigen ThreadPoolDevice.
Eigen::ThreadPoolDevice my_device(&pool, 4 /* number of threads to use */);

// Now just use the device when evaluating expressions.
Eigen::Tensor<float, 2> c(30, 50);
c.device(my_device) = a.contract(b, dot_product_dims);
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1587}{}\doxysubsubsection{Evaluating On G\+PU}\label{eigen_tensors_autotoc_md1587}
This is presently a bit more complicated than just using a thread pool device. You need to create a G\+PU device but you also need to explicitly allocate the memory for tensors with cuda.\hypertarget{eigen_tensors_autotoc_md1588}{}\doxysection{A\+P\+I Reference}\label{eigen_tensors_autotoc_md1588}
\hypertarget{eigen_tensors_autotoc_md1589}{}\doxysubsection{Datatypes}\label{eigen_tensors_autotoc_md1589}
In the documentation of the tensor methods and Operation we mention datatypes that are tensor-\/type specific\+:\hypertarget{eigen_tensors_autotoc_md1590}{}\doxysubsubsection{$<$\+Tensor-\/\+Type$>$\+::\+Dimensions}\label{eigen_tensors_autotoc_md1590}
Acts like an array of ints. Has an {\ttfamily int size} attribute, and can be indexed like an array to access individual values. Used to represent the dimensions of a tensor. See {\ttfamily dimensions()}.\hypertarget{eigen_tensors_autotoc_md1591}{}\doxysubsubsection{$<$\+Tensor-\/\+Type$>$\+::\+Index}\label{eigen_tensors_autotoc_md1591}
Acts like an {\ttfamily int}. Used for indexing tensors along their dimensions. See {\ttfamily operator()}, {\ttfamily dimension()}, and {\ttfamily size()}.\hypertarget{eigen_tensors_autotoc_md1592}{}\doxysubsubsection{$<$\+Tensor-\/\+Type$>$\+::\+Scalar}\label{eigen_tensors_autotoc_md1592}
Represents the datatype of individual tensor elements. For example, for a {\ttfamily Tensor$<$float$>$}, {\ttfamily Scalar} is the type {\ttfamily float}. See {\ttfamily set\+Constant()}.\hypertarget{eigen_tensors_autotoc_md1593}{}\doxysubsubsection{$<$\+Operation$>$}\label{eigen_tensors_autotoc_md1593}
We use this pseudo type to indicate that a tensor Operation is returned by a method. We indicate in the text the type and dimensions of the tensor that the Operation returns after evaluation.

The Operation will have to be evaluated, for example by assigning it to a tensor, before you can access the values of the resulting tensor. You can also access the values through a Tensor\+Ref.\hypertarget{eigen_tensors_autotoc_md1594}{}\doxysection{Built-\/in Tensor Methods}\label{eigen_tensors_autotoc_md1594}
These are usual C++ methods that act on tensors immediately. They are not Operations which provide delayed evaluation of their results. Unless specified otherwise, all the methods listed below are available on all tensor classes\+: Tensor, Tensor\+Fixed\+Size, and Tensor\+Map.\hypertarget{eigen_tensors_autotoc_md1595}{}\doxysection{Metadata}\label{eigen_tensors_autotoc_md1595}
\hypertarget{eigen_tensors_autotoc_md1596}{}\doxysubsection{int Num\+Dimensions}\label{eigen_tensors_autotoc_md1596}
Constant value indicating the number of dimensions of a Tensor. This is also known as the tensor \char`\"{}rank\char`\"{}. \begin{DoxyVerb}  Eigen::Tensor<float, 2> a(3, 4);
  cout << "Dims " << a.NumDimensions;
  => Dims 2
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1597}{}\doxysubsection{Dimensions dimensions()}\label{eigen_tensors_autotoc_md1597}
Returns an array-\/like object representing the dimensions of the tensor. The actual type of the {\ttfamily dimensions()} result is {\ttfamily $<$Tensor-\/\+Type$>$\+::}{\ttfamily Dimensions}. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(3, 4);
const Eigen::Tensor<float, 2>::Dimensions& d = a.dimensions();
cout << "Dim size: " << d.size << ", dim 0: " << d[0]
     << ", dim 1: " << d[1];
=> Dim size: 2, dim 0: 3, dim 1: 4
\end{DoxyVerb}


If you use a C++11 compiler, you can use {\ttfamily auto} to simplify the code\+: \begin{DoxyVerb}const auto& d = a.dimensions();
cout << "Dim size: " << d.size << ", dim 0: " << d[0]
     << ", dim 1: " << d[1];
=> Dim size: 2, dim 0: 3, dim 1: 4
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1598}{}\doxysubsection{Index dimension(\+Index n)}\label{eigen_tensors_autotoc_md1598}
Returns the n-\/th dimension of the tensor. The actual type of the {\ttfamily dimension()} result is {\ttfamily $<$Tensor-\/\+Type$>$\+::}{\ttfamily Index}, but you can always use it like an int. \begin{DoxyVerb}  Eigen::Tensor<float, 2> a(3, 4);
  int dim1 = a.dimension(1);
  cout << "Dim 1: " << dim1;
  => Dim 1: 4
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1599}{}\doxysubsection{Index size()}\label{eigen_tensors_autotoc_md1599}
Returns the total number of elements in the tensor. This is the product of all the tensor dimensions. The actual type of the {\ttfamily size()} result is {\ttfamily $<$Tensor-\/\+Type$>$\+::}{\ttfamily Index}, but you can always use it like an int. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(3, 4);
cout << "Size: " << a.size();
=> Size: 12
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1600}{}\doxysubsection{Getting Dimensions From An Operation}\label{eigen_tensors_autotoc_md1600}
A few operations provide {\ttfamily dimensions()} directly, e.\+g. {\ttfamily Tensor\+Reslicing\+Op}. Most operations defer calculating dimensions until the operation is being evaluated. If you need access to the dimensions of a deferred operation, you can wrap it in a Tensor\+Ref (see Assigning to a Tensor\+Ref above), which provides {\ttfamily dimensions()} and {\ttfamily dimension()} as above.

Tensor\+Ref can also wrap the plain Tensor types, so this is a useful idiom in templated contexts where the underlying object could be either a raw Tensor or some deferred operation (e.\+g. a slice of a Tensor). In this case, the template code can wrap the object in a Tensor\+Ref and reason about its dimensionality while remaining agnostic to the underlying type.\hypertarget{eigen_tensors_autotoc_md1601}{}\doxysection{Constructors}\label{eigen_tensors_autotoc_md1601}
\hypertarget{eigen_tensors_autotoc_md1602}{}\doxysubsection{Tensor}\label{eigen_tensors_autotoc_md1602}
Creates a tensor of the specified size. The number of arguments must be equal to the rank of the tensor. The content of the tensor is not initialized. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(3, 4);
cout << "NumRows: " << a.dimension(0) << " NumCols: " << a.dimension(1) << endl;
=> NumRows: 3 NumCols: 4
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1603}{}\doxysubsection{Tensor\+Fixed\+Size}\label{eigen_tensors_autotoc_md1603}
Creates a tensor of the specified size. The number of arguments in the Sizes$<$$>$ template parameter determines the rank of the tensor. The content of the tensor is not initialized. \begin{DoxyVerb}Eigen::TensorFixedSize<float, Sizes<3, 4>> a;
cout << "Rank: " << a.rank() << endl;
=> Rank: 2
cout << "NumRows: " << a.dimension(0) << " NumCols: " << a.dimension(1) << endl;
=> NumRows: 3 NumCols: 4
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1604}{}\doxysubsection{Tensor\+Map}\label{eigen_tensors_autotoc_md1604}
Creates a tensor mapping an existing array of data. The data must not be freed until the Tensor\+Map is discarded, and the size of the data must be large enough to accommodate the coefficients of the tensor. \begin{DoxyVerb}float data[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11};
Eigen::TensorMap<Tensor<float, 2>> a(data, 3, 4);
cout << "NumRows: " << a.dimension(0) << " NumCols: " << a.dimension(1) << endl;
=> NumRows: 3 NumCols: 4
cout << "a(1, 2): " << a(1, 2) << endl;
=> a(1, 2): 7
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1605}{}\doxysection{Contents Initialization}\label{eigen_tensors_autotoc_md1605}
When a new Tensor or a new Tensor\+Fixed\+Size are created, memory is allocated to hold all the tensor elements, but the memory is not initialized. Similarly, when a new Tensor\+Map is created on top of non-\/initialized memory the memory its contents are not initialized.

You can use one of the methods below to initialize the tensor memory. These have an immediate effect on the tensor and return the tensor itself as a result. These are not tensor Operations which delay evaluation.\hypertarget{eigen_tensors_autotoc_md1606}{}\doxysubsection{$<$\+Tensor-\/\+Type$>$ set\+Constant(const Scalar\& val)}\label{eigen_tensors_autotoc_md1606}
Sets all elements of the tensor to the constant value {\ttfamily val}. {\ttfamily Scalar} is the type of data stored in the tensor. You can pass any value that is convertible to that type.

Returns the tensor itself in case you want to chain another call. \begin{DoxyVerb}a.setConstant(12.3f);
cout << "Constant: " << endl << a << endl << endl;
=>
Constant:
12.3 12.3 12.3 12.3
12.3 12.3 12.3 12.3
12.3 12.3 12.3 12.3
\end{DoxyVerb}


Note that {\ttfamily set\+Constant()} can be used on any tensor where the element type has a copy constructor and an {\ttfamily operator=()}\+: \begin{DoxyVerb}Eigen::Tensor<string, 2> a(2, 3);
a.setConstant("yolo");
cout << "String tensor: " << endl << a << endl << endl;
=>
String tensor:
yolo yolo yolo
yolo yolo yolo
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1607}{}\doxysubsection{$<$\+Tensor-\/\+Type$>$ set\+Zero()}\label{eigen_tensors_autotoc_md1607}
Fills the tensor with zeros. Equivalent to {\ttfamily set\+Constant(\+Scalar(0))}. Returns the tensor itself in case you want to chain another call. \begin{DoxyVerb}a.setZero();
cout << "Zeros: " << endl << a << endl << endl;
=>
Zeros:
0 0 0 0
0 0 0 0
0 0 0 0
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1608}{}\doxysubsection{$<$\+Tensor-\/\+Type$>$ set\+Values(\{..\+initializer\+\_\+list\})}\label{eigen_tensors_autotoc_md1608}
Fills the tensor with explicit values specified in a std\+::initializer\+\_\+list. The type of the initializer list depends on the type and rank of the tensor.

If the tensor has rank N, the initializer list must be nested N times. The most deeply nested lists must contains P scalars of the Tensor type where P is the size of the last dimension of the Tensor.

For example, for a {\ttfamily Tensor\+Fixed\+Size$<$float, 2, 3$>$} the initializer list must contains 2 lists of 3 floats each.

{\ttfamily set\+Values()} returns the tensor itself in case you want to chain another call. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(2, 3);
a.setValues({{0.0f, 1.0f, 2.0f}, {3.0f, 4.0f, 5.0f}});
cout << "a" << endl << a << endl << endl;
=>
a
0 1 2
3 4 5
\end{DoxyVerb}


If a list is too short, the corresponding elements of the tensor will not be changed. This is valid at each level of nesting. For example the following code only sets the values of the first row of the tensor. \begin{DoxyVerb}Eigen::Tensor<int, 2> a(2, 3);
a.setConstant(1000);
a.setValues({{10, 20, 30}});
cout << "a" << endl << a << endl << endl;
=>
a
10   20   30
1000 1000 1000
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1609}{}\doxysubsection{$<$\+Tensor-\/\+Type$>$ set\+Random()}\label{eigen_tensors_autotoc_md1609}
Fills the tensor with random values. Returns the tensor itself in case you want to chain another call. \begin{DoxyVerb}a.setRandom();
cout << "Random: " << endl << a << endl << endl;
=>
Random:
  0.680375    0.59688  -0.329554    0.10794
 -0.211234   0.823295   0.536459 -0.0452059
  0.566198  -0.604897  -0.444451   0.257742
\end{DoxyVerb}


You can customize {\ttfamily set\+Random()} by providing your own random number generator as a template argument\+: \begin{DoxyVerb}a.setRandom<MyRandomGenerator>();
\end{DoxyVerb}


Here, {\ttfamily My\+Random\+Generator} must be a struct with the following member functions, where Scalar and Index are the same as {\ttfamily $<$Tensor-\/\+Type$>$\+::}{\ttfamily Scalar} and {\ttfamily $<$Tensor-\/\+Type$>$\+::}{\ttfamily Index}.

See {\ttfamily struct Uniform\+Random\+Generator} in Tensor\+Functors.\+h for an example. \begin{DoxyVerb}// Custom number generator for use with setRandom().
struct MyRandomGenerator {
  // Default and copy constructors. Both are needed
  MyRandomGenerator() { }
  MyRandomGenerator(const MyRandomGenerator& ) { }

  // Return a random value to be used.  "element_location" is the
  // location of the entry to set in the tensor, it can typically
  // be ignored.
  Scalar operator()(Eigen::DenseIndex element_location,
                    Eigen::DenseIndex /*unused*/ = 0) const {
    return <randomly generated value of type T>;
  }

  // Same as above but generates several numbers at a time.
  typename internal::packet_traits<Scalar>::type packetOp(
      Eigen::DenseIndex packet_location, Eigen::DenseIndex /*unused*/ = 0) const {
    return <a packet of randomly generated values>;
  }
};
\end{DoxyVerb}


You can also use one of the 2 random number generators that are part of the tensor library\+:
\begin{DoxyItemize}
\item Uniform\+Random\+Generator
\item Normal\+Random\+Generator
\end{DoxyItemize}\hypertarget{eigen_tensors_autotoc_md1610}{}\doxysection{Data Access}\label{eigen_tensors_autotoc_md1610}
The Tensor, Tensor\+Fixed\+Size, and Tensor\+Ref classes provide the following accessors to access the tensor coefficients\+: \begin{DoxyVerb}const Scalar& operator()(const array<Index, NumIndices>& indices)
const Scalar& operator()(Index firstIndex, IndexTypes... otherIndices)
Scalar& operator()(const array<Index, NumIndices>& indices)
Scalar& operator()(Index firstIndex, IndexTypes... otherIndices)
\end{DoxyVerb}


The number of indices must be equal to the rank of the tensor. Moreover, these accessors are not available on tensor expressions. In order to access the values of a tensor expression, the expression must either be evaluated or wrapped in a Tensor\+Ref.\hypertarget{eigen_tensors_autotoc_md1611}{}\doxysubsection{Scalar$\ast$ data() and const Scalar$\ast$ data() const}\label{eigen_tensors_autotoc_md1611}
Returns a pointer to the storage for the tensor. The pointer is const if the tensor was const. This allows direct access to the data. The layout of the data depends on the tensor layout\+: Row\+Major or Col\+Major.

This access is usually only needed for special cases, for example when mixing \mbox{\hyperlink{namespace_eigen}{Eigen}} Tensor code with other libraries.

Scalar is the type of data stored in the tensor. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(3, 4);
float* a_data = a.data();
a_data[0] = 123.45f;
cout << "a(0, 0): " << a(0, 0);
=> a(0, 0): 123.45
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1612}{}\doxysection{Tensor Operations}\label{eigen_tensors_autotoc_md1612}
All the methods documented below return non evaluated tensor {\ttfamily Operations}. These can be chained\+: you can apply another Tensor Operation to the value returned by the method.

The chain of Operation is evaluated lazily, typically when it is assigned to a tensor. See \char`\"{}\+Controlling when Expression are Evaluated\char`\"{} for more details about their evaluation.\hypertarget{eigen_tensors_autotoc_md1613}{}\doxysubsection{$<$\+Operation$>$ constant(const Scalar\& val)}\label{eigen_tensors_autotoc_md1613}
Returns a tensor of the same type and dimensions as the original tensor but where all elements have the value {\ttfamily val}.

This is useful, for example, when you want to add or subtract a constant from a tensor, or multiply every element of a tensor by a scalar. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(2, 3);
a.setConstant(1.0f);
Eigen::Tensor<float, 2> b = a + a.constant(2.0f);
Eigen::Tensor<float, 2> c = b * b.constant(0.2f);
cout << "a" << endl << a << endl << endl;
cout << "b" << endl << b << endl << endl;
cout << "c" << endl << c << endl << endl;
=>
a
1 1 1
1 1 1

b
3 3 3
3 3 3

c
0.6 0.6 0.6
0.6 0.6 0.6
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1614}{}\doxysubsection{$<$\+Operation$>$ random()}\label{eigen_tensors_autotoc_md1614}
Returns a tensor of the same type and dimensions as the current tensor but where all elements have random values.

This is for example useful to add random values to an existing tensor. The generation of random values can be customized in the same manner as for {\ttfamily set\+Random()}. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(2, 3);
a.setConstant(1.0f);
Eigen::Tensor<float, 2> b = a + a.random();
cout << "a" << endl << a << endl << endl;
cout << "b" << endl << b << endl << endl;
=>
a
1 1 1
1 1 1

b
1.68038   1.5662  1.82329
0.788766  1.59688 0.395103
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1615}{}\doxysection{Unary Element Wise Operations}\label{eigen_tensors_autotoc_md1615}
All these operations take a single input tensor as argument and return a tensor of the same type and dimensions as the tensor to which they are applied. The requested operations are applied to each element independently.\hypertarget{eigen_tensors_autotoc_md1616}{}\doxysubsection{$<$\+Operation$>$ operator-\/()}\label{eigen_tensors_autotoc_md1616}
Returns a tensor of the same type and dimensions as the original tensor containing the opposite values of the original tensor. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(2, 3);
a.setConstant(1.0f);
Eigen::Tensor<float, 2> b = -a;
cout << "a" << endl << a << endl << endl;
cout << "b" << endl << b << endl << endl;
=>
a
1 1 1
1 1 1

b
-1 -1 -1
-1 -1 -1
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1617}{}\doxysubsection{$<$\+Operation$>$ sqrt()}\label{eigen_tensors_autotoc_md1617}
Returns a tensor of the same type and dimensions as the original tensor containing the square roots of the original tensor.\hypertarget{eigen_tensors_autotoc_md1618}{}\doxysubsection{$<$\+Operation$>$ rsqrt()}\label{eigen_tensors_autotoc_md1618}
Returns a tensor of the same type and dimensions as the original tensor containing the inverse square roots of the original tensor.\hypertarget{eigen_tensors_autotoc_md1619}{}\doxysubsection{$<$\+Operation$>$ square()}\label{eigen_tensors_autotoc_md1619}
Returns a tensor of the same type and dimensions as the original tensor containing the squares of the original tensor values.\hypertarget{eigen_tensors_autotoc_md1620}{}\doxysubsection{$<$\+Operation$>$ inverse()}\label{eigen_tensors_autotoc_md1620}
Returns a tensor of the same type and dimensions as the original tensor containing the inverse of the original tensor values.\hypertarget{eigen_tensors_autotoc_md1621}{}\doxysubsection{$<$\+Operation$>$ exp()}\label{eigen_tensors_autotoc_md1621}
Returns a tensor of the same type and dimensions as the original tensor containing the exponential of the original tensor.\hypertarget{eigen_tensors_autotoc_md1622}{}\doxysubsection{$<$\+Operation$>$ log()}\label{eigen_tensors_autotoc_md1622}
Returns a tensor of the same type and dimensions as the original tensor containing the natural logarithms of the original tensor.\hypertarget{eigen_tensors_autotoc_md1623}{}\doxysubsection{$<$\+Operation$>$ abs()}\label{eigen_tensors_autotoc_md1623}
Returns a tensor of the same type and dimensions as the original tensor containing the absolute values of the original tensor.\hypertarget{eigen_tensors_autotoc_md1624}{}\doxysubsection{$<$\+Operation$>$ arg()}\label{eigen_tensors_autotoc_md1624}
Returns a tensor with the same dimensions as the original tensor containing the complex argument (phase angle) of the values of the original tensor.\hypertarget{eigen_tensors_autotoc_md1625}{}\doxysubsection{$<$\+Operation$>$ real()}\label{eigen_tensors_autotoc_md1625}
Returns a tensor with the same dimensions as the original tensor containing the real part of the complex values of the original tensor.\hypertarget{eigen_tensors_autotoc_md1626}{}\doxysubsection{$<$\+Operation$>$ imag()}\label{eigen_tensors_autotoc_md1626}
Returns a tensor with the same dimensions as the orginal tensor containing the imaginary part of the complex values of the original tensor.\hypertarget{eigen_tensors_autotoc_md1627}{}\doxysubsection{$<$\+Operation$>$ pow(\+Scalar exponent)}\label{eigen_tensors_autotoc_md1627}
Returns a tensor of the same type and dimensions as the original tensor containing the coefficients of the original tensor to the power of the exponent.

The type of the exponent, Scalar, is always the same as the type of the tensor coefficients. For example, only integer exponents can be used in conjuntion with tensors of integer values.

You can use cast() to lift this restriction. For example this computes cubic roots of an int Tensor\+: \begin{DoxyVerb}Eigen::Tensor<int, 2> a(2, 3);
a.setValues({{0, 1, 8}, {27, 64, 125}});
Eigen::Tensor<double, 2> b = a.cast<double>().pow(1.0 / 3.0);
cout << "a" << endl << a << endl << endl;
cout << "b" << endl << b << endl << endl;
=>
a
0   1   8
27  64 125

b
0 1 2
3 4 5
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1628}{}\doxysubsection{$<$\+Operation$>$  operator $\ast$ (\+Scalar scale)}\label{eigen_tensors_autotoc_md1628}
Multiplies all the coefficients of the input tensor by the provided scale.\hypertarget{eigen_tensors_autotoc_md1629}{}\doxysubsection{$<$\+Operation$>$  cwise\+Max(\+Scalar threshold)}\label{eigen_tensors_autotoc_md1629}
T\+O\+DO\hypertarget{eigen_tensors_autotoc_md1630}{}\doxysubsection{$<$\+Operation$>$  cwise\+Min(\+Scalar threshold)}\label{eigen_tensors_autotoc_md1630}
T\+O\+DO\hypertarget{eigen_tensors_autotoc_md1631}{}\doxysubsection{$<$\+Operation$>$  unary\+Expr(const Custom\+Unary\+Op\& func)}\label{eigen_tensors_autotoc_md1631}
T\+O\+DO\hypertarget{eigen_tensors_autotoc_md1632}{}\doxysection{Binary Element Wise Operations}\label{eigen_tensors_autotoc_md1632}
These operations take two input tensors as arguments. The 2 input tensors should be of the same type and dimensions. The result is a tensor of the same dimensions as the tensors to which they are applied, and unless otherwise specified it is also of the same type. The requested operations are applied to each pair of elements independently.\hypertarget{eigen_tensors_autotoc_md1633}{}\doxysubsection{$<$\+Operation$>$ operator+(const Other\+Derived\& other)}\label{eigen_tensors_autotoc_md1633}
Returns a tensor of the same type and dimensions as the input tensors containing the coefficient wise sums of the inputs.\hypertarget{eigen_tensors_autotoc_md1634}{}\doxysubsection{$<$\+Operation$>$ operator-\/(const Other\+Derived\& other)}\label{eigen_tensors_autotoc_md1634}
Returns a tensor of the same type and dimensions as the input tensors containing the coefficient wise differences of the inputs.\hypertarget{eigen_tensors_autotoc_md1635}{}\doxysubsection{$<$\+Operation$>$ operator$\ast$(const Other\+Derived\& other)}\label{eigen_tensors_autotoc_md1635}
Returns a tensor of the same type and dimensions as the input tensors containing the coefficient wise products of the inputs.\hypertarget{eigen_tensors_autotoc_md1636}{}\doxysubsection{$<$\+Operation$>$ operator/(const Other\+Derived\& other)}\label{eigen_tensors_autotoc_md1636}
Returns a tensor of the same type and dimensions as the input tensors containing the coefficient wise quotients of the inputs.

This operator is not supported for integer types.\hypertarget{eigen_tensors_autotoc_md1637}{}\doxysubsection{$<$\+Operation$>$ cwise\+Max(const Other\+Derived\& other)}\label{eigen_tensors_autotoc_md1637}
Returns a tensor of the same type and dimensions as the input tensors containing the coefficient wise maximums of the inputs.\hypertarget{eigen_tensors_autotoc_md1638}{}\doxysubsection{$<$\+Operation$>$ cwise\+Min(const Other\+Derived\& other)}\label{eigen_tensors_autotoc_md1638}
Returns a tensor of the same type and dimensions as the input tensors containing the coefficient wise mimimums of the inputs.\hypertarget{eigen_tensors_autotoc_md1639}{}\doxysubsection{$<$\+Operation$>$ Logical operators}\label{eigen_tensors_autotoc_md1639}
The following logical operators are supported as well\+:


\begin{DoxyItemize}
\item operator\&\&(const Other\+Derived\& other)
\item operator$\vert$$\vert$(const Other\+Derived\& other)
\item operator$<$(const Other\+Derived\& other)
\item operator$<$=(const Other\+Derived\& other)
\item operator$>$(const Other\+Derived\& other)
\item operator$>$=(const Other\+Derived\& other)
\item operator==(const Other\+Derived\& other)
\item operator!=(const Other\+Derived\& other)
\end{DoxyItemize}

They all return a tensor of boolean values.\hypertarget{eigen_tensors_autotoc_md1640}{}\doxysection{Selection (select(const Then\+Derived\& then\+Tensor, const Else\+Derived\& else\+Tensor)}\label{eigen_tensors_autotoc_md1640}
Selection is a coefficient-\/wise ternary operator that is the tensor equivalent to the if-\/then-\/else operation. \begin{DoxyVerb}Tensor<bool, 3> if = ...;
Tensor<float, 3> then = ...;
Tensor<float, 3> else = ...;
Tensor<float, 3> result = if.select(then, else);
\end{DoxyVerb}


The 3 arguments must be of the same dimensions, which will also be the dimension of the result. The \textquotesingle{}if\textquotesingle{} tensor must be of type boolean, the \textquotesingle{}then\textquotesingle{} and the \textquotesingle{}else\textquotesingle{} tensor must be of the same type, which will also be the type of the result.

Each coefficient in the result is equal to the corresponding coefficient in the \textquotesingle{}then\textquotesingle{} tensor if the corresponding value in the \textquotesingle{}if\textquotesingle{} tensor is true. If not, the resulting coefficient will come from the \textquotesingle{}else\textquotesingle{} tensor.\hypertarget{eigen_tensors_autotoc_md1641}{}\doxysection{Contraction}\label{eigen_tensors_autotoc_md1641}
Tensor {\itshape contractions} are a generalization of the matrix product to the multidimensional case. \begin{DoxyVerb}// Create 2 matrices using tensors of rank 2
Eigen::Tensor<int, 2> a(2, 3);
a.setValues({{1, 2, 3}, {6, 5, 4}});
Eigen::Tensor<int, 2> b(3, 2);
b.setValues({{1, 2}, {4, 5}, {5, 6}});

// Compute the traditional matrix product
Eigen::array<Eigen::IndexPair<int>, 1> product_dims = { Eigen::IndexPair<int>(1, 0) };
Eigen::Tensor<int, 2> AB = a.contract(b, product_dims);

// Compute the product of the transpose of the matrices
Eigen::array<Eigen::IndexPair<int>, 1> transposed_product_dims = { Eigen::IndexPair<int>(0, 1) };
Eigen::Tensor<int, 2> AtBt = a.contract(b, transposed_product_dims);

// Contraction to scalar value using a double contraction.
// First coordinate of both tensors are contracted as well as both second coordinates, i.e., this computes the sum of the squares of the elements.
Eigen::array<Eigen::IndexPair<int>, 2> double_contraction_product_dims = { Eigen::IndexPair<int>(0, 0), Eigen::IndexPair<int>(1, 1) };
Eigen::Tensor<int, 0> AdoubleContractedA = a.contract(a, double_contraction_product_dims);

// Extracting the scalar value of the tensor contraction for further usage
int value = AdoubleContractedA(0);
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1642}{}\doxysection{Reduction Operations}\label{eigen_tensors_autotoc_md1642}
A {\itshape Reduction} operation returns a tensor with fewer dimensions than the original tensor. The values in the returned tensor are computed by applying a {\itshape reduction operator} to slices of values from the original tensor. You specify the dimensions along which the slices are made.

The \mbox{\hyperlink{namespace_eigen}{Eigen}} Tensor library provides a set of predefined reduction operators such as {\ttfamily maximum()} and {\ttfamily sum()} and lets you define additional operators by implementing a few methods from a reductor template.\hypertarget{eigen_tensors_autotoc_md1643}{}\doxysubsection{Reduction Dimensions}\label{eigen_tensors_autotoc_md1643}
All reduction operations take a single parameter of type {\ttfamily $<$Tensor\+Type$>$\+::}{\ttfamily Dimensions} which can always be specified as an array of ints. These are called the \char`\"{}reduction dimensions.\char`\"{} The values are the indices of the dimensions of the input tensor over which the reduction is done. The parameter can have at most as many element as the rank of the input tensor; each element must be less than the tensor rank, as it indicates one of the dimensions to reduce.

Each dimension of the input tensor should occur at most once in the reduction dimensions as the implementation does not remove duplicates.

The order of the values in the reduction dimensions does not affect the results, but the code may execute faster if you list the dimensions in increasing order.

Example\+: Reduction along one dimension. \begin{DoxyVerb}// Create a tensor of 2 dimensions
Eigen::Tensor<int, 2> a(2, 3);
a.setValues({{1, 2, 3}, {6, 5, 4}});
// Reduce it along the second dimension (1)...
Eigen::array<int, 1> dims({1 /* dimension to reduce */});
// ...using the "maximum" operator.
// The result is a tensor with one dimension.  The size of
// that dimension is the same as the first (non-reduced) dimension of a.
Eigen::Tensor<int, 1> b = a.maximum(dims);
cout << "a" << endl << a << endl << endl;
cout << "b" << endl << b << endl << endl;
=>
a
1 2 3
6 5 4

b
3
6
\end{DoxyVerb}


Example\+: Reduction along two dimensions. \begin{DoxyVerb}Eigen::Tensor<float, 3, Eigen::ColMajor> a(2, 3, 4);
a.setValues({{{0.0f, 1.0f, 2.0f, 3.0f},
              {7.0f, 6.0f, 5.0f, 4.0f},
              {8.0f, 9.0f, 10.0f, 11.0f}},
             {{12.0f, 13.0f, 14.0f, 15.0f},
              {19.0f, 18.0f, 17.0f, 16.0f},
              {20.0f, 21.0f, 22.0f, 23.0f}}});
// The tensor a has 3 dimensions.  We reduce along the
// first 2, resulting in a tensor with a single dimension
// of size 4 (the last dimension of a.)
// Note that we pass the array of reduction dimensions
// directly to the maximum() call.
Eigen::Tensor<float, 1, Eigen::ColMajor> b =
    a.maximum(Eigen::array<int, 2>({0, 1}));
cout << "b" << endl << b << endl << endl;
=>
b
20
21
22
23
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1644}{}\doxysubsubsection{Reduction along all dimensions}\label{eigen_tensors_autotoc_md1644}
As a special case, if you pass no parameter to a reduction operation the original tensor is reduced along {\itshape all} its dimensions. The result is a scalar, represented as a zero-\/dimension tensor. \begin{DoxyVerb}Eigen::Tensor<float, 3> a(2, 3, 4);
a.setValues({{{0.0f, 1.0f, 2.0f, 3.0f},
              {7.0f, 6.0f, 5.0f, 4.0f},
              {8.0f, 9.0f, 10.0f, 11.0f}},
             {{12.0f, 13.0f, 14.0f, 15.0f},
              {19.0f, 18.0f, 17.0f, 16.0f},
              {20.0f, 21.0f, 22.0f, 23.0f}}});
// Reduce along all dimensions using the sum() operator.
Eigen::Tensor<float, 0> b = a.sum();
cout << "b" << endl << b << endl << endl;
=>
b
276
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1645}{}\doxysubsection{$<$\+Operation$>$ sum(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1645}
\hypertarget{eigen_tensors_autotoc_md1646}{}\doxysubsection{$<$\+Operation$>$ sum()}\label{eigen_tensors_autotoc_md1646}
Reduce a tensor using the sum() operator. The resulting values are the sum of the reduced values.\hypertarget{eigen_tensors_autotoc_md1647}{}\doxysubsection{$<$\+Operation$>$ mean(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1647}
\hypertarget{eigen_tensors_autotoc_md1648}{}\doxysubsection{$<$\+Operation$>$ mean()}\label{eigen_tensors_autotoc_md1648}
Reduce a tensor using the mean() operator. The resulting values are the mean of the reduced values.\hypertarget{eigen_tensors_autotoc_md1649}{}\doxysubsection{$<$\+Operation$>$ maximum(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1649}
\hypertarget{eigen_tensors_autotoc_md1650}{}\doxysubsection{$<$\+Operation$>$ maximum()}\label{eigen_tensors_autotoc_md1650}
Reduce a tensor using the maximum() operator. The resulting values are the largest of the reduced values.\hypertarget{eigen_tensors_autotoc_md1651}{}\doxysubsection{$<$\+Operation$>$ minimum(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1651}
\hypertarget{eigen_tensors_autotoc_md1652}{}\doxysubsection{$<$\+Operation$>$ minimum()}\label{eigen_tensors_autotoc_md1652}
Reduce a tensor using the minimum() operator. The resulting values are the smallest of the reduced values.\hypertarget{eigen_tensors_autotoc_md1653}{}\doxysubsection{$<$\+Operation$>$ prod(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1653}
\hypertarget{eigen_tensors_autotoc_md1654}{}\doxysubsection{$<$\+Operation$>$ prod()}\label{eigen_tensors_autotoc_md1654}
Reduce a tensor using the prod() operator. The resulting values are the product of the reduced values.\hypertarget{eigen_tensors_autotoc_md1655}{}\doxysubsection{$<$\+Operation$>$ all(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1655}
\hypertarget{eigen_tensors_autotoc_md1656}{}\doxysubsection{$<$\+Operation$>$ all()}\label{eigen_tensors_autotoc_md1656}
Reduce a tensor using the all() operator. Casts tensor to bool and then checks whether all elements are true. Runs through all elements rather than short-\/circuiting, so may be significantly inefficient.\hypertarget{eigen_tensors_autotoc_md1657}{}\doxysubsection{$<$\+Operation$>$ any(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1657}
\hypertarget{eigen_tensors_autotoc_md1658}{}\doxysubsection{$<$\+Operation$>$ any()}\label{eigen_tensors_autotoc_md1658}
Reduce a tensor using the \mbox{\hyperlink{group__core__func__vector__relational_ga632a2644532d9332011c8860400d30b2}{any()}} operator. Casts tensor to bool and then checks whether any element is true. Runs through all elements rather than short-\/circuiting, so may be significantly inefficient.\hypertarget{eigen_tensors_autotoc_md1659}{}\doxysubsection{$<$\+Operation$>$ reduce(const Dimensions\& new\+\_\+dims, const Reducer\& reducer)}\label{eigen_tensors_autotoc_md1659}
Reduce a tensor using a user-\/defined reduction operator. See {\ttfamily Sum\+Reducer} in Tensor\+Functors.\+h for information on how to implement a reduction operator.\hypertarget{eigen_tensors_autotoc_md1660}{}\doxysection{Trace}\label{eigen_tensors_autotoc_md1660}
A {\itshape \mbox{\hyperlink{class_trace}{Trace}}} operation returns a tensor with fewer dimensions than the original tensor. It returns a tensor whose elements are the sum of the elements of the original tensor along the main diagonal for a list of specified dimensions, the \char`\"{}trace dimensions\char`\"{}. Similar to the {\ttfamily Reduction Dimensions}, the trace dimensions are passed as an input parameter to the operation, are of type {\ttfamily $<$Tensor\+Type$>$\+::}{\ttfamily Dimensions} , and have the same requirements when passed as an input parameter. In addition, the trace dimensions must have the same size.

Example\+: \mbox{\hyperlink{class_trace}{Trace}} along 2 dimensions. \begin{DoxyVerb}// Create a tensor of 3 dimensions
Eigen::Tensor<int, 3> a(2, 2, 3);
a.setValues({{{1, 2, 3}, {4, 5, 6}}, {{7, 8, 9}, {10, 11, 12}}});
// Specify the dimensions along which the trace will be computed.
// In this example, the trace can only be computed along the dimensions
// with indices 0 and 1
Eigen::array<int, 2> dims({0, 1});
// The output tensor contains all but the trace dimensions.
Tensor<int, 1> a_trace = a.trace(dims);
cout << "a_trace:" << endl;
cout << a_trace << endl;
=>
a_trace:
11
13
15
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1661}{}\doxysubsection{$<$\+Operation$>$ trace(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1661}
\hypertarget{eigen_tensors_autotoc_md1662}{}\doxysubsection{$<$\+Operation$>$ trace()}\label{eigen_tensors_autotoc_md1662}
As a special case, if no parameter is passed to the operation, trace is computed along {\itshape all} dimensions of the input tensor.

Example\+: \mbox{\hyperlink{class_trace}{Trace}} along all dimensions. \begin{DoxyVerb}// Create a tensor of 3 dimensions, with all dimensions having the same size.
Eigen::Tensor<int, 3> a(3, 3, 3);
a.setValues({{{1, 2, 3}, {4, 5, 6}, {7, 8, 9}},
            {{10, 11, 12}, {13, 14, 15}, {16, 17, 18}},
            {{19, 20, 21}, {22, 23, 24}, {25, 26, 27}}});
// Result is a zero dimension tensor
Tensor<int, 0> a_trace = a.trace();
cout<<"a_trace:"<<endl;
cout<<a_trace<<endl;
=>
a_trace:
42
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1663}{}\doxysection{Scan Operations}\label{eigen_tensors_autotoc_md1663}
A {\itshape Scan} operation returns a tensor with the same dimensions as the original tensor. The operation performs an inclusive scan along the specified axis, which means it computes a running total along the axis for a given reduction operation. If the reduction operation corresponds to summation, then this computes the prefix sum of the tensor along the given axis.

Example\+: dd a comment to this line \begin{DoxyVerb}// Create a tensor of 2 dimensions
Eigen::Tensor<int, 2> a(2, 3);
a.setValues({{1, 2, 3}, {4, 5, 6}});
// Scan it along the second dimension (1) using summation
Eigen::Tensor<int, 2> b = a.cumsum(1);
// The result is a tensor with the same size as the input
cout << "a" << endl << a << endl << endl;
cout << "b" << endl << b << endl << endl;
=>
a
1 2 3
4 5 6

b
1  3  6
4  9 15
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1664}{}\doxysubsection{$<$\+Operation$>$ cumsum(const Index\& axis)}\label{eigen_tensors_autotoc_md1664}
Perform a scan by summing consecutive entries.\hypertarget{eigen_tensors_autotoc_md1665}{}\doxysubsection{$<$\+Operation$>$ cumprod(const Index\& axis)}\label{eigen_tensors_autotoc_md1665}
Perform a scan by multiplying consecutive entries.\hypertarget{eigen_tensors_autotoc_md1666}{}\doxysection{Convolutions}\label{eigen_tensors_autotoc_md1666}
\hypertarget{eigen_tensors_autotoc_md1667}{}\doxysubsection{$<$\+Operation$>$ convolve(const Kernel\& kernel, const Dimensions\& dims)}\label{eigen_tensors_autotoc_md1667}
Returns a tensor that is the output of the convolution of the input tensor with the kernel, along the specified dimensions of the input tensor. The dimension size for dimensions of the output tensor which were part of the convolution will be reduced by the formula\+: output\+\_\+dim\+\_\+size = input\+\_\+dim\+\_\+size -\/ kernel\+\_\+dim\+\_\+size + 1 (requires\+: input\+\_\+dim\+\_\+size $>$= kernel\+\_\+dim\+\_\+size). The dimension sizes for dimensions that were not part of the convolution will remain the same. Performance of the convolution can depend on the length of the stride(s) of the input tensor dimension(s) along which the convolution is computed (the first dimension has the shortest stride for Col\+Major, whereas Row\+Major\textquotesingle{}s shortest stride is for the last dimension). \begin{DoxyVerb}// Compute convolution along the second and third dimension.
Tensor<float, 4, DataLayout> input(3, 3, 7, 11);
Tensor<float, 2, DataLayout> kernel(2, 2);
Tensor<float, 4, DataLayout> output(3, 2, 6, 11);
input.setRandom();
kernel.setRandom();

Eigen::array<ptrdiff_t, 2> dims({1, 2});  // Specify second and third dimension for convolution.
output = input.convolve(kernel, dims);

for (int i = 0; i < 3; ++i) {
  for (int j = 0; j < 2; ++j) {
    for (int k = 0; k < 6; ++k) {
      for (int l = 0; l < 11; ++l) {
        const float result = output(i,j,k,l);
        const float expected = input(i,j+0,k+0,l) * kernel(0,0) +
                               input(i,j+1,k+0,l) * kernel(1,0) +
                               input(i,j+0,k+1,l) * kernel(0,1) +
                               input(i,j+1,k+1,l) * kernel(1,1);
        VERIFY_IS_APPROX(result, expected);
      }
    }
  }
}
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1668}{}\doxysection{Geometrical Operations}\label{eigen_tensors_autotoc_md1668}
These operations return a Tensor with different dimensions than the original Tensor. They can be used to access slices of tensors, see them with different dimensions, or pad tensors with additional data.\hypertarget{eigen_tensors_autotoc_md1669}{}\doxysubsection{$<$\+Operation$>$ reshape(const Dimensions\& new\+\_\+dims)}\label{eigen_tensors_autotoc_md1669}
Returns a view of the input tensor that has been reshaped to the specified new dimensions. The argument new\+\_\+dims is an array of Index values. The rank of the resulting tensor is equal to the number of elements in new\+\_\+dims.

The product of all the sizes in the new dimension array must be equal to the number of elements in the input tensor. \begin{DoxyVerb}// Increase the rank of the input tensor by introducing a new dimension
// of size 1.
Tensor<float, 2> input(7, 11);
array<int, 3> three_dims{{7, 11, 1}};
Tensor<float, 3> result = input.reshape(three_dims);

// Decrease the rank of the input tensor by merging 2 dimensions;
array<int, 1> one_dim{{7 * 11}};
Tensor<float, 1> result = input.reshape(one_dim);
\end{DoxyVerb}


This operation does not move any data in the input tensor, so the resulting contents of a reshaped Tensor depend on the data layout of the original Tensor.

For example this is what happens when you {\ttfamily reshape()} a 2D Col\+Major tensor to one dimension\+: \begin{DoxyVerb}Eigen::Tensor<float, 2, Eigen::ColMajor> a(2, 3);
a.setValues({{0.0f, 100.0f, 200.0f}, {300.0f, 400.0f, 500.0f}});
Eigen::array<Eigen::DenseIndex, 1> one_dim({3 * 2});
Eigen::Tensor<float, 1, Eigen::ColMajor> b = a.reshape(one_dim);
cout << "b" << endl << b << endl;
=>
b
  0
300
100
400
200
500
\end{DoxyVerb}


This is what happens when the 2D Tensor is Row\+Major\+: \begin{DoxyVerb}Eigen::Tensor<float, 2, Eigen::RowMajor> a(2, 3);
a.setValues({{0.0f, 100.0f, 200.0f}, {300.0f, 400.0f, 500.0f}});
Eigen::array<Eigen::DenseIndex, 1> one_dim({3 * 2});
Eigen::Tensor<float, 1, Eigen::RowMajor> b = a.reshape(one_dim);
cout << "b" << endl << b << endl;
=>
b
  0
100
200
300
400
500
\end{DoxyVerb}


The reshape operation is a lvalue. In other words, it can be used on the left side of the assignment operator.

The previous example can be rewritten as follow\+: \begin{DoxyVerb}Eigen::Tensor<float, 2, Eigen::ColMajor> a(2, 3);
a.setValues({{0.0f, 100.0f, 200.0f}, {300.0f, 400.0f, 500.0f}});
Eigen::array<Eigen::DenseIndex, 2> two_dim({2, 3});
Eigen::Tensor<float, 1, Eigen::ColMajor> b(6);
b.reshape(two_dim) = a;
cout << "b" << endl << b << endl;
=>
b
  0
300
100
400
200
500
\end{DoxyVerb}


Note that \char`\"{}b\char`\"{} itself was not reshaped but that instead the assignment is done to the reshape view of b.\hypertarget{eigen_tensors_autotoc_md1670}{}\doxysubsection{$<$\+Operation$>$ shuffle(const Shuffle\& shuffle)}\label{eigen_tensors_autotoc_md1670}
Returns a copy of the input tensor whose dimensions have been reordered according to the specified permutation. The argument shuffle is an array of Index values. Its size is the rank of the input tensor. It must contain a permutation of 0, 1, ..., rank -\/ 1. The i-\/th dimension of the output tensor equals to the size of the shuffle\mbox{[}i\mbox{]}-\/th dimension of the input tensor. For example\+: \begin{DoxyVerb}// Shuffle all dimensions to the left by 1.
Tensor<float, 3> input(20, 30, 50);
// ... set some values in input.
Tensor<float, 3> output = input.shuffle({1, 2, 0})

eigen_assert(output.dimension(0) == 30);
eigen_assert(output.dimension(1) == 50);
eigen_assert(output.dimension(2) == 20);
\end{DoxyVerb}


Indices into the output tensor are shuffled accordingly to formulate indices into the input tensor. For example, one can assert in the above code snippet that\+: \begin{DoxyVerb}eigen_assert(output(3, 7, 11) == input(11, 3, 7));
\end{DoxyVerb}


In general, one can assert that \begin{DoxyVerb}eigen_assert(output(..., indices[shuffle[i]], ...) ==
             input(..., indices[i], ...))
\end{DoxyVerb}


The shuffle operation results in a lvalue, which means that it can be assigned to. In other words, it can be used on the left side of the assignment operator.

Let\textquotesingle{}s rewrite the previous example to take advantage of this feature\+: \begin{DoxyVerb}// Shuffle all dimensions to the left by 1.
Tensor<float, 3> input(20, 30, 50);
// ... set some values in input.
Tensor<float, 3> output(30, 50, 20);
output.shuffle({2, 0, 1}) = input;
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1671}{}\doxysubsection{$<$\+Operation$>$ stride(const Strides\& strides)}\label{eigen_tensors_autotoc_md1671}
Returns a view of the input tensor that strides (skips stride-\/1 elements) along each of the dimensions. The argument strides is an array of Index values. The dimensions of the resulting tensor are ceil(input\+\_\+dimensions\mbox{[}i\mbox{]} / strides\mbox{[}i\mbox{]}).

For example this is what happens when you {\ttfamily stride()} a 2D tensor\+: \begin{DoxyVerb}Eigen::Tensor<int, 2> a(4, 3);
a.setValues({{0, 100, 200}, {300, 400, 500}, {600, 700, 800}, {900, 1000, 1100}});
Eigen::array<Eigen::DenseIndex, 2> strides({3, 2});
Eigen::Tensor<int, 2> b = a.stride(strides);
cout << "b" << endl << b << endl;
=>
b
   0   200
 900  1100
\end{DoxyVerb}


It is possible to assign a tensor to a stride\+: Tensor$<$float, 3$>$ input(20, 30, 50); // ... set some values in input. Tensor$<$float, 3$>$ output(40, 90, 200); output.\+stride(\{2, 3, 4\}) = input;\hypertarget{eigen_tensors_autotoc_md1672}{}\doxysubsection{$<$\+Operation$>$ slice(const Start\+Indices\& offsets, const Sizes\& extents)}\label{eigen_tensors_autotoc_md1672}
Returns a sub-\/tensor of the given tensor. For each dimension i, the slice is made of the coefficients stored between offset\mbox{[}i\mbox{]} and offset\mbox{[}i\mbox{]} + extents\mbox{[}i\mbox{]} in the input tensor. \begin{DoxyVerb}Eigen::Tensor<int, 2> a(4, 3);
a.setValues({{0, 100, 200}, {300, 400, 500},
             {600, 700, 800}, {900, 1000, 1100}});
Eigen::array<Eigen::Index, 2> offsets = {1, 0};
Eigen::array<Eigen::Index, 2> extents = {2, 2};
Eigen::Tensor<int, 2> slice = a.slice(offsets, extents);
cout << "a" << endl << a << endl;
=>
a
   0   100   200
 300   400   500
 600   700   800
 900  1000  1100
cout << "slice" << endl << slice << endl;
=>
slice
 300   400
 600   700
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1673}{}\doxysubsection{$<$\+Operation$>$ chip(const Index offset, const Index dim)}\label{eigen_tensors_autotoc_md1673}
A chip is a special kind of slice. It is the subtensor at the given offset in the dimension dim. The returned tensor has one fewer dimension than the input tensor\+: the dimension dim is removed.

For example, a matrix chip would be either a row or a column of the input matrix. \begin{DoxyVerb}Eigen::Tensor<int, 2> a(4, 3);
a.setValues({{0, 100, 200}, {300, 400, 500},
             {600, 700, 800}, {900, 1000, 1100}});
Eigen::Tensor<int, 1> row_3 = a.chip(2, 0);
Eigen::Tensor<int, 1> col_2 = a.chip(1, 1);
cout << "a" << endl << a << endl;
=>
a
   0   100   200
 300   400   500
 600   700   800
 900  1000  1100
cout << "row_3" << endl << row_3 << endl;
=>
row_3
   600   700   800
cout << "col_2" << endl << col_2 << endl;
=>
col_2
   100   400   700    1000
\end{DoxyVerb}


It is possible to assign values to a tensor chip since the chip operation is a lvalue. For example\+: \begin{DoxyVerb}Eigen::Tensor<int, 1> a(3);
a.setValues({{100, 200, 300}});
Eigen::Tensor<int, 2> b(2, 3);
b.setZero();
b.chip(0, 0) = a;
cout << "a" << endl << a << endl;
=>
a
 100
 200
 300
cout << "b" << endl << b << endl;
=>
b
   100   200   300
     0     0     0
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1674}{}\doxysubsection{$<$\+Operation$>$ reverse(const Reverse\+Dimensions\& reverse)}\label{eigen_tensors_autotoc_md1674}
Returns a view of the input tensor that reverses the order of the coefficients along a subset of the dimensions. The argument reverse is an array of boolean values that indicates whether or not the order of the coefficients should be reversed along each of the dimensions. This operation preserves the dimensions of the input tensor.

For example this is what happens when you {\ttfamily reverse()} the first dimension of a 2D tensor\+: \begin{DoxyVerb}Eigen::Tensor<int, 2> a(4, 3);
a.setValues({{0, 100, 200}, {300, 400, 500},
            {600, 700, 800}, {900, 1000, 1100}});
Eigen::array<bool, 2> reverse({true, false});
Eigen::Tensor<int, 2> b = a.reverse(reverse);
cout << "a" << endl << a << endl << "b" << endl << b << endl;
=>
a
   0   100   200
 300   400   500
 600   700   800
 900  1000  1100
b
 900  1000  1100
 600   700   800
 300   400   500
   0   100   200
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1675}{}\doxysubsection{$<$\+Operation$>$ broadcast(const Broadcast\& broadcast)}\label{eigen_tensors_autotoc_md1675}
Returns a view of the input tensor in which the input is replicated one to many times. The broadcast argument specifies how many copies of the input tensor need to be made in each of the dimensions. \begin{DoxyVerb}Eigen::Tensor<int, 2> a(2, 3);
a.setValues({{0, 100, 200}, {300, 400, 500}});
Eigen::array<int, 2> bcast({3, 2});
Eigen::Tensor<int, 2> b = a.broadcast(bcast);
cout << "a" << endl << a << endl << "b" << endl << b << endl;
=>
a
   0   100   200
 300   400   500
b
   0   100   200    0   100   200
 300   400   500  300   400   500
   0   100   200    0   100   200
 300   400   500  300   400   500
   0   100   200    0   100   200
 300   400   500  300   400   500
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1676}{}\doxysubsection{$<$\+Operation$>$ concatenate(const Other\+Derived\& other, Axis axis)}\label{eigen_tensors_autotoc_md1676}
T\+O\+DO\hypertarget{eigen_tensors_autotoc_md1677}{}\doxysubsection{$<$\+Operation$>$  pad(const Padding\+Dimensions\& padding)}\label{eigen_tensors_autotoc_md1677}
Returns a view of the input tensor in which the input is padded with zeros. \begin{DoxyVerb}Eigen::Tensor<int, 2> a(2, 3);
a.setValues({{0, 100, 200}, {300, 400, 500}});
Eigen::array<pair<int, int>, 2> paddings;
paddings[0] = make_pair(0, 1);
paddings[1] = make_pair(2, 3);
Eigen::Tensor<int, 2> b = a.pad(paddings);
cout << "a" << endl << a << endl << "b" << endl << b << endl;
=>
a
   0   100   200
 300   400   500
b
   0     0     0    0
   0     0     0    0
   0   100   200    0
 300   400   500    0
   0     0     0    0
   0     0     0    0
   0     0     0    0
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1678}{}\doxysubsection{$<$\+Operation$>$  extract\+\_\+patches(const Patch\+Dims\& patch\+\_\+dims)}\label{eigen_tensors_autotoc_md1678}
Returns a tensor of coefficient patches extracted from the input tensor, where each patch is of dimension specified by \textquotesingle{}patch\+\_\+dims\textquotesingle{}. The returned tensor has one greater dimension than the input tensor, which is used to index each patch. The patch index in the output tensor depends on the data layout of the input tensor\+: the patch index is the last dimension Col\+Major layout, and the first dimension in Row\+Major layout.

For example, given the following input tensor\+: \begin{DoxyVerb}Eigen::Tensor<float, 2, DataLayout> tensor(3,4);
tensor.setValues({{0.0f, 1.0f, 2.0f, 3.0f},
                  {4.0f, 5.0f, 6.0f, 7.0f},
                  {8.0f, 9.0f, 10.0f, 11.0f}});

cout << "tensor: " << endl << tensor << endl;
=>
tensor:
 0   1   2   3
 4   5   6   7
 8   9  10  11
\end{DoxyVerb}


Six 2x2 patches can be extracted and indexed using the following code\+: \begin{DoxyVerb}Eigen::Tensor<float, 3, DataLayout> patch;
Eigen::array<ptrdiff_t, 2> patch_dims;
patch_dims[0] = 2;
patch_dims[1] = 2;
patch = tensor.extract_patches(patch_dims);
for (int k = 0; k < 6; ++k) {
  cout << "patch index: " << k << endl;
  for (int i = 0; i < 2; ++i) {
    for (int j = 0; j < 2; ++j) {
      if (DataLayout == ColMajor) {
        cout << patch(i, j, k) << " ";
      } else {
        cout << patch(k, i, j) << " ";
      }
    }
    cout << endl;
  }
}
\end{DoxyVerb}


This code results in the following output when the data layout is Col\+Major\+: \begin{DoxyVerb}patch index: 0
0 1
4 5
patch index: 1
4 5
8 9
patch index: 2
1 2
5 6
patch index: 3
5 6
9 10
patch index: 4
2 3
6 7
patch index: 5
6 7
10 11
\end{DoxyVerb}


This code results in the following output when the data layout is Row\+Major\+: (N\+O\+TE\+: the set of patches is the same as in Col\+Major, but are indexed differently). \begin{DoxyVerb}patch index: 0
0 1
4 5
patch index: 1
1 2
5 6
patch index: 2
2 3
6 7
patch index: 3
4 5
8 9
patch index: 4
5 6
9 10
patch index: 5
6 7
10 11
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1679}{}\doxysubsection{$<$\+Operation$>$  extract\+\_\+image\+\_\+patches(const Index patch\+\_\+rows, const Index patch\+\_\+cols, const Index row\+\_\+stride, const Index col\+\_\+stride, const Padding\+Type padding\+\_\+type)}\label{eigen_tensors_autotoc_md1679}
Returns a tensor of coefficient image patches extracted from the input tensor, which is expected to have dimensions ordered as follows (depending on the data layout of the input tensor, and the number of additional dimensions \textquotesingle{}N\textquotesingle{})\+:

$\ast$) Col\+Major 1st dimension\+: channels (of size d) 2nd dimension\+: rows (of size r) 3rd dimension\+: columns (of size c) 4th-\/\+Nth dimension\+: time (for video) or batch (for bulk processing).

$\ast$) Row\+Major (reverse order of Col\+Major) 1st-\/\+Nth dimension\+: time (for video) or batch (for bulk processing). N+1\textquotesingle{}th dimension\+: columns (of size c) N+2\textquotesingle{}th dimension\+: rows (of size r) N+3\textquotesingle{}th dimension\+: channels (of size d)

The returned tensor has one greater dimension than the input tensor, which is used to index each patch. The patch index in the output tensor depends on the data layout of the input tensor\+: the patch index is the 4\textquotesingle{}th dimension in Col\+Major layout, and the 4\textquotesingle{}th from the last dimension in Row\+Major layout.

For example, given the following input tensor with the following dimension sizes\+: $\ast$) depth\+: 2 $\ast$) rows\+: 3 $\ast$) columns\+: 5 $\ast$) batch\+: 7

Tensor$<$float, 4$>$ tensor(2,3,5,7); Tensor$<$float, 4, Row\+Major$>$ tensor\+\_\+row\+\_\+major = tensor.\+swap\+\_\+layout();

2x2 image patches can be extracted and indexed using the following code\+:

$\ast$) 2D patch\+: Col\+Major (patch indexed by second-\/to-\/last dimension) \begin{DoxyVerb}Tensor<float, 5> twod_patch;
twod_patch = tensor.extract_image_patches<2, 2>();
// twod_patch.dimension(0) == 2
// twod_patch.dimension(1) == 2
// twod_patch.dimension(2) == 2
// twod_patch.dimension(3) == 3*5
// twod_patch.dimension(4) == 7
\end{DoxyVerb}


$\ast$) 2D patch\+: Row\+Major (patch indexed by the second dimension) \begin{DoxyVerb}Tensor<float, 5, RowMajor> twod_patch_row_major;
twod_patch_row_major = tensor_row_major.extract_image_patches<2, 2>();
// twod_patch_row_major.dimension(0) == 7
// twod_patch_row_major.dimension(1) == 3*5
// twod_patch_row_major.dimension(2) == 2
// twod_patch_row_major.dimension(3) == 2
// twod_patch_row_major.dimension(4) == 2
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1680}{}\doxysection{Special Operations}\label{eigen_tensors_autotoc_md1680}
\hypertarget{eigen_tensors_autotoc_md1681}{}\doxysubsection{$<$\+Operation$>$ cast$<$\+T$>$()}\label{eigen_tensors_autotoc_md1681}
Returns a tensor of type T with the same dimensions as the original tensor. The returned tensor contains the values of the original tensor converted to type T. \begin{DoxyVerb}Eigen::Tensor<float, 2> a(2, 3);
Eigen::Tensor<int, 2> b = a.cast<int>();
\end{DoxyVerb}


This can be useful for example if you need to do element-\/wise division of Tensors of integers. This is not currently supported by the Tensor library but you can easily cast the tensors to floats to do the division\+: \begin{DoxyVerb}Eigen::Tensor<int, 2> a(2, 3);
a.setValues({{0, 1, 2}, {3, 4, 5}});
Eigen::Tensor<int, 2> b =
    (a.cast<float>() / a.constant(2).cast<float>()).cast<int>();
cout << "a" << endl << a << endl << endl;
cout << "b" << endl << b << endl << endl;
=>
a
0 1 2
3 4 5

b
0 0 1
1 2 2
\end{DoxyVerb}
\hypertarget{eigen_tensors_autotoc_md1682}{}\doxysubsection{$<$\+Operation$>$     eval()}\label{eigen_tensors_autotoc_md1682}
T\+O\+DO\hypertarget{eigen_tensors_autotoc_md1683}{}\doxysection{Tensor Printing}\label{eigen_tensors_autotoc_md1683}
Tensors can be printed into a stream object (e.\+g. {\ttfamily std\+::cout}) using different formatting options. \begin{DoxyVerb}Eigen::Tensor<float, 3> tensor3d = {4, 3, 2};
tensor3d.setValues( {{{1, 2}, {3, 4}, {5, 6}}, {{7, 8}, {9, 10}, {11, 12}}, {{13, 14}, {15, 16}, {17, 18}}, {{19, 20}, {21, 22}, {23, 24}}} );
std::cout << tensor3d.format(Eigen::TensorIOFormat::Plain()) << std::endl;
==>
 1  2 
 3  4 
 5  6 

 7  8 
 9 10
11 12

13 14
15 16
17 18

19 20
21 22
23 24
\end{DoxyVerb}


In the example, we used the predefined format {\ttfamily Eigen\+::\+Tensor\+I\+O\+Format\+::\+Plain}. Here is the list of all predefined formats from which you can choose\+:
\begin{DoxyItemize}
\item {\ttfamily Eigen\+::\+Tensor\+I\+O\+Format\+::\+Plain()} for a plain output without braces. Different submatrices are separated by a blank line.
\item {\ttfamily Eigen\+::\+Tensor\+I\+O\+Format\+::\+Numpy()} for numpy-\/like output.
\item {\ttfamily Eigen\+::\+Tensor\+I\+O\+Format\+::\+Native()} for a {\ttfamily c++} like output which can be directly copy-\/pasted to set\+Values().
\item {\ttfamily Eigen\+::\+Tensor\+I\+O\+Format\+::\+Legacy()} for a backwards compatible printing of tensors.
\end{DoxyItemize}

If you send the tensor directly to the stream the default format is called which is {\ttfamily Eigen\+::\+I\+O\+Formats\+::\+Plain()}.

You can define your own format by explicitly providing a {\ttfamily \mbox{\hyperlink{struct_eigen_1_1_tensor_i_o_format}{Eigen\+::\+Tensor\+I\+O\+Format}}} class instance. Here, you can specify\+:
\begin{DoxyItemize}
\item The overall prefix and suffix with {\ttfamily std\+::string ten\+Prefix} and {\ttfamily std\+::string ten\+Suffix}
\item The prefix, separator and suffix for each new element, row, matrix, 3d subtensor, ... with {\ttfamily std\+::vector$<$std\+::string$>$ prefix}, {\ttfamily std\+::vector$<$std\+::string$>$ separator} and {\ttfamily std\+::vector$<$std\+::string$>$ suffix}. Note that the first entry in each of the vectors refer to the last dimension of the tensor, e.\+g. {\ttfamily separator\mbox{[}0\mbox{]}} will be printed between adjacent elements, {\ttfamily separator\mbox{[}1\mbox{]}} will be printed between adjacent matrices, ...
\item {\ttfamily char fill}\+: character which will be placed if the elements are aligned.
\item {\ttfamily int precision}
\item {\ttfamily int flags}\+: an O\+R-\/ed combination of flags, the default value is 0, the only currently available flag is {\ttfamily Eigen\+::\+Dont\+Align\+Cols} which allows to disable the alignment of columns, resulting in faster code.
\end{DoxyItemize}\hypertarget{eigen_tensors_autotoc_md1684}{}\doxysection{Representation of scalar values}\label{eigen_tensors_autotoc_md1684}
Scalar values are often represented by tensors of size 1 and rank 0.\+For example Tensor$<$\+T, N$>$\+::maximum() currently returns a Tensor$<$\+T, 0$>$. Similarly, the inner product of 2 1d tensors (through contractions) returns a 0d tensor.\hypertarget{eigen_tensors_autotoc_md1685}{}\doxysection{Limitations}\label{eigen_tensors_autotoc_md1685}

\begin{DoxyItemize}
\item The number of tensor dimensions is currently limited to 250 when using a compiler that supports cxx11. It is limited to only 5 for older compilers.
\item The Index\+List class requires a cxx11 compliant compiler. You can use an array of indices instead if you don\textquotesingle{}t have access to a modern compiler.
\item On G\+P\+Us only floating point values are properly tested and optimized for. 
\end{DoxyItemize}