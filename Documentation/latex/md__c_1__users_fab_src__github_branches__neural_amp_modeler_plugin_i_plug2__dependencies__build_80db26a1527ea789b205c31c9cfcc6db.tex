There are two ways use Oboe in your Android Studio project\+:

1) {\bfseries{Use the Oboe pre-\/built library binaries and headers}} $\ast$(Experimental)$\ast$. Use this approach if you just want to use a stable version of the Oboe library in your project.

or

2) {\bfseries{Build Oboe from source.}} Use this approach if you would like to debug or make changes to the Oboe source code and contribute back to the project.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md410}{}\doxysection{Option 1) Using pre-\/built binaries and headers}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md410}
{\itshape This approach is currently experimental as it uses a preview version of Android Studio.}

Oboe is distributed as a \href{https://github.com/google/prefab}{\texttt{ prefab}} package via \href{https://maven.google.com/web/index.html}{\texttt{ Google Maven}} (search for \char`\"{}oboe\char`\"{}). \href{https://android-developers.googleblog.com/2020/02/native-dependencies-in-android-studio-40.html}{\texttt{ Prefab support was added}} to \href{https://developer.android.com/studio/preview}{\texttt{ Android Studio Preview 4.\+0 Canary 9}} so you\textquotesingle{}ll need to be using this version of Android Studio or above.

Add the oboe dependency to your app\textquotesingle{}s {\ttfamily build.\+gradle} file. Replace \char`\"{}1.\+4.\+2\char`\"{} with the \href{https://github.com/google/oboe/releases/}{\texttt{ latest stable version}} of Oboe\+: \begin{DoxyVerb}dependencies {
    implementation 'com.google.oboe:oboe:1.4.2'
}
\end{DoxyVerb}


Also enable prefab by adding\+: \begin{DoxyVerb}android {
    buildFeatures {
        prefab true
    }
}
\end{DoxyVerb}


Include and link to oboe by updating your {\ttfamily C\+Make\+Lists.\+txt}\+: \begin{DoxyVerb}find_package (oboe REQUIRED CONFIG)
target_link_libraries(app oboe::oboe) # You may have other libraries here such as `log`.
\end{DoxyVerb}


Configure your app to use the shared S\+TL by updating your {\ttfamily app/build.\+gradle}\+: \begin{DoxyVerb}android { 
    defaultConfig { 
        externalNativeBuild {
            cmake {
                arguments "-DANDROID_STL=c++_shared"
            }
        }
    }
}
\end{DoxyVerb}
\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md411}{}\doxysection{Option 2) Building from source}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md411}
\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md412}{}\doxysubsection{1. Clone the github repository}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md412}
Start by cloning the \href{https://github.com/google/oboe/releases/}{\texttt{ latest stable release}} of the Oboe repository, for example\+: \begin{DoxyVerb}git clone -b 1.4-stable https://github.com/google/oboe
\end{DoxyVerb}


{\bfseries{Make a note of the path which you cloned oboe into -\/ you will need it shortly}}

If you use git as your version control system, consider adding Oboe as a \href{https://gist.github.com/gitaarik/8735255}{\texttt{ submodule}} (underneath your cpp directory)


\begin{DoxyCode}{0}
\DoxyCodeLine{git submodule add https://github.com/google/oboe}
\end{DoxyCode}


This makes it easier to integrate updates to Oboe into your app, as well as contribute to the Oboe project.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md413}{}\doxysubsection{2. Update C\+Make\+Lists.\+txt}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md413}
Open your app\textquotesingle{}s {\ttfamily C\+Make\+Lists.\+txt}. This can be found under {\ttfamily External Build Files} in the Android project view. If you don\textquotesingle{}t have a {\ttfamily C\+Make\+Lists.\+txt} you will need to \href{https://developer.android.com/studio/projects/add-native-code}{\texttt{ add C++ support to your project}}.



Now add the following commands to the end of {\ttfamily C\+Make\+Lists.\+txt}. {\bfseries{Remember to update {\ttfamily $\ast$$\ast$\+P\+A\+TH TO O\+B\+O\+E$\ast$$\ast$} with your local Oboe path from the previous step}}\+: \begin{DoxyVerb}# Set the path to the Oboe directory.
set (OBOE_DIR ***PATH TO OBOE***)

# Add the Oboe library as a subdirectory in your project.
# add_subdirectory tells CMake to look in this directory to
# compile oboe source files using oboe's CMake file.
# ./oboe specifies where the compiled binaries will be stored
add_subdirectory (${OBOE_DIR} ./oboe)

# Specify the path to the Oboe header files.
# This allows targets compiled with this CMake (application code)
# to see public Oboe headers, in order to access its API.
include_directories (${OBOE_DIR}/include)
\end{DoxyVerb}


In the same file find the \href{https://cmake.org/cmake/help/latest/command/target_link_libraries.html}{\texttt{ {\ttfamily target\+\_\+link\+\_\+libraries}}} command. Add {\ttfamily oboe} to the list of libraries which your app\textquotesingle{}s library depends on. For example\+: \begin{DoxyVerb}target_link_libraries(native-lib oboe)
\end{DoxyVerb}


Here\textquotesingle{}s a complete example {\ttfamily C\+Make\+Lists.\+txt} file\+: \begin{DoxyVerb}cmake_minimum_required(VERSION 3.4.1)

# Build our own native library
add_library (native-lib SHARED native-lib.cpp )

# Build the Oboe library
set (OBOE_DIR ./oboe)
add_subdirectory (${OBOE_DIR} ./oboe)

# Make the Oboe public headers available to our app
include_directories (${OBOE_DIR}/include)

# Specify the libraries which our native library is dependent on, including Oboe
target_link_libraries (native-lib log oboe)
\end{DoxyVerb}


Now go to {\ttfamily Build-\/$>$Refresh Linked C++ Projects} to have Android Studio index the Oboe library.

Verify that your project builds correctly. If you have any issues building please \href{issues/new}{\texttt{ report them here}}.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md414}{}\doxysection{Using Oboe}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md414}
Once you\textquotesingle{}ve added Oboe to your project you can start using Oboe\textquotesingle{}s features. The simplest, and probably most common thing you\textquotesingle{}ll do in Oboe is to create an audio stream.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md415}{}\doxysubsection{Creating an audio stream}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md415}
Include the Oboe header\+: \begin{DoxyVerb}#include <oboe/Oboe.h>
\end{DoxyVerb}


Streams are built using an {\ttfamily Audio\+Stream\+Builder}. Create one like this\+: \begin{DoxyVerb}oboe::AudioStreamBuilder builder;
\end{DoxyVerb}


Use the builder\textquotesingle{}s set methods to set properties on the stream (you can read more about these properties in the full guide)\+: \begin{DoxyVerb}builder.setDirection(oboe::Direction::Output);
builder.setPerformanceMode(oboe::PerformanceMode::LowLatency);
builder.setSharingMode(oboe::SharingMode::Exclusive);
builder.setFormat(oboe::AudioFormat::Float);
builder.setChannelCount(oboe::ChannelCount::Mono);
\end{DoxyVerb}


The builder\textquotesingle{}s set methods return a pointer to the builder. So they can be easily chained\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{oboe::AudioStreamBuilder builder;}
\DoxyCodeLine{builder.setPerformanceMode(oboe::PerformanceMode::LowLatency)}
\DoxyCodeLine{  -\/>setSharingMode(oboe::SharingMode::Exclusive)}
\DoxyCodeLine{  -\/>setCallback(myCallback)}
\DoxyCodeLine{  -\/>setFormat(oboe::AudioFormat::Float);}
\end{DoxyCode}


Define an {\ttfamily Audio\+Stream\+Callback} class to receive callbacks whenever the stream requires new data. \begin{DoxyVerb}class MyCallback : public oboe::AudioStreamCallback {
public:
    oboe::DataCallbackResult
    onAudioReady(oboe::AudioStream *audioStream, void *audioData, int32_t numFrames) {

        // We requested AudioFormat::Float so we assume we got it.
        // For production code always check what format
        // the stream has and cast to the appropriate type.
        auto *outputData = static_cast<float *>(audioData);

        // Generate random numbers (white noise) centered around zero.
        const float amplitude = 0.2f;
        for (int i = 0; i < numFrames; ++i){
            outputData[i] = ((float)drand48() - 0.5f) * 2 * amplitude;
        }

        return oboe::DataCallbackResult::Continue;
    }
};
\end{DoxyVerb}


You can find examples of how to play sound using digital synthesis and pre-\/recorded audio in the \href{../samples}{\texttt{ code samples}}.

Declare your callback somewhere that it won\textquotesingle{}t get deleted while you are using it. \begin{DoxyVerb}MyCallback myCallback;
\end{DoxyVerb}


Supply this callback class to the builder\+: \begin{DoxyVerb}builder.setCallback(&myCallback);
\end{DoxyVerb}


Declare a Managed\+Stream. Make sure it is declared in an appropriate scope (e.\+g.\+the member of a managing class). Avoid declaring it as a global. 
\begin{DoxyCode}{0}
\DoxyCodeLine{oboe::ManagedStream managedStream;}
\end{DoxyCode}


Open the stream\+: \begin{DoxyVerb}oboe::Result result = builder.openManagedStream(managedStream);
\end{DoxyVerb}


Check the result to make sure the stream was opened successfully. Oboe has a convenience method for converting its types into human-\/readable strings called {\ttfamily \mbox{\hyperlink{namespaceoboe_a0310f9ed27a82c4b9859beb938737096}{oboe\+::convert\+To\+Text}}}\+: \begin{DoxyVerb}if (result != oboe::Result::OK) {
    LOGE("Failed to create stream. Error: %s", oboe::convertToText(result));
}
\end{DoxyVerb}


Note that this sample code uses the \href{https://github.com/googlesamples/android-audio-high-performance/blob/master/debug-utils/logging_macros.h}{\texttt{ logging macros from here}}.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md416}{}\doxysubsection{Playing audio}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md416}
Check the properties of the created stream. If you did not specify a channel\+Count, sample\+Rate, or format then you need to query the stream to see what you got. The {\bfseries{format}} property will dictate the {\ttfamily audio\+Data} type in the {\ttfamily Audio\+Stream\+Callback\+::on\+Audio\+Ready} callback. If you did specify any of those three properties then you will get what you requested. \begin{DoxyVerb}oboe::AudioFormat format = stream->getFormat();
LOGI("AudioStream format is %s", oboe::convertToText(format));
\end{DoxyVerb}


Now start the stream. \begin{DoxyVerb}managedStream->requestStart();
\end{DoxyVerb}


At this point you should start receiving callbacks.

To stop receiving callbacks call \begin{DoxyVerb}managedStream->requestStop();
\end{DoxyVerb}
\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md417}{}\doxysubsection{Closing the stream}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md417}
It is important to close your stream when you\textquotesingle{}re not using it to avoid hogging audio resources which other apps could use. This is particularly true when using {\ttfamily Sharing\+Mode\+::\+Exclusive} because you might prevent other apps from obtaining a low latency audio stream.

Streams can be explicitly closed\+: \begin{DoxyVerb}stream->close();
\end{DoxyVerb}


{\ttfamily close()} is a blocking call which also stops the stream.

Streams can also be automatically closed when going out of scope\+: \begin{DoxyVerb}{
    ManagedStream mStream;
    AudioStreamBuilder().build(mStream);
    mStream->requestStart();
} // Out of this scope the mStream has been automatically closed 
\end{DoxyVerb}


It is preferable to let the {\ttfamily Managed\+Stream} object go out of scope (or be explicitly deleted) when the app is no longer playing audio. For apps which only play or record audio when they are in the foreground this is usually done when \href{https://developer.android.com/guide/components/activities/activity-lifecycle\#onpause}{\texttt{ {\ttfamily Activity.\+on\+Pause()}}} is called.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md418}{}\doxysubsection{Reconfiguring streams}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md418}
In order to change the configuration of the stream, simply call {\ttfamily open\+Managed\+Stream} again. The existing stream is closed, destroyed and a new stream is built and populates the {\ttfamily managed\+Stream}. 
\begin{DoxyCode}{0}
\DoxyCodeLine{// Modify the builder with some additional properties at runtime.}
\DoxyCodeLine{builder.setDeviceId(MY\_DEVICE\_ID);}
\DoxyCodeLine{// Re-\/open the stream with some additional config}
\DoxyCodeLine{// The old ManagedStream is automatically closed and deleted}
\DoxyCodeLine{builder.openManagedStream(managedStream);}
\end{DoxyCode}


The {\ttfamily Managed\+Stream} takes care of its own closure and destruction. If used in an automatic allocation context (such as a member of a class), the stream does not need to be closed or deleted manually. Make sure that the object which is responsible for the {\ttfamily Managed\+Stream} (its enclosing class) goes out of scope whenever the app is no longer playing or recording audio, such as when {\ttfamily Activity.\+on\+Pause()} is called.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md419}{}\doxysubsection{Example}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md419}
The following class is a complete implementation of a {\ttfamily Managed\+Stream}, which renders a sine wave. Creating the class (e.\+g. through the J\+NI bridge) creates and opens an Oboe stream which renders audio, and its destruction stops and closes the stream. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\#include <oboe/Oboe.h>}
\DoxyCodeLine{\#include <math.h>}
\DoxyCodeLine{}
\DoxyCodeLine{class OboeSinePlayer: public oboe::AudioStreamCallback \{}
\DoxyCodeLine{public:}
\DoxyCodeLine{}
\DoxyCodeLine{}
\DoxyCodeLine{    OboeSinePlayer() \{}
\DoxyCodeLine{        oboe::AudioStreamBuilder builder;}
\DoxyCodeLine{        // The builder set methods can be chained for convenience.}
\DoxyCodeLine{        builder.setSharingMode(oboe::SharingMode::Exclusive)}
\DoxyCodeLine{          -\/>setPerformanceMode(oboe::PerformanceMode::LowLatency)}
\DoxyCodeLine{          -\/>setChannelCount(kChannelCount)}
\DoxyCodeLine{          -\/>setSampleRate(kSampleRate)}
\DoxyCodeLine{          -\/>setFormat(oboe::AudioFormat::Float)}
\DoxyCodeLine{          -\/>setCallback(this)}
\DoxyCodeLine{          -\/>openManagedStream(outStream);}
\DoxyCodeLine{        // Typically, start the stream after querying some stream information, as well as some input from the user}
\DoxyCodeLine{        outStream-\/>requestStart();}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    oboe::DataCallbackResult onAudioReady(oboe::AudioStream *oboeStream, void *audioData, int32\_t numFrames) override \{}
\DoxyCodeLine{        float *floatData = (float *) audioData;}
\DoxyCodeLine{        for (int i = 0; i < numFrames; ++i) \{}
\DoxyCodeLine{            float sampleValue = kAmplitude * sinf(mPhase);}
\DoxyCodeLine{            for (int j = 0; j < kChannelCount; j++) \{}
\DoxyCodeLine{                floatData[i * kChannelCount + j] = sampleValue;}
\DoxyCodeLine{            \}}
\DoxyCodeLine{            mPhase += mPhaseIncrement;}
\DoxyCodeLine{            if (mPhase >= kTwoPi) mPhase -\/= kTwoPi;}
\DoxyCodeLine{        \}}
\DoxyCodeLine{        return oboe::DataCallbackResult::Continue;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{private:}
\DoxyCodeLine{    oboe::ManagedStream outStream;}
\DoxyCodeLine{    // Stream params}
\DoxyCodeLine{    static int constexpr kChannelCount = 2;}
\DoxyCodeLine{    static int constexpr kSampleRate = 48000;}
\DoxyCodeLine{    // Wave params, these could be instance variables in order to modify at runtime}
\DoxyCodeLine{    static float constexpr kAmplitude = 0.5f;}
\DoxyCodeLine{    static float constexpr kFrequency = 440;}
\DoxyCodeLine{    static float constexpr kPI = M\_PI;}
\DoxyCodeLine{    static float constexpr kTwoPi = kPI * 2;}
\DoxyCodeLine{    static double constexpr mPhaseIncrement = kFrequency * kTwoPi / (double) kSampleRate;}
\DoxyCodeLine{    // Keeps track of where the wave is}
\DoxyCodeLine{    float mPhase = 0.0;}
\DoxyCodeLine{\};}
\end{DoxyCode}


Note that this implementation computes sine values at run-\/time for simplicity, rather than pre-\/computing them. Additionally, best practice is to implement a separate callback class, rather than managing the stream and defining its callback in the same class. This class also automatically starts the stream upon construction. Typically, the stream is queried for information prior to being started (e.\+g. burst size), and started upon user input. For more examples on how to use {\ttfamily Managed\+Stream} look in the \href{https://github.com/google/oboe/tree/master/samples}{\texttt{ samples}} folder.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md420}{}\doxysubsection{Obtaining optimal latency}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md420}
One of the goals of the Oboe library is to provide low latency audio streams on the widest range of hardware configurations. When a stream is opened using A\+Audio, the optimal rate will be chosen unless the app requests a specific rate. The frames\+Per\+Burst is also provided by A\+Audio.

But Open\+SL ES cannot determine those values. So applications should query them using Java and then pass them to Oboe. They will be used for Open\+SL ES streams on older devices.

Here\textquotesingle{}s a code sample showing how to set these default values.

{\itshape Main\+Activity.\+java} \begin{DoxyVerb}if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1){
    AudioManager myAudioMgr = (AudioManager) context.getSystemService(Context.AUDIO_SERVICE);
    String sampleRateStr = myAudioMgr.getProperty(AudioManager.PROPERTY_OUTPUT_SAMPLE_RATE);
    int defaultSampleRate = Integer.parseInt(sampleRateStr);
    String framesPerBurstStr = myAudioMgr.getProperty(AudioManager.PROPERTY_OUTPUT_FRAMES_PER_BUFFER);
    int defaultFramesPerBurst = Integer.parseInt(framesPerBurstStr);

    native_setDefaultStreamValues(defaultSampleRate, defaultFramesPerBurst);
}
\end{DoxyVerb}


{\itshape jni-\/bridge.\+cpp} \begin{DoxyVerb}JNIEXPORT void JNICALL
Java_com_google_sample_oboe_hellooboe_MainActivity_native_1setDefaultStreamValues(JNIEnv *env,
                                                                                  jclass type,
                                                                                  jint sampleRate,
                                                                                  jint framesPerBurst) {
    oboe::DefaultStreamValues::SampleRate = (int32_t) sampleRate;
    oboe::DefaultStreamValues::FramesPerBurst = (int32_t) framesPerBurst;
}
\end{DoxyVerb}


Note that the values from Java are for built-\/in audio devices. Peripheral devices, such as Bluetooth may need larger frames\+Per\+Burst.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md421}{}\doxysection{Further information}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__build_80db26a1527ea789b205c31c9cfcc6db_autotoc_md421}

\begin{DoxyItemize}
\item \href{https://github.com/google/oboe/tree/master/samples}{\texttt{ Code samples}}
\item Full guide to Oboe 
\end{DoxyItemize}