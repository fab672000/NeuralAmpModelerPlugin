{\itshape This project is not actively maintained.}\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__i_graphics__nano_s_v_g__r_e_a_d_m_e_autotoc_md1330}{}\doxysection{Nano S\+VG}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__i_graphics__nano_s_v_g__r_e_a_d_m_e_autotoc_md1330}
\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__i_graphics__nano_s_v_g__r_e_a_d_m_e_autotoc_md1331}{}\doxysubsection{Parser}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__i_graphics__nano_s_v_g__r_e_a_d_m_e_autotoc_md1331}


Nano\+S\+VG is a simple stupid single-\/header-\/file S\+VG parse. The output of the parser is a list of cubic bezier shapes.

The library suits well for anything from rendering scalable icons in your editor application to prototyping a game.

Nano\+S\+VG supports a wide range of S\+VG features, but something may be missing, feel free to create a pull request!

The shapes in the S\+VG images are transformed by the view\+Box and converted to specified units. That is, you should get the same looking data as your designed in your favorite app.

Nano\+S\+VG can return the paths in few different units. For example if you want to render an image, you may choose to get the paths in pixels, or if you are feeding the data into a C\+N\+C-\/cutter, you may want to use millimeters.

The units passed to Nano\+S\+VG should be one of\+: \textquotesingle{}px\textquotesingle{}, \textquotesingle{}pt\textquotesingle{}, \textquotesingle{}pc\textquotesingle{} \textquotesingle{}mm\textquotesingle{}, \textquotesingle{}cm\textquotesingle{}, or \textquotesingle{}in\textquotesingle{}. D\+PI (dots-\/per-\/inch) controls how the unit conversion is done.

If you don\textquotesingle{}t know or care about the units stuff, \char`\"{}px\char`\"{} and 96 should get you going.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__i_graphics__nano_s_v_g__r_e_a_d_m_e_autotoc_md1332}{}\doxysubsection{Rasterizer}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__i_graphics__nano_s_v_g__r_e_a_d_m_e_autotoc_md1332}


The parser library is accompanied with really simpler S\+VG rasterizer. Currently it only renders flat filled shapes.

The intended usage for the rasterizer is to for example bake icons of different size into a texture. The rasterizer is not particular fast or accurate, but it\textquotesingle{}s small and packed in one header file.\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__i_graphics__nano_s_v_g__r_e_a_d_m_e_autotoc_md1333}{}\doxysubsection{Example Usage}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__i_graphics__nano_s_v_g__r_e_a_d_m_e_autotoc_md1333}

\begin{DoxyCode}{0}
\DoxyCodeLine{// Load}
\DoxyCodeLine{struct NSVGimage* image;}
\DoxyCodeLine{image = nsvgParseFromFile("test.svg", "px", 96);}
\DoxyCodeLine{printf("size: \%f x \%f\(\backslash\)n", image-\/>width, image-\/>height);}
\DoxyCodeLine{// Use...}
\DoxyCodeLine{for (shape = image-\/>shapes; shape != NULL; shape = shape-\/>next) \{}
\DoxyCodeLine{    for (path = shape-\/>paths; path != NULL; path = path-\/>next) \{}
\DoxyCodeLine{        for (i = 0; i < path-\/>npts-\/1; i += 3) \{}
\DoxyCodeLine{            float* p = \&path-\/>pts[i*2];}
\DoxyCodeLine{            drawCubicBez(p[0],p[1], p[2],p[3], p[4],p[5], p[6],p[7]);}
\DoxyCodeLine{        \}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{// Delete}
\DoxyCodeLine{nsvgDelete(image);}
\end{DoxyCode}
\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__i_graphics__nano_s_v_g__r_e_a_d_m_e_autotoc_md1334}{}\doxysubsection{Using Nano\+S\+V\+G in your project}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__i_graphics__nano_s_v_g__r_e_a_d_m_e_autotoc_md1334}
In order to use Nano\+S\+VG in your own project, just copy \mbox{\hyperlink{nanosvg_8h_source}{nanosvg.\+h}} to your project. In one C/\+C++ define {\ttfamily N\+A\+N\+O\+S\+V\+G\+\_\+\+I\+M\+P\+L\+E\+M\+E\+N\+T\+A\+T\+I\+ON} before including the library to expand the Nano\+S\+VG implementation in that file. Nano\+S\+VG depends on {\ttfamily stdio.\+h} ,{\ttfamily string.\+h} and {\ttfamily math.\+h}, they should be included where the implementation is expanded before including Nano\+S\+VG.


\begin{DoxyCode}{0}
\DoxyCodeLine{\#include <stdio.h>}
\DoxyCodeLine{\#include <string.h>}
\DoxyCodeLine{\#include <math.h>}
\DoxyCodeLine{\#define NANOSVG\_IMPLEMENTATION  // Expands implementation}
\DoxyCodeLine{\#include "nanosvg.h"}
\end{DoxyCode}


By default, Nano\+S\+VG parses only the most common colors. In order to get support for full list of \href{http://www.w3.org/TR/SVG11/types.html\#ColorKeywords}{\texttt{ S\+VG color keywords}}, define {\ttfamily N\+A\+N\+O\+S\+V\+G\+\_\+\+A\+L\+L\+\_\+\+C\+O\+L\+O\+R\+\_\+\+K\+E\+Y\+W\+O\+R\+DS} before expanding the implementation.


\begin{DoxyCode}{0}
\DoxyCodeLine{\#include <stdio.h>}
\DoxyCodeLine{\#include <string.h>}
\DoxyCodeLine{\#include <math.h>}
\DoxyCodeLine{\#define NANOSVG\_ALL\_COLOR\_KEYWORDS  // Include full list of color keywords.}
\DoxyCodeLine{\#define NANOSVG\_IMPLEMENTATION      // Expands implementation}
\DoxyCodeLine{\#include "nanosvg.h"}
\end{DoxyCode}
\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__i_graphics__nano_s_v_g__r_e_a_d_m_e_autotoc_md1335}{}\doxysubsection{Compiling Example Project}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__i_graphics__nano_s_v_g__r_e_a_d_m_e_autotoc_md1335}
In order to compile the demo project, your will need to install \href{http://www.glfw.org/}{\texttt{ G\+L\+FW}} to compile.

Nano\+S\+VG demo project uses \href{http://industriousone.com/premake}{\texttt{ premake4}} to build platform specific projects, now is good time to install it if you don\textquotesingle{}t have it already. To build the example, navigate into the root folder in your favorite terminal, then\+:


\begin{DoxyItemize}
\item {\itshape OS X}\+: {\ttfamily premake4 xcode4}
\item {\itshape Windows}\+: {\ttfamily premake4 vs2010}
\item {\itshape Linux}\+: {\ttfamily premake4 gmake}
\end{DoxyItemize}

See premake4 documentation for full list of supported build file types. The projects will be created in {\ttfamily build} folder. An example of building and running the example on OS X\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\$ premake4 gmake}
\DoxyCodeLine{\$ cd build/}
\DoxyCodeLine{\$ make}
\DoxyCodeLine{\$ ./example}
\end{DoxyCode}
\hypertarget{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__i_graphics__nano_s_v_g__r_e_a_d_m_e_autotoc_md1336}{}\doxysection{License}\label{md__c_1__users_fab_src__github_branches__neural_amp_modeler_plugin_i_plug2__dependencies__i_graphics__nano_s_v_g__r_e_a_d_m_e_autotoc_md1336}
The library is licensed under \href{LICENSE.txt}{\texttt{ zlib license}} 