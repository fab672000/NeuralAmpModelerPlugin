\hypertarget{class_sk_writer32}{}\doxysection{Sk\+Writer32 Class Reference}
\label{class_sk_writer32}\index{SkWriter32@{SkWriter32}}
Inheritance diagram for Sk\+Writer32\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{class_sk_writer32}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_sk_writer32_a9ed4f58b1b6b922037a7fd00fe33753d}{Sk\+Writer32}} (void $\ast$external=nullptr, size\+\_\+t external\+Bytes=0)
\item 
\mbox{\Hypertarget{class_sk_writer32_afab98c6247f41a510f3f12e6d63aa5e8}\label{class_sk_writer32_afab98c6247f41a510f3f12e6d63aa5e8}} 
size\+\_\+t {\bfseries bytes\+Written} () const
\item 
\mbox{\Hypertarget{class_sk_writer32_a1c6799285b9b92189559ada46d23b0c9}\label{class_sk_writer32_a1c6799285b9b92189559ada46d23b0c9}} 
bool {\bfseries using\+Initial\+Storage} () const
\item 
\mbox{\Hypertarget{class_sk_writer32_aa424afe432719d5cd374c02f504c0d55}\label{class_sk_writer32_aa424afe432719d5cd374c02f504c0d55}} 
void {\bfseries reset} (void $\ast$external=nullptr, size\+\_\+t external\+Bytes=0)
\item 
\mbox{\Hypertarget{class_sk_writer32_a8fdca1b2b10c6550446ce5926908730c}\label{class_sk_writer32_a8fdca1b2b10c6550446ce5926908730c}} 
uint32\+\_\+t $\ast$ {\bfseries reserve} (size\+\_\+t size)
\item 
{\footnotesize template$<$typename T $>$ }\\const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& \mbox{\hyperlink{class_sk_writer32_a02201bed2b8c90f9840ebb6ea7145225}{read\+T\+At}} (size\+\_\+t offset) const
\item 
{\footnotesize template$<$typename T $>$ }\\void \mbox{\hyperlink{class_sk_writer32_a02fb7886a3e8fd4092b9e97c67671902}{overwrite\+T\+At}} (size\+\_\+t offset, const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&value)
\item 
\mbox{\Hypertarget{class_sk_writer32_acf47d754f553f9f8369ab490a9291cfe}\label{class_sk_writer32_acf47d754f553f9f8369ab490a9291cfe}} 
bool {\bfseries write\+Bool} (bool value)
\item 
\mbox{\Hypertarget{class_sk_writer32_a09874b9fdb5ba6e6142e2c7b405a4834}\label{class_sk_writer32_a09874b9fdb5ba6e6142e2c7b405a4834}} 
void {\bfseries write\+Int} (int32\+\_\+t value)
\item 
\mbox{\Hypertarget{class_sk_writer32_aa5d831799166a7ec883d0193f56791dc}\label{class_sk_writer32_aa5d831799166a7ec883d0193f56791dc}} 
void {\bfseries write8} (int32\+\_\+t value)
\item 
\mbox{\Hypertarget{class_sk_writer32_a8ad19c3c04659a6dbb5c87fec938eb25}\label{class_sk_writer32_a8ad19c3c04659a6dbb5c87fec938eb25}} 
void {\bfseries write16} (int32\+\_\+t value)
\item 
\mbox{\Hypertarget{class_sk_writer32_a0d1e35211b94f72de20eba6fa4fb6756}\label{class_sk_writer32_a0d1e35211b94f72de20eba6fa4fb6756}} 
void {\bfseries write32} (int32\+\_\+t value)
\item 
\mbox{\Hypertarget{class_sk_writer32_a4c188db628a2b939c1ab2d6c1d3300e5}\label{class_sk_writer32_a4c188db628a2b939c1ab2d6c1d3300e5}} 
void {\bfseries write\+Scalar} (Sk\+Scalar value)
\item 
\mbox{\Hypertarget{class_sk_writer32_a8c6369a65189e904409cee233ed0ab87}\label{class_sk_writer32_a8c6369a65189e904409cee233ed0ab87}} 
void {\bfseries write\+Point} (const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&pt)
\item 
\mbox{\Hypertarget{class_sk_writer32_ab0c2714ee908f184997d352640b35cf9}\label{class_sk_writer32_ab0c2714ee908f184997d352640b35cf9}} 
void {\bfseries write\+Point3} (const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&pt)
\item 
\mbox{\Hypertarget{class_sk_writer32_a41c7dd8f707b6903c0275103b5ebb8e8}\label{class_sk_writer32_a41c7dd8f707b6903c0275103b5ebb8e8}} 
void {\bfseries write\+Rect} (const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&rect)
\item 
\mbox{\Hypertarget{class_sk_writer32_a59989ba5c63f0e9e71bfbc3fdacdf9e2}\label{class_sk_writer32_a59989ba5c63f0e9e71bfbc3fdacdf9e2}} 
void {\bfseries write\+I\+Rect} (const \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} \&rect)
\item 
\mbox{\Hypertarget{class_sk_writer32_a1df300fc1cb1b257a91d8258962e2f72}\label{class_sk_writer32_a1df300fc1cb1b257a91d8258962e2f72}} 
void {\bfseries write\+R\+Rect} (const \mbox{\hyperlink{class_sk_r_rect}{Sk\+R\+Rect}} \&rrect)
\item 
\mbox{\Hypertarget{class_sk_writer32_aad988c863681cc74549b0f32c51b3479}\label{class_sk_writer32_aad988c863681cc74549b0f32c51b3479}} 
void {\bfseries write\+Path} (const \mbox{\hyperlink{class_sk_path}{Sk\+Path}} \&path)
\item 
\mbox{\Hypertarget{class_sk_writer32_a5ce308625ba2f361c2648a5a7e69e8cb}\label{class_sk_writer32_a5ce308625ba2f361c2648a5a7e69e8cb}} 
void {\bfseries write\+Matrix} (const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} \&matrix)
\item 
\mbox{\Hypertarget{class_sk_writer32_ad40a5f50409a804f25cc2d40b0ade187}\label{class_sk_writer32_ad40a5f50409a804f25cc2d40b0ade187}} 
void {\bfseries write\+Region} (const \mbox{\hyperlink{class_sk_region}{Sk\+Region}} \&rgn)
\item 
\mbox{\Hypertarget{class_sk_writer32_a91f64439cc53e8129ed2286cebf919ba}\label{class_sk_writer32_a91f64439cc53e8129ed2286cebf919ba}} 
void {\bfseries write\+Mul4} (const void $\ast$values, size\+\_\+t size)
\item 
void \mbox{\hyperlink{class_sk_writer32_a14aca14db3c5a8fc738083908cb27174}{write}} (const void $\ast$values, size\+\_\+t size)
\item 
uint32\+\_\+t $\ast$ \mbox{\hyperlink{class_sk_writer32_a26ced2ca2d232a0acd4cd59f4e7857b4}{reserve\+Pad}} (size\+\_\+t size)
\item 
void \mbox{\hyperlink{class_sk_writer32_a9ab59bb491ba0c68e65c3e049337569f}{write\+Pad}} (const void $\ast$src, size\+\_\+t size)
\item 
void \mbox{\hyperlink{class_sk_writer32_af2360b1871e085d19340f4af4808589d}{write\+String}} (const char $\ast$str, size\+\_\+t len=(size\+\_\+t) -\/1)
\item 
\mbox{\Hypertarget{class_sk_writer32_a9d3e9f79aff28de433094c592b2842b7}\label{class_sk_writer32_a9d3e9f79aff28de433094c592b2842b7}} 
void {\bfseries write\+Data} (const \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $\ast$data)
\item 
void \mbox{\hyperlink{class_sk_writer32_ade93423a9b7c84f5da43147e18d22e9a}{rewind\+To\+Offset}} (size\+\_\+t offset)
\item 
\mbox{\Hypertarget{class_sk_writer32_adab8265e181d06f61f284bd2bb81eabd}\label{class_sk_writer32_adab8265e181d06f61f284bd2bb81eabd}} 
void {\bfseries flatten} (void $\ast$dst) const
\item 
\mbox{\Hypertarget{class_sk_writer32_ac03555d5efbc81a9c014315f2c767321}\label{class_sk_writer32_ac03555d5efbc81a9c014315f2c767321}} 
bool {\bfseries write\+To\+Stream} (\mbox{\hyperlink{class_sk_w_stream}{Sk\+W\+Stream}} $\ast$stream) const
\item 
\mbox{\Hypertarget{class_sk_writer32_a4e9e3ccc4e2c744ed91b29ff0611cd81}\label{class_sk_writer32_a4e9e3ccc4e2c744ed91b29ff0611cd81}} 
size\+\_\+t {\bfseries read\+From\+Stream} (\mbox{\hyperlink{class_sk_stream}{Sk\+Stream}} $\ast$stream, size\+\_\+t length)
\item 
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ \mbox{\hyperlink{class_sk_writer32_adf9ee7b96d4bc8e2dfe9a80bf4231b75}{snapshot\+As\+Data}} () const
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static size\+\_\+t \mbox{\hyperlink{class_sk_writer32_ac99c61acaf482e379b68ea42e4f5b93e}{Write\+String\+Size}} (const char $\ast$str, size\+\_\+t len=(size\+\_\+t) -\/1)
\item 
\mbox{\Hypertarget{class_sk_writer32_a0b0982f5b4e34c7a27e26bf75aecdcef}\label{class_sk_writer32_a0b0982f5b4e34c7a27e26bf75aecdcef}} 
static size\+\_\+t {\bfseries Write\+Data\+Size} (const \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $\ast$data)
\end{DoxyCompactItemize}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_sk_writer32_a9ed4f58b1b6b922037a7fd00fe33753d}\label{class_sk_writer32_a9ed4f58b1b6b922037a7fd00fe33753d}} 
\index{SkWriter32@{SkWriter32}!SkWriter32@{SkWriter32}}
\index{SkWriter32@{SkWriter32}!SkWriter32@{SkWriter32}}
\doxysubsubsection{\texorpdfstring{SkWriter32()}{SkWriter32()}}
{\footnotesize\ttfamily Sk\+Writer32\+::\+Sk\+Writer32 (\begin{DoxyParamCaption}\item[{void $\ast$}]{external = {\ttfamily nullptr},  }\item[{size\+\_\+t}]{external\+Bytes = {\ttfamily 0} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

The caller can specify an initial block of storage, which the caller manages.

\mbox{\hyperlink{class_sk_writer32}{Sk\+Writer32}} will try to back reserve and write calls with this external storage until the first time an allocation doesn\textquotesingle{}t fit. From then it will use dynamically allocated storage. This used to be optional behavior, but pipe now relies on it. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_writer32_a02fb7886a3e8fd4092b9e97c67671902}\label{class_sk_writer32_a02fb7886a3e8fd4092b9e97c67671902}} 
\index{SkWriter32@{SkWriter32}!overwriteTAt@{overwriteTAt}}
\index{overwriteTAt@{overwriteTAt}!SkWriter32@{SkWriter32}}
\doxysubsubsection{\texorpdfstring{overwriteTAt()}{overwriteTAt()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
void Sk\+Writer32\+::overwrite\+T\+At (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{offset,  }\item[{const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Overwrite a T record at offset, which must be a multiple of 4. Only legal if the record was written atomically using the write methods below. \mbox{\Hypertarget{class_sk_writer32_a02201bed2b8c90f9840ebb6ea7145225}\label{class_sk_writer32_a02201bed2b8c90f9840ebb6ea7145225}} 
\index{SkWriter32@{SkWriter32}!readTAt@{readTAt}}
\index{readTAt@{readTAt}!SkWriter32@{SkWriter32}}
\doxysubsubsection{\texorpdfstring{readTAt()}{readTAt()}}
{\footnotesize\ttfamily template$<$typename T $>$ \\
const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}\& Sk\+Writer32\+::read\+T\+At (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{offset }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Read a T record at offset, which must be a multiple of 4. Only legal if the record was written atomically using the write methods below. \mbox{\Hypertarget{class_sk_writer32_a26ced2ca2d232a0acd4cd59f4e7857b4}\label{class_sk_writer32_a26ced2ca2d232a0acd4cd59f4e7857b4}} 
\index{SkWriter32@{SkWriter32}!reservePad@{reservePad}}
\index{reservePad@{reservePad}!SkWriter32@{SkWriter32}}
\doxysubsubsection{\texorpdfstring{reservePad()}{reservePad()}}
{\footnotesize\ttfamily uint32\+\_\+t$\ast$ Sk\+Writer32\+::reserve\+Pad (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Reserve size bytes. Does not need to be 4 byte aligned. The remaining space (if any) will be filled in with zeroes. \mbox{\Hypertarget{class_sk_writer32_ade93423a9b7c84f5da43147e18d22e9a}\label{class_sk_writer32_ade93423a9b7c84f5da43147e18d22e9a}} 
\index{SkWriter32@{SkWriter32}!rewindToOffset@{rewindToOffset}}
\index{rewindToOffset@{rewindToOffset}!SkWriter32@{SkWriter32}}
\doxysubsubsection{\texorpdfstring{rewindToOffset()}{rewindToOffset()}}
{\footnotesize\ttfamily void Sk\+Writer32\+::rewind\+To\+Offset (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{offset }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Move the cursor back to offset bytes from the beginning. offset must be a multiple of 4 no greater than size(). \mbox{\Hypertarget{class_sk_writer32_adf9ee7b96d4bc8e2dfe9a80bf4231b75}\label{class_sk_writer32_adf9ee7b96d4bc8e2dfe9a80bf4231b75}} 
\index{SkWriter32@{SkWriter32}!snapshotAsData@{snapshotAsData}}
\index{snapshotAsData@{snapshotAsData}!SkWriter32@{SkWriter32}}
\doxysubsubsection{\texorpdfstring{snapshotAsData()}{snapshotAsData()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ Sk\+Writer32\+::snapshot\+As\+Data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Captures a snapshot of the data as it is right now, and return it. \mbox{\Hypertarget{class_sk_writer32_a14aca14db3c5a8fc738083908cb27174}\label{class_sk_writer32_a14aca14db3c5a8fc738083908cb27174}} 
\index{SkWriter32@{SkWriter32}!write@{write}}
\index{write@{write}!SkWriter32@{SkWriter32}}
\doxysubsubsection{\texorpdfstring{write()}{write()}}
{\footnotesize\ttfamily void Sk\+Writer32\+::write (\begin{DoxyParamCaption}\item[{const void $\ast$}]{values,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Write size bytes from values. size must be a multiple of 4, though values need not be 4-\/byte aligned. \mbox{\Hypertarget{class_sk_writer32_a9ab59bb491ba0c68e65c3e049337569f}\label{class_sk_writer32_a9ab59bb491ba0c68e65c3e049337569f}} 
\index{SkWriter32@{SkWriter32}!writePad@{writePad}}
\index{writePad@{writePad}!SkWriter32@{SkWriter32}}
\doxysubsubsection{\texorpdfstring{writePad()}{writePad()}}
{\footnotesize\ttfamily void Sk\+Writer32\+::write\+Pad (\begin{DoxyParamCaption}\item[{const void $\ast$}]{src,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Write size bytes from src, and pad to 4 byte alignment with zeroes. \mbox{\Hypertarget{class_sk_writer32_af2360b1871e085d19340f4af4808589d}\label{class_sk_writer32_af2360b1871e085d19340f4af4808589d}} 
\index{SkWriter32@{SkWriter32}!writeString@{writeString}}
\index{writeString@{writeString}!SkWriter32@{SkWriter32}}
\doxysubsubsection{\texorpdfstring{writeString()}{writeString()}}
{\footnotesize\ttfamily void Sk\+Writer32\+::write\+String (\begin{DoxyParamCaption}\item[{const char $\ast$}]{str,  }\item[{size\+\_\+t}]{len = {\ttfamily (size\+\_\+t)-\/1} }\end{DoxyParamCaption})}

Writes a string to the writer, which can be retrieved with Sk\+Read\+Buffer\+::read\+String(). The length can be specified, or if -\/1 is passed, it will be computed by calling strlen(). The length must be $<$ max size\+\_\+t.

If you write N\+U\+LL, it will be read as \char`\"{}\char`\"{}. \mbox{\Hypertarget{class_sk_writer32_ac99c61acaf482e379b68ea42e4f5b93e}\label{class_sk_writer32_ac99c61acaf482e379b68ea42e4f5b93e}} 
\index{SkWriter32@{SkWriter32}!WriteStringSize@{WriteStringSize}}
\index{WriteStringSize@{WriteStringSize}!SkWriter32@{SkWriter32}}
\doxysubsubsection{\texorpdfstring{WriteStringSize()}{WriteStringSize()}}
{\footnotesize\ttfamily size\+\_\+t Sk\+Writer32\+::\+Write\+String\+Size (\begin{DoxyParamCaption}\item[{const char $\ast$}]{str,  }\item[{size\+\_\+t}]{len = {\ttfamily (size\+\_\+t)-\/1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Computes the size (aligned to multiple of 4) need to write the string in a call to \mbox{\hyperlink{class_sk_writer32_af2360b1871e085d19340f4af4808589d}{write\+String()}}. If the length is not specified, it will be computed by calling strlen(). 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Writer32.\+h\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Writer32.\+cpp\end{DoxyCompactItemize}
