\hypertarget{class_sk_block_allocator}{}\doxysection{Sk\+Block\+Allocator Class Reference}
\label{class_sk_block_allocator}\index{SkBlockAllocator@{SkBlockAllocator}}


{\ttfamily \#include $<$Sk\+Block\+Allocator.\+h$>$}

Inheritance diagram for Sk\+Block\+Allocator\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_sk_block_allocator}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}}
\item 
class \mbox{\hyperlink{class_sk_block_allocator_1_1_block_iter}{Block\+Iter}}
\item 
struct \mbox{\hyperlink{struct_sk_block_allocator_1_1_byte_range}{Byte\+Range}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_block_allocator_a2cb0d0bf04e26c69fda5e2beb8586c45}\label{class_sk_block_allocator_a2cb0d0bf04e26c69fda5e2beb8586c45}} 
enum {\bfseries Growth\+Policy} \+: int \{ \newline
{\bfseries k\+Fixed}, 
{\bfseries k\+Linear}, 
{\bfseries k\+Fibonacci}, 
{\bfseries k\+Exponential}, 
\newline
{\bfseries k\+Last} = k\+Exponential
 \}
\item 
\mbox{\Hypertarget{class_sk_block_allocator_abfa09201ce71382daed8db78a6239c6b}\label{class_sk_block_allocator_abfa09201ce71382daed8db78a6239c6b}} 
enum {\bfseries Reserve\+Flags} \+: unsigned \{ {\bfseries k\+Ignore\+Growth\+Policy\+\_\+\+Flag} = 0b01, 
{\bfseries k\+Ignore\+Existing\+Bytes\+\_\+\+Flag} = 0b10, 
{\bfseries k\+No\+\_\+\+Reserve\+Flags} = 0b00
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_block_allocator_aca859622443c8a611b3befff678d38e5}\label{class_sk_block_allocator_aca859622443c8a611b3befff678d38e5}} 
{\bfseries Sk\+Block\+Allocator} (Growth\+Policy policy, size\+\_\+t block\+Increment\+Bytes, size\+\_\+t additional\+Prealloc\+Bytes=0)
\item 
\mbox{\Hypertarget{class_sk_block_allocator_a8358e1051adb79e2a0933c440c0794e9}\label{class_sk_block_allocator_a8358e1051adb79e2a0933c440c0794e9}} 
void {\bfseries operator delete} (void $\ast$p)
\item 
size\+\_\+t \mbox{\hyperlink{class_sk_block_allocator_a904b21efec9487223d952d164bef159e}{total\+Size}} () const
\item 
size\+\_\+t \mbox{\hyperlink{class_sk_block_allocator_abcfc637f3bc835a84eb0743d342bd6e7}{total\+Usable\+Space}} () const
\item 
size\+\_\+t \mbox{\hyperlink{class_sk_block_allocator_a232fa348a798fefda7a00f456bef1ab1}{total\+Space\+In\+Use}} () const
\item 
size\+\_\+t \mbox{\hyperlink{class_sk_block_allocator_ab64924932b25c02e426c95a6f552ec9a}{prealloc\+Size}} () const
\item 
size\+\_\+t \mbox{\hyperlink{class_sk_block_allocator_a631af1889f71b627419c1341660385cf}{prealloc\+Usable\+Space}} () const
\item 
int \mbox{\hyperlink{class_sk_block_allocator_aa407213783ddfb0a05dd104849388a3a}{metadata}} () const
\item 
void \mbox{\hyperlink{class_sk_block_allocator_a6571df06fbfd507871869cd25a5e0396}{set\+Metadata}} (int value)
\item 
{\footnotesize template$<$size\+\_\+t Align, size\+\_\+t Padding = 0$>$ }\\\mbox{\hyperlink{struct_sk_block_allocator_1_1_byte_range}{Byte\+Range}} \mbox{\hyperlink{class_sk_block_allocator_a9d5238baa2e451f5ba69abb01a1c8a82}{allocate}} (size\+\_\+t size)
\item 
{\footnotesize template$<$size\+\_\+t Align = 1, size\+\_\+t Padding = 0$>$ }\\void \mbox{\hyperlink{class_sk_block_allocator_a3998492724e925aaddbde94e806c337a}{reserve}} (size\+\_\+t size, Reserve\+Flags flags=k\+No\+\_\+\+Reserve\+Flags)
\item 
const \mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}} $\ast$ \mbox{\hyperlink{class_sk_block_allocator_a0c042b9cde3495671025fe5b2c1435ce}{current\+Block}} () const
\item 
\mbox{\Hypertarget{class_sk_block_allocator_a2f679a3c64fb066031848a2f709b1305}\label{class_sk_block_allocator_a2f679a3c64fb066031848a2f709b1305}} 
\mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}} $\ast$ {\bfseries current\+Block} ()
\item 
\mbox{\Hypertarget{class_sk_block_allocator_ad5582ece6bd15fbdd93c01e6bc6fe221}\label{class_sk_block_allocator_ad5582ece6bd15fbdd93c01e6bc6fe221}} 
const \mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}} $\ast$ {\bfseries head\+Block} () const
\item 
\mbox{\Hypertarget{class_sk_block_allocator_a8916b6e0633783edbb9a2a9ee2c1c7ce}\label{class_sk_block_allocator_a8916b6e0633783edbb9a2a9ee2c1c7ce}} 
\mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}} $\ast$ {\bfseries head\+Block} ()
\item 
{\footnotesize template$<$size\+\_\+t Align, size\+\_\+t Padding = 0$>$ }\\\mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}} $\ast$ \mbox{\hyperlink{class_sk_block_allocator_af21b1520a07b555379a7394d4e3f6485}{owning\+Block}} (const void $\ast$ptr, int start)
\item 
\mbox{\Hypertarget{class_sk_block_allocator_a8fad52c18ffdb2f9b8cdcfbb7d167e71}\label{class_sk_block_allocator_a8fad52c18ffdb2f9b8cdcfbb7d167e71}} 
{\footnotesize template$<$size\+\_\+t Align, size\+\_\+t Padding = 0$>$ }\\const \mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}} $\ast$ {\bfseries owning\+Block} (const void $\ast$ptr, int start) const
\item 
\mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}} $\ast$ \mbox{\hyperlink{class_sk_block_allocator_acc79159f461ad58e708d5c04c080f593}{find\+Owning\+Block}} (const void $\ast$ptr)
\item 
\mbox{\Hypertarget{class_sk_block_allocator_a9468f2779e4512f745eb42a5f7457907}\label{class_sk_block_allocator_a9468f2779e4512f745eb42a5f7457907}} 
const \mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}} $\ast$ {\bfseries find\+Owning\+Block} (const void $\ast$ptr) const
\item 
void \mbox{\hyperlink{class_sk_block_allocator_a69341cd91a76c54ba1e0bf44068c3883}{release\+Block}} (\mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}} $\ast$block)
\item 
void \mbox{\hyperlink{class_sk_block_allocator_a9abf0eac7b7c326878304b765f661c55}{steal\+Heap\+Blocks}} (\mbox{\hyperlink{class_sk_block_allocator}{Sk\+Block\+Allocator}} $\ast$other)
\item 
void \mbox{\hyperlink{class_sk_block_allocator_a84cddf7176b64d38c473141a1d957a44}{reset}} ()
\item 
void \mbox{\hyperlink{class_sk_block_allocator_a5b89d67e347bed5dc44c541cc75e211e}{reset\+Scratch\+Space}} ()
\item 
\mbox{\hyperlink{class_sk_block_allocator_1_1_block_iter}{Block\+Iter}}$<$ true, false $>$ \mbox{\hyperlink{class_sk_block_allocator_a50674e2cd30e0b78bc3e850e36cd2e04}{blocks}} ()
\item 
\mbox{\Hypertarget{class_sk_block_allocator_a60ff682f906ba03a34f9aabd9a47a96d}\label{class_sk_block_allocator_a60ff682f906ba03a34f9aabd9a47a96d}} 
\mbox{\hyperlink{class_sk_block_allocator_1_1_block_iter}{Block\+Iter}}$<$ true, true $>$ {\bfseries blocks} () const
\item 
\mbox{\Hypertarget{class_sk_block_allocator_a6663ca5fa77a1e9017cffdacdd39e5a7}\label{class_sk_block_allocator_a6663ca5fa77a1e9017cffdacdd39e5a7}} 
\mbox{\hyperlink{class_sk_block_allocator_1_1_block_iter}{Block\+Iter}}$<$ false, false $>$ {\bfseries rblocks} ()
\item 
\mbox{\Hypertarget{class_sk_block_allocator_a8d4c77c5dabaeb4f5d1c8d2d9c34f8e4}\label{class_sk_block_allocator_a8d4c77c5dabaeb4f5d1c8d2d9c34f8e4}} 
\mbox{\hyperlink{class_sk_block_allocator_1_1_block_iter}{Block\+Iter}}$<$ false, true $>$ {\bfseries rblocks} () const
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$size\+\_\+t Align = 1, size\+\_\+t Padding = 0$>$ }\\static constexpr size\+\_\+t \mbox{\hyperlink{class_sk_block_allocator_a01418c38a66c2b97545150a499da71a8}{Block\+Overhead}} ()
\item 
{\footnotesize template$<$size\+\_\+t Align = 1, size\+\_\+t Padding = 0$>$ }\\static constexpr size\+\_\+t \mbox{\hyperlink{class_sk_block_allocator_a3ef5b2860a3d68be14da639c644c1a9a}{Overhead}} ()
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_block_allocator_ada1ef370d6a4ecd6202a8f85b6b56a41}\label{class_sk_block_allocator_ada1ef370d6a4ecd6202a8f85b6b56a41}} 
static constexpr int {\bfseries k\+Max\+Allocation\+Size} = 1 $<$$<$ 29
\item 
\mbox{\Hypertarget{class_sk_block_allocator_ac9ba2d03896050114c23b2ee6fe9f823}\label{class_sk_block_allocator_ac9ba2d03896050114c23b2ee6fe9f823}} 
static constexpr int {\bfseries k\+Growth\+Policy\+Count} = static\+\_\+cast$<$int$>$(Growth\+Policy\+::k\+Last) + 1
\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_block_allocator_af165934b4b15108fb9578072085cf6ba}\label{class_sk_block_allocator_af165934b4b15108fb9578072085cf6ba}} 
class {\bfseries Block\+Allocator\+Test\+Access}
\item 
\mbox{\Hypertarget{class_sk_block_allocator_a888c86797386bd2e7e6f1c8f6d5ced55}\label{class_sk_block_allocator_a888c86797386bd2e7e6f1c8f6d5ced55}} 
class {\bfseries T\+Block\+List\+Test\+Access}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\mbox{\hyperlink{class_sk_block_allocator}{Sk\+Block\+Allocator}} provides low-\/level support for a block allocated arena with a dynamic tail that tracks space reservations within each block. Its A\+P\+Is provide the ability to reserve space, resize reservations, and release reservations. It will automatically create new blocks if needed and destroy all remaining blocks when it is destructed. It assumes that anything allocated within its blocks has its destructors called externally. It is recommended that \mbox{\hyperlink{class_sk_block_allocator}{Sk\+Block\+Allocator}} is wrapped by a higher-\/level allocator that uses the low-\/level A\+P\+Is to implement a simpler, purpose-\/focused A\+PI w/o having to worry as much about byte-\/level concerns.

\mbox{\hyperlink{class_sk_block_allocator}{Sk\+Block\+Allocator}} has no limit to its total size, but each allocation is limited to 512MB (which should be sufficient for Skia\textquotesingle{}s use cases). This upper allocation limit allows all internal operations to be performed using \textquotesingle{}int\textquotesingle{} and avoid many overflow checks. Static asserts are used to ensure that those operations would not overflow when using the largest possible values.

Possible use modes\+:
\begin{DoxyEnumerate}
\item No upfront allocation, either on the stack or as a field \mbox{\hyperlink{class_sk_block_allocator}{Sk\+Block\+Allocator}} allocator(policy, heap\+Alloc\+Size);
\item In-\/place new\textquotesingle{}d void$\ast$ mem = operator new(total\+Size); Sk\+Block\+Allocator$\ast$ allocator = new (mem) \mbox{\hyperlink{class_sk_block_allocator}{Sk\+Block\+Allocator}}(policy, heap\+Alloc\+Size, total\+Size-\/ sizeof(\+Sk\+Block\+Allocator)); delete allocator;
\item Use \mbox{\hyperlink{class_sk_s_block_allocator}{Sk\+S\+Block\+Allocator}} to increase the preallocation size Sk\+S\+Block\+Allocator$<$1024$>$ allocator(policy, heap\+Alloc\+Size); sizeof(allocator) == 1024; 
\end{DoxyEnumerate}

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_block_allocator_a9d5238baa2e451f5ba69abb01a1c8a82}\label{class_sk_block_allocator_a9d5238baa2e451f5ba69abb01a1c8a82}} 
\index{SkBlockAllocator@{SkBlockAllocator}!allocate@{allocate}}
\index{allocate@{allocate}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{allocate()}{allocate()}}
{\footnotesize\ttfamily template$<$size\+\_\+t Align, size\+\_\+t Padding$>$ \\
\mbox{\hyperlink{struct_sk_block_allocator_1_1_byte_range}{Sk\+Block\+Allocator\+::\+Byte\+Range}} Sk\+Block\+Allocator\+::allocate (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})}

Reserve space that will hold \textquotesingle{}size\textquotesingle{} bytes. This will automatically allocate a new block if there is not enough available space in the current block to provide \textquotesingle{}size\textquotesingle{} bytes. The returned \mbox{\hyperlink{struct_sk_block_allocator_1_1_byte_range}{Byte\+Range}} tuple specifies the \mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}} owning the reserved memory, the full byte range, and the aligned offset within that range to use for the user-\/facing pointer. The following invariants hold\+:


\begin{DoxyEnumerate}
\item block-\/$>$ptr(aligned\+Offset) is aligned to Align
\item end -\/ aligned\+Offset == size
\item Padding $<$= aligned\+Offset -\/ start $<$= Padding + Align -\/ 1
\end{DoxyEnumerate}

Invariant \#3, when Padding $>$ 0, allows intermediate allocators to embed metadata along with the allocations. If the Padding bytes are used for some \textquotesingle{}struct \mbox{\hyperlink{struct_meta}{Meta}}\textquotesingle{}, then ptr(aligned\+Offset -\/ sizeof(\+Meta)) can be safely used as a Meta$\ast$ if \mbox{\hyperlink{struct_meta}{Meta}}\textquotesingle{}s alignment requirements are less than or equal to the alignment specified in allocate$<$$>$. This can be easily guaranteed by using the pattern\+:

allocate$<$max(\+User\+Align, alignof(\+Meta)), sizeof(\+Meta)$>$(user\+Size);

This ensures that ptr(aligned\+Offset) will always satisfy User\+Align and ptr(aligned\+Offset -\/ sizeof(\+Meta)) will always satisfy alignof(\+Meta). Alternatively, memcpy can be used to read and write values between start and aligned\+Offset without worrying about alignment requirements of the metadata.

For over-\/aligned allocations, the aligned\+Offset (as an int) may not be a multiple of Align, but the result of ptr(aligned\+Offset) will be a multiple of Align. \mbox{\Hypertarget{class_sk_block_allocator_a01418c38a66c2b97545150a499da71a8}\label{class_sk_block_allocator_a01418c38a66c2b97545150a499da71a8}} 
\index{SkBlockAllocator@{SkBlockAllocator}!BlockOverhead@{BlockOverhead}}
\index{BlockOverhead@{BlockOverhead}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{BlockOverhead()}{BlockOverhead()}}
{\footnotesize\ttfamily template$<$size\+\_\+t Align, size\+\_\+t Padding$>$ \\
constexpr size\+\_\+t Sk\+Block\+Allocator\+::\+Block\+Overhead\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [constexpr]}}

Helper to calculate the minimum number of bytes needed for heap block size, under the assumption that Align will be the requested alignment of the first call to \mbox{\hyperlink{class_sk_block_allocator_a9d5238baa2e451f5ba69abb01a1c8a82}{allocate()}}. Ex. To store N instances of T in a heap block, the \textquotesingle{}block\+Increment\+Bytes\textquotesingle{} should be set to Block\+Overhead$<$alignof(\+T)$>$() + N $\ast$ sizeof(\+T) when making the \mbox{\hyperlink{class_sk_block_allocator}{Sk\+Block\+Allocator}}. \mbox{\Hypertarget{class_sk_block_allocator_a50674e2cd30e0b78bc3e850e36cd2e04}\label{class_sk_block_allocator_a50674e2cd30e0b78bc3e850e36cd2e04}} 
\index{SkBlockAllocator@{SkBlockAllocator}!blocks@{blocks}}
\index{blocks@{blocks}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{blocks()}{blocks()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_sk_block_allocator_1_1_block_iter}{Sk\+Block\+Allocator\+::\+Block\+Iter}}$<$ true, true $>$ Sk\+Block\+Allocator\+::blocks (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Clients can iterate over all active Blocks in the \mbox{\hyperlink{class_sk_block_allocator}{Sk\+Block\+Allocator}} using for loops\+:

Forward iteration from head to tail block (or non-\/const variant)\+: for (const Block$\ast$ b \+: this-\/$>$\mbox{\hyperlink{class_sk_block_allocator_a50674e2cd30e0b78bc3e850e36cd2e04}{blocks()}}) \{ \} Reverse iteration from tail to head block\+: for (const Block$\ast$ b \+: this-\/$>$rblocks()) \{ \}

It is safe to call \mbox{\hyperlink{class_sk_block_allocator_a69341cd91a76c54ba1e0bf44068c3883}{release\+Block()}} on the active block while looping. \mbox{\Hypertarget{class_sk_block_allocator_a0c042b9cde3495671025fe5b2c1435ce}\label{class_sk_block_allocator_a0c042b9cde3495671025fe5b2c1435ce}} 
\index{SkBlockAllocator@{SkBlockAllocator}!currentBlock@{currentBlock}}
\index{currentBlock@{currentBlock}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{currentBlock()}{currentBlock()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}}$\ast$ Sk\+Block\+Allocator\+::current\+Block (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return a pointer to the start of the current block. This will never be null. \mbox{\Hypertarget{class_sk_block_allocator_acc79159f461ad58e708d5c04c080f593}\label{class_sk_block_allocator_acc79159f461ad58e708d5c04c080f593}} 
\index{SkBlockAllocator@{SkBlockAllocator}!findOwningBlock@{findOwningBlock}}
\index{findOwningBlock@{findOwningBlock}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{findOwningBlock()}{findOwningBlock()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Sk\+Block\+Allocator\+::\+Block}} $\ast$ Sk\+Block\+Allocator\+::find\+Owning\+Block (\begin{DoxyParamCaption}\item[{const void $\ast$}]{ptr }\end{DoxyParamCaption})}

Find the owning block of the allocated pointer, \textquotesingle{}p\textquotesingle{}. Without any additional information this is O(\+N) on the number of allocated blocks. \mbox{\Hypertarget{class_sk_block_allocator_aa407213783ddfb0a05dd104849388a3a}\label{class_sk_block_allocator_aa407213783ddfb0a05dd104849388a3a}} 
\index{SkBlockAllocator@{SkBlockAllocator}!metadata@{metadata}}
\index{metadata@{metadata}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{metadata()}{metadata()}}
{\footnotesize\ttfamily int Sk\+Block\+Allocator\+::metadata (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Get the current value of the allocator-\/level metadata (a user-\/oriented slot). This is separate from any block-\/level metadata, but can serve a similar purpose to compactly support data collections on top of \mbox{\hyperlink{class_sk_block_allocator}{Sk\+Block\+Allocator}}. \mbox{\Hypertarget{class_sk_block_allocator_a3ef5b2860a3d68be14da639c644c1a9a}\label{class_sk_block_allocator_a3ef5b2860a3d68be14da639c644c1a9a}} 
\index{SkBlockAllocator@{SkBlockAllocator}!Overhead@{Overhead}}
\index{Overhead@{Overhead}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{Overhead()}{Overhead()}}
{\footnotesize\ttfamily template$<$size\+\_\+t Align, size\+\_\+t Padding$>$ \\
constexpr size\+\_\+t Sk\+Block\+Allocator\+::\+Overhead\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [constexpr]}}

Helper to calculate the minimum number of bytes needed for a preallocation, under the assumption that Align will be the requested alignment of the first call to \mbox{\hyperlink{class_sk_block_allocator_a9d5238baa2e451f5ba69abb01a1c8a82}{allocate()}}. Ex. To preallocate a \mbox{\hyperlink{class_sk_s_block_allocator}{Sk\+S\+Block\+Allocator}} to hold N instances of T, its arge should be Overhead$<$alignof(\+T)$>$() + N $\ast$ sizeof(\+T) \mbox{\Hypertarget{class_sk_block_allocator_af21b1520a07b555379a7394d4e3f6485}\label{class_sk_block_allocator_af21b1520a07b555379a7394d4e3f6485}} 
\index{SkBlockAllocator@{SkBlockAllocator}!owningBlock@{owningBlock}}
\index{owningBlock@{owningBlock}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{owningBlock()}{owningBlock()}}
{\footnotesize\ttfamily template$<$size\+\_\+t Align, size\+\_\+t Padding$>$ \\
\mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Sk\+Block\+Allocator\+::\+Block}} $\ast$ Sk\+Block\+Allocator\+::owning\+Block (\begin{DoxyParamCaption}\item[{const void $\ast$}]{ptr,  }\item[{int}]{start }\end{DoxyParamCaption})}

Return the block that owns the allocated \textquotesingle{}ptr\textquotesingle{}. Assuming that earlier, an allocation was returned as \{b, start, aligned\+Offset, end\}, and \textquotesingle{}p = b-\/$>$ptr(aligned\+Offset)\textquotesingle{}, then a call to \textquotesingle{}owning\+Block$<$\+Align, Padding$>$(p, start) == b\textquotesingle{}.

If calling code has already made a pointer to their metadata, i.\+e. \textquotesingle{}m = p -\/ Padding\textquotesingle{}, then \textquotesingle{}owning\+Block$<$\+Align, 0$>$(m, start)\textquotesingle{} will also return b, allowing you to recover the block from the metadata pointer.

If calling code has access to the original aligned\+Offset, this function should not be used since the owning block is just \textquotesingle{}p -\/ aligned\+Offset\textquotesingle{}, regardless of original Align or Padding. \mbox{\Hypertarget{class_sk_block_allocator_ab64924932b25c02e426c95a6f552ec9a}\label{class_sk_block_allocator_ab64924932b25c02e426c95a6f552ec9a}} 
\index{SkBlockAllocator@{SkBlockAllocator}!preallocSize@{preallocSize}}
\index{preallocSize@{preallocSize}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{preallocSize()}{preallocSize()}}
{\footnotesize\ttfamily size\+\_\+t Sk\+Block\+Allocator\+::prealloc\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return the total number of bytes that were pre-\/allocated for the \mbox{\hyperlink{class_sk_block_allocator}{Sk\+Block\+Allocator}}. This will include \textquotesingle{}additional\+Prealloc\+Bytes\textquotesingle{} passed to the constructor, and represents what the total size would become after a call to \mbox{\hyperlink{class_sk_block_allocator_a84cddf7176b64d38c473141a1d957a44}{reset()}}. \mbox{\Hypertarget{class_sk_block_allocator_a631af1889f71b627419c1341660385cf}\label{class_sk_block_allocator_a631af1889f71b627419c1341660385cf}} 
\index{SkBlockAllocator@{SkBlockAllocator}!preallocUsableSpace@{preallocUsableSpace}}
\index{preallocUsableSpace@{preallocUsableSpace}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{preallocUsableSpace()}{preallocUsableSpace()}}
{\footnotesize\ttfamily size\+\_\+t Sk\+Block\+Allocator\+::prealloc\+Usable\+Space (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return the usable size of the inline head block; this will be equal to \textquotesingle{}additional\+Prealloc\+Bytes\textquotesingle{} plus any alignment padding that the system had to add to \mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}}. The returned value represents what could be allocated before a heap block is be created. \mbox{\Hypertarget{class_sk_block_allocator_a69341cd91a76c54ba1e0bf44068c3883}\label{class_sk_block_allocator_a69341cd91a76c54ba1e0bf44068c3883}} 
\index{SkBlockAllocator@{SkBlockAllocator}!releaseBlock@{releaseBlock}}
\index{releaseBlock@{releaseBlock}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{releaseBlock()}{releaseBlock()}}
{\footnotesize\ttfamily void Sk\+Block\+Allocator\+::release\+Block (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}} $\ast$}]{block }\end{DoxyParamCaption})}

Explicitly free an entire block, invalidating any remaining allocations from the block. \mbox{\hyperlink{class_sk_block_allocator}{Sk\+Block\+Allocator}} will release all alive blocks automatically when it is destroyed, but this function can be used to reclaim memory over the lifetime of the allocator. The provided \textquotesingle{}block\textquotesingle{} pointer must have previously come from a call to current\+Block() or \mbox{\hyperlink{class_sk_block_allocator_a9d5238baa2e451f5ba69abb01a1c8a82}{allocate()}}.

If \textquotesingle{}block\textquotesingle{} represents the inline-\/allocated head block, its cursor and metadata are instead reset to their defaults.

If the block is not the head block, it may be kept as a scratch block to be reused for subsequent allocation requests, instead of making an entirely new block. A scratch block is not visible when iterating over blocks but is reported in the total size of the allocator. \mbox{\Hypertarget{class_sk_block_allocator_a3998492724e925aaddbde94e806c337a}\label{class_sk_block_allocator_a3998492724e925aaddbde94e806c337a}} 
\index{SkBlockAllocator@{SkBlockAllocator}!reserve@{reserve}}
\index{reserve@{reserve}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{reserve()}{reserve()}}
{\footnotesize\ttfamily template$<$size\+\_\+t Align, size\+\_\+t Padding$>$ \\
void Sk\+Block\+Allocator\+::reserve (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size,  }\item[{Reserve\+Flags}]{flags = {\ttfamily kNo\+\_\+ReserveFlags} }\end{DoxyParamCaption})}

Ensure the block allocator has \textquotesingle{}size\textquotesingle{} contiguous available bytes. After calling this function, current\+Block()-\/$>$avail$<$\+Align, Padding$>$() may still report less than \textquotesingle{}size\textquotesingle{} if the reserved space was added as a scratch block. This is done so that anything remaining in the current block can still be used if a smaller-\/than-\/size allocation is requested. If \textquotesingle{}size\textquotesingle{} is requested by a subsequent allocation, the scratch block will automatically be activated and the request will not itself trigger any malloc.

The optional \textquotesingle{}flags\textquotesingle{} controls how the input size is allocated; by default it will attempt to use available contiguous bytes in the current block and will respect the growth policy of the allocator. \mbox{\Hypertarget{class_sk_block_allocator_a84cddf7176b64d38c473141a1d957a44}\label{class_sk_block_allocator_a84cddf7176b64d38c473141a1d957a44}} 
\index{SkBlockAllocator@{SkBlockAllocator}!reset@{reset}}
\index{reset@{reset}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}}
{\footnotesize\ttfamily void Sk\+Block\+Allocator\+::reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Explicitly free all blocks (invalidating all allocations), and resets the head block to its default state. The allocator-\/level metadata is reset to 0 as well. \mbox{\Hypertarget{class_sk_block_allocator_a5b89d67e347bed5dc44c541cc75e211e}\label{class_sk_block_allocator_a5b89d67e347bed5dc44c541cc75e211e}} 
\index{SkBlockAllocator@{SkBlockAllocator}!resetScratchSpace@{resetScratchSpace}}
\index{resetScratchSpace@{resetScratchSpace}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{resetScratchSpace()}{resetScratchSpace()}}
{\footnotesize\ttfamily void Sk\+Block\+Allocator\+::reset\+Scratch\+Space (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Remove any reserved scratch space, either from calling \mbox{\hyperlink{class_sk_block_allocator_a3998492724e925aaddbde94e806c337a}{reserve()}} or \mbox{\hyperlink{class_sk_block_allocator_a69341cd91a76c54ba1e0bf44068c3883}{release\+Block()}}. \mbox{\Hypertarget{class_sk_block_allocator_a6571df06fbfd507871869cd25a5e0396}\label{class_sk_block_allocator_a6571df06fbfd507871869cd25a5e0396}} 
\index{SkBlockAllocator@{SkBlockAllocator}!setMetadata@{setMetadata}}
\index{setMetadata@{setMetadata}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{setMetadata()}{setMetadata()}}
{\footnotesize\ttfamily void Sk\+Block\+Allocator\+::set\+Metadata (\begin{DoxyParamCaption}\item[{int}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Set the current value of the allocator-\/level metadata. \mbox{\Hypertarget{class_sk_block_allocator_a9abf0eac7b7c326878304b765f661c55}\label{class_sk_block_allocator_a9abf0eac7b7c326878304b765f661c55}} 
\index{SkBlockAllocator@{SkBlockAllocator}!stealHeapBlocks@{stealHeapBlocks}}
\index{stealHeapBlocks@{stealHeapBlocks}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{stealHeapBlocks()}{stealHeapBlocks()}}
{\footnotesize\ttfamily void Sk\+Block\+Allocator\+::steal\+Heap\+Blocks (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_block_allocator}{Sk\+Block\+Allocator}} $\ast$}]{other }\end{DoxyParamCaption})}

Detach every heap-\/allocated block owned by \textquotesingle{}other\textquotesingle{} and concatenate them to this allocator\textquotesingle{}s list of blocks. This memory is now managed by this allocator. Since this only transfers ownership of a \mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}}, and a \mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}} itself does not move, any previous allocations remain valid and associated with their original \mbox{\hyperlink{class_sk_block_allocator_1_1_block}{Block}} instances. Sk\+Block\+Allocator-\/level functions that accept allocated pointers (e.\+g. find\+Owning\+Block), must now use this allocator and not \textquotesingle{}other\textquotesingle{} for these allocations.

The head block of \textquotesingle{}other\textquotesingle{} cannot be stolen, so higher-\/level allocators and memory structures must handle that data differently. \mbox{\Hypertarget{class_sk_block_allocator_a904b21efec9487223d952d164bef159e}\label{class_sk_block_allocator_a904b21efec9487223d952d164bef159e}} 
\index{SkBlockAllocator@{SkBlockAllocator}!totalSize@{totalSize}}
\index{totalSize@{totalSize}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{totalSize()}{totalSize()}}
{\footnotesize\ttfamily size\+\_\+t Sk\+Block\+Allocator\+::total\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Return the total number of bytes of the allocator, including its instance overhead, per-\/block overhead and space used for allocations. \mbox{\Hypertarget{class_sk_block_allocator_a232fa348a798fefda7a00f456bef1ab1}\label{class_sk_block_allocator_a232fa348a798fefda7a00f456bef1ab1}} 
\index{SkBlockAllocator@{SkBlockAllocator}!totalSpaceInUse@{totalSpaceInUse}}
\index{totalSpaceInUse@{totalSpaceInUse}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{totalSpaceInUse()}{totalSpaceInUse()}}
{\footnotesize\ttfamily size\+\_\+t Sk\+Block\+Allocator\+::total\+Space\+In\+Use (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Return the total number of usable bytes that have been reserved by allocations. This will be less than or equal to \mbox{\hyperlink{class_sk_block_allocator_abcfc637f3bc835a84eb0743d342bd6e7}{total\+Usable\+Space()}}. \mbox{\Hypertarget{class_sk_block_allocator_abcfc637f3bc835a84eb0743d342bd6e7}\label{class_sk_block_allocator_abcfc637f3bc835a84eb0743d342bd6e7}} 
\index{SkBlockAllocator@{SkBlockAllocator}!totalUsableSpace@{totalUsableSpace}}
\index{totalUsableSpace@{totalUsableSpace}!SkBlockAllocator@{SkBlockAllocator}}
\doxysubsubsection{\texorpdfstring{totalUsableSpace()}{totalUsableSpace()}}
{\footnotesize\ttfamily size\+\_\+t Sk\+Block\+Allocator\+::total\+Usable\+Space (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Return the total number of bytes usable for allocations. This includes bytes that have been reserved already by a call to \mbox{\hyperlink{class_sk_block_allocator_a9d5238baa2e451f5ba69abb01a1c8a82}{allocate()}} and bytes that are still available. It is \mbox{\hyperlink{class_sk_block_allocator_a904b21efec9487223d952d164bef159e}{total\+Size()}} minus all allocator and block-\/level overhead. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Block\+Allocator.\+h\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Block\+Allocator.\+cpp\end{DoxyCompactItemize}
