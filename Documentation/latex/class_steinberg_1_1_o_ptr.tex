\hypertarget{class_steinberg_1_1_o_ptr}{}\doxysection{Steinberg\+::O\+Ptr$<$ I $>$ Class Template Reference}
\label{class_steinberg_1_1_o_ptr}\index{Steinberg::OPtr$<$ I $>$@{Steinberg::OPtr$<$ I $>$}}


{\ttfamily \#include $<$smartpointer.\+h$>$}

Inheritance diagram for Steinberg\+::O\+Ptr$<$ I $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_steinberg_1_1_o_ptr}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_steinberg_1_1_o_ptr_a31ba8ce706d29739559294c359382a4b}\label{class_steinberg_1_1_o_ptr_a31ba8ce706d29739559294c359382a4b}} 
{\bfseries O\+Ptr} (\mbox{\hyperlink{struct_i}{I}} $\ast$p)
\item 
\mbox{\Hypertarget{class_steinberg_1_1_o_ptr_ad7855d90df3dcfdd4feb6d7199facff4}\label{class_steinberg_1_1_o_ptr_ad7855d90df3dcfdd4feb6d7199facff4}} 
{\bfseries O\+Ptr} (const \mbox{\hyperlink{class_steinberg_1_1_i_ptr}{I\+Ptr}}$<$ \mbox{\hyperlink{struct_i}{I}} $>$ \&p)
\item 
\mbox{\Hypertarget{class_steinberg_1_1_o_ptr_a72f57299d35db9e549d4c7d582969ffd}\label{class_steinberg_1_1_o_ptr_a72f57299d35db9e549d4c7d582969ffd}} 
{\bfseries O\+Ptr} (const \mbox{\hyperlink{class_steinberg_1_1_o_ptr}{O\+Ptr}}$<$ \mbox{\hyperlink{struct_i}{I}} $>$ \&p)
\item 
\mbox{\Hypertarget{class_steinberg_1_1_o_ptr_a26cdf4e213b711a7cc5d1822167807a9}\label{class_steinberg_1_1_o_ptr_a26cdf4e213b711a7cc5d1822167807a9}} 
\mbox{\hyperlink{struct_i}{I}} $\ast$ {\bfseries operator=} (\mbox{\hyperlink{struct_i}{I}} $\ast$\+\_\+ptr)
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$class I$>$\newline
class Steinberg\+::\+O\+Ptr$<$ I $>$}

\mbox{\hyperlink{class_steinberg_1_1_o_ptr}{O\+Ptr}} -\/ \char`\"{}owning\char`\"{} smart pointer used for newly created F\+Objects.

\mbox{\hyperlink{class_steinberg_1_1_f_unknown}{F\+Unknown}} implementations are supposed to have a ref\+Count of 1 right after creation. So using an \mbox{\hyperlink{class_steinberg_1_1_i_ptr}{I\+Ptr}} on newly created objects would lead to a leak. Instead the \mbox{\hyperlink{class_steinberg_1_1_o_ptr}{O\+Ptr}} can be used in this case. ~\newline
Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{OPtr<IPath> path = FHostCreate (IPath, hostClasses);}
\DoxyCodeLine{\textcolor{comment}{// no release is needed...}}
\end{DoxyCode}
 The assignment operator takes ownership of a new object and releases the old. So its safe to write\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{OPtr<IPath> path = FHostCreate (IPath, hostClasses);}
\DoxyCodeLine{path = FHostCreate (IPath, hostClasses);}
\DoxyCodeLine{path = 0;}
\end{DoxyCode}
 This is the difference to using an \mbox{\hyperlink{class_steinberg_1_1_i_ptr}{I\+Ptr}} with add\+Ref=false. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// DONT DO THIS:}}
\DoxyCodeLine{IPtr<IPath> path (FHostCreate (IPath, hostClasses), \textcolor{keyword}{false});}
\DoxyCodeLine{path = FHostCreate (IPath, hostClasses);}
\DoxyCodeLine{path = 0;}
\end{DoxyCode}
 This will lead to a leak! 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+I\+Plug/\+V\+S\+T3\+\_\+\+S\+D\+K/pluginterfaces/base/smartpointer.\+h\end{DoxyCompactItemize}
