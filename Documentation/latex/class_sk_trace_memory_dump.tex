\hypertarget{class_sk_trace_memory_dump}{}\doxysection{Sk\+Trace\+Memory\+Dump Class Reference}
\label{class_sk_trace_memory_dump}\index{SkTraceMemoryDump@{SkTraceMemoryDump}}


{\ttfamily \#include $<$Sk\+Trace\+Memory\+Dump.\+h$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{class_sk_trace_memory_dump_a7087a3aafe792abc6973a2718135906a}{Level\+Of\+Detail}} \{ {\bfseries k\+Light\+\_\+\+Level\+Of\+Detail}, 
{\bfseries k\+Objects\+Breakdowns\+\_\+\+Level\+Of\+Detail}
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \mbox{\hyperlink{class_sk_trace_memory_dump_af64e84ca16e36a3064e6a74b0d6c9ea0}{dump\+Numeric\+Value}} (const char $\ast$dump\+Name, const char $\ast$value\+Name, const char $\ast$units, uint64\+\_\+t value)=0
\item 
\mbox{\Hypertarget{class_sk_trace_memory_dump_ab818a66bfdc7ab2b39ef4bacd872cd3e}\label{class_sk_trace_memory_dump_ab818a66bfdc7ab2b39ef4bacd872cd3e}} 
virtual void {\bfseries dump\+String\+Value} (const char $\ast$, const char $\ast$, const char $\ast$)
\item 
virtual void \mbox{\hyperlink{class_sk_trace_memory_dump_a1c02b809c621785f058230c3eab5692d}{set\+Memory\+Backing}} (const char $\ast$dump\+Name, const char $\ast$backing\+Type, const char $\ast$backing\+Object\+Id)=0
\item 
virtual void \mbox{\hyperlink{class_sk_trace_memory_dump_a384787d875a6502300b25e9942c644b7}{set\+Discardable\+Memory\+Backing}} (const char $\ast$dump\+Name, const \mbox{\hyperlink{class_sk_discardable_memory}{Sk\+Discardable\+Memory}} \&discardable\+Memory\+Object)=0
\item 
virtual \mbox{\hyperlink{class_sk_trace_memory_dump_a7087a3aafe792abc6973a2718135906a}{Level\+Of\+Detail}} \mbox{\hyperlink{class_sk_trace_memory_dump_a386310710d5b60f05488af1e9673b8e2}{get\+Requested\+Details}} () const =0
\item 
virtual bool \mbox{\hyperlink{class_sk_trace_memory_dump_ae95fdec0ea448397dfe6d3588f6605df}{should\+Dump\+Wrapped\+Objects}} () const
\item 
virtual void \mbox{\hyperlink{class_sk_trace_memory_dump_ab69332db719c3463c7f8ec6cf431f0ea}{dump\+Wrapped\+State}} (const char $\ast$, bool)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_trace_memory_dump_a269f47399edb53828b03e484052d5ff3}\label{class_sk_trace_memory_dump_a269f47399edb53828b03e484052d5ff3}} 
{\bfseries Sk\+Trace\+Memory\+Dump} (const \mbox{\hyperlink{class_sk_trace_memory_dump}{Sk\+Trace\+Memory\+Dump}} \&)=delete
\item 
\mbox{\Hypertarget{class_sk_trace_memory_dump_ab62233da37bc72e497bf063abb6d9375}\label{class_sk_trace_memory_dump_ab62233da37bc72e497bf063abb6d9375}} 
\mbox{\hyperlink{class_sk_trace_memory_dump}{Sk\+Trace\+Memory\+Dump}} \& {\bfseries operator=} (const \mbox{\hyperlink{class_sk_trace_memory_dump}{Sk\+Trace\+Memory\+Dump}} \&)=delete
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Interface for memory tracing. This interface is meant to be passed as argument to the memory dump methods of Skia objects. The implementation of this interface is provided by the embedder. 

\doxysubsection{Member Enumeration Documentation}
\mbox{\Hypertarget{class_sk_trace_memory_dump_a7087a3aafe792abc6973a2718135906a}\label{class_sk_trace_memory_dump_a7087a3aafe792abc6973a2718135906a}} 
\index{SkTraceMemoryDump@{SkTraceMemoryDump}!LevelOfDetail@{LevelOfDetail}}
\index{LevelOfDetail@{LevelOfDetail}!SkTraceMemoryDump@{SkTraceMemoryDump}}
\doxysubsubsection{\texorpdfstring{LevelOfDetail}{LevelOfDetail}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{class_sk_trace_memory_dump_a7087a3aafe792abc6973a2718135906a}{Sk\+Trace\+Memory\+Dump\+::\+Level\+Of\+Detail}}}

Enum to specify the level of the requested details for the dump from the Skia objects. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_trace_memory_dump_af64e84ca16e36a3064e6a74b0d6c9ea0}\label{class_sk_trace_memory_dump_af64e84ca16e36a3064e6a74b0d6c9ea0}} 
\index{SkTraceMemoryDump@{SkTraceMemoryDump}!dumpNumericValue@{dumpNumericValue}}
\index{dumpNumericValue@{dumpNumericValue}!SkTraceMemoryDump@{SkTraceMemoryDump}}
\doxysubsubsection{\texorpdfstring{dumpNumericValue()}{dumpNumericValue()}}
{\footnotesize\ttfamily virtual void Sk\+Trace\+Memory\+Dump\+::dump\+Numeric\+Value (\begin{DoxyParamCaption}\item[{const char $\ast$}]{dump\+Name,  }\item[{const char $\ast$}]{value\+Name,  }\item[{const char $\ast$}]{units,  }\item[{uint64\+\_\+t}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Appends a new memory dump (i.\+e. a row) to the trace memory infrastructure. If dump\+Name does not exist yet, a new one is created. Otherwise, a new column is appended to the previously created dump. Arguments\+: dump\+Name\+: an absolute, slash-\/separated, name for the item being dumped e.\+g., \char`\"{}skia/\+Cache\+X/\+Entry\+Y\char`\"{}. value\+Name\+: a string indicating the name of the column. e.\+g., \char`\"{}size\char`\"{}, \char`\"{}active\+\_\+size\char`\"{}, \char`\"{}number\+\_\+of\+\_\+objects\char`\"{}. This string is supposed to be long lived and is N\+OT copied. units\+: a string indicating the units for the value. e.\+g., \char`\"{}bytes\char`\"{}, \char`\"{}objects\char`\"{}. This string is supposed to be long lived and is N\+OT copied. value\+: the actual value being dumped. \mbox{\Hypertarget{class_sk_trace_memory_dump_ab69332db719c3463c7f8ec6cf431f0ea}\label{class_sk_trace_memory_dump_ab69332db719c3463c7f8ec6cf431f0ea}} 
\index{SkTraceMemoryDump@{SkTraceMemoryDump}!dumpWrappedState@{dumpWrappedState}}
\index{dumpWrappedState@{dumpWrappedState}!SkTraceMemoryDump@{SkTraceMemoryDump}}
\doxysubsubsection{\texorpdfstring{dumpWrappedState()}{dumpWrappedState()}}
{\footnotesize\ttfamily virtual void Sk\+Trace\+Memory\+Dump\+::dump\+Wrapped\+State (\begin{DoxyParamCaption}\item[{const char $\ast$}]{,  }\item[{bool}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

If \mbox{\hyperlink{class_sk_trace_memory_dump_ae95fdec0ea448397dfe6d3588f6605df}{should\+Dump\+Wrapped\+Objects()}} returns true then this function will be called to populate the output with information on whether the item being dumped is a wrapped object. \mbox{\Hypertarget{class_sk_trace_memory_dump_a386310710d5b60f05488af1e9673b8e2}\label{class_sk_trace_memory_dump_a386310710d5b60f05488af1e9673b8e2}} 
\index{SkTraceMemoryDump@{SkTraceMemoryDump}!getRequestedDetails@{getRequestedDetails}}
\index{getRequestedDetails@{getRequestedDetails}!SkTraceMemoryDump@{SkTraceMemoryDump}}
\doxysubsubsection{\texorpdfstring{getRequestedDetails()}{getRequestedDetails()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{class_sk_trace_memory_dump_a7087a3aafe792abc6973a2718135906a}{Level\+Of\+Detail}} Sk\+Trace\+Memory\+Dump\+::get\+Requested\+Details (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [pure virtual]}}

Returns the type of details requested in the dump. The granularity of the dump is supposed to match the Level\+Of\+Detail argument. The level of detail must not affect the total size reported, but only granularity of the child entries. \mbox{\Hypertarget{class_sk_trace_memory_dump_a384787d875a6502300b25e9942c644b7}\label{class_sk_trace_memory_dump_a384787d875a6502300b25e9942c644b7}} 
\index{SkTraceMemoryDump@{SkTraceMemoryDump}!setDiscardableMemoryBacking@{setDiscardableMemoryBacking}}
\index{setDiscardableMemoryBacking@{setDiscardableMemoryBacking}!SkTraceMemoryDump@{SkTraceMemoryDump}}
\doxysubsubsection{\texorpdfstring{setDiscardableMemoryBacking()}{setDiscardableMemoryBacking()}}
{\footnotesize\ttfamily virtual void Sk\+Trace\+Memory\+Dump\+::set\+Discardable\+Memory\+Backing (\begin{DoxyParamCaption}\item[{const char $\ast$}]{dump\+Name,  }\item[{const \mbox{\hyperlink{class_sk_discardable_memory}{Sk\+Discardable\+Memory}} \&}]{discardable\+Memory\+Object }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Specialization for memory backed by discardable memory. \mbox{\Hypertarget{class_sk_trace_memory_dump_a1c02b809c621785f058230c3eab5692d}\label{class_sk_trace_memory_dump_a1c02b809c621785f058230c3eab5692d}} 
\index{SkTraceMemoryDump@{SkTraceMemoryDump}!setMemoryBacking@{setMemoryBacking}}
\index{setMemoryBacking@{setMemoryBacking}!SkTraceMemoryDump@{SkTraceMemoryDump}}
\doxysubsubsection{\texorpdfstring{setMemoryBacking()}{setMemoryBacking()}}
{\footnotesize\ttfamily virtual void Sk\+Trace\+Memory\+Dump\+::set\+Memory\+Backing (\begin{DoxyParamCaption}\item[{const char $\ast$}]{dump\+Name,  }\item[{const char $\ast$}]{backing\+Type,  }\item[{const char $\ast$}]{backing\+Object\+Id }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Sets the memory backing for an existing dump. backing\+Type and backing\+Object\+Id are used by the embedder to associate the memory dumped via dump\+Numeric\+Value with the corresponding dump that backs the memory. \mbox{\Hypertarget{class_sk_trace_memory_dump_ae95fdec0ea448397dfe6d3588f6605df}\label{class_sk_trace_memory_dump_ae95fdec0ea448397dfe6d3588f6605df}} 
\index{SkTraceMemoryDump@{SkTraceMemoryDump}!shouldDumpWrappedObjects@{shouldDumpWrappedObjects}}
\index{shouldDumpWrappedObjects@{shouldDumpWrappedObjects}!SkTraceMemoryDump@{SkTraceMemoryDump}}
\doxysubsubsection{\texorpdfstring{shouldDumpWrappedObjects()}{shouldDumpWrappedObjects()}}
{\footnotesize\ttfamily virtual bool Sk\+Trace\+Memory\+Dump\+::should\+Dump\+Wrapped\+Objects (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}

Returns true if we should dump wrapped objects. Wrapped objects come from outside Skia, and may be independently tracked there. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/include/core/Sk\+Trace\+Memory\+Dump.\+h\end{DoxyCompactItemize}
