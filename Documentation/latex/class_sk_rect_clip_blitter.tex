\hypertarget{class_sk_rect_clip_blitter}{}\doxysection{Sk\+Rect\+Clip\+Blitter Class Reference}
\label{class_sk_rect_clip_blitter}\index{SkRectClipBlitter@{SkRectClipBlitter}}


{\ttfamily \#include $<$Sk\+Blitter.\+h$>$}

Inheritance diagram for Sk\+Rect\+Clip\+Blitter\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_sk_rect_clip_blitter}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_rect_clip_blitter_ac3e68d2e8568a153d1bbe9a7f77b6c56}\label{class_sk_rect_clip_blitter_ac3e68d2e8568a153d1bbe9a7f77b6c56}} 
void {\bfseries init} (\mbox{\hyperlink{class_sk_blitter}{Sk\+Blitter}} $\ast$blitter, const \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} \&clip\+Rect)
\item 
\mbox{\Hypertarget{class_sk_rect_clip_blitter_a4443a42e40e30918406accf23ae9bbf2}\label{class_sk_rect_clip_blitter_a4443a42e40e30918406accf23ae9bbf2}} 
void \mbox{\hyperlink{class_sk_rect_clip_blitter_a4443a42e40e30918406accf23ae9bbf2}{blitH}} (int x, int y, int width) override
\begin{DoxyCompactList}\small\item\em Blit a horizontal run of one or more pixels. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_sk_rect_clip_blitter_a24e787f137cf3b2a4bf10dbd266b0b76}{blit\+AntiH}} (int x, int y, const \mbox{\hyperlink{_sk_color_8h_a918cf5a3a68406ac8107f6be48fb906e}{Sk\+Alpha}}\mbox{[}$\,$\mbox{]}, const int16\+\_\+t runs\mbox{[}$\,$\mbox{]}) override
\item 
\mbox{\Hypertarget{class_sk_rect_clip_blitter_a552926f3562fe7bf77efda3260c01eb6}\label{class_sk_rect_clip_blitter_a552926f3562fe7bf77efda3260c01eb6}} 
void \mbox{\hyperlink{class_sk_rect_clip_blitter_a552926f3562fe7bf77efda3260c01eb6}{blitV}} (int x, int y, int height, \mbox{\hyperlink{_sk_color_8h_a918cf5a3a68406ac8107f6be48fb906e}{Sk\+Alpha}} alpha) override
\begin{DoxyCompactList}\small\item\em Blit a vertical run of pixels with a constant alpha value. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_sk_rect_clip_blitter_ad689aaf42a6095222136404f9432ab90}\label{class_sk_rect_clip_blitter_ad689aaf42a6095222136404f9432ab90}} 
void \mbox{\hyperlink{class_sk_rect_clip_blitter_ad689aaf42a6095222136404f9432ab90}{blit\+Rect}} (int x, int y, int width, int height) override
\begin{DoxyCompactList}\small\item\em Blit a solid rectangle one or more pixels wide. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_sk_rect_clip_blitter_a5aa09fb8bd933d47d920c84a0c8a1b0a}{blit\+Anti\+Rect}} (int x, int y, int width, int height, \mbox{\hyperlink{_sk_color_8h_a918cf5a3a68406ac8107f6be48fb906e}{Sk\+Alpha}} left\+Alpha, \mbox{\hyperlink{_sk_color_8h_a918cf5a3a68406ac8107f6be48fb906e}{Sk\+Alpha}} right\+Alpha) override
\item 
void \mbox{\hyperlink{class_sk_rect_clip_blitter_a96bbe2c661f9ecfbac5124b7d016ddb2}{blit\+Mask}} (const \mbox{\hyperlink{struct_sk_mask}{Sk\+Mask}} \&, const \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} \&clip) override
\item 
const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} $\ast$ \mbox{\hyperlink{class_sk_rect_clip_blitter_a850649c361f4e4d7569f6a07058a7f78}{just\+An\+Opaque\+Color}} (uint32\+\_\+t $\ast$value) override
\item 
int \mbox{\hyperlink{class_sk_rect_clip_blitter_a3eeaf188a8e2030c0fdb7d5ad11abd1f}{request\+Rows\+Preserved}} () const override
\item 
void $\ast$ \mbox{\hyperlink{class_sk_rect_clip_blitter_aef11c491a5a7fccb76ce1289fbd9f329}{alloc\+Blit\+Memory}} (size\+\_\+t sz) override
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
Wraps another (real) blitter, and ensures that the real blitter is only called with coordinates that have been clipped by the specified clip\+Rect. This means the caller need not perform the clipping ahead of time. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_rect_clip_blitter_aef11c491a5a7fccb76ce1289fbd9f329}\label{class_sk_rect_clip_blitter_aef11c491a5a7fccb76ce1289fbd9f329}} 
\index{SkRectClipBlitter@{SkRectClipBlitter}!allocBlitMemory@{allocBlitMemory}}
\index{allocBlitMemory@{allocBlitMemory}!SkRectClipBlitter@{SkRectClipBlitter}}
\doxysubsubsection{\texorpdfstring{allocBlitMemory()}{allocBlitMemory()}}
{\footnotesize\ttfamily void$\ast$ Sk\+Rect\+Clip\+Blitter\+::alloc\+Blit\+Memory (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{sz }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}

This function allocates memory for the blitter that the blitter then owns. The memory can be used by the calling function at will, but it will be released when the blitter\textquotesingle{}s destructor is called. This function returns nullptr if no persistent memory is needed by the blitter. 

Reimplemented from \mbox{\hyperlink{class_sk_blitter_a77147df39a3c9d6b546d90139781a644}{Sk\+Blitter}}.

\mbox{\Hypertarget{class_sk_rect_clip_blitter_a24e787f137cf3b2a4bf10dbd266b0b76}\label{class_sk_rect_clip_blitter_a24e787f137cf3b2a4bf10dbd266b0b76}} 
\index{SkRectClipBlitter@{SkRectClipBlitter}!blitAntiH@{blitAntiH}}
\index{blitAntiH@{blitAntiH}!SkRectClipBlitter@{SkRectClipBlitter}}
\doxysubsubsection{\texorpdfstring{blitAntiH()}{blitAntiH()}}
{\footnotesize\ttfamily void Sk\+Rect\+Clip\+Blitter\+::blit\+AntiH (\begin{DoxyParamCaption}\item[{int}]{x,  }\item[{int}]{y,  }\item[{const}]{antialias\mbox{[}$\,$\mbox{]},  }\item[{const int16\+\_\+t}]{runs\mbox{[}$\,$\mbox{]} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Blit a horizontal run of antialiased pixels; runs\mbox{[}\mbox{]} is a {\itshape sparse} zero-\/terminated run-\/length encoding of spans of constant alpha values. The runs\mbox{[}\mbox{]} and antialias\mbox{[}\mbox{]} work together to represent long runs of pixels with the same alphas. The runs\mbox{[}\mbox{]} contains the number of pixels with the same alpha, and antialias\mbox{[}\mbox{]} contain the coverage value for that number of pixels. The runs\mbox{[}\mbox{]} (and antialias\mbox{[}\mbox{]}) are encoded in a clever way. The runs array is zero terminated, and has enough entries for each pixel plus one, in most cases some of the entries will not contain valid data. An entry in the runs array contains the number of pixels (np) that have the same alpha value. The next np value is found np entries away. For example, if runs\mbox{[}0\mbox{]} = 7, then the next valid entry will by at runs\mbox{[}7\mbox{]}. The runs array and antialias\mbox{[}\mbox{]} are coupled by index. So, if the np entry is at runs\mbox{[}45\mbox{]} = 12 then the alpha value can be found at antialias\mbox{[}45\mbox{]} = 0x88. This would mean to use an alpha value of 0x88 for the next 12 pixels starting at pixel 45. 

Implements \mbox{\hyperlink{class_sk_blitter_a9690b92ca395a44e130e60ef057a0bbd}{Sk\+Blitter}}.

\mbox{\Hypertarget{class_sk_rect_clip_blitter_a5aa09fb8bd933d47d920c84a0c8a1b0a}\label{class_sk_rect_clip_blitter_a5aa09fb8bd933d47d920c84a0c8a1b0a}} 
\index{SkRectClipBlitter@{SkRectClipBlitter}!blitAntiRect@{blitAntiRect}}
\index{blitAntiRect@{blitAntiRect}!SkRectClipBlitter@{SkRectClipBlitter}}
\doxysubsubsection{\texorpdfstring{blitAntiRect()}{blitAntiRect()}}
{\footnotesize\ttfamily void Sk\+Rect\+Clip\+Blitter\+::blit\+Anti\+Rect (\begin{DoxyParamCaption}\item[{int}]{x,  }\item[{int}]{y,  }\item[{int}]{width,  }\item[{int}]{height,  }\item[{\mbox{\hyperlink{_sk_color_8h_a918cf5a3a68406ac8107f6be48fb906e}{Sk\+Alpha}}}]{left\+Alpha,  }\item[{\mbox{\hyperlink{_sk_color_8h_a918cf5a3a68406ac8107f6be48fb906e}{Sk\+Alpha}}}]{right\+Alpha }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Blit a rectangle with one alpha-\/blended column on the left, width (zero or more) opaque pixels, and one alpha-\/blended column on the right. The result will always be at least two pixels wide.

Default implementation doesn\textquotesingle{}t check for easy optimizations such as alpha == 255; also uses \mbox{\hyperlink{class_sk_rect_clip_blitter_a552926f3562fe7bf77efda3260c01eb6}{blit\+V()}}, which some subclasses may not support. 

Reimplemented from \mbox{\hyperlink{class_sk_blitter_a8c89cb263233c70f7b3978602cadc4f9}{Sk\+Blitter}}.

\mbox{\Hypertarget{class_sk_rect_clip_blitter_a96bbe2c661f9ecfbac5124b7d016ddb2}\label{class_sk_rect_clip_blitter_a96bbe2c661f9ecfbac5124b7d016ddb2}} 
\index{SkRectClipBlitter@{SkRectClipBlitter}!blitMask@{blitMask}}
\index{blitMask@{blitMask}!SkRectClipBlitter@{SkRectClipBlitter}}
\doxysubsubsection{\texorpdfstring{blitMask()}{blitMask()}}
{\footnotesize\ttfamily void Sk\+Rect\+Clip\+Blitter\+::blit\+Mask (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_mask}{Sk\+Mask}} \&}]{mask,  }\item[{const \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} \&}]{clip }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Blit a pattern of pixels defined by a rectangle-\/clipped mask; typically used for text. 

Reimplemented from \mbox{\hyperlink{class_sk_blitter_a8402f28f6d9527e228695a145fff19a1}{Sk\+Blitter}}.

\mbox{\Hypertarget{class_sk_rect_clip_blitter_a850649c361f4e4d7569f6a07058a7f78}\label{class_sk_rect_clip_blitter_a850649c361f4e4d7569f6a07058a7f78}} 
\index{SkRectClipBlitter@{SkRectClipBlitter}!justAnOpaqueColor@{justAnOpaqueColor}}
\index{justAnOpaqueColor@{justAnOpaqueColor}!SkRectClipBlitter@{SkRectClipBlitter}}
\doxysubsubsection{\texorpdfstring{justAnOpaqueColor()}{justAnOpaqueColor()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} $\ast$ Sk\+Rect\+Clip\+Blitter\+::just\+An\+Opaque\+Color (\begin{DoxyParamCaption}\item[{uint32\+\_\+t $\ast$}]{value }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

If the blitter just sets a single value for each pixel, return the bitmap it draws into, and assign value. If not, return nullptr and ignore the value parameter. 

Reimplemented from \mbox{\hyperlink{class_sk_blitter_a2c7339eac34e3bd95c0e5eaa1fa1c1e2}{Sk\+Blitter}}.

\mbox{\Hypertarget{class_sk_rect_clip_blitter_a3eeaf188a8e2030c0fdb7d5ad11abd1f}\label{class_sk_rect_clip_blitter_a3eeaf188a8e2030c0fdb7d5ad11abd1f}} 
\index{SkRectClipBlitter@{SkRectClipBlitter}!requestRowsPreserved@{requestRowsPreserved}}
\index{requestRowsPreserved@{requestRowsPreserved}!SkRectClipBlitter@{SkRectClipBlitter}}
\doxysubsubsection{\texorpdfstring{requestRowsPreserved()}{requestRowsPreserved()}}
{\footnotesize\ttfamily int Sk\+Rect\+Clip\+Blitter\+::request\+Rows\+Preserved (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}

Special methods for blitters that can blit more than one row at a time. This function returns the number of rows that this blitter could optimally process at a time. It is still required to support blitting one scanline at a time. 

Reimplemented from \mbox{\hyperlink{class_sk_blitter_a39cd14212151afdc716087597ee43abd}{Sk\+Blitter}}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Blitter.\+h\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Blitter.\+cpp\end{DoxyCompactItemize}
