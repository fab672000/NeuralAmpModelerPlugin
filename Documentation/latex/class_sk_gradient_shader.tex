\hypertarget{class_sk_gradient_shader}{}\doxysection{Sk\+Gradient\+Shader Class Reference}
\label{class_sk_gradient_shader}\index{SkGradientShader@{SkGradientShader}}


{\ttfamily \#include $<$Sk\+Gradient\+Shader.\+h$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{class_sk_gradient_shader_aadb14dc8b07ae06618a0957b85b3bd55}{Flags}} \{ \mbox{\hyperlink{class_sk_gradient_shader_aadb14dc8b07ae06618a0957b85b3bd55a431f2dd3ae8a32c763981333fad0b50c}{k\+Interpolate\+Colors\+In\+Premul\+\_\+\+Flag}} = 1 $<$$<$ 0
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ \mbox{\hyperlink{class_sk_gradient_shader_aa318af3ada260c10c0df123c25720141}{Make\+Linear}} (const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} pts\mbox{[}2\mbox{]}, const \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} colors\mbox{[}$\,$\mbox{]}, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, Sk\+Tile\+Mode mode, uint32\+\_\+t flags, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$local\+Matrix)
\item 
\mbox{\Hypertarget{class_sk_gradient_shader_af4ee25dd1202b3cff564b96c3b0bf908}\label{class_sk_gradient_shader_af4ee25dd1202b3cff564b96c3b0bf908}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ {\bfseries Make\+Linear} (const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} pts\mbox{[}2\mbox{]}, const \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} colors\mbox{[}$\,$\mbox{]}, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, Sk\+Tile\+Mode mode)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ \mbox{\hyperlink{class_sk_gradient_shader_a737b0fdeee28f23a825cb18cdd87bfce}{Make\+Linear}} (const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} pts\mbox{[}2\mbox{]}, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} colors\mbox{[}$\,$\mbox{]}, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$ color\+Space, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, Sk\+Tile\+Mode mode, uint32\+\_\+t flags, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$local\+Matrix)
\item 
\mbox{\Hypertarget{class_sk_gradient_shader_a0ce26539b71809584517a9c7f8f84bea}\label{class_sk_gradient_shader_a0ce26539b71809584517a9c7f8f84bea}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ {\bfseries Make\+Linear} (const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} pts\mbox{[}2\mbox{]}, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} colors\mbox{[}$\,$\mbox{]}, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$ color\+Space, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, Sk\+Tile\+Mode mode)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ \mbox{\hyperlink{class_sk_gradient_shader_ae026100c264bdff0e351a1de91f905fb}{Make\+Radial}} (const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&center, Sk\+Scalar radius, const \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} colors\mbox{[}$\,$\mbox{]}, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, Sk\+Tile\+Mode mode, uint32\+\_\+t flags, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$local\+Matrix)
\item 
\mbox{\Hypertarget{class_sk_gradient_shader_a8992e13c09c76e0ef160b54b3374847b}\label{class_sk_gradient_shader_a8992e13c09c76e0ef160b54b3374847b}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ {\bfseries Make\+Radial} (const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&center, Sk\+Scalar radius, const \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} colors\mbox{[}$\,$\mbox{]}, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, Sk\+Tile\+Mode mode)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ \mbox{\hyperlink{class_sk_gradient_shader_a8cc8b8a83927dc6a96392683346ab707}{Make\+Radial}} (const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&center, Sk\+Scalar radius, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} colors\mbox{[}$\,$\mbox{]}, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$ color\+Space, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, Sk\+Tile\+Mode mode, uint32\+\_\+t flags, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$local\+Matrix)
\item 
\mbox{\Hypertarget{class_sk_gradient_shader_ab51aa3746d33b918963e361d5aaee51b}\label{class_sk_gradient_shader_ab51aa3746d33b918963e361d5aaee51b}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ {\bfseries Make\+Radial} (const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&center, Sk\+Scalar radius, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} colors\mbox{[}$\,$\mbox{]}, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$ color\+Space, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, Sk\+Tile\+Mode mode)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ \mbox{\hyperlink{class_sk_gradient_shader_ad5642795e2f08c70baad2bd03632107c}{Make\+Two\+Point\+Conical}} (const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&start, Sk\+Scalar start\+Radius, const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&end, Sk\+Scalar end\+Radius, const \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} colors\mbox{[}$\,$\mbox{]}, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, Sk\+Tile\+Mode mode, uint32\+\_\+t flags, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$local\+Matrix)
\item 
\mbox{\Hypertarget{class_sk_gradient_shader_a118352e9ba8649aadac039d93a2943cb}\label{class_sk_gradient_shader_a118352e9ba8649aadac039d93a2943cb}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ {\bfseries Make\+Two\+Point\+Conical} (const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&start, Sk\+Scalar start\+Radius, const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&end, Sk\+Scalar end\+Radius, const \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} colors\mbox{[}$\,$\mbox{]}, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, Sk\+Tile\+Mode mode)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ \mbox{\hyperlink{class_sk_gradient_shader_acde808cc9fa7842cf9f1a4cfea5e0b2c}{Make\+Two\+Point\+Conical}} (const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&start, Sk\+Scalar start\+Radius, const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&end, Sk\+Scalar end\+Radius, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} colors\mbox{[}$\,$\mbox{]}, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$ color\+Space, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, Sk\+Tile\+Mode mode, uint32\+\_\+t flags, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$local\+Matrix)
\item 
\mbox{\Hypertarget{class_sk_gradient_shader_a3f5a5869d7acc74e6ab7b6c675fec7ac}\label{class_sk_gradient_shader_a3f5a5869d7acc74e6ab7b6c675fec7ac}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ {\bfseries Make\+Two\+Point\+Conical} (const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&start, Sk\+Scalar start\+Radius, const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&end, Sk\+Scalar end\+Radius, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} colors\mbox{[}$\,$\mbox{]}, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$ color\+Space, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, Sk\+Tile\+Mode mode)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ \mbox{\hyperlink{class_sk_gradient_shader_a8c3fd6576084287b256304f7bda6fb96}{Make\+Sweep}} (Sk\+Scalar cx, Sk\+Scalar cy, const \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} colors\mbox{[}$\,$\mbox{]}, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, Sk\+Tile\+Mode mode, Sk\+Scalar start\+Angle, Sk\+Scalar end\+Angle, uint32\+\_\+t flags, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$local\+Matrix)
\item 
\mbox{\Hypertarget{class_sk_gradient_shader_adc251ec7d199b0c9aefb0df74fd1307a}\label{class_sk_gradient_shader_adc251ec7d199b0c9aefb0df74fd1307a}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ {\bfseries Make\+Sweep} (Sk\+Scalar cx, Sk\+Scalar cy, const \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} colors\mbox{[}$\,$\mbox{]}, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, uint32\+\_\+t flags, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$local\+Matrix)
\item 
\mbox{\Hypertarget{class_sk_gradient_shader_a294a0f7f4127c913def1566c84a08a83}\label{class_sk_gradient_shader_a294a0f7f4127c913def1566c84a08a83}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ {\bfseries Make\+Sweep} (Sk\+Scalar cx, Sk\+Scalar cy, const \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} colors\mbox{[}$\,$\mbox{]}, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ \mbox{\hyperlink{class_sk_gradient_shader_a2fc649cdf627c2f20738b7002e87568a}{Make\+Sweep}} (Sk\+Scalar cx, Sk\+Scalar cy, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} colors\mbox{[}$\,$\mbox{]}, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$ color\+Space, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, Sk\+Tile\+Mode mode, Sk\+Scalar start\+Angle, Sk\+Scalar end\+Angle, uint32\+\_\+t flags, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$local\+Matrix)
\item 
\mbox{\Hypertarget{class_sk_gradient_shader_ac13602617dd2ee03eaa761525fd40f6f}\label{class_sk_gradient_shader_ac13602617dd2ee03eaa761525fd40f6f}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ {\bfseries Make\+Sweep} (Sk\+Scalar cx, Sk\+Scalar cy, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} colors\mbox{[}$\,$\mbox{]}, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$ color\+Space, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count, uint32\+\_\+t flags, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$local\+Matrix)
\item 
\mbox{\Hypertarget{class_sk_gradient_shader_a012cdbcc61e5d32e7b811920899c8d92}\label{class_sk_gradient_shader_a012cdbcc61e5d32e7b811920899c8d92}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ {\bfseries Make\+Sweep} (Sk\+Scalar cx, Sk\+Scalar cy, const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}} colors\mbox{[}$\,$\mbox{]}, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$ color\+Space, const Sk\+Scalar pos\mbox{[}$\,$\mbox{]}, int count)
\item 
\mbox{\Hypertarget{class_sk_gradient_shader_ab6f150bd30968f0829e3f2febff9827d}\label{class_sk_gradient_shader_ab6f150bd30968f0829e3f2febff9827d}} 
static void {\bfseries Register\+Flattenables} ()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\mbox{\hyperlink{class_sk_gradient_shader}{Sk\+Gradient\+Shader}} hosts factories for creating subclasses of \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} that render linear and radial gradients. In general, degenerate cases should not produce surprising results, but there are several types of degeneracies\+:

A linear gradient made from the same two points. A radial gradient with a radius of zero. A sweep gradient where the start and end angle are the same. A two point conical gradient where the two centers and the two radii are the same.

For any degenerate gradient with a decal tile mode, it will draw empty since the interpolating region is zero area and the outer region is discarded by the decal mode.

For any degenerate gradient with a repeat or mirror tile mode, it will draw a solid color that is the average gradient color, since infinitely many repetitions of the gradients will fill the shape.

For a clamped gradient, every type is well-\/defined at the limit except for linear gradients. The radial gradient with zero radius becomes the last color. The sweep gradient draws the sector from 0 to the provided angle with the first color, with a hardstop switching to the last color. When the provided angle is 0, this is just the solid last color again. Similarly, the two point conical gradient becomes a circle filled with the first color, sized to the provided radius, with a hardstop switching to the last color. When the two radii are both zero, this is just the solid last color.

As a linear gradient approaches the degenerate case, its shader will approach the appearance of two half planes, each filled by the first and last colors of the gradient. The planes will be oriented perpendicular to the vector between the two defining points of the gradient. However, once they become the same point, Skia cannot reconstruct what that expected orientation is. To provide a stable and predictable color in this case, Skia just uses the last color as a solid fill to be similar to many of the other degenerate gradients\textquotesingle{} behaviors in clamp mode. 

\doxysubsection{Member Enumeration Documentation}
\mbox{\Hypertarget{class_sk_gradient_shader_aadb14dc8b07ae06618a0957b85b3bd55}\label{class_sk_gradient_shader_aadb14dc8b07ae06618a0957b85b3bd55}} 
\index{SkGradientShader@{SkGradientShader}!Flags@{Flags}}
\index{Flags@{Flags}!SkGradientShader@{SkGradientShader}}
\doxysubsubsection{\texorpdfstring{Flags}{Flags}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{class_sk_gradient_shader_aadb14dc8b07ae06618a0957b85b3bd55}{Sk\+Gradient\+Shader\+::\+Flags}}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kInterpolateColorsInPremul\_Flag@{kInterpolateColorsInPremul\_Flag}!SkGradientShader@{SkGradientShader}}\index{SkGradientShader@{SkGradientShader}!kInterpolateColorsInPremul\_Flag@{kInterpolateColorsInPremul\_Flag}}}\mbox{\Hypertarget{class_sk_gradient_shader_aadb14dc8b07ae06618a0957b85b3bd55a431f2dd3ae8a32c763981333fad0b50c}\label{class_sk_gradient_shader_aadb14dc8b07ae06618a0957b85b3bd55a431f2dd3ae8a32c763981333fad0b50c}} 
k\+Interpolate\+Colors\+In\+Premul\+\_\+\+Flag&By default gradients will interpolate their colors in unpremul space and then premultiply each of the results. By setting this flag, the gradients will premultiply their colors first, and then interpolate between them. example\+: \href{https://fiddle.skia.org/c/@GradientShader_MakeLinear}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Gradient\+Shader\+\_\+\+Make\+Linear}} \\
\hline

\end{DoxyEnumFields}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_gradient_shader_aa318af3ada260c10c0df123c25720141}\label{class_sk_gradient_shader_aa318af3ada260c10c0df123c25720141}} 
\index{SkGradientShader@{SkGradientShader}!MakeLinear@{MakeLinear}}
\index{MakeLinear@{MakeLinear}!SkGradientShader@{SkGradientShader}}
\doxysubsubsection{\texorpdfstring{MakeLinear()}{MakeLinear()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_shader}{Sk\+Shader}}$>$ Sk\+Gradient\+Shader\+::\+Make\+Linear (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}}}]{pts\mbox{[}2\mbox{]},  }\item[{const \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}}}]{colors\mbox{[}$\,$\mbox{]},  }\item[{const Sk\+Scalar}]{pos\mbox{[}$\,$\mbox{]},  }\item[{int}]{count,  }\item[{Sk\+Tile\+Mode}]{mode,  }\item[{uint32\+\_\+t}]{flags,  }\item[{const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$}]{local\+Matrix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns a shader that generates a linear gradient between the two specified points. 


\begin{DoxyParams}{Parameters}
{\em pts} & The start and end points for the gradient. \\
\hline
{\em colors} & The array\mbox{[}count\mbox{]} of colors, to be distributed between the two points \\
\hline
{\em pos} & May be N\+U\+LL. array\mbox{[}count\mbox{]} of Sk\+Scalars, or N\+U\+LL, of the relative position of each corresponding color in the colors array. If this is N\+U\+LL, the the colors are distributed evenly between the start and end point. If this is not null, the values must begin with 0, end with 1.\+0, and intermediate values must be strictly increasing. \\
\hline
{\em count} & Must be $>$=2. The number of colors (and pos if not N\+U\+LL) entries. \\
\hline
{\em mode} & The tiling mode\\
\hline
\end{DoxyParams}
example\+: \href{https://fiddle.skia.org/c/@GradientShader_MakeLinear}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Gradient\+Shader\+\_\+\+Make\+Linear}} \mbox{\Hypertarget{class_sk_gradient_shader_a737b0fdeee28f23a825cb18cdd87bfce}\label{class_sk_gradient_shader_a737b0fdeee28f23a825cb18cdd87bfce}} 
\index{SkGradientShader@{SkGradientShader}!MakeLinear@{MakeLinear}}
\index{MakeLinear@{MakeLinear}!SkGradientShader@{SkGradientShader}}
\doxysubsubsection{\texorpdfstring{MakeLinear()}{MakeLinear()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_shader}{Sk\+Shader}}$>$ Sk\+Gradient\+Shader\+::\+Make\+Linear (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}}}]{pts\mbox{[}2\mbox{]},  }\item[{const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}}}]{colors\mbox{[}$\,$\mbox{]},  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$}]{color\+Space,  }\item[{const Sk\+Scalar}]{pos\mbox{[}$\,$\mbox{]},  }\item[{int}]{count,  }\item[{Sk\+Tile\+Mode}]{mode,  }\item[{uint32\+\_\+t}]{flags,  }\item[{const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$}]{local\+Matrix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns a shader that generates a linear gradient between the two specified points. 


\begin{DoxyParams}{Parameters}
{\em pts} & The start and end points for the gradient. \\
\hline
{\em colors} & The array\mbox{[}count\mbox{]} of colors, to be distributed between the two points \\
\hline
{\em pos} & May be N\+U\+LL. array\mbox{[}count\mbox{]} of Sk\+Scalars, or N\+U\+LL, of the relative position of each corresponding color in the colors array. If this is N\+U\+LL, the the colors are distributed evenly between the start and end point. If this is not null, the values must begin with 0, end with 1.\+0, and intermediate values must be strictly increasing. \\
\hline
{\em count} & Must be $>$=2. The number of colors (and pos if not N\+U\+LL) entries. \\
\hline
{\em mode} & The tiling mode\\
\hline
\end{DoxyParams}
example\+: \href{https://fiddle.skia.org/c/@GradientShader_MakeLinear}{\texttt{ https\+://fiddle.\+skia.\+org/c/@\+Gradient\+Shader\+\_\+\+Make\+Linear}} \mbox{\Hypertarget{class_sk_gradient_shader_ae026100c264bdff0e351a1de91f905fb}\label{class_sk_gradient_shader_ae026100c264bdff0e351a1de91f905fb}} 
\index{SkGradientShader@{SkGradientShader}!MakeRadial@{MakeRadial}}
\index{MakeRadial@{MakeRadial}!SkGradientShader@{SkGradientShader}}
\doxysubsubsection{\texorpdfstring{MakeRadial()}{MakeRadial()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_shader}{Sk\+Shader}}$>$ Sk\+Gradient\+Shader\+::\+Make\+Radial (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&}]{center,  }\item[{Sk\+Scalar}]{radius,  }\item[{const \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}}}]{colors\mbox{[}$\,$\mbox{]},  }\item[{const Sk\+Scalar}]{pos\mbox{[}$\,$\mbox{]},  }\item[{int}]{count,  }\item[{Sk\+Tile\+Mode}]{mode,  }\item[{uint32\+\_\+t}]{flags,  }\item[{const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$}]{local\+Matrix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns a shader that generates a radial gradient given the center and radius. 


\begin{DoxyParams}{Parameters}
{\em center} & The center of the circle for this gradient \\
\hline
{\em radius} & Must be positive. The radius of the circle for this gradient \\
\hline
{\em colors} & The array\mbox{[}count\mbox{]} of colors, to be distributed between the center and edge of the circle \\
\hline
{\em pos} & May be N\+U\+LL. The array\mbox{[}count\mbox{]} of Sk\+Scalars, or N\+U\+LL, of the relative position of each corresponding color in the colors array. If this is N\+U\+LL, the the colors are distributed evenly between the center and edge of the circle. If this is not null, the values must begin with 0, end with 1.\+0, and intermediate values must be strictly increasing. \\
\hline
{\em count} & Must be $>$= 2. The number of colors (and pos if not N\+U\+LL) entries \\
\hline
{\em mode} & The tiling mode \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_gradient_shader_a8cc8b8a83927dc6a96392683346ab707}\label{class_sk_gradient_shader_a8cc8b8a83927dc6a96392683346ab707}} 
\index{SkGradientShader@{SkGradientShader}!MakeRadial@{MakeRadial}}
\index{MakeRadial@{MakeRadial}!SkGradientShader@{SkGradientShader}}
\doxysubsubsection{\texorpdfstring{MakeRadial()}{MakeRadial()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_shader}{Sk\+Shader}}$>$ Sk\+Gradient\+Shader\+::\+Make\+Radial (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&}]{center,  }\item[{Sk\+Scalar}]{radius,  }\item[{const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}}}]{colors\mbox{[}$\,$\mbox{]},  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$}]{color\+Space,  }\item[{const Sk\+Scalar}]{pos\mbox{[}$\,$\mbox{]},  }\item[{int}]{count,  }\item[{Sk\+Tile\+Mode}]{mode,  }\item[{uint32\+\_\+t}]{flags,  }\item[{const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$}]{local\+Matrix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns a shader that generates a radial gradient given the center and radius. 


\begin{DoxyParams}{Parameters}
{\em center} & The center of the circle for this gradient \\
\hline
{\em radius} & Must be positive. The radius of the circle for this gradient \\
\hline
{\em colors} & The array\mbox{[}count\mbox{]} of colors, to be distributed between the center and edge of the circle \\
\hline
{\em pos} & May be N\+U\+LL. The array\mbox{[}count\mbox{]} of Sk\+Scalars, or N\+U\+LL, of the relative position of each corresponding color in the colors array. If this is N\+U\+LL, the the colors are distributed evenly between the center and edge of the circle. If this is not null, the values must begin with 0, end with 1.\+0, and intermediate values must be strictly increasing. \\
\hline
{\em count} & Must be $>$= 2. The number of colors (and pos if not N\+U\+LL) entries \\
\hline
{\em mode} & The tiling mode \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_gradient_shader_a8c3fd6576084287b256304f7bda6fb96}\label{class_sk_gradient_shader_a8c3fd6576084287b256304f7bda6fb96}} 
\index{SkGradientShader@{SkGradientShader}!MakeSweep@{MakeSweep}}
\index{MakeSweep@{MakeSweep}!SkGradientShader@{SkGradientShader}}
\doxysubsubsection{\texorpdfstring{MakeSweep()}{MakeSweep()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_shader}{Sk\+Shader}}$>$ Sk\+Gradient\+Shader\+::\+Make\+Sweep (\begin{DoxyParamCaption}\item[{Sk\+Scalar}]{cx,  }\item[{Sk\+Scalar}]{cy,  }\item[{const \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}}}]{colors\mbox{[}$\,$\mbox{]},  }\item[{const Sk\+Scalar}]{pos\mbox{[}$\,$\mbox{]},  }\item[{int}]{count,  }\item[{Sk\+Tile\+Mode}]{mode,  }\item[{Sk\+Scalar}]{start\+Angle,  }\item[{Sk\+Scalar}]{end\+Angle,  }\item[{uint32\+\_\+t}]{flags,  }\item[{const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$}]{local\+Matrix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns a shader that generates a sweep gradient given a center. 


\begin{DoxyParams}{Parameters}
{\em cx} & The X coordinate of the center of the sweep \\
\hline
{\em cx} & The Y coordinate of the center of the sweep \\
\hline
{\em colors} & The array\mbox{[}count\mbox{]} of colors, to be distributed around the center, within the gradient angle range. \\
\hline
{\em pos} & May be N\+U\+LL. The array\mbox{[}count\mbox{]} of Sk\+Scalars, or N\+U\+LL, of the relative position of each corresponding color in the colors array. If this is N\+U\+LL, then the colors are distributed evenly within the angular range. If this is not null, the values must begin with 0, end with 1.\+0, and intermediate values must be strictly increasing. \\
\hline
{\em count} & Must be $>$= 2. The number of colors (and pos if not N\+U\+LL) entries \\
\hline
{\em mode} & Tiling mode\+: controls drawing outside of the gradient angular range. \\
\hline
{\em start\+Angle} & Start of the angular range, corresponding to pos == 0. \\
\hline
{\em end\+Angle} & End of the angular range, corresponding to pos == 1. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_gradient_shader_a2fc649cdf627c2f20738b7002e87568a}\label{class_sk_gradient_shader_a2fc649cdf627c2f20738b7002e87568a}} 
\index{SkGradientShader@{SkGradientShader}!MakeSweep@{MakeSweep}}
\index{MakeSweep@{MakeSweep}!SkGradientShader@{SkGradientShader}}
\doxysubsubsection{\texorpdfstring{MakeSweep()}{MakeSweep()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_shader}{Sk\+Shader}}$>$ Sk\+Gradient\+Shader\+::\+Make\+Sweep (\begin{DoxyParamCaption}\item[{Sk\+Scalar}]{cx,  }\item[{Sk\+Scalar}]{cy,  }\item[{const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}}}]{colors\mbox{[}$\,$\mbox{]},  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$}]{color\+Space,  }\item[{const Sk\+Scalar}]{pos\mbox{[}$\,$\mbox{]},  }\item[{int}]{count,  }\item[{Sk\+Tile\+Mode}]{mode,  }\item[{Sk\+Scalar}]{start\+Angle,  }\item[{Sk\+Scalar}]{end\+Angle,  }\item[{uint32\+\_\+t}]{flags,  }\item[{const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$}]{local\+Matrix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns a shader that generates a sweep gradient given a center. 


\begin{DoxyParams}{Parameters}
{\em cx} & The X coordinate of the center of the sweep \\
\hline
{\em cx} & The Y coordinate of the center of the sweep \\
\hline
{\em colors} & The array\mbox{[}count\mbox{]} of colors, to be distributed around the center, within the gradient angle range. \\
\hline
{\em pos} & May be N\+U\+LL. The array\mbox{[}count\mbox{]} of Sk\+Scalars, or N\+U\+LL, of the relative position of each corresponding color in the colors array. If this is N\+U\+LL, then the colors are distributed evenly within the angular range. If this is not null, the values must begin with 0, end with 1.\+0, and intermediate values must be strictly increasing. \\
\hline
{\em count} & Must be $>$= 2. The number of colors (and pos if not N\+U\+LL) entries \\
\hline
{\em mode} & Tiling mode\+: controls drawing outside of the gradient angular range. \\
\hline
{\em start\+Angle} & Start of the angular range, corresponding to pos == 0. \\
\hline
{\em end\+Angle} & End of the angular range, corresponding to pos == 1. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_gradient_shader_ad5642795e2f08c70baad2bd03632107c}\label{class_sk_gradient_shader_ad5642795e2f08c70baad2bd03632107c}} 
\index{SkGradientShader@{SkGradientShader}!MakeTwoPointConical@{MakeTwoPointConical}}
\index{MakeTwoPointConical@{MakeTwoPointConical}!SkGradientShader@{SkGradientShader}}
\doxysubsubsection{\texorpdfstring{MakeTwoPointConical()}{MakeTwoPointConical()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_shader}{Sk\+Shader}}$>$ Sk\+Gradient\+Shader\+::\+Make\+Two\+Point\+Conical (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&}]{start,  }\item[{Sk\+Scalar}]{start\+Radius,  }\item[{const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&}]{end,  }\item[{Sk\+Scalar}]{end\+Radius,  }\item[{const \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}}}]{colors\mbox{[}$\,$\mbox{]},  }\item[{const Sk\+Scalar}]{pos\mbox{[}$\,$\mbox{]},  }\item[{int}]{count,  }\item[{Sk\+Tile\+Mode}]{mode,  }\item[{uint32\+\_\+t}]{flags,  }\item[{const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$}]{local\+Matrix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns a shader that generates a conical gradient given two circles, or returns N\+U\+LL if the inputs are invalid. The gradient interprets the two circles according to the following H\+T\+ML spec. \href{http://dev.w3.org/html5/2dcontext/\#dom-context-2d-createradialgradient}{\texttt{ http\+://dev.\+w3.\+org/html5/2dcontext/\#dom-\/context-\/2d-\/createradialgradient}} \mbox{\Hypertarget{class_sk_gradient_shader_acde808cc9fa7842cf9f1a4cfea5e0b2c}\label{class_sk_gradient_shader_acde808cc9fa7842cf9f1a4cfea5e0b2c}} 
\index{SkGradientShader@{SkGradientShader}!MakeTwoPointConical@{MakeTwoPointConical}}
\index{MakeTwoPointConical@{MakeTwoPointConical}!SkGradientShader@{SkGradientShader}}
\doxysubsubsection{\texorpdfstring{MakeTwoPointConical()}{MakeTwoPointConical()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_shader}{Sk\+Shader}}$>$ Sk\+Gradient\+Shader\+::\+Make\+Two\+Point\+Conical (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&}]{start,  }\item[{Sk\+Scalar}]{start\+Radius,  }\item[{const \mbox{\hyperlink{struct_sk_point}{Sk\+Point}} \&}]{end,  }\item[{Sk\+Scalar}]{end\+Radius,  }\item[{const \mbox{\hyperlink{struct_sk_color4f}{Sk\+Color4f}}}]{colors\mbox{[}$\,$\mbox{]},  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} $>$}]{color\+Space,  }\item[{const Sk\+Scalar}]{pos\mbox{[}$\,$\mbox{]},  }\item[{int}]{count,  }\item[{Sk\+Tile\+Mode}]{mode,  }\item[{uint32\+\_\+t}]{flags,  }\item[{const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} $\ast$}]{local\+Matrix }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns a shader that generates a conical gradient given two circles, or returns N\+U\+LL if the inputs are invalid. The gradient interprets the two circles according to the following H\+T\+ML spec. \href{http://dev.w3.org/html5/2dcontext/\#dom-context-2d-createradialgradient}{\texttt{ http\+://dev.\+w3.\+org/html5/2dcontext/\#dom-\/context-\/2d-\/createradialgradient}} 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/include/effects/Sk\+Gradient\+Shader.\+h\end{DoxyCompactItemize}
