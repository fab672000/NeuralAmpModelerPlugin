\hypertarget{class_sk_r_tree}{}\doxysection{Sk\+R\+Tree Class Reference}
\label{class_sk_r_tree}\index{SkRTree@{SkRTree}}


{\ttfamily \#include $<$Sk\+R\+Tree.\+h$>$}

Inheritance diagram for Sk\+R\+Tree\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4.000000cm]{class_sk_r_tree}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{class_sk_r_tree_a19f939bb284c0b8c6be1f5bc9a9dbf1e}{insert}} (const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}}\mbox{[}$\,$\mbox{]}, int N) override
\item 
void \mbox{\hyperlink{class_sk_r_tree_aa072d082116927238a0486c705113b54}{search}} (const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&query, std\+::vector$<$ int $>$ $\ast$results) const override
\item 
size\+\_\+t \mbox{\hyperlink{class_sk_r_tree_ac0f15ca05d28166d8ddf8983b2e0fdfa}{bytes\+Used}} () const override
\item 
\mbox{\Hypertarget{class_sk_r_tree_a4d8084c43e1ba15ec627a9e2772bf35b}\label{class_sk_r_tree_a4d8084c43e1ba15ec627a9e2772bf35b}} 
int {\bfseries get\+Depth} () const
\item 
\mbox{\Hypertarget{class_sk_r_tree_aa1adfe25c50c3310ada2a1f639c6ea85}\label{class_sk_r_tree_aa1adfe25c50c3310ada2a1f639c6ea85}} 
int {\bfseries get\+Count} () const
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_r_tree_a41067d622a6acdc54c79a11977d53c55}\label{class_sk_r_tree_a41067d622a6acdc54c79a11977d53c55}} 
static const int {\bfseries k\+Min\+Children} = 6
\item 
\mbox{\Hypertarget{class_sk_r_tree_abe70d19eebb756f2fdcb253edf137f5e}\label{class_sk_r_tree_abe70d19eebb756f2fdcb253edf137f5e}} 
static const int {\bfseries k\+Max\+Children} = 11
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
An R-\/\+Tree implementation. In short, it is a balanced n-\/ary tree containing a hierarchy of bounding rectangles.

It only supports bulk-\/loading, i.\+e. creation from a batch of bounding rectangles. This performs a bottom-\/up bulk load using the S\+TR (sort-\/tile-\/recursive) algorithm.

T\+O\+DO\+: Experiment with other bulk-\/load algorithms (in particular the Hilbert pack variant, which groups rects by position on the Hilbert curve, is probably worth a look). There also exist top-\/down bulk load variants (V\+A\+M\+Split, Top\+Down\+Greedy, etc).

For more details see\+:

Beckmann, N.; Kriegel, \mbox{\hyperlink{struct_h}{H}}. P.; Schneider, R.; Seeger, B. (1990). \char`\"{}\+The R$\ast$-\/tree\+:
     an efficient and robust access method for points and rectangles\char`\"{} 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_r_tree_ac0f15ca05d28166d8ddf8983b2e0fdfa}\label{class_sk_r_tree_ac0f15ca05d28166d8ddf8983b2e0fdfa}} 
\index{SkRTree@{SkRTree}!bytesUsed@{bytesUsed}}
\index{bytesUsed@{bytesUsed}!SkRTree@{SkRTree}}
\doxysubsubsection{\texorpdfstring{bytesUsed()}{bytesUsed()}}
{\footnotesize\ttfamily size\+\_\+t Sk\+R\+Tree\+::bytes\+Used (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Return approximate size in memory of $\ast$this. 

Implements \mbox{\hyperlink{class_sk_b_box_hierarchy_a4cf37d432b019b2e78254c314625cbad}{Sk\+B\+Box\+Hierarchy}}.

\mbox{\Hypertarget{class_sk_r_tree_a19f939bb284c0b8c6be1f5bc9a9dbf1e}\label{class_sk_r_tree_a19f939bb284c0b8c6be1f5bc9a9dbf1e}} 
\index{SkRTree@{SkRTree}!insert@{insert}}
\index{insert@{insert}!SkRTree@{SkRTree}}
\doxysubsubsection{\texorpdfstring{insert()}{insert()}}
{\footnotesize\ttfamily void Sk\+R\+Tree\+::insert (\begin{DoxyParamCaption}\item[{const}]{Sk\+Rect\mbox{[}$\,$\mbox{]},  }\item[{int}]{N }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Insert N bounding boxes into the hierarchy. 

Implements \mbox{\hyperlink{class_sk_b_box_hierarchy_ab8e0e81e3736197f0dcb3babcf4831e0}{Sk\+B\+Box\+Hierarchy}}.

\mbox{\Hypertarget{class_sk_r_tree_aa072d082116927238a0486c705113b54}\label{class_sk_r_tree_aa072d082116927238a0486c705113b54}} 
\index{SkRTree@{SkRTree}!search@{search}}
\index{search@{search}!SkRTree@{SkRTree}}
\doxysubsubsection{\texorpdfstring{search()}{search()}}
{\footnotesize\ttfamily void Sk\+R\+Tree\+::search (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&}]{query,  }\item[{std\+::vector$<$ int $>$ $\ast$}]{results }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}

Populate results with the indices of bounding boxes intersecting that query. 

Implements \mbox{\hyperlink{class_sk_b_box_hierarchy_a8e399515d88f49d25e3c4529371a8167}{Sk\+B\+Box\+Hierarchy}}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+R\+Tree.\+h\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+R\+Tree.\+cpp\end{DoxyCompactItemize}
