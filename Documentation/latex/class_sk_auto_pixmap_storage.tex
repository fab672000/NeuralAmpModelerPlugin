\hypertarget{class_sk_auto_pixmap_storage}{}\doxysection{Sk\+Auto\+Pixmap\+Storage Class Reference}
\label{class_sk_auto_pixmap_storage}\index{SkAutoPixmapStorage@{SkAutoPixmapStorage}}
Inheritance diagram for Sk\+Auto\+Pixmap\+Storage\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_sk_auto_pixmap_storage}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_auto_pixmap_storage_a1e999f06c983c0558a7adc12436b37d7}\label{class_sk_auto_pixmap_storage_a1e999f06c983c0558a7adc12436b37d7}} 
{\bfseries Sk\+Auto\+Pixmap\+Storage} (\mbox{\hyperlink{class_sk_auto_pixmap_storage}{Sk\+Auto\+Pixmap\+Storage}} \&\&other)
\item 
\mbox{\hyperlink{class_sk_auto_pixmap_storage}{Sk\+Auto\+Pixmap\+Storage}} \& \mbox{\hyperlink{class_sk_auto_pixmap_storage_aab45ce946ff05234c92aecf55555f068}{operator=}} (\mbox{\hyperlink{class_sk_auto_pixmap_storage}{Sk\+Auto\+Pixmap\+Storage}} \&\&other)
\item 
bool \mbox{\hyperlink{class_sk_auto_pixmap_storage_a8a5c8de5a7a6aeddf74ddaaf29caba88}{try\+Alloc}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&)
\item 
void \mbox{\hyperlink{class_sk_auto_pixmap_storage_a921cda0db1ac366c9f42f976e94b4f85}{alloc}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&)
\item 
void $\ast$S\+K\+\_\+\+W\+A\+R\+N\+\_\+\+U\+N\+U\+S\+E\+D\+\_\+\+R\+E\+S\+U\+LT \mbox{\hyperlink{class_sk_auto_pixmap_storage_aca4fffdc740f201cb9d94913e7b1c94c}{detach\+Pixels}} ()
\item 
\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ S\+K\+\_\+\+W\+A\+R\+N\+\_\+\+U\+N\+U\+S\+E\+D\+\_\+\+R\+E\+S\+U\+LT \mbox{\hyperlink{class_sk_auto_pixmap_storage_ac5227240ea9bd26a38f0ac777cad3631}{detach\+Pixels\+As\+Data}} ()
\item 
\mbox{\Hypertarget{class_sk_auto_pixmap_storage_a87bbdebc855f9a9b87a3239fe2a9d327}\label{class_sk_auto_pixmap_storage_a87bbdebc855f9a9b87a3239fe2a9d327}} 
void {\bfseries reset} ()
\item 
\mbox{\Hypertarget{class_sk_auto_pixmap_storage_abbefc2deb628bb6de11374604f32aff6}\label{class_sk_auto_pixmap_storage_abbefc2deb628bb6de11374604f32aff6}} 
void {\bfseries reset} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&\mbox{\hyperlink{class_sk_pixmap_af416c5e3a8bfccee38fa2a149a2732f0}{info}}, const void $\ast$\mbox{\hyperlink{class_sk_pixmap_a500fccb095c04cda2804505500c710c2}{addr}}, size\+\_\+t rb)
\item 
\mbox{\Hypertarget{class_sk_auto_pixmap_storage_a9af471e89831e3307dc0c951182821e4}\label{class_sk_auto_pixmap_storage_a9af471e89831e3307dc0c951182821e4}} 
bool S\+K\+\_\+\+W\+A\+R\+N\+\_\+\+U\+N\+U\+S\+E\+D\+\_\+\+R\+E\+S\+U\+LT {\bfseries reset} (const \mbox{\hyperlink{struct_sk_mask}{Sk\+Mask}} \&mask)
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static size\+\_\+t \mbox{\hyperlink{class_sk_auto_pixmap_storage_a2365b96b4c3d9fd1f416736dc8569460}{Alloc\+Size}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&\mbox{\hyperlink{class_sk_pixmap_af416c5e3a8bfccee38fa2a149a2732f0}{info}}, size\+\_\+t $\ast$\mbox{\hyperlink{class_sk_pixmap_a473df7755ceeb87dab2c3ebfaa834c94}{row\+Bytes}})
\end{DoxyCompactItemize}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_auto_pixmap_storage_a921cda0db1ac366c9f42f976e94b4f85}\label{class_sk_auto_pixmap_storage_a921cda0db1ac366c9f42f976e94b4f85}} 
\index{SkAutoPixmapStorage@{SkAutoPixmapStorage}!alloc@{alloc}}
\index{alloc@{alloc}!SkAutoPixmapStorage@{SkAutoPixmapStorage}}
\doxysubsubsection{\texorpdfstring{alloc()}{alloc()}}
{\footnotesize\ttfamily void Sk\+Auto\+Pixmap\+Storage\+::alloc (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{info }\end{DoxyParamCaption})}

Allocate memory for the pixels needed to match the specified Info and fill out the pixmap to point to that memory. The storage will be freed when this object is destroyed, or if another call to \mbox{\hyperlink{class_sk_auto_pixmap_storage_a8a5c8de5a7a6aeddf74ddaaf29caba88}{try\+Alloc()}} or \mbox{\hyperlink{class_sk_auto_pixmap_storage_a921cda0db1ac366c9f42f976e94b4f85}{alloc()}} is made.

If the memory cannot be allocated, calls S\+K\+\_\+\+A\+B\+O\+R\+T(). \mbox{\Hypertarget{class_sk_auto_pixmap_storage_a2365b96b4c3d9fd1f416736dc8569460}\label{class_sk_auto_pixmap_storage_a2365b96b4c3d9fd1f416736dc8569460}} 
\index{SkAutoPixmapStorage@{SkAutoPixmapStorage}!AllocSize@{AllocSize}}
\index{AllocSize@{AllocSize}!SkAutoPixmapStorage@{SkAutoPixmapStorage}}
\doxysubsubsection{\texorpdfstring{AllocSize()}{AllocSize()}}
{\footnotesize\ttfamily size\+\_\+t Sk\+Auto\+Pixmap\+Storage\+::\+Alloc\+Size (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{info,  }\item[{size\+\_\+t $\ast$}]{row\+Bytes }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Gets the size and optionally the row\+Bytes that would be allocated by \mbox{\hyperlink{class_sk_auto_pixmap_storage}{Sk\+Auto\+Pixmap\+Storage}} if alloc/try\+Alloc was called. \mbox{\Hypertarget{class_sk_auto_pixmap_storage_aca4fffdc740f201cb9d94913e7b1c94c}\label{class_sk_auto_pixmap_storage_aca4fffdc740f201cb9d94913e7b1c94c}} 
\index{SkAutoPixmapStorage@{SkAutoPixmapStorage}!detachPixels@{detachPixels}}
\index{detachPixels@{detachPixels}!SkAutoPixmapStorage@{SkAutoPixmapStorage}}
\doxysubsubsection{\texorpdfstring{detachPixels()}{detachPixels()}}
{\footnotesize\ttfamily void $\ast$ Sk\+Auto\+Pixmap\+Storage\+::detach\+Pixels (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns a void$\ast$ of the allocated pixel memory and resets the pixmap. If the storage hasn\textquotesingle{}t been allocated, the result is N\+U\+LL. The caller is responsible for calling sk\+\_\+free to free the returned memory. \mbox{\Hypertarget{class_sk_auto_pixmap_storage_ac5227240ea9bd26a38f0ac777cad3631}\label{class_sk_auto_pixmap_storage_ac5227240ea9bd26a38f0ac777cad3631}} 
\index{SkAutoPixmapStorage@{SkAutoPixmapStorage}!detachPixelsAsData@{detachPixelsAsData}}
\index{detachPixelsAsData@{detachPixelsAsData}!SkAutoPixmapStorage@{SkAutoPixmapStorage}}
\doxysubsubsection{\texorpdfstring{detachPixelsAsData()}{detachPixelsAsData()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$ Sk\+Auto\+Pixmap\+Storage\+::detach\+Pixels\+As\+Data (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Returns an \mbox{\hyperlink{class_sk_data}{Sk\+Data}} object wrapping the allocated pixels memory, and resets the pixmap. If the storage hasn\textquotesingle{}t been allocated, the result is N\+U\+LL. \mbox{\Hypertarget{class_sk_auto_pixmap_storage_aab45ce946ff05234c92aecf55555f068}\label{class_sk_auto_pixmap_storage_aab45ce946ff05234c92aecf55555f068}} 
\index{SkAutoPixmapStorage@{SkAutoPixmapStorage}!operator=@{operator=}}
\index{operator=@{operator=}!SkAutoPixmapStorage@{SkAutoPixmapStorage}}
\doxysubsubsection{\texorpdfstring{operator=()}{operator=()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_sk_auto_pixmap_storage}{Sk\+Auto\+Pixmap\+Storage}} \& Sk\+Auto\+Pixmap\+Storage\+::operator= (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_auto_pixmap_storage}{Sk\+Auto\+Pixmap\+Storage}} \&\&}]{other }\end{DoxyParamCaption})}

Leave the moved-\/from object in a free-\/but-\/valid state. \mbox{\Hypertarget{class_sk_auto_pixmap_storage_a8a5c8de5a7a6aeddf74ddaaf29caba88}\label{class_sk_auto_pixmap_storage_a8a5c8de5a7a6aeddf74ddaaf29caba88}} 
\index{SkAutoPixmapStorage@{SkAutoPixmapStorage}!tryAlloc@{tryAlloc}}
\index{tryAlloc@{tryAlloc}!SkAutoPixmapStorage@{SkAutoPixmapStorage}}
\doxysubsubsection{\texorpdfstring{tryAlloc()}{tryAlloc()}}
{\footnotesize\ttfamily bool Sk\+Auto\+Pixmap\+Storage\+::try\+Alloc (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{info }\end{DoxyParamCaption})}

Try to allocate memory for the pixels needed to match the specified Info. On success return true and fill out the pixmap to point to that memory. The storage will be freed when this object is destroyed, or if another call to \mbox{\hyperlink{class_sk_auto_pixmap_storage_a8a5c8de5a7a6aeddf74ddaaf29caba88}{try\+Alloc()}} or \mbox{\hyperlink{class_sk_auto_pixmap_storage_a921cda0db1ac366c9f42f976e94b4f85}{alloc()}} is made.

On failure, return false and reset() the pixmap to empty. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Auto\+Pixmap\+Storage.\+h\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Auto\+Pixmap\+Storage.\+cpp\end{DoxyCompactItemize}
