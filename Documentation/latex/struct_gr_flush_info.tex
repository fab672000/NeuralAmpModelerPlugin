\hypertarget{struct_gr_flush_info}{}\doxysection{Gr\+Flush\+Info Struct Reference}
\label{struct_gr_flush_info}\index{GrFlushInfo@{GrFlushInfo}}


{\ttfamily \#include $<$Gr\+Types.\+h$>$}

\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{struct_gr_flush_info_afd807feeb1fbb263a4843f2a9b281ef9}\label{struct_gr_flush_info_afd807feeb1fbb263a4843f2a9b281ef9}} 
size\+\_\+t {\bfseries f\+Num\+Semaphores} = 0
\item 
\mbox{\Hypertarget{struct_gr_flush_info_a4bdb32c561ea66b2e956d2156f23512a}\label{struct_gr_flush_info_a4bdb32c561ea66b2e956d2156f23512a}} 
\mbox{\hyperlink{class_gr_backend_semaphore}{Gr\+Backend\+Semaphore}} $\ast$ {\bfseries f\+Signal\+Semaphores} = nullptr
\item 
\mbox{\Hypertarget{struct_gr_flush_info_a62d96e8baa51a60984318f2240473e83}\label{struct_gr_flush_info_a62d96e8baa51a60984318f2240473e83}} 
Gr\+Gpu\+Finished\+Proc {\bfseries f\+Finished\+Proc} = nullptr
\item 
\mbox{\Hypertarget{struct_gr_flush_info_a05c61801f59d895755a9898d7aae6dc2}\label{struct_gr_flush_info_a05c61801f59d895755a9898d7aae6dc2}} 
Gr\+Gpu\+Finished\+Context {\bfseries f\+Finished\+Context} = nullptr
\item 
\mbox{\Hypertarget{struct_gr_flush_info_af25695ba11cfd11e1e454eb4b961070f}\label{struct_gr_flush_info_af25695ba11cfd11e1e454eb4b961070f}} 
Gr\+Gpu\+Submitted\+Proc {\bfseries f\+Submitted\+Proc} = nullptr
\item 
\mbox{\Hypertarget{struct_gr_flush_info_adb6a906646c20a26608f272ac1289939}\label{struct_gr_flush_info_adb6a906646c20a26608f272ac1289939}} 
Gr\+Gpu\+Submitted\+Context {\bfseries f\+Submitted\+Context} = nullptr
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Struct to supply options to flush calls.

After issuing all commands, f\+Num\+Semaphore semaphores will be signaled by the gpu. The client passes in an array of f\+Num\+Semaphores Gr\+Backend\+Semaphores. In general these \mbox{\hyperlink{class_gr_backend_semaphore}{Gr\+Backend\+Semaphore}}\textquotesingle{}s can be either initialized or not. If they are initialized, the backend uses the passed in semaphore. If it is not initialized, a new semaphore is created and the \mbox{\hyperlink{class_gr_backend_semaphore}{Gr\+Backend\+Semaphore}} object is initialized with that semaphore. The semaphores are not sent to the G\+PU until the next Gr\+Context\+::submit call is made. See the Gr\+Context\+::submit for more information.

The client will own and be responsible for deleting the underlying semaphores that are stored and returned in initialized \mbox{\hyperlink{class_gr_backend_semaphore}{Gr\+Backend\+Semaphore}} objects. The \mbox{\hyperlink{class_gr_backend_semaphore}{Gr\+Backend\+Semaphore}} objects themselves can be deleted as soon as this function returns.

If a finished\+Proc is provided, the finished\+Proc will be called when all work submitted to the gpu from this flush call and all previous flush calls has finished on the G\+PU. If the flush call fails due to an error and nothing ends up getting sent to the G\+PU, the finished proc is called immediately.

If a submitted\+Proc is provided, the submitted\+Proc will be called when all work from this flush call is submitted to the G\+PU. If the flush call fails due to an error and nothing will get sent to the G\+PU, the submitted proc is called immediately. It is possibly that when work is finally submitted, that the submission actual fails. In this case we will not reattempt to do the submission. Skia notifies the client of these via the success bool passed into the submitted\+Proc. The submitted\+Proc is useful to the client to know when semaphores that were sent with the flush have actually been submitted to the G\+PU so that they can be waited on (or deleted if the submit fails). Note about GL\+: In GL work gets sent to the driver immediately during the flush call, but we don\textquotesingle{}t really know when the driver sends the work to the G\+PU. Therefore, we treat the submitted proc as we do in other backends. It will be called when the next Gr\+Context\+::submit is called after the flush (or possibly during the flush if there is no work to be done for the flush). The main use case for the submitted\+Proc is to know when semaphores have been sent to the G\+PU and even in GL it is required to call Gr\+Context\+::submit to flush them. So a client should be able to treat all backend A\+P\+Is the same in terms of how the submitted procs are treated. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/include/gpu/Gr\+Types.\+h\end{DoxyCompactItemize}
