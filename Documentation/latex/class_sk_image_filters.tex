\hypertarget{class_sk_image_filters}{}\doxysection{Sk\+Image\+Filters Class Reference}
\label{class_sk_image_filters}\index{SkImageFilters@{SkImageFilters}}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_image_filters_a44cb5e20955e61030ccc042abae30de8}\label{class_sk_image_filters_a44cb5e20955e61030ccc042abae30de8}} 
enum {\bfseries Dither} \+: bool \{ {\bfseries k\+No} = false, 
{\bfseries k\+Yes} = true
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_a943ef471a6895761e79d9be7df710412}{Alpha\+Threshold}} (const \mbox{\hyperlink{class_sk_region}{Sk\+Region}} \&region, Sk\+Scalar inner\+Min, Sk\+Scalar outer\+Max, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_ad73542d3bcee219815b3181c29d563d1}{Arithmetic}} (Sk\+Scalar k1, Sk\+Scalar k2, Sk\+Scalar k3, Sk\+Scalar k4, bool enforce\+P\+M\+Color, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ background, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ foreground, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_a7f91ba472b60c44804dda1ce8a9875d4}{Blend}} (Sk\+Blend\+Mode mode, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ background, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ foreground=nullptr, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_adba7e5fd26cceaccc0bd682a30d09f18}{Blend}} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_blender}{Sk\+Blender}} $>$ blender, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ background, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ foreground=nullptr, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_a9cbc8ef4bef80adda33622b229136f90}{Blur}} (Sk\+Scalar sigmaX, Sk\+Scalar sigmaY, Sk\+Tile\+Mode tile\+Mode, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
\mbox{\Hypertarget{class_sk_image_filters_a813eacb07b0f11c467df80f100b40126}\label{class_sk_image_filters_a813eacb07b0f11c467df80f100b40126}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ {\bfseries Blur} (Sk\+Scalar sigmaX, Sk\+Scalar sigmaY, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_ab662534b2d8336904460db1ec9133284}{Color\+Filter}} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_filter}{Sk\+Color\+Filter}} $>$ cf, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_afec5b0474ddfdcbbae20d4c65d1630ff}{Compose}} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ outer, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ inner)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_aa83bc85ebe76f2f6904a51907e63f876}{Displacement\+Map}} (\mbox{\hyperlink{_sk_color_8h_aac1e9297f6f6a4155b8539d878da3543}{Sk\+Color\+Channel}} x\+Channel\+Selector, \mbox{\hyperlink{_sk_color_8h_aac1e9297f6f6a4155b8539d878da3543}{Sk\+Color\+Channel}} y\+Channel\+Selector, Sk\+Scalar scale, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ displacement, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ color, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_ae119af896156ba44d448d5c7fc933c2b}{Drop\+Shadow}} (Sk\+Scalar dx, Sk\+Scalar dy, Sk\+Scalar sigmaX, Sk\+Scalar sigmaY, \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} color, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_a91354167ad35b6a0d95b6f1fc23f3aea}{Drop\+Shadow\+Only}} (Sk\+Scalar dx, Sk\+Scalar dy, Sk\+Scalar sigmaX, Sk\+Scalar sigmaY, \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} color, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_aac4f43618455f7096e57f688678ab7a7}{Image}} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image}{Sk\+Image}} $>$ image, const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&src\+Rect, const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&dst\+Rect, const \mbox{\hyperlink{struct_sk_sampling_options}{Sk\+Sampling\+Options}} \&sampling)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_ae7fb62d980b9a958abbdea2fabe424e7}{Image}} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image}{Sk\+Image}} $>$ image, const \mbox{\hyperlink{struct_sk_sampling_options}{Sk\+Sampling\+Options}} \&sampling)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_a0f0e4d6e0c76a639f68b75d27ced4419}{Image}} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image}{Sk\+Image}} $>$ image)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_aed91574898cfcbd9e87c3a32103f6faa}{Magnifier}} (const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&src\+Rect, Sk\+Scalar inset, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_ab8990e9d03d1831b1bf0caacc4324177}{Matrix\+Convolution}} (const \mbox{\hyperlink{struct_sk_i_size}{Sk\+I\+Size}} \&kernel\+Size, const Sk\+Scalar kernel\mbox{[}$\,$\mbox{]}, Sk\+Scalar gain, Sk\+Scalar bias, const \mbox{\hyperlink{struct_sk_i_point}{Sk\+I\+Point}} \&kernel\+Offset, Sk\+Tile\+Mode tile\+Mode, bool convolve\+Alpha, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_a8ba7298d90ed5356ce146a02b84738f8}{Matrix\+Transform}} (const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} \&matrix, const \mbox{\hyperlink{struct_sk_sampling_options}{Sk\+Sampling\+Options}} \&sampling, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_a4bcbafd4c35b3e6f1a7ea63f26ba775a}{Merge}} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ $\ast$const filters, int count, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_ad6e7fe3ab6d988a59190ce85caca559d}{Merge}} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ first, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ second, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_af05d6bbf03d075536b8c47978d70e7e4}{Offset}} (Sk\+Scalar dx, Sk\+Scalar dy, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_a2a603d468389439747fa4364c2bf2cae}{Paint}} (const \mbox{\hyperlink{class_sk_paint}{Sk\+Paint}} \&paint, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_acabdd7a3e8a734ca7d4ff582c482f676}{Picture}} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_picture}{Sk\+Picture}} $>$ pic, const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&target\+Rect)
\item 
\mbox{\Hypertarget{class_sk_image_filters_a596fdd0090b936b530c74a168187f12c}\label{class_sk_image_filters_a596fdd0090b936b530c74a168187f12c}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ {\bfseries Picture} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_picture}{Sk\+Picture}} $>$ pic)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_a4e8b289018517291027adaaf6985bd64}{Shader}} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ shader, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
\mbox{\Hypertarget{class_sk_image_filters_ab8f7cb266ae9cdfb42476ca2cfdda692}\label{class_sk_image_filters_ab8f7cb266ae9cdfb42476ca2cfdda692}} 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ {\bfseries Shader} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$ shader, Dither dither, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_aad7faeda56f1beb913936d67cce31d1e}{Tile}} (const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&src, const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&dst, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input)
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_ad70f6c6451fdbe864e09fd416c54eb5b}{Dilate}} (Sk\+Scalar radiusX, Sk\+Scalar radiusY, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_aad25852530a8db9cc0ff7d04f61d0a51}{Erode}} (Sk\+Scalar radiusX, Sk\+Scalar radiusY, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_ae661455a358d5fe69e53dcd00f8b8228}{Distant\+Lit\+Diffuse}} (const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&direction, \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} light\+Color, Sk\+Scalar surface\+Scale, Sk\+Scalar kd, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_a1b5ef34e18865862e8305b1c0fd97647}{Point\+Lit\+Diffuse}} (const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&location, \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} light\+Color, Sk\+Scalar surface\+Scale, Sk\+Scalar kd, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_a4a89ed2ec342feab4a15838f500c9cc4}{Spot\+Lit\+Diffuse}} (const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&location, const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&target, Sk\+Scalar falloff\+Exponent, Sk\+Scalar cutoff\+Angle, \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} light\+Color, Sk\+Scalar surface\+Scale, Sk\+Scalar kd, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_afc753f67075af0bd451133e2627dcb20}{Distant\+Lit\+Specular}} (const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&direction, \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} light\+Color, Sk\+Scalar surface\+Scale, Sk\+Scalar ks, Sk\+Scalar shininess, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_af08d376dfc635d272393487dace89b2a}{Point\+Lit\+Specular}} (const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&location, \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} light\+Color, Sk\+Scalar surface\+Scale, Sk\+Scalar ks, Sk\+Scalar shininess, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\item 
static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ \mbox{\hyperlink{class_sk_image_filters_ab835ffa20ce7a1a62882597d39cf0239}{Spot\+Lit\+Specular}} (const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&location, const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&target, Sk\+Scalar falloff\+Exponent, Sk\+Scalar cutoff\+Angle, \mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}} light\+Color, Sk\+Scalar surface\+Scale, Sk\+Scalar ks, Sk\+Scalar shininess, \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ input, const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&crop\+Rect=\{\})
\end{DoxyCompactItemize}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_image_filters_a943ef471a6895761e79d9be7df710412}\label{class_sk_image_filters_a943ef471a6895761e79d9be7df710412}} 
\index{SkImageFilters@{SkImageFilters}!AlphaThreshold@{AlphaThreshold}}
\index{AlphaThreshold@{AlphaThreshold}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{AlphaThreshold()}{AlphaThreshold()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Alpha\+Threshold (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_region}{Sk\+Region}} \&}]{region,  }\item[{Sk\+Scalar}]{inner\+Min,  }\item[{Sk\+Scalar}]{outer\+Max,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that updates the alpha of the image based on \textquotesingle{}region\textquotesingle{}. Pixels inside the region are made more opaque and pixels outside are made more transparent.

Specifically, if a pixel is inside the region, its alpha will be set to max(inner\+Min, pixel\textquotesingle{}s alpha). If a pixel is outside the region, its alpha will be updated to min(outer\+Max, pixel\textquotesingle{}s alpha). 
\begin{DoxyParams}{Parameters}
{\em region} & The geometric region controlling the inner and outer alpha thresholds. \\
\hline
{\em inner\+Min} & The minimum alpha value for pixels inside \textquotesingle{}region\textquotesingle{}. \\
\hline
{\em outer\+Max} & The maximum alpha value for pixels outside of \textquotesingle{}region\textquotesingle{}. \\
\hline
{\em input} & The input filter, or uses the source bitmap if this is null. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_ad73542d3bcee219815b3181c29d563d1}\label{class_sk_image_filters_ad73542d3bcee219815b3181c29d563d1}} 
\index{SkImageFilters@{SkImageFilters}!Arithmetic@{Arithmetic}}
\index{Arithmetic@{Arithmetic}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Arithmetic()}{Arithmetic()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Arithmetic (\begin{DoxyParamCaption}\item[{Sk\+Scalar}]{k1,  }\item[{Sk\+Scalar}]{k2,  }\item[{Sk\+Scalar}]{k3,  }\item[{Sk\+Scalar}]{k4,  }\item[{bool}]{enforce\+P\+M\+Color,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{background,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{foreground,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that implements a custom blend mode. Each output pixel is the result of combining the corresponding background and foreground pixels using the 4 coefficients\+: k1 $\ast$ foreground $\ast$ background + k2 $\ast$ foreground + k3 $\ast$ background + k4 
\begin{DoxyParams}{Parameters}
{\em k1,k2,k3,k4} & The four coefficients used to combine the foreground and background. \\
\hline
{\em enforce\+P\+M\+Color} & If true, the R\+GB channels will be clamped to the calculated alpha. \\
\hline
{\em background} & The background content, using the source bitmap when this is null. \\
\hline
{\em foreground} & The foreground content, using the source bitmap when this is null. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the inputs and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_adba7e5fd26cceaccc0bd682a30d09f18}\label{class_sk_image_filters_adba7e5fd26cceaccc0bd682a30d09f18}} 
\index{SkImageFilters@{SkImageFilters}!Blend@{Blend}}
\index{Blend@{Blend}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Blend()}{Blend()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Blend (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_blender}{Sk\+Blender}} $>$}]{blender,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{background,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{foreground = {\ttfamily nullptr},  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This filter takes an Sk\+Blend\+Mode and uses it to composite the two filters together. 
\begin{DoxyParams}{Parameters}
{\em blender} & The blender that defines the compositing operation \\
\hline
{\em background} & The Dst pixels used in blending, if null the source bitmap is used. \\
\hline
{\em foreground} & The Src pixels used in blending, if null the source bitmap is used. @crop\+Rect Optional rectangle to crop input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_a7f91ba472b60c44804dda1ce8a9875d4}\label{class_sk_image_filters_a7f91ba472b60c44804dda1ce8a9875d4}} 
\index{SkImageFilters@{SkImageFilters}!Blend@{Blend}}
\index{Blend@{Blend}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Blend()}{Blend()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Blend (\begin{DoxyParamCaption}\item[{Sk\+Blend\+Mode}]{mode,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{background,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{foreground = {\ttfamily nullptr},  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This filter takes an Sk\+Blend\+Mode and uses it to composite the two filters together. 
\begin{DoxyParams}{Parameters}
{\em mode} & The blend mode that defines the compositing operation \\
\hline
{\em background} & The Dst pixels used in blending, if null the source bitmap is used. \\
\hline
{\em foreground} & The Src pixels used in blending, if null the source bitmap is used. @crop\+Rect Optional rectangle to crop input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_a9cbc8ef4bef80adda33622b229136f90}\label{class_sk_image_filters_a9cbc8ef4bef80adda33622b229136f90}} 
\index{SkImageFilters@{SkImageFilters}!Blur@{Blur}}
\index{Blur@{Blur}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Blur()}{Blur()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Blur (\begin{DoxyParamCaption}\item[{Sk\+Scalar}]{sigmaX,  }\item[{Sk\+Scalar}]{sigmaY,  }\item[{Sk\+Tile\+Mode}]{tile\+Mode,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that blurs its input by the separate X and Y sigmas. The provided tile mode is used when the blur kernel goes outside the input image. 
\begin{DoxyParams}{Parameters}
{\em sigmaX} & The Gaussian sigma value for blurring along the X axis. \\
\hline
{\em sigmaY} & The Gaussian sigma value for blurring along the Y axis. \\
\hline
{\em tile\+Mode} & The tile mode applied at edges . T\+O\+DO (michaelludwig) -\/ k\+Mirror is not supported yet \\
\hline
{\em input} & The input filter that is blurred, uses source bitmap if this is null. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_ab662534b2d8336904460db1ec9133284}\label{class_sk_image_filters_ab662534b2d8336904460db1ec9133284}} 
\index{SkImageFilters@{SkImageFilters}!ColorFilter@{ColorFilter}}
\index{ColorFilter@{ColorFilter}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{ColorFilter()}{ColorFilter()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Color\+Filter (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_color_filter}{Sk\+Color\+Filter}} $>$}]{cf,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that applies the color filter to the input filter results. 
\begin{DoxyParams}{Parameters}
{\em cf} & The color filter that transforms the input image. \\
\hline
{\em input} & The input filter, or uses the source bitmap if this is null. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_afec5b0474ddfdcbbae20d4c65d1630ff}\label{class_sk_image_filters_afec5b0474ddfdcbbae20d4c65d1630ff}} 
\index{SkImageFilters@{SkImageFilters}!Compose@{Compose}}
\index{Compose@{Compose}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Compose()}{Compose()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Compose (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{outer,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{inner }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that composes \textquotesingle{}inner\textquotesingle{} with \textquotesingle{}outer\textquotesingle{}, such that the results of \textquotesingle{}inner\textquotesingle{} are treated as the source bitmap passed to \textquotesingle{}outer\textquotesingle{}, i.\+e. result = outer(inner(source)). 
\begin{DoxyParams}{Parameters}
{\em outer} & The outer filter that evaluates the results of inner. \\
\hline
{\em inner} & The inner filter that produces the input to outer. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_ad70f6c6451fdbe864e09fd416c54eb5b}\label{class_sk_image_filters_ad70f6c6451fdbe864e09fd416c54eb5b}} 
\index{SkImageFilters@{SkImageFilters}!Dilate@{Dilate}}
\index{Dilate@{Dilate}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Dilate()}{Dilate()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Dilate (\begin{DoxyParamCaption}\item[{Sk\+Scalar}]{radiusX,  }\item[{Sk\+Scalar}]{radiusY,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that dilates each input pixel\textquotesingle{}s channel values to the max value within the given radii along the x and y axes. 
\begin{DoxyParams}{Parameters}
{\em radiusX} & The distance to dilate along the x axis to either side of each pixel. \\
\hline
{\em radiusY} & The distance to dilate along the y axis to either side of each pixel. \\
\hline
{\em input} & The image filter that is dilated, using source bitmap if this is null. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_aa83bc85ebe76f2f6904a51907e63f876}\label{class_sk_image_filters_aa83bc85ebe76f2f6904a51907e63f876}} 
\index{SkImageFilters@{SkImageFilters}!DisplacementMap@{DisplacementMap}}
\index{DisplacementMap@{DisplacementMap}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{DisplacementMap()}{DisplacementMap()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Displacement\+Map (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{_sk_color_8h_aac1e9297f6f6a4155b8539d878da3543}{Sk\+Color\+Channel}}}]{x\+Channel\+Selector,  }\item[{\mbox{\hyperlink{_sk_color_8h_aac1e9297f6f6a4155b8539d878da3543}{Sk\+Color\+Channel}}}]{y\+Channel\+Selector,  }\item[{Sk\+Scalar}]{scale,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{displacement,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{color,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that moves each pixel in its color input based on an (x,y) vector encoded in its displacement input filter. Two color components of the displacement image are mapped into a vector as scale $\ast$ (color\mbox{[}x\+Channel\mbox{]}, color\mbox{[}y\+Channel\mbox{]}), where the channel selectors are one of R, \mbox{\hyperlink{struct_g}{G}}, B, or A. 
\begin{DoxyParams}{Parameters}
{\em x\+Channel\+Selector} & R\+G\+BA channel that encodes the x displacement per pixel. \\
\hline
{\em y\+Channel\+Selector} & R\+G\+BA channel that encodes the y displacement per pixel. \\
\hline
{\em scale} & Scale applied to displacement extracted from image. \\
\hline
{\em displacement} & The filter defining the displacement image, or null to use source. \\
\hline
{\em color} & The filter providing the color pixels to be displaced. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the color input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_ae661455a358d5fe69e53dcd00f8b8228}\label{class_sk_image_filters_ae661455a358d5fe69e53dcd00f8b8228}} 
\index{SkImageFilters@{SkImageFilters}!DistantLitDiffuse@{DistantLitDiffuse}}
\index{DistantLitDiffuse@{DistantLitDiffuse}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{DistantLitDiffuse()}{DistantLitDiffuse()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Distant\+Lit\+Diffuse (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&}]{direction,  }\item[{\mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}}}]{light\+Color,  }\item[{Sk\+Scalar}]{surface\+Scale,  }\item[{Sk\+Scalar}]{kd,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that calculates the diffuse illumination from a distant light source, interpreting the alpha channel of the input as the height profile of the surface (to approximate normal vectors). 
\begin{DoxyParams}{Parameters}
{\em direction} & The direction to the distance light. \\
\hline
{\em light\+Color} & The color of the diffuse light source. \\
\hline
{\em surface\+Scale} & Scale factor to transform from alpha values to physical height. \\
\hline
{\em kd} & Diffuse reflectance coefficient. \\
\hline
{\em input} & The input filter that defines surface normals (as alpha), or uses the source bitmap when null. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_afc753f67075af0bd451133e2627dcb20}\label{class_sk_image_filters_afc753f67075af0bd451133e2627dcb20}} 
\index{SkImageFilters@{SkImageFilters}!DistantLitSpecular@{DistantLitSpecular}}
\index{DistantLitSpecular@{DistantLitSpecular}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{DistantLitSpecular()}{DistantLitSpecular()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Distant\+Lit\+Specular (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&}]{direction,  }\item[{\mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}}}]{light\+Color,  }\item[{Sk\+Scalar}]{surface\+Scale,  }\item[{Sk\+Scalar}]{ks,  }\item[{Sk\+Scalar}]{shininess,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that calculates the specular illumination from a distant light source, interpreting the alpha channel of the input as the height profile of the surface (to approximate normal vectors). 
\begin{DoxyParams}{Parameters}
{\em direction} & The direction to the distance light. \\
\hline
{\em light\+Color} & The color of the specular light source. \\
\hline
{\em surface\+Scale} & Scale factor to transform from alpha values to physical height. \\
\hline
{\em ks} & Specular reflectance coefficient. \\
\hline
{\em shininess} & The specular exponent determining how shiny the surface is. \\
\hline
{\em input} & The input filter that defines surface normals (as alpha), or uses the source bitmap when null. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_ae119af896156ba44d448d5c7fc933c2b}\label{class_sk_image_filters_ae119af896156ba44d448d5c7fc933c2b}} 
\index{SkImageFilters@{SkImageFilters}!DropShadow@{DropShadow}}
\index{DropShadow@{DropShadow}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{DropShadow()}{DropShadow()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Drop\+Shadow (\begin{DoxyParamCaption}\item[{Sk\+Scalar}]{dx,  }\item[{Sk\+Scalar}]{dy,  }\item[{Sk\+Scalar}]{sigmaX,  }\item[{Sk\+Scalar}]{sigmaY,  }\item[{\mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}}}]{color,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that draws a drop shadow under the input content. This filter produces an image that includes the inputs\textquotesingle{} content. 
\begin{DoxyParams}{Parameters}
{\em dx} & The X offset of the shadow. \\
\hline
{\em dy} & The Y offset of the shadow. \\
\hline
{\em sigmaX} & The blur radius for the shadow, along the X axis. \\
\hline
{\em sigmaY} & The blur radius for the shadow, along the Y axis. \\
\hline
{\em color} & The color of the drop shadow. \\
\hline
{\em input} & The input filter, or will use the source bitmap if this is null. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_a91354167ad35b6a0d95b6f1fc23f3aea}\label{class_sk_image_filters_a91354167ad35b6a0d95b6f1fc23f3aea}} 
\index{SkImageFilters@{SkImageFilters}!DropShadowOnly@{DropShadowOnly}}
\index{DropShadowOnly@{DropShadowOnly}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{DropShadowOnly()}{DropShadowOnly()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Drop\+Shadow\+Only (\begin{DoxyParamCaption}\item[{Sk\+Scalar}]{dx,  }\item[{Sk\+Scalar}]{dy,  }\item[{Sk\+Scalar}]{sigmaX,  }\item[{Sk\+Scalar}]{sigmaY,  }\item[{\mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}}}]{color,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that renders a drop shadow, in exactly the same manner as \+::\+Drop\+Shadow, except that the resulting image does not include the input content. This allows the shadow and input to be composed by a filter D\+AG in a more flexible manner. 
\begin{DoxyParams}{Parameters}
{\em dx} & The X offset of the shadow. \\
\hline
{\em dy} & The Y offset of the shadow. \\
\hline
{\em sigmaX} & The blur radius for the shadow, along the X axis. \\
\hline
{\em sigmaY} & The blur radius for the shadow, along the Y axis. \\
\hline
{\em color} & The color of the drop shadow. \\
\hline
{\em input} & The input filter, or will use the source bitmap if this is null. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_aad25852530a8db9cc0ff7d04f61d0a51}\label{class_sk_image_filters_aad25852530a8db9cc0ff7d04f61d0a51}} 
\index{SkImageFilters@{SkImageFilters}!Erode@{Erode}}
\index{Erode@{Erode}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Erode()}{Erode()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Erode (\begin{DoxyParamCaption}\item[{Sk\+Scalar}]{radiusX,  }\item[{Sk\+Scalar}]{radiusY,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that erodes each input pixel\textquotesingle{}s channel values to the minimum channel value within the given radii along the x and y axes. 
\begin{DoxyParams}{Parameters}
{\em radiusX} & The distance to erode along the x axis to either side of each pixel. \\
\hline
{\em radiusY} & The distance to erode along the y axis to either side of each pixel. \\
\hline
{\em input} & The image filter that is eroded, using source bitmap if this is null. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_a0f0e4d6e0c76a639f68b75d27ced4419}\label{class_sk_image_filters_a0f0e4d6e0c76a639f68b75d27ced4419}} 
\index{SkImageFilters@{SkImageFilters}!Image@{Image}}
\index{Image@{Image}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Image()}{Image()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Image (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image}{Sk\+Image}} $>$}]{image }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Create a filter that draws the image using Mitchel cubic resampling. 
\begin{DoxyParams}{Parameters}
{\em image} & The image that is output by the filter. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_aac4f43618455f7096e57f688678ab7a7}\label{class_sk_image_filters_aac4f43618455f7096e57f688678ab7a7}} 
\index{SkImageFilters@{SkImageFilters}!Image@{Image}}
\index{Image@{Image}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Image()}{Image()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Image (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image}{Sk\+Image}} $>$}]{image,  }\item[{const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&}]{src\+Rect,  }\item[{const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&}]{dst\+Rect,  }\item[{const \mbox{\hyperlink{struct_sk_sampling_options}{Sk\+Sampling\+Options}} \&}]{sampling }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that draws the \textquotesingle{}src\+Rect\textquotesingle{} portion of image into \textquotesingle{}dst\+Rect\textquotesingle{} using the given filter quality. Similar to Sk\+Canvas\+::draw\+Image\+Rect. Returns null if \textquotesingle{}image\textquotesingle{} is null. 
\begin{DoxyParams}{Parameters}
{\em image} & The image that is output by the filter, subset by \textquotesingle{}src\+Rect\textquotesingle{}. \\
\hline
{\em src\+Rect} & The source pixels sampled into \textquotesingle{}dst\+Rect\textquotesingle{} \\
\hline
{\em dst\+Rect} & The local rectangle to draw the image into. \\
\hline
{\em sampling} & The sampling to use when drawing the image. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_ae7fb62d980b9a958abbdea2fabe424e7}\label{class_sk_image_filters_ae7fb62d980b9a958abbdea2fabe424e7}} 
\index{SkImageFilters@{SkImageFilters}!Image@{Image}}
\index{Image@{Image}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Image()}{Image()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Image (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image}{Sk\+Image}} $>$}]{image,  }\item[{const \mbox{\hyperlink{struct_sk_sampling_options}{Sk\+Sampling\+Options}} \&}]{sampling }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Create a filter that draws the image using the given sampling. Similar to Sk\+Canvas\+::draw\+Image. Returns null if \textquotesingle{}image\textquotesingle{} is null. 
\begin{DoxyParams}{Parameters}
{\em image} & The image that is output by the filter. \\
\hline
{\em sampling} & The sampling to use when drawing the image. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_aed91574898cfcbd9e87c3a32103f6faa}\label{class_sk_image_filters_aed91574898cfcbd9e87c3a32103f6faa}} 
\index{SkImageFilters@{SkImageFilters}!Magnifier@{Magnifier}}
\index{Magnifier@{Magnifier}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Magnifier()}{Magnifier()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Magnifier (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&}]{src\+Rect,  }\item[{Sk\+Scalar}]{inset,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that mimics a zoom/magnifying lens effect. 
\begin{DoxyParams}{Parameters}
{\em src\+Rect} & \\
\hline
{\em inset} & \\
\hline
{\em input} & The input filter that is magnified, if null the source bitmap is used. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_ab8990e9d03d1831b1bf0caacc4324177}\label{class_sk_image_filters_ab8990e9d03d1831b1bf0caacc4324177}} 
\index{SkImageFilters@{SkImageFilters}!MatrixConvolution@{MatrixConvolution}}
\index{MatrixConvolution@{MatrixConvolution}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{MatrixConvolution()}{MatrixConvolution()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Matrix\+Convolution (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_i_size}{Sk\+I\+Size}} \&}]{kernel\+Size,  }\item[{const Sk\+Scalar}]{kernel\mbox{[}$\,$\mbox{]},  }\item[{Sk\+Scalar}]{gain,  }\item[{Sk\+Scalar}]{bias,  }\item[{const \mbox{\hyperlink{struct_sk_i_point}{Sk\+I\+Point}} \&}]{kernel\+Offset,  }\item[{Sk\+Tile\+Mode}]{tile\+Mode,  }\item[{bool}]{convolve\+Alpha,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that applies an NxM image processing kernel to the input image. This can be used to produce effects such as sharpening, blurring, edge detection, etc. 
\begin{DoxyParams}{Parameters}
{\em kernel\+Size} & The kernel size in pixels, in each dimension (N by M). \\
\hline
{\em kernel} & The image processing kernel. Must contain N $\ast$ M elements, in row order. \\
\hline
{\em gain} & A scale factor applied to each pixel after convolution. This can be used to normalize the kernel, if it does not already sum to 1. \\
\hline
{\em bias} & A bias factor added to each pixel after convolution. \\
\hline
{\em kernel\+Offset} & An offset applied to each pixel coordinate before convolution. This can be used to center the kernel over the image (e.\+g., a 3x3 kernel should have an offset of \{1, 1\}). \\
\hline
{\em tile\+Mode} & How accesses outside the image are treated. T\+O\+DO (michaelludwig) -\/ k\+Mirror is not supported yet \\
\hline
{\em convolve\+Alpha} & If true, all channels are convolved. If false, only the R\+GB channels are convolved, and alpha is copied from the source image. \\
\hline
{\em input} & The input image filter, if null the source bitmap is used instead. \\
\hline
{\em crop\+Rect} & Optional rectangle to which the output processing will be limited. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_a8ba7298d90ed5356ce146a02b84738f8}\label{class_sk_image_filters_a8ba7298d90ed5356ce146a02b84738f8}} 
\index{SkImageFilters@{SkImageFilters}!MatrixTransform@{MatrixTransform}}
\index{MatrixTransform@{MatrixTransform}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{MatrixTransform()}{MatrixTransform()}}
{\footnotesize\ttfamily \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ Sk\+Image\+Filters\+::\+Matrix\+Transform (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} \&}]{matrix,  }\item[{const \mbox{\hyperlink{struct_sk_sampling_options}{Sk\+Sampling\+Options}} \&}]{sampling,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that transforms the input image by \textquotesingle{}matrix\textquotesingle{}. This matrix transforms the local space, which means it effectively happens prior to any transformation coming from the \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} initiating the filtering. 
\begin{DoxyParams}{Parameters}
{\em matrix} & The matrix to apply to the original content. \\
\hline
{\em sampling} & How the image will be sampled when it is transformed \\
\hline
{\em input} & The image filter to transform, or null to use the source image. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_a4bcbafd4c35b3e6f1a7ea63f26ba775a}\label{class_sk_image_filters_a4bcbafd4c35b3e6f1a7ea63f26ba775a}} 
\index{SkImageFilters@{SkImageFilters}!Merge@{Merge}}
\index{Merge@{Merge}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Merge()}{Merge()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Merge (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$ $\ast$const}]{filters,  }\item[{int}]{count,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that merges the \textquotesingle{}count\textquotesingle{} filters together by drawing their results in order with src-\/over blending. 
\begin{DoxyParams}{Parameters}
{\em filters} & The input filter array to merge, which must have \textquotesingle{}count\textquotesingle{} elements. Any null filter pointers will use the source bitmap instead. \\
\hline
{\em count} & The number of input filters to be merged. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops all input filters and the output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_ad6e7fe3ab6d988a59190ce85caca559d}\label{class_sk_image_filters_ad6e7fe3ab6d988a59190ce85caca559d}} 
\index{SkImageFilters@{SkImageFilters}!Merge@{Merge}}
\index{Merge@{Merge}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Merge()}{Merge()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Merge (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{first,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{second,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Create a filter that merges the results of the two filters together with src-\/over blending. 
\begin{DoxyParams}{Parameters}
{\em first} & The first input filter, or the source bitmap if this is null. \\
\hline
{\em second} & The second input filter, or the source bitmap if this null. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the inputs and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_af05d6bbf03d075536b8c47978d70e7e4}\label{class_sk_image_filters_af05d6bbf03d075536b8c47978d70e7e4}} 
\index{SkImageFilters@{SkImageFilters}!Offset@{Offset}}
\index{Offset@{Offset}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Offset()}{Offset()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Offset (\begin{DoxyParamCaption}\item[{Sk\+Scalar}]{dx,  }\item[{Sk\+Scalar}]{dy,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that offsets the input filter by the given vector. 
\begin{DoxyParams}{Parameters}
{\em dx} & The x offset in local space that the image is shifted. \\
\hline
{\em dy} & The y offset in local space that the image is shifted. \\
\hline
{\em input} & The input that will be moved, if null the source bitmap is used instead. \\
\hline
{\em crop\+Rect} & Optional rectangle to crop the input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_a2a603d468389439747fa4364c2bf2cae}\label{class_sk_image_filters_a2a603d468389439747fa4364c2bf2cae}} 
\index{SkImageFilters@{SkImageFilters}!Paint@{Paint}}
\index{Paint@{Paint}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Paint()}{Paint()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Paint (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_paint}{Sk\+Paint}} \&}]{paint,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that fills the output with the given paint. 
\begin{DoxyParams}{Parameters}
{\em paint} & The paint to fill \\
\hline
{\em crop\+Rect} & Optional rectangle that will be filled. If null, the source bitmap\textquotesingle{}s bounds are filled even though the source bitmap itself is not used.\\
\hline
\end{DoxyParams}
D\+E\+P\+R\+E\+C\+A\+T\+ED\+: Use \mbox{\hyperlink{class_sk_image_filters_a4e8b289018517291027adaaf6985bd64}{Shader()}} instead, since many features of \mbox{\hyperlink{class_sk_paint}{Sk\+Paint}} are ignored when filling the target output, and paint color/alpha can be emulated with Sk\+Shaders\+::\+Color(). \mbox{\Hypertarget{class_sk_image_filters_acabdd7a3e8a734ca7d4ff582c482f676}\label{class_sk_image_filters_acabdd7a3e8a734ca7d4ff582c482f676}} 
\index{SkImageFilters@{SkImageFilters}!Picture@{Picture}}
\index{Picture@{Picture}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Picture()}{Picture()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Picture (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_picture}{Sk\+Picture}} $>$}]{pic,  }\item[{const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&}]{target\+Rect }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that produces the \mbox{\hyperlink{class_sk_picture}{Sk\+Picture}} as its output, drawn into target\+Rect. Note that the target\+Rect is not the same as the \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} crop\+Rect that many filters accept. Returns null if \textquotesingle{}pic\textquotesingle{} is null. 
\begin{DoxyParams}{Parameters}
{\em pic} & The picture that is drawn for the filter output. \\
\hline
{\em target\+Rect} & The drawing region for the picture. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_a1b5ef34e18865862e8305b1c0fd97647}\label{class_sk_image_filters_a1b5ef34e18865862e8305b1c0fd97647}} 
\index{SkImageFilters@{SkImageFilters}!PointLitDiffuse@{PointLitDiffuse}}
\index{PointLitDiffuse@{PointLitDiffuse}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{PointLitDiffuse()}{PointLitDiffuse()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Point\+Lit\+Diffuse (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&}]{location,  }\item[{\mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}}}]{light\+Color,  }\item[{Sk\+Scalar}]{surface\+Scale,  }\item[{Sk\+Scalar}]{kd,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that calculates the diffuse illumination from a point light source, using alpha channel of the input as the height profile of the surface (to approximate normal vectors). 
\begin{DoxyParams}{Parameters}
{\em location} & The location of the point light. \\
\hline
{\em light\+Color} & The color of the diffuse light source. \\
\hline
{\em surface\+Scale} & Scale factor to transform from alpha values to physical height. \\
\hline
{\em kd} & Diffuse reflectance coefficient. \\
\hline
{\em input} & The input filter that defines surface normals (as alpha), or uses the source bitmap when null. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_af08d376dfc635d272393487dace89b2a}\label{class_sk_image_filters_af08d376dfc635d272393487dace89b2a}} 
\index{SkImageFilters@{SkImageFilters}!PointLitSpecular@{PointLitSpecular}}
\index{PointLitSpecular@{PointLitSpecular}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{PointLitSpecular()}{PointLitSpecular()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Point\+Lit\+Specular (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&}]{location,  }\item[{\mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}}}]{light\+Color,  }\item[{Sk\+Scalar}]{surface\+Scale,  }\item[{Sk\+Scalar}]{ks,  }\item[{Sk\+Scalar}]{shininess,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that calculates the specular illumination from a point light source, using alpha channel of the input as the height profile of the surface (to approximate normal vectors). 
\begin{DoxyParams}{Parameters}
{\em location} & The location of the point light. \\
\hline
{\em light\+Color} & The color of the specular light source. \\
\hline
{\em surface\+Scale} & Scale factor to transform from alpha values to physical height. \\
\hline
{\em ks} & Specular reflectance coefficient. \\
\hline
{\em shininess} & The specular exponent determining how shiny the surface is. \\
\hline
{\em input} & The input filter that defines surface normals (as alpha), or uses the source bitmap when null. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_a4e8b289018517291027adaaf6985bd64}\label{class_sk_image_filters_a4e8b289018517291027adaaf6985bd64}} 
\index{SkImageFilters@{SkImageFilters}!Shader@{Shader}}
\index{Shader@{Shader}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Shader()}{Shader()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Shader (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}} $>$}]{shader,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}

Create a filter that fills the output with the per-\/pixel evaluation of the \mbox{\hyperlink{class_sk_shader}{Sk\+Shader}}. The shader is defined in the image filter\textquotesingle{}s local coordinate system, so will automatically be affected by \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}}\textquotesingle{} transform.

Like \mbox{\hyperlink{class_sk_image_filters_aac4f43618455f7096e57f688678ab7a7}{Image()}} and \mbox{\hyperlink{class_sk_image_filters_acabdd7a3e8a734ca7d4ff582c482f676}{Picture()}}, this is a leaf filter that can be used to introduce inputs to a complex filter graph, but should generally be combined with a filter that as at least one null input to use the implicit source image. 
\begin{DoxyParams}{Parameters}
{\em shader} & The shader that fills the result image \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_a4a89ed2ec342feab4a15838f500c9cc4}\label{class_sk_image_filters_a4a89ed2ec342feab4a15838f500c9cc4}} 
\index{SkImageFilters@{SkImageFilters}!SpotLitDiffuse@{SpotLitDiffuse}}
\index{SpotLitDiffuse@{SpotLitDiffuse}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{SpotLitDiffuse()}{SpotLitDiffuse()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Spot\+Lit\+Diffuse (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&}]{location,  }\item[{const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&}]{target,  }\item[{Sk\+Scalar}]{falloff\+Exponent,  }\item[{Sk\+Scalar}]{cutoff\+Angle,  }\item[{\mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}}}]{light\+Color,  }\item[{Sk\+Scalar}]{surface\+Scale,  }\item[{Sk\+Scalar}]{kd,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that calculates the diffuse illumination from a spot light source, using alpha channel of the input as the height profile of the surface (to approximate normal vectors). The spot light is restricted to be within \textquotesingle{}cutoff\+Angle\textquotesingle{} of the vector between the location and target. 
\begin{DoxyParams}{Parameters}
{\em location} & The location of the spot light. \\
\hline
{\em target} & The location that the spot light is point towards \\
\hline
{\em falloff\+Exponent} & Exponential falloff parameter for illumination outside of cutoff\+Angle \\
\hline
{\em cutoff\+Angle} & Maximum angle from lighting direction that receives full light \\
\hline
{\em light\+Color} & The color of the diffuse light source. \\
\hline
{\em surface\+Scale} & Scale factor to transform from alpha values to physical height. \\
\hline
{\em kd} & Diffuse reflectance coefficient. \\
\hline
{\em input} & The input filter that defines surface normals (as alpha), or uses the source bitmap when null. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_ab835ffa20ce7a1a62882597d39cf0239}\label{class_sk_image_filters_ab835ffa20ce7a1a62882597d39cf0239}} 
\index{SkImageFilters@{SkImageFilters}!SpotLitSpecular@{SpotLitSpecular}}
\index{SpotLitSpecular@{SpotLitSpecular}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{SpotLitSpecular()}{SpotLitSpecular()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Spot\+Lit\+Specular (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&}]{location,  }\item[{const \mbox{\hyperlink{struct_sk_point3}{Sk\+Point3}} \&}]{target,  }\item[{Sk\+Scalar}]{falloff\+Exponent,  }\item[{Sk\+Scalar}]{cutoff\+Angle,  }\item[{\mbox{\hyperlink{_sk_color_8h_a84c81e6a24ff07a55333acf5603046a8}{Sk\+Color}}}]{light\+Color,  }\item[{Sk\+Scalar}]{surface\+Scale,  }\item[{Sk\+Scalar}]{ks,  }\item[{Sk\+Scalar}]{shininess,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input,  }\item[{const \mbox{\hyperlink{struct_sk_image_filters_1_1_crop_rect}{Crop\+Rect}} \&}]{crop\+Rect = {\ttfamily \{\}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a filter that calculates the specular illumination from a spot light source, using alpha channel of the input as the height profile of the surface (to approximate normal vectors). The spot light is restricted to be within \textquotesingle{}cutoff\+Angle\textquotesingle{} of the vector between the location and target. 
\begin{DoxyParams}{Parameters}
{\em location} & The location of the spot light. \\
\hline
{\em target} & The location that the spot light is point towards \\
\hline
{\em falloff\+Exponent} & Exponential falloff parameter for illumination outside of cutoff\+Angle \\
\hline
{\em cutoff\+Angle} & Maximum angle from lighting direction that receives full light \\
\hline
{\em light\+Color} & The color of the specular light source. \\
\hline
{\em surface\+Scale} & Scale factor to transform from alpha values to physical height. \\
\hline
{\em ks} & Specular reflectance coefficient. \\
\hline
{\em shininess} & The specular exponent determining how shiny the surface is. \\
\hline
{\em input} & The input filter that defines surface normals (as alpha), or uses the source bitmap when null. \\
\hline
{\em crop\+Rect} & Optional rectangle that crops the input and output. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_image_filters_aad7faeda56f1beb913936d67cce31d1e}\label{class_sk_image_filters_aad7faeda56f1beb913936d67cce31d1e}} 
\index{SkImageFilters@{SkImageFilters}!Tile@{Tile}}
\index{Tile@{Tile}!SkImageFilters@{SkImageFilters}}
\doxysubsubsection{\texorpdfstring{Tile()}{Tile()}}
{\footnotesize\ttfamily static \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}}$>$ Sk\+Image\+Filters\+::\+Tile (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&}]{src,  }\item[{const \mbox{\hyperlink{struct_sk_rect}{Sk\+Rect}} \&}]{dst,  }\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image_filter}{Sk\+Image\+Filter}} $>$}]{input }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Create a tile image filter. 
\begin{DoxyParams}{Parameters}
{\em src} & Defines the pixels to tile \\
\hline
{\em dst} & Defines the pixel region that the tiles will be drawn to \\
\hline
{\em input} & The input that will be tiled, if null the source bitmap is used instead. \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/include/effects/Sk\+Image\+Filters.\+h\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Matrix\+Image\+Filter.\+cpp\end{DoxyCompactItemize}
