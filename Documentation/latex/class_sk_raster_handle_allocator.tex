\hypertarget{class_sk_raster_handle_allocator}{}\doxysection{Sk\+Raster\+Handle\+Allocator Class Reference}
\label{class_sk_raster_handle_allocator}\index{SkRasterHandleAllocator@{SkRasterHandleAllocator}}


{\ttfamily \#include $<$Sk\+Raster\+Handle\+Allocator.\+h$>$}

\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_sk_raster_handle_allocator_1_1_rec}{Rec}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_raster_handle_allocator_acb5f7ae91b3c5a73f551c4f3d2cb8954}\label{class_sk_raster_handle_allocator_acb5f7ae91b3c5a73f551c4f3d2cb8954}} 
typedef void $\ast$ {\bfseries Handle}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual bool \mbox{\hyperlink{class_sk_raster_handle_allocator_acb18b1c8234940f73a87d861e76cf4eb}{alloc\+Handle}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&, \mbox{\hyperlink{struct_sk_raster_handle_allocator_1_1_rec}{Rec}} $\ast$)=0
\item 
virtual void \mbox{\hyperlink{class_sk_raster_handle_allocator_ab24128403de1078bd08b2c99e2e7e5ac}{update\+Handle}} (Handle, const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} \&, const \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} \&)=0
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} $>$ \mbox{\hyperlink{class_sk_raster_handle_allocator_ad5a06e782d7e4731b506f93ba360fefa}{Make\+Canvas}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{class_sk_raster_handle_allocator}{Sk\+Raster\+Handle\+Allocator}} $>$, const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&, const \mbox{\hyperlink{struct_sk_raster_handle_allocator_1_1_rec}{Rec}} $\ast$rec=nullptr)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_raster_handle_allocator_ad50b9766478d3eecdb337378ee1c7663}\label{class_sk_raster_handle_allocator_ad50b9766478d3eecdb337378ee1c7663}} 
{\bfseries Sk\+Raster\+Handle\+Allocator} (const \mbox{\hyperlink{class_sk_raster_handle_allocator}{Sk\+Raster\+Handle\+Allocator}} \&)=delete
\item 
\mbox{\Hypertarget{class_sk_raster_handle_allocator_a43369bd38a92e82d2d37e775c81829b9}\label{class_sk_raster_handle_allocator_a43369bd38a92e82d2d37e775c81829b9}} 
\mbox{\hyperlink{class_sk_raster_handle_allocator}{Sk\+Raster\+Handle\+Allocator}} \& {\bfseries operator=} (const \mbox{\hyperlink{class_sk_raster_handle_allocator}{Sk\+Raster\+Handle\+Allocator}} \&)=delete
\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_raster_handle_allocator_a79ae9c1567d8ef7993bd306831fdf0b5}\label{class_sk_raster_handle_allocator_a79ae9c1567d8ef7993bd306831fdf0b5}} 
class {\bfseries Sk\+Bitmap\+Device}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
If a client wants to control the allocation of raster layers in a canvas, it should subclass \mbox{\hyperlink{class_sk_raster_handle_allocator}{Sk\+Raster\+Handle\+Allocator}}. This allocator performs two tasks\+:
\begin{DoxyEnumerate}
\item controls how the memory for the pixels is allocated
\item associates a \char`\"{}handle\char`\"{} to a private object that can track the matrix/clip of the \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}}
\end{DoxyEnumerate}

This example allocates a canvas, and defers to the allocator to create the base layer. \begin{DoxyVerb}std::unique_ptr<SkCanvas> canvas = SkRasterHandleAllocator::MakeCanvas(
        SkImageInfo::Make(...),
        std::make_unique<MySubclassRasterHandleAllocator>(...),
        nullptr);
\end{DoxyVerb}


If you have already allocated the base layer (and its handle, release-\/proc etc.) then you can pass those in using the last parameter to \mbox{\hyperlink{class_sk_raster_handle_allocator_ad5a06e782d7e4731b506f93ba360fefa}{Make\+Canvas()}}.

Regardless of how the base layer is allocated, each time canvas-\/$>$save\+Layer() is called, your allocator\textquotesingle{}s \mbox{\hyperlink{class_sk_raster_handle_allocator_acb18b1c8234940f73a87d861e76cf4eb}{alloc\+Handle()}} will be called. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_raster_handle_allocator_acb18b1c8234940f73a87d861e76cf4eb}\label{class_sk_raster_handle_allocator_acb18b1c8234940f73a87d861e76cf4eb}} 
\index{SkRasterHandleAllocator@{SkRasterHandleAllocator}!allocHandle@{allocHandle}}
\index{allocHandle@{allocHandle}!SkRasterHandleAllocator@{SkRasterHandleAllocator}}
\doxysubsubsection{\texorpdfstring{allocHandle()}{allocHandle()}}
{\footnotesize\ttfamily virtual bool Sk\+Raster\+Handle\+Allocator\+::alloc\+Handle (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{,  }\item[{\mbox{\hyperlink{struct_sk_raster_handle_allocator_1_1_rec}{Rec}} $\ast$}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Given a requested info, allocate the corresponding pixels/rowbytes, and whatever handle is desired to give clients access to those pixels. The rec also contains a proc and context which will be called when this allocation goes out of scope.

e.\+g. when canvas-\/$>$save\+Layer() is called, the allocator will be called to allocate the pixels for the layer. When canvas-\/$>$restore() is called, the f\+Release\+Proc will be called. \mbox{\Hypertarget{class_sk_raster_handle_allocator_ad5a06e782d7e4731b506f93ba360fefa}\label{class_sk_raster_handle_allocator_ad5a06e782d7e4731b506f93ba360fefa}} 
\index{SkRasterHandleAllocator@{SkRasterHandleAllocator}!MakeCanvas@{MakeCanvas}}
\index{MakeCanvas@{MakeCanvas}!SkRasterHandleAllocator@{SkRasterHandleAllocator}}
\doxysubsubsection{\texorpdfstring{MakeCanvas()}{MakeCanvas()}}
{\footnotesize\ttfamily std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{class_sk_canvas}{Sk\+Canvas}} $>$ Sk\+Raster\+Handle\+Allocator\+::\+Make\+Canvas (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{class_sk_raster_handle_allocator}{Sk\+Raster\+Handle\+Allocator}} $>$}]{alloc,  }\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{info,  }\item[{const \mbox{\hyperlink{struct_sk_raster_handle_allocator_1_1_rec}{Rec}} $\ast$}]{rec = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

This creates a canvas which will use the allocator to manage pixel allocations, including all calls to save\+Layer().

If rec is non-\/null, then it will be used as the base-\/layer of pixels/handle. If rec is null, then the allocator will be called for the base-\/layer as well. \mbox{\Hypertarget{class_sk_raster_handle_allocator_ab24128403de1078bd08b2c99e2e7e5ac}\label{class_sk_raster_handle_allocator_ab24128403de1078bd08b2c99e2e7e5ac}} 
\index{SkRasterHandleAllocator@{SkRasterHandleAllocator}!updateHandle@{updateHandle}}
\index{updateHandle@{updateHandle}!SkRasterHandleAllocator@{SkRasterHandleAllocator}}
\doxysubsubsection{\texorpdfstring{updateHandle()}{updateHandle()}}
{\footnotesize\ttfamily virtual void Sk\+Raster\+Handle\+Allocator\+::update\+Handle (\begin{DoxyParamCaption}\item[{Handle}]{,  }\item[{const \mbox{\hyperlink{class_sk_matrix}{Sk\+Matrix}} \&}]{,  }\item[{const \mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}

Clients access the handle for a given layer by calling \mbox{\hyperlink{class_sk_canvas_a12a09e49fc7bb86c7b30c1c56433e286}{Sk\+Canvas\+::access\+Top\+Raster\+Handle()}}. To allow the handle to reflect the current matrix/clip in the canvs, \mbox{\hyperlink{class_sk_raster_handle_allocator_ab24128403de1078bd08b2c99e2e7e5ac}{update\+Handle()}} is is called. The subclass is responsible to update the handle as it sees fit. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/include/core/Sk\+Raster\+Handle\+Allocator.\+h\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Canvas.\+cpp\end{DoxyCompactItemize}
