\hypertarget{struct_sk_mask}{}\doxysection{Sk\+Mask Class Reference}
\label{struct_sk_mask}\index{SkMask@{SkMask}}


{\ttfamily \#include $<$Sk\+Mask.\+h$>$}

\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_sk_mask_1_1_alpha_iter}{Alpha\+Iter}}
\item 
struct \mbox{\hyperlink{struct_sk_mask_1_1_alpha_iter_3_01_sk_mask_1_1k_a8___format_01_4}{Alpha\+Iter$<$ Sk\+Mask\+::k\+A8\+\_\+\+Format $>$}}
\item 
struct \mbox{\hyperlink{struct_sk_mask_1_1_alpha_iter_3_01_sk_mask_1_1k_a_r_g_b32___format_01_4}{Alpha\+Iter$<$ Sk\+Mask\+::k\+A\+R\+G\+B32\+\_\+\+Format $>$}}
\item 
struct \mbox{\hyperlink{struct_sk_mask_1_1_alpha_iter_3_01_sk_mask_1_1k_b_w___format_01_4}{Alpha\+Iter$<$ Sk\+Mask\+::k\+B\+W\+\_\+\+Format $>$}}
\item 
struct \mbox{\hyperlink{struct_sk_mask_1_1_alpha_iter_3_01_sk_mask_1_1k_l_c_d16___format_01_4}{Alpha\+Iter$<$ Sk\+Mask\+::k\+L\+C\+D16\+\_\+\+Format $>$}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6e}{Format}} \+: uint8\+\_\+t \{ \newline
\mbox{\hyperlink{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6eae4418aac30fe79e67375504bbc4f0574}{k\+B\+W\+\_\+\+Format}}, 
\mbox{\hyperlink{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6ea6afc497620a34b81a48c99f29623ab5f}{k\+A8\+\_\+\+Format}}, 
\mbox{\hyperlink{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6ea126aa3184ccfbae44a070b897289eb1a}{k3\+D\+\_\+\+Format}}, 
\mbox{\hyperlink{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6eaa85393e4f477755c8df51fbee6f5d75f}{k\+A\+R\+G\+B32\+\_\+\+Format}}, 
\newline
\mbox{\hyperlink{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6ea932fab8d1d4f0d0e0b3c6d4b8e61ec7c}{k\+L\+C\+D16\+\_\+\+Format}}, 
\mbox{\hyperlink{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6eace1993ff2ec27f80053c966a1d022c7e}{k\+S\+D\+F\+\_\+\+Format}}
 \}
\item 
\mbox{\Hypertarget{struct_sk_mask_a84b2bce48c32f464d976f330c61cd764}\label{struct_sk_mask_a84b2bce48c32f464d976f330c61cd764}} 
enum \{ {\bfseries k\+Count\+Mask\+Formats} = k\+S\+D\+F\+\_\+\+Format + 1
 \}
\item 
\mbox{\Hypertarget{struct_sk_mask_ad5e619797a499d857c608632b1a9f03a}\label{struct_sk_mask_ad5e619797a499d857c608632b1a9f03a}} 
enum {\bfseries Alloc\+Type} \{ {\bfseries k\+Uninit\+\_\+\+Alloc}, 
{\bfseries k\+Zero\+Init\+\_\+\+Alloc}
 \}
\item 
enum \mbox{\hyperlink{struct_sk_mask_abb010896d9c88b1582222e50674f431e}{Create\+Mode}} \{ \mbox{\hyperlink{struct_sk_mask_abb010896d9c88b1582222e50674f431eaeac3bbeff02e3d4189bdc11d3b6dd21b}{k\+Just\+Compute\+Bounds\+\_\+\+Create\+Mode}}, 
\mbox{\hyperlink{struct_sk_mask_abb010896d9c88b1582222e50674f431eabeca649f3ea7180c9c87ffbad3a9804b}{k\+Just\+Render\+Image\+\_\+\+Create\+Mode}}, 
\mbox{\hyperlink{struct_sk_mask_abb010896d9c88b1582222e50674f431eafbc8dc9198e2daabc6171510109925cd}{k\+Compute\+Bounds\+And\+Render\+Image\+\_\+\+Create\+Mode}}
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{struct_sk_mask_a620469e14c3b5e849afeb7b1417ab793}{is\+Empty}} () const
\item 
size\+\_\+t \mbox{\hyperlink{struct_sk_mask_ad35ce72d6888558f68f5ff2cd47a2bc7}{compute\+Image\+Size}} () const
\item 
size\+\_\+t \mbox{\hyperlink{struct_sk_mask_a7e1377d3d2eea3c1f3abc5d2b8970c17}{compute\+Total\+Image\+Size}} () const
\item 
uint8\+\_\+t $\ast$ \mbox{\hyperlink{struct_sk_mask_ae29b5e7a839802edfb6f61ae6c94d980}{get\+Addr1}} (int x, int y) const
\item 
uint8\+\_\+t $\ast$ \mbox{\hyperlink{struct_sk_mask_a6d122d13864e3bc36e1cdbfda055303f}{get\+Addr8}} (int x, int y) const
\item 
uint16\+\_\+t $\ast$ \mbox{\hyperlink{struct_sk_mask_a24d7a324c8c6c09d21166c1722ac0d25}{get\+Addr\+L\+C\+D16}} (int x, int y) const
\item 
uint32\+\_\+t $\ast$ \mbox{\hyperlink{struct_sk_mask_acd625aa83f5bc885e29f3777078d2bbf}{get\+Addr32}} (int x, int y) const
\item 
void $\ast$ \mbox{\hyperlink{struct_sk_mask_adbb452a4091b4f1b103316afe115182a}{get\+Addr}} (int x, int y) const
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{struct_sk_mask_a5d6e4952cd1363d413a16060f889f7fc}\label{struct_sk_mask_a5d6e4952cd1363d413a16060f889f7fc}} 
static bool {\bfseries Is\+Valid\+Format} (uint8\+\_\+t format)
\item 
static uint8\+\_\+t $\ast$ \mbox{\hyperlink{struct_sk_mask_abb9475657f4af82909a59c37697ab758}{Alloc\+Image}} (size\+\_\+t bytes, Alloc\+Type=k\+Uninit\+\_\+\+Alloc)
\item 
static void \mbox{\hyperlink{struct_sk_mask_a7ecc23a4a9227e1dc6f69b0a84b45e1d}{Free\+Image}} (void $\ast$image)
\item 
static \mbox{\hyperlink{struct_sk_mask}{Sk\+Mask}} \mbox{\hyperlink{struct_sk_mask_a292a36b01bd17b3519299583a55b2354}{Prepare\+Destination}} (int radiusX, int radiusY, const \mbox{\hyperlink{struct_sk_mask}{Sk\+Mask}} \&src)
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{struct_sk_mask_a4545f4c41bd6ac96a50296a50fa5de60}\label{struct_sk_mask_a4545f4c41bd6ac96a50296a50fa5de60}} 
uint8\+\_\+t $\ast$ {\bfseries f\+Image}
\item 
\mbox{\Hypertarget{struct_sk_mask_a99d3c12766a328024af8b8f93365ce54}\label{struct_sk_mask_a99d3c12766a328024af8b8f93365ce54}} 
\mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} {\bfseries f\+Bounds}
\item 
\mbox{\Hypertarget{struct_sk_mask_a3c93e4df76645a7296e545223ca2ab20}\label{struct_sk_mask_a3c93e4df76645a7296e545223ca2ab20}} 
uint32\+\_\+t {\bfseries f\+Row\+Bytes}
\item 
\mbox{\Hypertarget{struct_sk_mask_a7eae01ef86483a508e700861039d1d55}\label{struct_sk_mask_a7eae01ef86483a508e700861039d1d55}} 
\mbox{\hyperlink{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6e}{Format}} {\bfseries f\+Format}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\mbox{\hyperlink{struct_sk_mask}{Sk\+Mask}} is used to describe alpha bitmaps, either 1bit, 8bit, or the 3-\/channel 3D format. These are passed to \mbox{\hyperlink{class_sk_mask_filter}{Sk\+Mask\+Filter}} objects. 

\doxysubsection{Member Enumeration Documentation}
\mbox{\Hypertarget{struct_sk_mask_abb010896d9c88b1582222e50674f431e}\label{struct_sk_mask_abb010896d9c88b1582222e50674f431e}} 
\index{SkMask@{SkMask}!CreateMode@{CreateMode}}
\index{CreateMode@{CreateMode}!SkMask@{SkMask}}
\doxysubsubsection{\texorpdfstring{CreateMode}{CreateMode}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{struct_sk_mask_abb010896d9c88b1582222e50674f431e}{Sk\+Mask\+::\+Create\+Mode}}}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kJustComputeBounds\_CreateMode@{kJustComputeBounds\_CreateMode}!SkMask@{SkMask}}\index{SkMask@{SkMask}!kJustComputeBounds\_CreateMode@{kJustComputeBounds\_CreateMode}}}\mbox{\Hypertarget{struct_sk_mask_abb010896d9c88b1582222e50674f431eaeac3bbeff02e3d4189bdc11d3b6dd21b}\label{struct_sk_mask_abb010896d9c88b1582222e50674f431eaeac3bbeff02e3d4189bdc11d3b6dd21b}} 
k\+Just\+Compute\+Bounds\+\_\+\+Create\+Mode&compute bounds and return \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kJustRenderImage\_CreateMode@{kJustRenderImage\_CreateMode}!SkMask@{SkMask}}\index{SkMask@{SkMask}!kJustRenderImage\_CreateMode@{kJustRenderImage\_CreateMode}}}\mbox{\Hypertarget{struct_sk_mask_abb010896d9c88b1582222e50674f431eabeca649f3ea7180c9c87ffbad3a9804b}\label{struct_sk_mask_abb010896d9c88b1582222e50674f431eabeca649f3ea7180c9c87ffbad3a9804b}} 
k\+Just\+Render\+Image\+\_\+\+Create\+Mode&render into preallocate mask \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kComputeBoundsAndRenderImage\_CreateMode@{kComputeBoundsAndRenderImage\_CreateMode}!SkMask@{SkMask}}\index{SkMask@{SkMask}!kComputeBoundsAndRenderImage\_CreateMode@{kComputeBoundsAndRenderImage\_CreateMode}}}\mbox{\Hypertarget{struct_sk_mask_abb010896d9c88b1582222e50674f431eafbc8dc9198e2daabc6171510109925cd}\label{struct_sk_mask_abb010896d9c88b1582222e50674f431eafbc8dc9198e2daabc6171510109925cd}} 
k\+Compute\+Bounds\+And\+Render\+Image\+\_\+\+Create\+Mode&compute bounds, alloc image and render into it \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6e}\label{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6e}} 
\index{SkMask@{SkMask}!Format@{Format}}
\index{Format@{Format}!SkMask@{SkMask}}
\doxysubsubsection{\texorpdfstring{Format}{Format}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6e}{Sk\+Mask\+::\+Format}} \+: uint8\+\_\+t}

\begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kBW\_Format@{kBW\_Format}!SkMask@{SkMask}}\index{SkMask@{SkMask}!kBW\_Format@{kBW\_Format}}}\mbox{\Hypertarget{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6eae4418aac30fe79e67375504bbc4f0574}\label{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6eae4418aac30fe79e67375504bbc4f0574}} 
k\+B\+W\+\_\+\+Format&1bit per pixel mask (e.\+g. monochrome) \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kA8\_Format@{kA8\_Format}!SkMask@{SkMask}}\index{SkMask@{SkMask}!kA8\_Format@{kA8\_Format}}}\mbox{\Hypertarget{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6ea6afc497620a34b81a48c99f29623ab5f}\label{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6ea6afc497620a34b81a48c99f29623ab5f}} 
k\+A8\+\_\+\+Format&8bits per pixel mask (e.\+g. antialiasing) \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{k3D\_Format@{k3D\_Format}!SkMask@{SkMask}}\index{SkMask@{SkMask}!k3D\_Format@{k3D\_Format}}}\mbox{\Hypertarget{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6ea126aa3184ccfbae44a070b897289eb1a}\label{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6ea126aa3184ccfbae44a070b897289eb1a}} 
k3\+D\+\_\+\+Format&3 8bit per pixl planes\+: alpha, mul, add \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kARGB32\_Format@{kARGB32\_Format}!SkMask@{SkMask}}\index{SkMask@{SkMask}!kARGB32\_Format@{kARGB32\_Format}}}\mbox{\Hypertarget{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6eaa85393e4f477755c8df51fbee6f5d75f}\label{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6eaa85393e4f477755c8df51fbee6f5d75f}} 
k\+A\+R\+G\+B32\+\_\+\+Format&Sk\+P\+M\+Color. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kLCD16\_Format@{kLCD16\_Format}!SkMask@{SkMask}}\index{SkMask@{SkMask}!kLCD16\_Format@{kLCD16\_Format}}}\mbox{\Hypertarget{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6ea932fab8d1d4f0d0e0b3c6d4b8e61ec7c}\label{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6ea932fab8d1d4f0d0e0b3c6d4b8e61ec7c}} 
k\+L\+C\+D16\+\_\+\+Format&565 alpha for r/g/b \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kSDF\_Format@{kSDF\_Format}!SkMask@{SkMask}}\index{SkMask@{SkMask}!kSDF\_Format@{kSDF\_Format}}}\mbox{\Hypertarget{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6eace1993ff2ec27f80053c966a1d022c7e}\label{struct_sk_mask_a1fe832dd1564b241b1a9c96dfec3ab6eace1993ff2ec27f80053c966a1d022c7e}} 
k\+S\+D\+F\+\_\+\+Format&8bits representing signed distance field \\
\hline

\end{DoxyEnumFields}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{struct_sk_mask_abb9475657f4af82909a59c37697ab758}\label{struct_sk_mask_abb9475657f4af82909a59c37697ab758}} 
\index{SkMask@{SkMask}!AllocImage@{AllocImage}}
\index{AllocImage@{AllocImage}!SkMask@{SkMask}}
\doxysubsubsection{\texorpdfstring{AllocImage()}{AllocImage()}}
{\footnotesize\ttfamily uint8\+\_\+t $\ast$ Sk\+Mask\+::\+Alloc\+Image (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size,  }\item[{Alloc\+Type}]{at = {\ttfamily kUninit\+\_\+Alloc} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

We explicitly use this allocator for Sk\+Bimap pixels, so that we can freely assign memory allocated by one class to the other. \mbox{\Hypertarget{struct_sk_mask_ad35ce72d6888558f68f5ff2cd47a2bc7}\label{struct_sk_mask_ad35ce72d6888558f68f5ff2cd47a2bc7}} 
\index{SkMask@{SkMask}!computeImageSize@{computeImageSize}}
\index{computeImageSize@{computeImageSize}!SkMask@{SkMask}}
\doxysubsubsection{\texorpdfstring{computeImageSize()}{computeImageSize()}}
{\footnotesize\ttfamily size\+\_\+t Sk\+Mask\+::compute\+Image\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Return the byte size of the mask, assuming only 1 plane. Does not account for k3\+D\+\_\+\+Format. For that, use \mbox{\hyperlink{struct_sk_mask_a7e1377d3d2eea3c1f3abc5d2b8970c17}{compute\+Total\+Image\+Size()}}. If there is an overflow of 32bits, then returns 0. \mbox{\Hypertarget{struct_sk_mask_a7e1377d3d2eea3c1f3abc5d2b8970c17}\label{struct_sk_mask_a7e1377d3d2eea3c1f3abc5d2b8970c17}} 
\index{SkMask@{SkMask}!computeTotalImageSize@{computeTotalImageSize}}
\index{computeTotalImageSize@{computeTotalImageSize}!SkMask@{SkMask}}
\doxysubsubsection{\texorpdfstring{computeTotalImageSize()}{computeTotalImageSize()}}
{\footnotesize\ttfamily size\+\_\+t Sk\+Mask\+::compute\+Total\+Image\+Size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const}

Return the byte size of the mask, taking into account any extra planes (e.\+g. k3\+D\+\_\+\+Format). If there is an overflow of 32bits, then returns 0. \mbox{\Hypertarget{struct_sk_mask_a7ecc23a4a9227e1dc6f69b0a84b45e1d}\label{struct_sk_mask_a7ecc23a4a9227e1dc6f69b0a84b45e1d}} 
\index{SkMask@{SkMask}!FreeImage@{FreeImage}}
\index{FreeImage@{FreeImage}!SkMask@{SkMask}}
\doxysubsubsection{\texorpdfstring{FreeImage()}{FreeImage()}}
{\footnotesize\ttfamily void Sk\+Mask\+::\+Free\+Image (\begin{DoxyParamCaption}\item[{void $\ast$}]{image }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

We explicitly use this allocator for Sk\+Bimap pixels, so that we can freely assign memory allocated by one class to the other. \mbox{\Hypertarget{struct_sk_mask_adbb452a4091b4f1b103316afe115182a}\label{struct_sk_mask_adbb452a4091b4f1b103316afe115182a}} 
\index{SkMask@{SkMask}!getAddr@{getAddr}}
\index{getAddr@{getAddr}!SkMask@{SkMask}}
\doxysubsubsection{\texorpdfstring{getAddr()}{getAddr()}}
{\footnotesize\ttfamily void $\ast$ Sk\+Mask\+::get\+Addr (\begin{DoxyParamCaption}\item[{int}]{x,  }\item[{int}]{y }\end{DoxyParamCaption}) const}

Returns the address of the specified pixel, computing the pixel-\/size at runtime based on the mask format. This will be slightly slower than using one of the routines where the format is implied by the name e.\+g. get\+Addr8 or get\+Addr32.

x,y must be contained by the mask\textquotesingle{}s bounds (this is asserted in the debug build, but not checked in the release build.)

This should not be called with k\+B\+W\+\_\+\+Format, as it will give unspecified results (and assert in the debug build). \mbox{\Hypertarget{struct_sk_mask_ae29b5e7a839802edfb6f61ae6c94d980}\label{struct_sk_mask_ae29b5e7a839802edfb6f61ae6c94d980}} 
\index{SkMask@{SkMask}!getAddr1@{getAddr1}}
\index{getAddr1@{getAddr1}!SkMask@{SkMask}}
\doxysubsubsection{\texorpdfstring{getAddr1()}{getAddr1()}}
{\footnotesize\ttfamily uint8\+\_\+t$\ast$ Sk\+Mask\+::get\+Addr1 (\begin{DoxyParamCaption}\item[{int}]{x,  }\item[{int}]{y }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the address of the byte that holds the specified bit. Asserts that the mask is k\+B\+W\+\_\+\+Format, and that x,y are in range. x,y are in the same coordiate space as f\+Bounds. \mbox{\Hypertarget{struct_sk_mask_acd625aa83f5bc885e29f3777078d2bbf}\label{struct_sk_mask_acd625aa83f5bc885e29f3777078d2bbf}} 
\index{SkMask@{SkMask}!getAddr32@{getAddr32}}
\index{getAddr32@{getAddr32}!SkMask@{SkMask}}
\doxysubsubsection{\texorpdfstring{getAddr32()}{getAddr32()}}
{\footnotesize\ttfamily uint32\+\_\+t$\ast$ Sk\+Mask\+::get\+Addr32 (\begin{DoxyParamCaption}\item[{int}]{x,  }\item[{int}]{y }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return the address of the specified 32bit mask. In the debug build, this asserts that the mask\textquotesingle{}s format is 32bits, and that (x,y) are contained in the mask\textquotesingle{}s f\+Bounds. \mbox{\Hypertarget{struct_sk_mask_a6d122d13864e3bc36e1cdbfda055303f}\label{struct_sk_mask_a6d122d13864e3bc36e1cdbfda055303f}} 
\index{SkMask@{SkMask}!getAddr8@{getAddr8}}
\index{getAddr8@{getAddr8}!SkMask@{SkMask}}
\doxysubsubsection{\texorpdfstring{getAddr8()}{getAddr8()}}
{\footnotesize\ttfamily uint8\+\_\+t$\ast$ Sk\+Mask\+::get\+Addr8 (\begin{DoxyParamCaption}\item[{int}]{x,  }\item[{int}]{y }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the address of the specified byte. Asserts that the mask is k\+A8\+\_\+\+Format, and that x,y are in range. x,y are in the same coordiate space as f\+Bounds. \mbox{\Hypertarget{struct_sk_mask_a24d7a324c8c6c09d21166c1722ac0d25}\label{struct_sk_mask_a24d7a324c8c6c09d21166c1722ac0d25}} 
\index{SkMask@{SkMask}!getAddrLCD16@{getAddrLCD16}}
\index{getAddrLCD16@{getAddrLCD16}!SkMask@{SkMask}}
\doxysubsubsection{\texorpdfstring{getAddrLCD16()}{getAddrLCD16()}}
{\footnotesize\ttfamily uint16\+\_\+t$\ast$ Sk\+Mask\+::get\+Addr\+L\+C\+D16 (\begin{DoxyParamCaption}\item[{int}]{x,  }\item[{int}]{y }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return the address of the specified 16bit mask. In the debug build, this asserts that the mask\textquotesingle{}s format is k\+L\+C\+D16\+\_\+\+Format, and that (x,y) are contained in the mask\textquotesingle{}s f\+Bounds. \mbox{\Hypertarget{struct_sk_mask_a620469e14c3b5e849afeb7b1417ab793}\label{struct_sk_mask_a620469e14c3b5e849afeb7b1417ab793}} 
\index{SkMask@{SkMask}!isEmpty@{isEmpty}}
\index{isEmpty@{isEmpty}!SkMask@{SkMask}}
\doxysubsubsection{\texorpdfstring{isEmpty()}{isEmpty()}}
{\footnotesize\ttfamily bool Sk\+Mask\+::is\+Empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns true if the mask is empty\+: i.\+e. it has an empty bounds. \mbox{\Hypertarget{struct_sk_mask_a292a36b01bd17b3519299583a55b2354}\label{struct_sk_mask_a292a36b01bd17b3519299583a55b2354}} 
\index{SkMask@{SkMask}!PrepareDestination@{PrepareDestination}}
\index{PrepareDestination@{PrepareDestination}!SkMask@{SkMask}}
\doxysubsubsection{\texorpdfstring{PrepareDestination()}{PrepareDestination()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_sk_mask}{Sk\+Mask}} Sk\+Mask\+::\+Prepare\+Destination (\begin{DoxyParamCaption}\item[{int}]{radiusX,  }\item[{int}]{radiusY,  }\item[{const \mbox{\hyperlink{struct_sk_mask}{Sk\+Mask}} \&}]{src }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Returns initial destination mask data padded by radiusX and radiusY 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Mask.\+h\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/core/Sk\+Mask.\+cpp\end{DoxyCompactItemize}
