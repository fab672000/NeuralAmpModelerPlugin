\hypertarget{class_sk_t_array}{}\doxysection{Sk\+T\+Array$<$ T, M\+E\+M\+\_\+\+M\+O\+VE $>$ Class Template Reference}
\label{class_sk_t_array}\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}


{\ttfamily \#include $<$Sk\+T\+Array.\+h$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_t_array_aea0fa7b6ef61afd0d193123b9d117810}\label{class_sk_t_array_aea0fa7b6ef61afd0d193123b9d117810}} 
using {\bfseries value\+\_\+type} = \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_sk_t_array_a66d23fc8556f161c3588cb9075989b8f}{Sk\+T\+Array}} ()
\item 
\mbox{\hyperlink{class_sk_t_array_ab82c5d5bee6711045c0769bb5952961a}{Sk\+T\+Array}} (int reserve\+Count)
\item 
\mbox{\hyperlink{class_sk_t_array_a7971d491e6f65b8e1e697d9b7316f22b}{Sk\+T\+Array}} (const \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} \&that)
\item 
\mbox{\Hypertarget{class_sk_t_array_a27996e26ea1a43a994f7bf43953bd1c6}\label{class_sk_t_array_a27996e26ea1a43a994f7bf43953bd1c6}} 
{\bfseries Sk\+T\+Array} (\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} \&\&that)
\item 
\mbox{\hyperlink{class_sk_t_array_a99fb9819a820faed49432d3798d16712}{Sk\+T\+Array}} (const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$array, int \mbox{\hyperlink{class_sk_t_array_a6f74036de5023ed181e45878e431cc76}{count}})
\item 
\mbox{\hyperlink{class_sk_t_array_ae80b04eb8eec74ea83282fac02283e31}{Sk\+T\+Array}} (std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ data)
\item 
\mbox{\Hypertarget{class_sk_t_array_afb8d88dd5ee728b45a3be6f3fd54f7c1}\label{class_sk_t_array_afb8d88dd5ee728b45a3be6f3fd54f7c1}} 
\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} \& {\bfseries operator=} (const \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} \&that)
\item 
\mbox{\Hypertarget{class_sk_t_array_a4dc8f750d4d349c396c057451b1ba3e8}\label{class_sk_t_array_a4dc8f750d4d349c396c057451b1ba3e8}} 
\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} \& {\bfseries operator=} (\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} \&\&that)
\item 
void \mbox{\hyperlink{class_sk_t_array_a5ceea5da492f3d11d4508d787518b6be}{reset}} ()
\item 
void \mbox{\hyperlink{class_sk_t_array_a53659257c2affab420e2b4632f9ddca2}{reset}} (int n)
\item 
void \mbox{\hyperlink{class_sk_t_array_ade2988c06b38a493342a8b4ba71ce267}{reset}} (const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$array, int \mbox{\hyperlink{class_sk_t_array_a6f74036de5023ed181e45878e431cc76}{count}})
\item 
void \mbox{\hyperlink{class_sk_t_array_afb9a187fd90a52702edb12b4fed4b676}{reserve\+\_\+back}} (int n)
\item 
\mbox{\Hypertarget{class_sk_t_array_a7016e9a16ca4e8a88a65d054a3c2f5c6}\label{class_sk_t_array_a7016e9a16ca4e8a88a65d054a3c2f5c6}} 
void {\bfseries remove\+Shuffle} (int n)
\item 
int \mbox{\hyperlink{class_sk_t_array_a6f74036de5023ed181e45878e431cc76}{count}} () const
\item 
bool \mbox{\hyperlink{class_sk_t_array_aee6e6ebfb8b46076ceae77595f4dbf78}{empty}} () const
\item 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& \mbox{\hyperlink{class_sk_t_array_a1f5242882ad76b971e12c1344dcd2172}{push\+\_\+back}} ()
\item 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& \mbox{\hyperlink{class_sk_t_array_a46a85a98437d50ba0378191691b8a422}{push\+\_\+back}} (const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&t)
\item 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& \mbox{\hyperlink{class_sk_t_array_aad246da26e3040241273ebb46d330abd}{push\+\_\+back}} (\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&\&t)
\item 
{\footnotesize template$<$class... Args$>$ }\\\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& \mbox{\hyperlink{class_sk_t_array_ab6eb7128a59e32910373f3e8cfe5e2c4}{emplace\+\_\+back}} (Args \&\&... args)
\item 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ \mbox{\hyperlink{class_sk_t_array_aff326c970fe3fb25f7a583db512ed9f7}{push\+\_\+back\+\_\+n}} (int n)
\item 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ \mbox{\hyperlink{class_sk_t_array_ae0d844b8ee4e88404618b42345760559}{push\+\_\+back\+\_\+n}} (int n, const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&t)
\item 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ \mbox{\hyperlink{class_sk_t_array_aa8d4a5b35a07ac0cf63838af1481d9d7}{push\+\_\+back\+\_\+n}} (int n, const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} t\mbox{[}$\,$\mbox{]})
\item 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ \mbox{\hyperlink{class_sk_t_array_ab602433e81ee4d5e0d065d2743a48ed4}{move\+\_\+back\+\_\+n}} (int n, \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$t)
\item 
void \mbox{\hyperlink{class_sk_t_array_a442a56da4cbe27a5919c05111148b981}{pop\+\_\+back}} ()
\item 
void \mbox{\hyperlink{class_sk_t_array_a3f341ea1b464f085aeae45ad6a20d172}{pop\+\_\+back\+\_\+n}} (int n)
\item 
void \mbox{\hyperlink{class_sk_t_array_a675546a50953d2bbc08094ab870b6312}{resize\+\_\+back}} (int new\+Count)
\item 
void \mbox{\hyperlink{class_sk_t_array_a358e1f1eb8771db0b75dbf63f3b4a97d}{swap}} (\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} \&that)
\item 
\mbox{\Hypertarget{class_sk_t_array_a32fa8227d34f9e2bff2f1d47cbe713eb}\label{class_sk_t_array_a32fa8227d34f9e2bff2f1d47cbe713eb}} 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ {\bfseries begin} ()
\item 
\mbox{\Hypertarget{class_sk_t_array_a7e281fb1f2467177af2bf79932326d11}\label{class_sk_t_array_a7e281fb1f2467177af2bf79932326d11}} 
const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ {\bfseries begin} () const
\item 
\mbox{\Hypertarget{class_sk_t_array_a97d43bd39ad3bf50ad87058cd3799fe8}\label{class_sk_t_array_a97d43bd39ad3bf50ad87058cd3799fe8}} 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ {\bfseries end} ()
\item 
\mbox{\Hypertarget{class_sk_t_array_aaf57797da5b5cc6dd3b5a90f8095a44c}\label{class_sk_t_array_aaf57797da5b5cc6dd3b5a90f8095a44c}} 
const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ {\bfseries end} () const
\item 
\mbox{\Hypertarget{class_sk_t_array_a1424a7867baae0c970cf457f082009bb}\label{class_sk_t_array_a1424a7867baae0c970cf457f082009bb}} 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ {\bfseries data} ()
\item 
\mbox{\Hypertarget{class_sk_t_array_af6ca1aa079410c78653130a9d6f30d30}\label{class_sk_t_array_af6ca1aa079410c78653130a9d6f30d30}} 
const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ {\bfseries data} () const
\item 
\mbox{\Hypertarget{class_sk_t_array_a6b00cb35ef07dcfd97492f6bffbc3d23}\label{class_sk_t_array_a6b00cb35ef07dcfd97492f6bffbc3d23}} 
size\+\_\+t {\bfseries size} () const
\item 
\mbox{\Hypertarget{class_sk_t_array_aae39c71c37dbfb1dd09b452dcf0430d6}\label{class_sk_t_array_aae39c71c37dbfb1dd09b452dcf0430d6}} 
void {\bfseries resize} (size\+\_\+t \mbox{\hyperlink{class_sk_t_array_a6f74036de5023ed181e45878e431cc76}{count}})
\item 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& \mbox{\hyperlink{class_sk_t_array_ab70a30ee6a2458ae25048fc0bfc148dc}{operator\mbox{[}$\,$\mbox{]}}} (int i)
\item 
\mbox{\Hypertarget{class_sk_t_array_a1732431e4184c902bb151dfc1882e7ee}\label{class_sk_t_array_a1732431e4184c902bb151dfc1882e7ee}} 
const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& {\bfseries operator\mbox{[}$\,$\mbox{]}} (int i) const
\item 
\mbox{\Hypertarget{class_sk_t_array_a3e143efe2846de52118744d02e37791b}\label{class_sk_t_array_a3e143efe2846de52118744d02e37791b}} 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& {\bfseries at} (int i)
\item 
\mbox{\Hypertarget{class_sk_t_array_af30b51fa149a00d440d64aefe396a852}\label{class_sk_t_array_af30b51fa149a00d440d64aefe396a852}} 
const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& {\bfseries at} (int i) const
\item 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& \mbox{\hyperlink{class_sk_t_array_acfe215bed8bf28bbea2d48d1b20e26be}{front}} ()
\item 
\mbox{\Hypertarget{class_sk_t_array_a61e81abacd55cd60e8e63cc712a6f6c9}\label{class_sk_t_array_a61e81abacd55cd60e8e63cc712a6f6c9}} 
const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& {\bfseries front} () const
\item 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& \mbox{\hyperlink{class_sk_t_array_aaa13cd236f8b47349f4d9fafcad0f707}{back}} ()
\item 
\mbox{\Hypertarget{class_sk_t_array_ab8371ae0b44da99f22dcbe7b5e4799c3}\label{class_sk_t_array_ab8371ae0b44da99f22dcbe7b5e4799c3}} 
const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& {\bfseries back} () const
\item 
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& \mbox{\hyperlink{class_sk_t_array_ac6a377668e41671640bd0ce743521bbe}{from\+Back}} (int i)
\item 
\mbox{\Hypertarget{class_sk_t_array_a698f9ab1c4a478ccbf966e9d5470d426}\label{class_sk_t_array_a698f9ab1c4a478ccbf966e9d5470d426}} 
const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& {\bfseries from\+Back} (int i) const
\item 
\mbox{\Hypertarget{class_sk_t_array_a39998d7e401d77f79952d9d0fa0771c5}\label{class_sk_t_array_a39998d7e401d77f79952d9d0fa0771c5}} 
bool {\bfseries operator==} (const \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$ \&right) const
\item 
\mbox{\Hypertarget{class_sk_t_array_ad2548346c867e55220e8576a41915c54}\label{class_sk_t_array_ad2548346c867e55220e8576a41915c54}} 
bool {\bfseries operator!=} (const \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$ \&right) const
\item 
\mbox{\Hypertarget{class_sk_t_array_ad7cabb28985972d0d83c455db1ab5807}\label{class_sk_t_array_ad7cabb28985972d0d83c455db1ab5807}} 
int {\bfseries capacity} () const
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$int N$>$ }\\\mbox{\hyperlink{class_sk_t_array_a0742a43193959cf5a78fc73ccc7c0733}{Sk\+T\+Array}} (\mbox{\hyperlink{class_sk_aligned_s_t_storage}{Sk\+Aligned\+S\+T\+Storage}}$<$ N, \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ $\ast$storage)
\item 
{\footnotesize template$<$int N$>$ }\\\mbox{\hyperlink{class_sk_t_array_a762476dda733e848970fe010e50ffab9}{Sk\+T\+Array}} (const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$array, int \mbox{\hyperlink{class_sk_t_array_a6f74036de5023ed181e45878e431cc76}{count}}, \mbox{\hyperlink{class_sk_aligned_s_t_storage}{Sk\+Aligned\+S\+T\+Storage}}$<$ N, \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ $\ast$storage)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename T, bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$\newline
class Sk\+T\+Array$<$ T, M\+E\+M\+\_\+\+M\+O\+V\+E $>$}

Sk\+T\+Array$<$\+T$>$ implements a typical, mostly std\+::vector-\/like array. Each T will be default-\/initialized on allocation, and $\sim$T will be called on destruction.

M\+E\+M\+\_\+\+M\+O\+VE controls the behavior when a T needs to be moved (e.\+g. when the array is resized)
\begin{DoxyItemize}
\item true\+: T will be bit-\/copied via memcpy.
\item false\+: T will be moved via move-\/constructors.
\end{DoxyItemize}

Modern implementations of std\+::vector$<$\+T$>$ will generally provide similar performance characteristics when used with appropriate care. Consider using std\+::vector$<$\+T$>$ in new code. 

\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_sk_t_array_a66d23fc8556f161c3588cb9075989b8f}\label{class_sk_t_array_a66d23fc8556f161c3588cb9075989b8f}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!SkTArray@{SkTArray}}
\index{SkTArray@{SkTArray}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{SkTArray()}{SkTArray()}\hspace{0.1cm}{\footnotesize\ttfamily [1/7]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Creates an empty array with no initial storage \mbox{\Hypertarget{class_sk_t_array_ab82c5d5bee6711045c0769bb5952961a}\label{class_sk_t_array_ab82c5d5bee6711045c0769bb5952961a}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!SkTArray@{SkTArray}}
\index{SkTArray@{SkTArray}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{SkTArray()}{SkTArray()}\hspace{0.1cm}{\footnotesize\ttfamily [2/7]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} (\begin{DoxyParamCaption}\item[{int}]{reserve\+Count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}

Creates an empty array that will preallocate space for reserve\+Count elements. \mbox{\Hypertarget{class_sk_t_array_a7971d491e6f65b8e1e697d9b7316f22b}\label{class_sk_t_array_a7971d491e6f65b8e1e697d9b7316f22b}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!SkTArray@{SkTArray}}
\index{SkTArray@{SkTArray}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{SkTArray()}{SkTArray()}\hspace{0.1cm}{\footnotesize\ttfamily [3/7]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$ \&}]{that }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Copies one array to another. The new array will be heap allocated. \mbox{\Hypertarget{class_sk_t_array_a99fb9819a820faed49432d3798d16712}\label{class_sk_t_array_a99fb9819a820faed49432d3798d16712}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!SkTArray@{SkTArray}}
\index{SkTArray@{SkTArray}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{SkTArray()}{SkTArray()}\hspace{0.1cm}{\footnotesize\ttfamily [4/7]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$}]{array,  }\item[{int}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Creates a \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} by copying contents of a standard C array. The new array will be heap allocated. Be careful not to use this constructor when you really want the (void$\ast$, int) version. \mbox{\Hypertarget{class_sk_t_array_ae80b04eb8eec74ea83282fac02283e31}\label{class_sk_t_array_ae80b04eb8eec74ea83282fac02283e31}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!SkTArray@{SkTArray}}
\index{SkTArray@{SkTArray}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{SkTArray()}{SkTArray()}\hspace{0.1cm}{\footnotesize\ttfamily [5/7]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} (\begin{DoxyParamCaption}\item[{std\+::initializer\+\_\+list$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$}]{data }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Creates a \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} by copying contents of an initializer list. \mbox{\Hypertarget{class_sk_t_array_a0742a43193959cf5a78fc73ccc7c0733}\label{class_sk_t_array_a0742a43193959cf5a78fc73ccc7c0733}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!SkTArray@{SkTArray}}
\index{SkTArray@{SkTArray}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{SkTArray()}{SkTArray()}\hspace{0.1cm}{\footnotesize\ttfamily [6/7]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
template$<$int N$>$ \\
\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_aligned_s_t_storage}{Sk\+Aligned\+S\+T\+Storage}}$<$ N, \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ $\ast$}]{storage }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}

Creates an empty array that will use the passed storage block until it is insufficiently large to hold the entire array. \mbox{\Hypertarget{class_sk_t_array_a762476dda733e848970fe010e50ffab9}\label{class_sk_t_array_a762476dda733e848970fe010e50ffab9}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!SkTArray@{SkTArray}}
\index{SkTArray@{SkTArray}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{SkTArray()}{SkTArray()}\hspace{0.1cm}{\footnotesize\ttfamily [7/7]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
template$<$int N$>$ \\
\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$}]{array,  }\item[{int}]{count,  }\item[{\mbox{\hyperlink{class_sk_aligned_s_t_storage}{Sk\+Aligned\+S\+T\+Storage}}$<$ N, \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$ $\ast$}]{storage }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}

Copy a C array, using preallocated storage if pre\+Alloc\+Count $>$= count. Otherwise storage will only be used when array shrinks to fit. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_t_array_aaa13cd236f8b47349f4d9fafcad0f707}\label{class_sk_t_array_aaa13cd236f8b47349f4d9fafcad0f707}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!back@{back}}
\index{back@{back}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{back()}{back()}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}\& \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::back (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

equivalent to operator\mbox{[}\mbox{]}(\mbox{\hyperlink{class_sk_t_array_a6f74036de5023ed181e45878e431cc76}{count()}} -\/ 1) \mbox{\Hypertarget{class_sk_t_array_a6f74036de5023ed181e45878e431cc76}\label{class_sk_t_array_a6f74036de5023ed181e45878e431cc76}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!count@{count}}
\index{count@{count}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{count()}{count()}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
int \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Number of elements in the array. \mbox{\Hypertarget{class_sk_t_array_ab6eb7128a59e32910373f3e8cfe5e2c4}\label{class_sk_t_array_ab6eb7128a59e32910373f3e8cfe5e2c4}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!emplace\_back@{emplace\_back}}
\index{emplace\_back@{emplace\_back}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{emplace\_back()}{emplace\_back()}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
template$<$class... Args$>$ \\
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}\& \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::emplace\+\_\+back (\begin{DoxyParamCaption}\item[{Args \&\&...}]{args }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Construct a new T at the back of this array. \mbox{\Hypertarget{class_sk_t_array_aee6e6ebfb8b46076ceae77595f4dbf78}\label{class_sk_t_array_aee6e6ebfb8b46076ceae77595f4dbf78}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!empty@{empty}}
\index{empty@{empty}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{empty()}{empty()}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
bool \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::empty (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Is the array empty. \mbox{\Hypertarget{class_sk_t_array_ac6a377668e41671640bd0ce743521bbe}\label{class_sk_t_array_ac6a377668e41671640bd0ce743521bbe}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!fromBack@{fromBack}}
\index{fromBack@{fromBack}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{fromBack()}{fromBack()}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}\& \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::from\+Back (\begin{DoxyParamCaption}\item[{int}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

equivalent to operator\mbox{[}\mbox{]}(\mbox{\hyperlink{class_sk_t_array_a6f74036de5023ed181e45878e431cc76}{count()}}-\/1-\/i) \mbox{\Hypertarget{class_sk_t_array_acfe215bed8bf28bbea2d48d1b20e26be}\label{class_sk_t_array_acfe215bed8bf28bbea2d48d1b20e26be}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!front@{front}}
\index{front@{front}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{front()}{front()}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}\& \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::front (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

equivalent to operator\mbox{[}$\,$\mbox{]}(0) \mbox{\Hypertarget{class_sk_t_array_ab602433e81ee4d5e0d065d2743a48ed4}\label{class_sk_t_array_ab602433e81ee4d5e0d065d2743a48ed4}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!move\_back\_n@{move\_back\_n}}
\index{move\_back\_n@{move\_back\_n}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{move\_back\_n()}{move\_back\_n()}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}$\ast$ \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::move\+\_\+back\+\_\+n (\begin{DoxyParamCaption}\item[{int}]{n,  }\item[{\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$}]{t }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\hyperlink{struct_version}{Version}} of above that uses the move constructor to set n items. \mbox{\Hypertarget{class_sk_t_array_ab70a30ee6a2458ae25048fc0bfc148dc}\label{class_sk_t_array_ab70a30ee6a2458ae25048fc0bfc148dc}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!operator\mbox{[}\mbox{]}@{operator[]}}
\index{operator\mbox{[}\mbox{]}@{operator[]}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{operator[]()}{operator[]()}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}\& \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::operator\mbox{[}$\,$\mbox{]} (\begin{DoxyParamCaption}\item[{int}]{i }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Get the i$^\wedge$th element. \mbox{\Hypertarget{class_sk_t_array_a442a56da4cbe27a5919c05111148b981}\label{class_sk_t_array_a442a56da4cbe27a5919c05111148b981}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!pop\_back@{pop\_back}}
\index{pop\_back@{pop\_back}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{pop\_back()}{pop\_back()}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
void \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::pop\+\_\+back (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Removes the last element. Not safe to call when \mbox{\hyperlink{class_sk_t_array_a6f74036de5023ed181e45878e431cc76}{count()}} == 0. \mbox{\Hypertarget{class_sk_t_array_a3f341ea1b464f085aeae45ad6a20d172}\label{class_sk_t_array_a3f341ea1b464f085aeae45ad6a20d172}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!pop\_back\_n@{pop\_back\_n}}
\index{pop\_back\_n@{pop\_back\_n}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{pop\_back\_n()}{pop\_back\_n()}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
void \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::pop\+\_\+back\+\_\+n (\begin{DoxyParamCaption}\item[{int}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Removes the last n elements. Not safe to call when \mbox{\hyperlink{class_sk_t_array_a6f74036de5023ed181e45878e431cc76}{count()}} $<$ n. \mbox{\Hypertarget{class_sk_t_array_a1f5242882ad76b971e12c1344dcd2172}\label{class_sk_t_array_a1f5242882ad76b971e12c1344dcd2172}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!push\_back@{push\_back}}
\index{push\_back@{push\_back}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{push\_back()}{push\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}\& \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::push\+\_\+back (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Adds 1 new default-\/initialized T value and returns it by reference. Note the reference only remains valid until the next call that adds or removes elements. \mbox{\Hypertarget{class_sk_t_array_a46a85a98437d50ba0378191691b8a422}\label{class_sk_t_array_a46a85a98437d50ba0378191691b8a422}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!push\_back@{push\_back}}
\index{push\_back@{push\_back}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{push\_back()}{push\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}\& \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::push\+\_\+back (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&}]{t }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\hyperlink{struct_version}{Version}} of above that uses a copy constructor to initialize the new item \mbox{\Hypertarget{class_sk_t_array_aad246da26e3040241273ebb46d330abd}\label{class_sk_t_array_aad246da26e3040241273ebb46d330abd}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!push\_back@{push\_back}}
\index{push\_back@{push\_back}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{push\_back()}{push\_back()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}\& \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::push\+\_\+back (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&\&}]{t }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\hyperlink{struct_version}{Version}} of above that uses a move constructor to initialize the new item \mbox{\Hypertarget{class_sk_t_array_aff326c970fe3fb25f7a583db512ed9f7}\label{class_sk_t_array_aff326c970fe3fb25f7a583db512ed9f7}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!push\_back\_n@{push\_back\_n}}
\index{push\_back\_n@{push\_back\_n}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{push\_back\_n()}{push\_back\_n()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}$\ast$ \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::push\+\_\+back\+\_\+n (\begin{DoxyParamCaption}\item[{int}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Allocates n more default-\/initialized T values, and returns the address of the start of that new range. Note\+: this address is only valid until the next A\+PI call made on the array that might add or remove elements. \mbox{\Hypertarget{class_sk_t_array_ae0d844b8ee4e88404618b42345760559}\label{class_sk_t_array_ae0d844b8ee4e88404618b42345760559}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!push\_back\_n@{push\_back\_n}}
\index{push\_back\_n@{push\_back\_n}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{push\_back\_n()}{push\_back\_n()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}$\ast$ \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::push\+\_\+back\+\_\+n (\begin{DoxyParamCaption}\item[{int}]{n,  }\item[{const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&}]{t }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\hyperlink{struct_version}{Version}} of above that uses a copy constructor to initialize all n items to the same T. \mbox{\Hypertarget{class_sk_t_array_aa8d4a5b35a07ac0cf63838af1481d9d7}\label{class_sk_t_array_aa8d4a5b35a07ac0cf63838af1481d9d7}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!push\_back\_n@{push\_back\_n}}
\index{push\_back\_n@{push\_back\_n}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{push\_back\_n()}{push\_back\_n()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}$\ast$ \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::push\+\_\+back\+\_\+n (\begin{DoxyParamCaption}\item[{int}]{n,  }\item[{const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}}]{t\mbox{[}$\,$\mbox{]} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\mbox{\hyperlink{struct_version}{Version}} of above that uses a copy constructor to initialize the n items to separate T values. \mbox{\Hypertarget{class_sk_t_array_afb9a187fd90a52702edb12b4fed4b676}\label{class_sk_t_array_afb9a187fd90a52702edb12b4fed4b676}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!reserve\_back@{reserve\_back}}
\index{reserve\_back@{reserve\_back}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{reserve\_back()}{reserve\_back()}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
void \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::reserve\+\_\+back (\begin{DoxyParamCaption}\item[{int}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Ensures there is enough reserved space for n additional elements. The is guaranteed at least until the array size grows above n and subsequently shrinks below n, any version of \mbox{\hyperlink{class_sk_t_array_a5ceea5da492f3d11d4508d787518b6be}{reset()}} is called, or \mbox{\hyperlink{class_sk_t_array_afb9a187fd90a52702edb12b4fed4b676}{reserve\+\_\+back()}} is called again. \mbox{\Hypertarget{class_sk_t_array_a5ceea5da492f3d11d4508d787518b6be}\label{class_sk_t_array_a5ceea5da492f3d11d4508d787518b6be}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!reset@{reset}}
\index{reset@{reset}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
void \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::reset (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Resets to \mbox{\hyperlink{class_sk_t_array_a6f74036de5023ed181e45878e431cc76}{count()}} == 0 and resets any reserve count. \mbox{\Hypertarget{class_sk_t_array_ade2988c06b38a493342a8b4ba71ce267}\label{class_sk_t_array_ade2988c06b38a493342a8b4ba71ce267}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!reset@{reset}}
\index{reset@{reset}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
void \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::reset (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$}]{array,  }\item[{int}]{count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Resets to a copy of a C array and resets any reserve count. \mbox{\Hypertarget{class_sk_t_array_a53659257c2affab420e2b4632f9ddca2}\label{class_sk_t_array_a53659257c2affab420e2b4632f9ddca2}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!reset@{reset}}
\index{reset@{reset}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{reset()}{reset()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
void \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::reset (\begin{DoxyParamCaption}\item[{int}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Resets to \mbox{\hyperlink{class_sk_t_array_a6f74036de5023ed181e45878e431cc76}{count()}} = n newly constructed T objects and resets any reserve count. \mbox{\Hypertarget{class_sk_t_array_a675546a50953d2bbc08094ab870b6312}\label{class_sk_t_array_a675546a50953d2bbc08094ab870b6312}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!resize\_back@{resize\_back}}
\index{resize\_back@{resize\_back}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{resize\_back()}{resize\_back()}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
void \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::resize\+\_\+back (\begin{DoxyParamCaption}\item[{int}]{new\+Count }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Pushes or pops from the back to resize. Pushes will be default initialized. \mbox{\Hypertarget{class_sk_t_array_a358e1f1eb8771db0b75dbf63f3b4a97d}\label{class_sk_t_array_a358e1f1eb8771db0b75dbf63f3b4a97d}} 
\index{SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}!swap@{swap}}
\index{swap@{swap}!SkTArray$<$ T, MEM\_MOVE $>$@{SkTArray$<$ T, MEM\_MOVE $>$}}
\doxysubsubsection{\texorpdfstring{swap()}{swap()}}
{\footnotesize\ttfamily template$<$typename T , bool M\+E\+M\+\_\+\+M\+O\+VE = false$>$ \\
void \mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$\+::swap (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_t_array}{Sk\+T\+Array}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, M\+E\+M\+\_\+\+M\+O\+VE $>$ \&}]{that }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Swaps the contents of this array with that array. Does a pointer swap if possible, otherwise copies the T values. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/include/private/Sk\+T\+Array.\+h\end{DoxyCompactItemize}
