\hypertarget{class_i_a_c_f_component_factory}{}\doxysection{I\+A\+C\+F\+Component\+Factory Interface Reference}
\label{class_i_a_c_f_component_factory}\index{IACFComponentFactory@{IACFComponentFactory}}


Publicly inherits from I\+A\+C\+F\+Unknown.\+Provides the abstract interface for object creation.  




{\ttfamily \#include $<$acfbaseapi.\+h$>$}

Inheritance diagram for I\+A\+C\+F\+Component\+Factory\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_i_a_c_f_component_factory}
\end{center}
\end{figure}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual A\+C\+F\+R\+E\+S\+U\+LT A\+C\+F\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+PE \mbox{\hyperlink{class_i_a_c_f_component_factory_aede173faf7681bc8a0dea5c0b30cb038}{Create\+Component}} (const \mbox{\hyperlink{_a_a_x_8h_ab19414382287ff80930c48a196145214}{acf\+U\+ID}} \&compid, \mbox{\hyperlink{interface_i_a_c_f_unknown}{I\+A\+C\+F\+Unknown}} $\ast$p\+Unk\+Outer, const \mbox{\hyperlink{acfbasetypes_8h_a59df0b41744eee7a066787aaedf97f67}{acf\+I\+ID}} \&iid, void $\ast$$\ast$x)=0
\begin{DoxyCompactList}\small\item\em Creates an instance of an uninitialized component. \end{DoxyCompactList}\item 
virtual A\+C\+F\+R\+E\+S\+U\+LT A\+C\+F\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+PE \mbox{\hyperlink{class_i_a_c_f_component_factory_abf4718dece04429c3b2be7f263a1ea4a}{Create\+Instance}} (const \mbox{\hyperlink{acfbasetypes_8h_a5122736ac2d4cb5a3718a5926f44db8f}{acf\+C\+L\+S\+ID}} \&clsid, \mbox{\hyperlink{interface_i_a_c_f_unknown}{I\+A\+C\+F\+Unknown}} $\ast$p\+Unk\+Outer, const \mbox{\hyperlink{acfbasetypes_8h_a59df0b41744eee7a066787aaedf97f67}{acf\+I\+ID}} \&iid, void $\ast$$\ast$x)=0
\begin{DoxyCompactList}\small\item\em Creates an instance of an uninitialized component. \end{DoxyCompactList}\item 
virtual A\+C\+F\+R\+E\+S\+U\+LT A\+C\+F\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+PE \mbox{\hyperlink{class_i_a_c_f_component_factory_ab23848b969438f21e933d1d7dbf76c7e}{Get\+Class\+Factory}} (const \mbox{\hyperlink{acfbasetypes_8h_a5122736ac2d4cb5a3718a5926f44db8f}{acf\+C\+L\+S\+ID}} \&clsid, const \mbox{\hyperlink{acfbasetypes_8h_a59df0b41744eee7a066787aaedf97f67}{acf\+I\+ID}} \&iid, void $\ast$$\ast$x)=0
\begin{DoxyCompactList}\small\item\em Returns the class factory for a given component class implementation. \end{DoxyCompactList}\item 
virtual A\+C\+F\+R\+E\+S\+U\+LT A\+C\+F\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+PE \mbox{\hyperlink{class_i_a_c_f_component_factory_a4cfb509a8d2b07a5c47e65d6c20cf457}{Find\+Definition}} (const \mbox{\hyperlink{_a_a_x_8h_ab19414382287ff80930c48a196145214}{acf\+U\+ID}} \&uid, const \mbox{\hyperlink{acfbasetypes_8h_a59df0b41744eee7a066787aaedf97f67}{acf\+I\+ID}} \&iid, \mbox{\hyperlink{class_i_a_c_f_definition}{I\+A\+C\+F\+Definition}} $\ast$$\ast$pp\+Definition)=0
\begin{DoxyCompactList}\small\item\em Allows the plug-\/in to lookup a particular definition that has been registered with the host. \end{DoxyCompactList}\item 
virtual A\+C\+F\+R\+E\+S\+U\+LT A\+C\+F\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+PE \mbox{\hyperlink{class_i_a_c_f_component_factory_abce48652ea5a80b29d3d948af677519e}{Enum\+Definitions}} (const \mbox{\hyperlink{_a_a_x_8h_ab19414382287ff80930c48a196145214}{acf\+U\+ID}} \&component\+Type\+ID, \mbox{\hyperlink{class_i_a_c_f_enum_definitions}{I\+A\+C\+F\+Enum\+Definitions}} $\ast$$\ast$pp\+Enum)=0
\begin{DoxyCompactList}\small\item\em Allows enumeration of all of the registered definitions of a particular type. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Publicly inherits from I\+A\+C\+F\+Unknown.\+Provides the abstract interface for object creation. 

\begin{DoxyRemark}{Remarks}
This is one of the services provided by the host implementation object. The \mbox{\hyperlink{interface_i_a_c_f_unknown}{I\+A\+C\+F\+Unknown}} interface to the host is passed into every plug-\/in callback and every component implementation class through the \mbox{\hyperlink{class_i_a_c_f_class_factory_ae711c872449e7d0fef9c46b9f676fb26}{I\+A\+C\+F\+Class\+Factory\+::\+Create\+Instance}} method. Use Query\+Interface to acquire a reference to the host\textquotesingle{}s component factory interface. 
\end{DoxyRemark}
\begin{DoxyNote}{Note}
This interface is implemented by the host. The plug-\/in will use this interface to ask the host to create components or specific component implemenation classes that have been defined with the host. 
\end{DoxyNote}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_i_a_c_f_component_factory_aede173faf7681bc8a0dea5c0b30cb038}\label{class_i_a_c_f_component_factory_aede173faf7681bc8a0dea5c0b30cb038}} 
\index{IACFComponentFactory@{IACFComponentFactory}!CreateComponent@{CreateComponent}}
\index{CreateComponent@{CreateComponent}!IACFComponentFactory@{IACFComponentFactory}}
\doxysubsubsection{\texorpdfstring{CreateComponent()}{CreateComponent()}}
{\footnotesize\ttfamily virtual A\+C\+F\+R\+E\+S\+U\+LT A\+C\+F\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+PE I\+A\+C\+F\+Component\+Factory\+::\+Create\+Component (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{_a_a_x_8h_ab19414382287ff80930c48a196145214}{acf\+U\+ID}} \&}]{compid,  }\item[{\mbox{\hyperlink{interface_i_a_c_f_unknown}{I\+A\+C\+F\+Unknown}} $\ast$}]{p\+Unk\+Outer,  }\item[{const \mbox{\hyperlink{acfbasetypes_8h_a59df0b41744eee7a066787aaedf97f67}{acf\+I\+ID}} \&}]{iid,  }\item[{void $\ast$$\ast$}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates an instance of an uninitialized component. 

{\bfseries{Create\+Component}} \begin{DoxyRemark}{Remarks}
The Create\+Component method is the general component creation method used by the host and all plug-\/ins. If more than a single class has been registered for the given component this method will automatically create the latest acceptable version.
\end{DoxyRemark}
If you don\textquotesingle{}t want the host to choose the class to create for a given component and you know the specific implementation class id then use the Create\+Instance method instead. 
\begin{DoxyParams}{Parameters}
{\em compid} & Identifier of the Component \\
\hline
{\em p\+Unk\+Outer} & Pointer to object\textquotesingle{}s controlling unknown. If N\+U\+LL then the object is not being created as part of an aggregate. If non-\/\+N\+U\+LL then pointer is the aggregate\textquotesingle{}s \mbox{\hyperlink{interface_i_a_c_f_unknown}{I\+A\+C\+F\+Unknown}} interface (the controlling \mbox{\hyperlink{interface_i_a_c_f_unknown}{I\+A\+C\+F\+Unknown}}). \\
\hline
{\em iid} & Identifier for the initial interface to the new object. \\
\hline
{\em x} & Address of pointer variable that receives the interface pointer corresponding to the given iid. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_i_a_c_f_component_factory_abf4718dece04429c3b2be7f263a1ea4a}\label{class_i_a_c_f_component_factory_abf4718dece04429c3b2be7f263a1ea4a}} 
\index{IACFComponentFactory@{IACFComponentFactory}!CreateInstance@{CreateInstance}}
\index{CreateInstance@{CreateInstance}!IACFComponentFactory@{IACFComponentFactory}}
\doxysubsubsection{\texorpdfstring{CreateInstance()}{CreateInstance()}}
{\footnotesize\ttfamily virtual A\+C\+F\+R\+E\+S\+U\+LT A\+C\+F\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+PE I\+A\+C\+F\+Component\+Factory\+::\+Create\+Instance (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{acfbasetypes_8h_a5122736ac2d4cb5a3718a5926f44db8f}{acf\+C\+L\+S\+ID}} \&}]{clsid,  }\item[{\mbox{\hyperlink{interface_i_a_c_f_unknown}{I\+A\+C\+F\+Unknown}} $\ast$}]{p\+Unk\+Outer,  }\item[{const \mbox{\hyperlink{acfbasetypes_8h_a59df0b41744eee7a066787aaedf97f67}{acf\+I\+ID}} \&}]{iid,  }\item[{void $\ast$$\ast$}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Creates an instance of an uninitialized component. 

{\bfseries{Create\+Instance}} \begin{DoxyRemark}{Remarks}
The Createinstance method is the general object creation method used by the host and all plug-\/ins. Only use this method you really need to create a particular component implementation class. For example, you might want to create your new version of an existing component by creating and reusing part of a previous version (
\end{DoxyRemark}
\begin{DoxyNote}{Note}
for the two versions to coexist in the same host they should be in the same plug-\/in, if they are in different plug-\/ins the the plug-\/in ids must be different). 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em clsid} & Class identifier of the component implementation object. \\
\hline
{\em p\+Unk\+Outer} & Pointer to object\textquotesingle{}s controlling unknown. If N\+U\+LL then the object is not being created as part of an aggregate. If non-\/\+N\+U\+LL then pointer is the aggregate\textquotesingle{}s \mbox{\hyperlink{interface_i_a_c_f_unknown}{I\+A\+C\+F\+Unknown}} interface (the controlling \mbox{\hyperlink{interface_i_a_c_f_unknown}{I\+A\+C\+F\+Unknown}}). \\
\hline
{\em iid} & Identifier for the initial interface to the new object. \\
\hline
{\em x} & Address of pointer variable that receives the interface pointer corresponding to the given iid. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_i_a_c_f_component_factory_abce48652ea5a80b29d3d948af677519e}\label{class_i_a_c_f_component_factory_abce48652ea5a80b29d3d948af677519e}} 
\index{IACFComponentFactory@{IACFComponentFactory}!EnumDefinitions@{EnumDefinitions}}
\index{EnumDefinitions@{EnumDefinitions}!IACFComponentFactory@{IACFComponentFactory}}
\doxysubsubsection{\texorpdfstring{EnumDefinitions()}{EnumDefinitions()}}
{\footnotesize\ttfamily virtual A\+C\+F\+R\+E\+S\+U\+LT A\+C\+F\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+PE I\+A\+C\+F\+Component\+Factory\+::\+Enum\+Definitions (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{_a_a_x_8h_ab19414382287ff80930c48a196145214}{acf\+U\+ID}} \&}]{component\+Type\+ID,  }\item[{\mbox{\hyperlink{class_i_a_c_f_enum_definitions}{I\+A\+C\+F\+Enum\+Definitions}} $\ast$$\ast$}]{pp\+Enum }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Allows enumeration of all of the registered definitions of a particular type. 

{\bfseries{Enum\+Definitions}} \begin{DoxyRemark}{Remarks}
This method provides a mechanism of managing groups of plug-\/in components. This can be used to create an \char`\"{}effects manager\char`\"{}, \char`\"{}codec manager\char`\"{}, \char`\"{}file translator manager\char`\"{}, etc... 
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
{\em component\+Type\+ID} & Unique identifier for the definition \mbox{\hyperlink{group___component_type}{U\+I\+D\+S\+: Component Types}} \\
\hline
{\em pp\+Enum} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_i_a_c_f_component_factory_a4cfb509a8d2b07a5c47e65d6c20cf457}\label{class_i_a_c_f_component_factory_a4cfb509a8d2b07a5c47e65d6c20cf457}} 
\index{IACFComponentFactory@{IACFComponentFactory}!FindDefinition@{FindDefinition}}
\index{FindDefinition@{FindDefinition}!IACFComponentFactory@{IACFComponentFactory}}
\doxysubsubsection{\texorpdfstring{FindDefinition()}{FindDefinition()}}
{\footnotesize\ttfamily virtual A\+C\+F\+R\+E\+S\+U\+LT A\+C\+F\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+PE I\+A\+C\+F\+Component\+Factory\+::\+Find\+Definition (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{_a_a_x_8h_ab19414382287ff80930c48a196145214}{acf\+U\+ID}} \&}]{uid,  }\item[{const \mbox{\hyperlink{acfbasetypes_8h_a59df0b41744eee7a066787aaedf97f67}{acf\+I\+ID}} \&}]{iid,  }\item[{\mbox{\hyperlink{class_i_a_c_f_definition}{I\+A\+C\+F\+Definition}} $\ast$$\ast$}]{pp\+Definition }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Allows the plug-\/in to lookup a particular definition that has been registered with the host. 

{\bfseries{Find\+Definition}} \begin{DoxyRemark}{Remarks}
Use the method to find a existing definition that has been registered with the host. 
\end{DoxyRemark}

\begin{DoxyParams}{Parameters}
{\em uid} & Unique identifier for the definition \\
\hline
{\em iid} & The interface identifier for the type of definition interface we want. \\
\hline
{\em pp\+Definition} & \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_i_a_c_f_component_factory_ab23848b969438f21e933d1d7dbf76c7e}\label{class_i_a_c_f_component_factory_ab23848b969438f21e933d1d7dbf76c7e}} 
\index{IACFComponentFactory@{IACFComponentFactory}!GetClassFactory@{GetClassFactory}}
\index{GetClassFactory@{GetClassFactory}!IACFComponentFactory@{IACFComponentFactory}}
\doxysubsubsection{\texorpdfstring{GetClassFactory()}{GetClassFactory()}}
{\footnotesize\ttfamily virtual A\+C\+F\+R\+E\+S\+U\+LT A\+C\+F\+M\+E\+T\+H\+O\+D\+C\+A\+L\+L\+T\+Y\+PE I\+A\+C\+F\+Component\+Factory\+::\+Get\+Class\+Factory (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{acfbasetypes_8h_a5122736ac2d4cb5a3718a5926f44db8f}{acf\+C\+L\+S\+ID}} \&}]{clsid,  }\item[{const \mbox{\hyperlink{acfbasetypes_8h_a59df0b41744eee7a066787aaedf97f67}{acf\+I\+ID}} \&}]{iid,  }\item[{void $\ast$$\ast$}]{x }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [pure virtual]}}



Returns the class factory for a given component class implementation. 

{\bfseries{Get\+Class\+Factory}} \begin{DoxyRemark}{Remarks}
The Get\+Class\+Factory method is the low-\/level method to return a class factory for a particular component implementation. Use this method if you know the implementation class and you need create many instances of the same component. The overhead of the looking up the factorty (and loading the dll if necessary) is only performed once. Then call the factory\textquotesingle{}s \mbox{\hyperlink{class_i_a_c_f_component_factory_abf4718dece04429c3b2be7f263a1ea4a}{Create\+Instance()}} method to create each component instance.
\end{DoxyRemark}
\begin{DoxyNote}{Note}
The caller is responsible for initializing each component instance created from the class factory. 
\end{DoxyNote}

\begin{DoxyParams}{Parameters}
{\em clsid} & Class identifier of the component implementation object. \\
\hline
{\em iid} & Identifier for the initial interface to the new class factory object. \\
\hline
{\em x} & Address of pointer variable that receives the class factory interface pointer corresponding to the given iid. \\
\hline
\end{DoxyParams}


The documentation for this interface was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+I\+Plug/\+A\+A\+X\+\_\+\+S\+D\+K/\+Interfaces/\+A\+C\+F/\mbox{\hyperlink{acfbaseapi_8h}{acfbaseapi.\+h}}\end{DoxyCompactItemize}
