\hypertarget{class_eigen_1_1_tensor_async_device}{}\doxysection{Eigen\+::Tensor\+Async\+Device$<$ Expression\+Type, Device\+Type, Done\+Callback $>$ Class Template Reference}
\label{class_eigen_1_1_tensor_async_device}\index{Eigen::TensorAsyncDevice$<$ ExpressionType, DeviceType, DoneCallback $>$@{Eigen::TensorAsyncDevice$<$ ExpressionType, DeviceType, DoneCallback $>$}}


Pseudo expression providing an operator = that will evaluate its argument asynchronously on the specified device. Currently only Thread\+Pool\+Device implements proper asynchronous execution, while the default and G\+PU devices just run the expression synchronously and call m\+\_\+done() on completion..  




{\ttfamily \#include $<$Tensor\+Device.\+h$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_eigen_1_1_tensor_async_device_a277ac59c7227ea3473013423c864cfe4}\label{class_eigen_1_1_tensor_async_device_a277ac59c7227ea3473013423c864cfe4}} 
{\bfseries Tensor\+Async\+Device} (const Device\+Type \&device, Expression\+Type \&expression, Done\+Callback done)
\item 
\mbox{\Hypertarget{class_eigen_1_1_tensor_async_device_a4e7fced711f9f76eab72726ec01707af}\label{class_eigen_1_1_tensor_async_device_a4e7fced711f9f76eab72726ec01707af}} 
{\footnotesize template$<$typename Other\+Derived $>$ }\\E\+I\+G\+E\+N\+\_\+\+S\+T\+R\+O\+N\+G\+\_\+\+I\+N\+L\+I\+NE \mbox{\hyperlink{class_eigen_1_1_tensor_async_device}{Tensor\+Async\+Device}} \& {\bfseries operator=} (const Other\+Derived \&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1_tensor_async_device_a277ac59c7227ea3473013423c864cfe4}\label{class_eigen_1_1_tensor_async_device_a277ac59c7227ea3473013423c864cfe4}} 
{\bfseries Tensor\+Async\+Device} (const Device\+Type \&device, Expression\+Type \&expression, Done\+Callback done)
\item 
\mbox{\Hypertarget{class_eigen_1_1_tensor_async_device_a4e7fced711f9f76eab72726ec01707af}\label{class_eigen_1_1_tensor_async_device_a4e7fced711f9f76eab72726ec01707af}} 
{\footnotesize template$<$typename Other\+Derived $>$ }\\E\+I\+G\+E\+N\+\_\+\+S\+T\+R\+O\+N\+G\+\_\+\+I\+N\+L\+I\+NE \mbox{\hyperlink{class_eigen_1_1_tensor_async_device}{Tensor\+Async\+Device}} \& {\bfseries operator=} (const Other\+Derived \&other)
\end{DoxyCompactItemize}
\doxysubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_eigen_1_1_tensor_async_device_a8d600794cf8d05d07e99aa3a612eeb88}\label{class_eigen_1_1_tensor_async_device_a8d600794cf8d05d07e99aa3a612eeb88}} 
const Device\+Type \& {\bfseries m\+\_\+device}
\item 
\mbox{\Hypertarget{class_eigen_1_1_tensor_async_device_ab5500588a4da7f70589b022769776b67}\label{class_eigen_1_1_tensor_async_device_ab5500588a4da7f70589b022769776b67}} 
Expression\+Type \& {\bfseries m\+\_\+expression}
\item 
\mbox{\Hypertarget{class_eigen_1_1_tensor_async_device_ac8880c4bdee9b3a554d843342be77855}\label{class_eigen_1_1_tensor_async_device_ac8880c4bdee9b3a554d843342be77855}} 
Done\+Callback {\bfseries m\+\_\+done}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Expression\+Type, typename Device\+Type, typename Done\+Callback$>$\newline
class Eigen\+::\+Tensor\+Async\+Device$<$ Expression\+Type, Device\+Type, Done\+Callback $>$}

Pseudo expression providing an operator = that will evaluate its argument asynchronously on the specified device. Currently only Thread\+Pool\+Device implements proper asynchronous execution, while the default and G\+PU devices just run the expression synchronously and call m\+\_\+done() on completion.. 

Example\+: auto done = \mbox{[}\mbox{]}() \{ ... expression evaluation done ... \}; C.\+device(thread\+\_\+pool\+\_\+device, std\+::move(done)) = A + B; 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/Tensor\+Device.\+h\end{DoxyCompactItemize}
