\hypertarget{struct_eigen_1_1internal_1_1_expression_has_tensor_broadcasting_op}{}\doxysection{Eigen\+::internal\+::Expression\+Has\+Tensor\+Broadcasting\+Op$<$ Expression $>$ Struct Template Reference}
\label{struct_eigen_1_1internal_1_1_expression_has_tensor_broadcasting_op}\index{Eigen::internal::ExpressionHasTensorBroadcastingOp$<$ Expression $>$@{Eigen::internal::ExpressionHasTensorBroadcastingOp$<$ Expression $>$}}


{\ttfamily \#include $<$Tensor\+Executor.\+h$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{struct_eigen_1_1internal_1_1_expression_has_tensor_broadcasting_op_a0701cf3c7dae5bff0a8e099812145bd2}\label{struct_eigen_1_1internal_1_1_expression_has_tensor_broadcasting_op_a0701cf3c7dae5bff0a8e099812145bd2}} 
enum \{ {\bfseries value} = false
 \}
\item 
\mbox{\Hypertarget{struct_eigen_1_1internal_1_1_expression_has_tensor_broadcasting_op_a4d688477f46d9463b405686f4f606fe0}\label{struct_eigen_1_1internal_1_1_expression_has_tensor_broadcasting_op_a4d688477f46d9463b405686f4f606fe0}} 
enum \{ {\bfseries value} = false
 \}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Expression$>$\newline
struct Eigen\+::internal\+::\+Expression\+Has\+Tensor\+Broadcasting\+Op$<$ Expression $>$}

Evaluating \mbox{\hyperlink{class_eigen_1_1_tensor_broadcasting_op}{Tensor\+Broadcasting\+Op}} via coefficient of packet path is extremely expensive. If expression has at least one broadcast op in it, and it supports block based evaluation, we always prefer it, even for the small tensors. For all other tileable ops, block evaluation overhead for small tensors (fits into L1) is too large, and we fallback on vectorized evaluation. 

The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/eigen/unsupported/\+Eigen/\+C\+X\+X11/src/\+Tensor/Tensor\+Executor.\+h\end{DoxyCompactItemize}
