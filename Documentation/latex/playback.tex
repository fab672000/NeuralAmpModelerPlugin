In this example, we provide a complete program that demonstrates the use of \mbox{\hyperlink{class_rt_audio}{Rt\+Audio}} for audio playback. Our program produces a two-\/channel sawtooth waveform for output.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include "\mbox{\hyperlink{_rt_audio_8h}{RtAudio.h}}"}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <iostream>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <cstdlib>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{comment}{// Two-\/channel sawtooth wave generator.}}
\DoxyCodeLine{\textcolor{keywordtype}{int} saw( \textcolor{keywordtype}{void} *outputBuffer, \textcolor{keywordtype}{void} *inputBuffer, \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} nBufferFrames,}
\DoxyCodeLine{         \textcolor{keywordtype}{double} streamTime, \mbox{\hyperlink{_rt_audio_8h_a80e306d363583da3b0a1b65d9b57c806}{RtAudioStreamStatus}} status, \textcolor{keywordtype}{void} *userData )}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} i, j;}
\DoxyCodeLine{  \textcolor{keywordtype}{double} *\mbox{\hyperlink{structbuffer}{buffer}} = (\textcolor{keywordtype}{double} *) outputBuffer;}
\DoxyCodeLine{  \textcolor{keywordtype}{double} *lastValues = (\textcolor{keywordtype}{double} *) userData;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordflow}{if} ( status )}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"Stream underflow detected!"} << std::endl;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// Write interleaved audio data.}}
\DoxyCodeLine{  \textcolor{keywordflow}{for} ( i=0; i<nBufferFrames; i++ ) \{}
\DoxyCodeLine{    \textcolor{keywordflow}{for} ( j=0; j<2; j++ ) \{}
\DoxyCodeLine{      *\mbox{\hyperlink{structbuffer}{buffer}}++ = lastValues[j];}
\DoxyCodeLine{}
\DoxyCodeLine{      lastValues[j] += 0.005 * (j+1+(j*0.1));}
\DoxyCodeLine{      \textcolor{keywordflow}{if} ( lastValues[j] >= 1.0 ) lastValues[j] -\/= 2.0;}
\DoxyCodeLine{    \}}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \mbox{\hyperlink{class_rt_audio}{RtAudio}} dac;}
\DoxyCodeLine{  \textcolor{keywordflow}{if} ( dac.getDeviceCount() < 1 ) \{}
\DoxyCodeLine{    std::cout << \textcolor{stringliteral}{"\(\backslash\)nNo audio devices found!\(\backslash\)n"};}
\DoxyCodeLine{    exit( 0 );}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \mbox{\hyperlink{struct_rt_audio_1_1_stream_parameters}{RtAudio::StreamParameters}} parameters;}
\DoxyCodeLine{  parameters.deviceId = dac.getDefaultOutputDevice();}
\DoxyCodeLine{  parameters.nChannels = 2;}
\DoxyCodeLine{  parameters.firstChannel = 0;}
\DoxyCodeLine{  \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} sampleRate = 44100;}
\DoxyCodeLine{  \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int} bufferFrames = 256; \textcolor{comment}{// 256 sample frames}}
\DoxyCodeLine{  \textcolor{keywordtype}{double} data[2];}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{    dac.openStream( \&parameters, \mbox{\hyperlink{utypes_8h_a070d2ce7b6bb7e5c05602aa8c308d0c4}{NULL}}, RTAUDIO\_FLOAT64,}
\DoxyCodeLine{                    sampleRate, \&bufferFrames, \&saw, (\textcolor{keywordtype}{void} *)\&data );}
\DoxyCodeLine{    dac.startStream();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  \textcolor{keywordflow}{catch} ( \mbox{\hyperlink{class_rt_audio_error}{RtAudioError}}\& \mbox{\hyperlink{group__gtc__constants_ga4b7956eb6e2fbedfc7cf2e46e85c5139}{e}} ) \{}
\DoxyCodeLine{    \mbox{\hyperlink{group__gtc__constants_ga4b7956eb6e2fbedfc7cf2e46e85c5139}{e}}.printMessage();}
\DoxyCodeLine{    exit( 0 );}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  }
\DoxyCodeLine{  \textcolor{keywordtype}{char} input;}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"\(\backslash\)nPlaying ... press <enter> to quit.\(\backslash\)n"};}
\DoxyCodeLine{  std::cin.get( input );}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordflow}{try} \{}
\DoxyCodeLine{    \textcolor{comment}{// Stop the stream}}
\DoxyCodeLine{    dac.stopStream();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{  \textcolor{keywordflow}{catch} (\mbox{\hyperlink{class_rt_audio_error}{RtAudioError}}\& \mbox{\hyperlink{group__gtc__constants_ga4b7956eb6e2fbedfc7cf2e46e85c5139}{e}}) \{}
\DoxyCodeLine{    \mbox{\hyperlink{group__gtc__constants_ga4b7956eb6e2fbedfc7cf2e46e85c5139}{e}}.printMessage();}
\DoxyCodeLine{  \}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordflow}{if} ( dac.isStreamOpen() ) dac.closeStream();}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


We open the stream in exactly the same way as the previous example (except with a data format change) and specify the address of our callback function {\itshape \char`\"{}saw()\char`\"{}}. The callback function will automatically be invoked when the underlying audio system needs data for output. Note that the callback function is called only when the stream is \char`\"{}running\char`\"{} (between calls to the \mbox{\hyperlink{class_rt_audio_aec017a89629ccef66a90b60be22a2f80}{Rt\+Audio\+::start\+Stream()}} and \mbox{\hyperlink{class_rt_audio_af4c241ff86936ecc8108f0d9dfe3efdd}{Rt\+Audio\+::stop\+Stream()}} functions). We can also pass a pointer value to the \mbox{\hyperlink{class_rt_audio_a6907539d2527775df778ebce32ef1e3b}{Rt\+Audio\+::open\+Stream()}} function that is made available in the callback function. In this way, it is possible to gain access to arbitrary data created in our {\itshape main()} function from within the globally defined callback function.

In this example, we stop the stream with an explicit call to \mbox{\hyperlink{class_rt_audio_af4c241ff86936ecc8108f0d9dfe3efdd}{Rt\+Audio\+::stop\+Stream()}}. It is also possible to stop a stream by returning a non-\/zero value from the callback function. A return value of 1 will cause the stream to finish draining its internal buffers and then halt (equivalent to calling the \mbox{\hyperlink{class_rt_audio_af4c241ff86936ecc8108f0d9dfe3efdd}{Rt\+Audio\+::stop\+Stream()}} function). A return value of 2 will cause the stream to stop immediately (equivalent to calling the \mbox{\hyperlink{class_rt_audio_ad0586b47cd6bb9591a80b4052815991f}{Rt\+Audio\+::abort\+Stream()}} function). 