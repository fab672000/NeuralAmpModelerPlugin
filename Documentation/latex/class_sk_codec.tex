\hypertarget{class_sk_codec}{}\doxysection{Sk\+Codec Class Reference}
\label{class_sk_codec}\index{SkCodec@{SkCodec}}


{\ttfamily \#include $<$Sk\+Codec.\+h$>$}

Inheritance diagram for Sk\+Codec\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_sk_codec}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_sk_codec_1_1_frame_info}{Frame\+Info}}
\item 
struct \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} \{ \newline
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0af28b992d9388cc8642654166640ec1f5}{k\+Success}}, 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0a281db21a336583487cd0bd21a9c4ac7e}{k\+Incomplete\+Input}}, 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0af58aff50960c54080c1601b94b43420a}{k\+Error\+In\+Input}}, 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0a02c7eafb6cbb102d5e37da5adb243453}{k\+Invalid\+Conversion}}, 
\newline
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0a0f22b10314f4485a95b8de52c85c62e9}{k\+Invalid\+Scale}}, 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0aa164f152463ccb4d3eba3979de1d729b}{k\+Invalid\+Parameters}}, 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0a9b5d53c120a6aa375a3226d23f1a77fb}{k\+Invalid\+Input}}, 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0aa749a4b6013200f97e945ee7d2029a10}{k\+Could\+Not\+Rewind}}, 
\newline
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0aa3976b51cdb453b2b9a0a25621f58be0}{k\+Internal\+Error}}, 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0abaeee713abd66d9a77ff5696a73d8805}{k\+Unimplemented}}
 \}
\item 
enum \mbox{\hyperlink{class_sk_codec_ab54f614159c048c5fc7065e3558e966e}{Selection\+Policy}} \{ \mbox{\hyperlink{class_sk_codec_ab54f614159c048c5fc7065e3558e966ea5136a0dddb26f4ca4844b54ca82fad5d}{Selection\+Policy\+::k\+Prefer\+Still\+Image}}, 
\mbox{\hyperlink{class_sk_codec_ab54f614159c048c5fc7065e3558e966ea9c4e30992ac98b63be20b56930376d7f}{Selection\+Policy\+::k\+Prefer\+Animation}}
 \}
\item 
enum \mbox{\hyperlink{class_sk_codec_a63868ae492c5effb2196d3f40f5b8ad8}{Zero\+Initialized}} \{ \mbox{\hyperlink{class_sk_codec_a63868ae492c5effb2196d3f40f5b8ad8a174e9e42ebf13bdec44f5676438872f5}{k\+Yes\+\_\+\+Zero\+Initialized}}, 
\mbox{\hyperlink{class_sk_codec_a63868ae492c5effb2196d3f40f5b8ad8a5e57df28301694970868c2c9196bc4c9}{k\+No\+\_\+\+Zero\+Initialized}}
 \}
\item 
enum \mbox{\hyperlink{class_sk_codec_a77847b2f814711a4e08d1d10147bb884}{Sk\+Scanline\+Order}} \{ {\bfseries k\+Top\+Down\+\_\+\+Sk\+Scanline\+Order}, 
{\bfseries k\+Bottom\+Up\+\_\+\+Sk\+Scanline\+Order}
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \mbox{\hyperlink{class_sk_codec_af08867a592789e9577ae2e7d3933d292}{get\+Info}} () const
\item 
\mbox{\Hypertarget{class_sk_codec_a35805ee38cc2254edde820945cfb9103}\label{class_sk_codec_a35805ee38cc2254edde820945cfb9103}} 
\mbox{\hyperlink{struct_sk_i_size}{Sk\+I\+Size}} {\bfseries dimensions} () const
\item 
\mbox{\Hypertarget{class_sk_codec_a6a0770def081538abb95f95f8b007d34}\label{class_sk_codec_a6a0770def081538abb95f95f8b007d34}} 
\mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} {\bfseries bounds} () const
\item 
const \mbox{\hyperlink{structskcms___i_c_c_profile}{skcms\+\_\+\+I\+C\+C\+Profile}} $\ast$ \mbox{\hyperlink{class_sk_codec_a0f0138a8ac40a3dceddbcbbd5b9215e8}{get\+I\+C\+C\+Profile}} () const
\item 
Sk\+Encoded\+Origin \mbox{\hyperlink{class_sk_codec_ae4f6e062472900190f71c56be5f43144}{get\+Origin}} () const
\item 
\mbox{\hyperlink{struct_sk_i_size}{Sk\+I\+Size}} \mbox{\hyperlink{class_sk_codec_ac4729235361cb7f387688c9ac40b79f3}{get\+Scaled\+Dimensions}} (float desired\+Scale) const
\item 
bool \mbox{\hyperlink{class_sk_codec_a1da8966fb6dabd6584f955c0f5e70aee}{get\+Valid\+Subset}} (\mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} $\ast$desired\+Subset) const
\item 
Sk\+Encoded\+Image\+Format \mbox{\hyperlink{class_sk_codec_aa7573e6b32c540dfc3f67b9eaeef1bd5}{get\+Encoded\+Format}} () const
\item 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} \mbox{\hyperlink{class_sk_codec_affddeb85741238d2a275cedf1f627da5}{get\+Pixels}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&info, void $\ast$pixels, size\+\_\+t row\+Bytes, const \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}} $\ast$)
\item 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} \mbox{\hyperlink{class_sk_codec_a6d622127e713e0f623e9defebca4f773}{get\+Pixels}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&info, void $\ast$pixels, size\+\_\+t row\+Bytes)
\item 
\mbox{\Hypertarget{class_sk_codec_a70bb647fdbffc2732c8255532d6fd860}\label{class_sk_codec_a70bb647fdbffc2732c8255532d6fd860}} 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} {\bfseries get\+Pixels} (const \mbox{\hyperlink{class_sk_pixmap}{Sk\+Pixmap}} \&pm, const \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}} $\ast$opts=nullptr)
\item 
std\+::tuple$<$ \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image}{Sk\+Image}} $>$, \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Sk\+Codec\+::\+Result}} $>$ \mbox{\hyperlink{class_sk_codec_aa9f54973c7ea1d57062c3f9d49eea634}{get\+Image}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&info, const \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}} $\ast$opts=nullptr)
\item 
\mbox{\Hypertarget{class_sk_codec_a4832e34cbd4a004fea6c86c2ae7f9a38}\label{class_sk_codec_a4832e34cbd4a004fea6c86c2ae7f9a38}} 
std\+::tuple$<$ \mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_image}{Sk\+Image}} $>$, \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Sk\+Codec\+::\+Result}} $>$ {\bfseries get\+Image} ()
\item 
bool \mbox{\hyperlink{class_sk_codec_a4fa1d1b5ac807579b98bf56678c87e7b}{query\+Y\+U\+V\+A\+Info}} (const \mbox{\hyperlink{class_sk_y_u_v_a_pixmap_info_1_1_supported_data_types}{Sk\+Y\+U\+V\+A\+Pixmap\+Info\+::\+Supported\+Data\+Types}} \&supported\+Data\+Types, \mbox{\hyperlink{class_sk_y_u_v_a_pixmap_info}{Sk\+Y\+U\+V\+A\+Pixmap\+Info}} $\ast$yuva\+Pixmap\+Info) const
\item 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} \mbox{\hyperlink{class_sk_codec_a3fa230b3f5cfd8baf4e12778c7264fd2}{get\+Y\+U\+V\+A\+Planes}} (const \mbox{\hyperlink{class_sk_y_u_v_a_pixmaps}{Sk\+Y\+U\+V\+A\+Pixmaps}} \&yuva\+Pixmaps)
\item 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} \mbox{\hyperlink{class_sk_codec_adc8b46291b91638c58391665f7a96b5b}{start\+Incremental\+Decode}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&dst\+Info, void $\ast$dst, size\+\_\+t row\+Bytes, const \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}} $\ast$)
\item 
\mbox{\Hypertarget{class_sk_codec_ad6324de4de977f9db266c6bd113f4376}\label{class_sk_codec_ad6324de4de977f9db266c6bd113f4376}} 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} {\bfseries start\+Incremental\+Decode} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&dst\+Info, void $\ast$dst, size\+\_\+t row\+Bytes)
\item 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} \mbox{\hyperlink{class_sk_codec_a9da5958ea146f27a624285cbd4e280ad}{incremental\+Decode}} (int $\ast$rows\+Decoded=nullptr)
\item 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} \mbox{\hyperlink{class_sk_codec_a952a6ca87c12d4c2482bd54c4eda1ba9}{start\+Scanline\+Decode}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&dst\+Info, const \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}} $\ast$options)
\item 
\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} \mbox{\hyperlink{class_sk_codec_ade349e283630bdf80d816e89f0d250cb}{start\+Scanline\+Decode}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&dst\+Info)
\item 
int \mbox{\hyperlink{class_sk_codec_a05d129c55ba6889be63c790918a0e374}{get\+Scanlines}} (void $\ast$dst, int count\+Lines, size\+\_\+t row\+Bytes)
\item 
bool \mbox{\hyperlink{class_sk_codec_af07efc4311f76f25535969998b2d2377}{skip\+Scanlines}} (int count\+Lines)
\item 
\mbox{\hyperlink{class_sk_codec_a77847b2f814711a4e08d1d10147bb884}{Sk\+Scanline\+Order}} \mbox{\hyperlink{class_sk_codec_a960496ac4d6f886b99878aaeb0901a5e}{get\+Scanline\+Order}} () const
\item 
int \mbox{\hyperlink{class_sk_codec_af6c8cfaf7754ca3929626a010df66392}{next\+Scanline}} () const
\item 
int \mbox{\hyperlink{class_sk_codec_ad81cd31a6144db8eddf7b96246a1ec08}{output\+Scanline}} (int input\+Scanline) const
\item 
int \mbox{\hyperlink{class_sk_codec_a82806b5f7b331a4152cc529703afdf2b}{get\+Frame\+Count}} ()
\item 
bool \mbox{\hyperlink{class_sk_codec_a0365f020979f47404572d0e0e85e42f4}{get\+Frame\+Info}} (int index, \mbox{\hyperlink{struct_sk_codec_1_1_frame_info}{Frame\+Info}} $\ast$info) const
\item 
std\+::vector$<$ \mbox{\hyperlink{struct_sk_codec_1_1_frame_info}{Frame\+Info}} $>$ \mbox{\hyperlink{class_sk_codec_a10d73b25fe06bdbc28a62abf7bc8ea66}{get\+Frame\+Info}} ()
\item 
int \mbox{\hyperlink{class_sk_codec_a3b34fa67ae57bca7dc50c717d7cdad09}{get\+Repetition\+Count}} ()
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static constexpr size\+\_\+t \mbox{\hyperlink{class_sk_codec_a619e4149e0eeda445f561f1d850d70e9}{Min\+Buffered\+Bytes\+Needed}} ()
\item 
static const char $\ast$ \mbox{\hyperlink{class_sk_codec_ab7733c4d013384bfec645aa0c9c8249e}{Result\+To\+String}} (\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}})
\item 
static std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{class_sk_codec}{Sk\+Codec}} $>$ \mbox{\hyperlink{class_sk_codec_ab3704593dd81ecd2b5c2962c0687a309}{Make\+From\+Stream}} (std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{class_sk_stream}{Sk\+Stream}} $>$, \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} $\ast$=nullptr, \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} $\ast$=nullptr, \mbox{\hyperlink{class_sk_codec_ab54f614159c048c5fc7065e3558e966e}{Selection\+Policy}} selection\+Policy=\mbox{\hyperlink{class_sk_codec_ab54f614159c048c5fc7065e3558e966ea5136a0dddb26f4ca4844b54ca82fad5d}{Selection\+Policy\+::k\+Prefer\+Still\+Image}})
\item 
static std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{class_sk_codec}{Sk\+Codec}} $>$ \mbox{\hyperlink{class_sk_codec_a7dc7c7b794754dfe2302a74553149980}{Make\+From\+Data}} (\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$, \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} $\ast$=nullptr)
\item 
\mbox{\Hypertarget{class_sk_codec_a7c716f571200130fcd1dc1ce7c3d0614}\label{class_sk_codec_a7c716f571200130fcd1dc1ce7c3d0614}} 
static void {\bfseries Register} (bool($\ast$peek)(const void $\ast$, size\+\_\+t), std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{class_sk_codec}{Sk\+Codec}} $>$($\ast$make)(std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{class_sk_stream}{Sk\+Stream}} $>$, \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Sk\+Codec\+::\+Result}} $\ast$))
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_codec_aea5d645540a83c7c6d88e29791e86567}\label{class_sk_codec_aea5d645540a83c7c6d88e29791e86567}} 
static constexpr int {\bfseries k\+No\+Frame} = -\/1
\item 
\mbox{\Hypertarget{class_sk_codec_abd490dd156e8a8d89ee282a2d32b344c}\label{class_sk_codec_abd490dd156e8a8d89ee282a2d32b344c}} 
static constexpr int {\bfseries k\+Repetition\+Count\+Infinite} = -\/1
\end{DoxyCompactItemize}
\doxysubsection*{Protected Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_codec_a7a33c22ea36f93e17e53d2898a8b1c3d}\label{class_sk_codec_a7a33c22ea36f93e17e53d2898a8b1c3d}} 
using {\bfseries Xform\+Format} = skcms\+\_\+\+Pixel\+Format
\end{DoxyCompactItemize}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_codec_ab0b72e4c22b948d94ff88c63fe1c04f7}\label{class_sk_codec_ab0b72e4c22b948d94ff88c63fe1c04f7}} 
const \mbox{\hyperlink{struct_sk_encoded_info}{Sk\+Encoded\+Info}} \& {\bfseries get\+Encoded\+Info} () const
\item 
\mbox{\Hypertarget{class_sk_codec_a73a31c721e7e6de169aef649d25a08a6}\label{class_sk_codec_a73a31c721e7e6de169aef649d25a08a6}} 
{\bfseries Sk\+Codec} (\mbox{\hyperlink{struct_sk_encoded_info}{Sk\+Encoded\+Info}} \&\&, Xform\+Format src\+Format, std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{class_sk_stream}{Sk\+Stream}} $>$, Sk\+Encoded\+Origin=k\+Top\+Left\+\_\+\+Sk\+Encoded\+Origin)
\item 
\mbox{\Hypertarget{class_sk_codec_aaedb167064ff3e0323d9ba13e91b7808}\label{class_sk_codec_aaedb167064ff3e0323d9ba13e91b7808}} 
virtual \mbox{\hyperlink{struct_sk_i_size}{Sk\+I\+Size}} {\bfseries on\+Get\+Scaled\+Dimensions} (float) const
\item 
virtual bool \mbox{\hyperlink{class_sk_codec_a4eca650de18970858729e32bad46f70f}{on\+Dimensions\+Supported}} (const \mbox{\hyperlink{struct_sk_i_size}{Sk\+I\+Size}} \&)
\item 
\mbox{\Hypertarget{class_sk_codec_a30d72867b852c931dc8da70ce6d5493b}\label{class_sk_codec_a30d72867b852c931dc8da70ce6d5493b}} 
virtual Sk\+Encoded\+Image\+Format {\bfseries on\+Get\+Encoded\+Format} () const =0
\item 
virtual \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} \mbox{\hyperlink{class_sk_codec_a058da1d38eac36ad2165e47758e0adca}{on\+Get\+Pixels}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&info, void $\ast$pixels, size\+\_\+t row\+Bytes, const \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}} \&, int $\ast$rows\+Decoded)=0
\item 
\mbox{\Hypertarget{class_sk_codec_ab0bc8d621ca5ee02bcfa1ccaae74bd7f}\label{class_sk_codec_ab0bc8d621ca5ee02bcfa1ccaae74bd7f}} 
virtual bool {\bfseries on\+Query\+Y\+U\+V\+A\+Info} (const \mbox{\hyperlink{class_sk_y_u_v_a_pixmap_info_1_1_supported_data_types}{Sk\+Y\+U\+V\+A\+Pixmap\+Info\+::\+Supported\+Data\+Types}} \&, \mbox{\hyperlink{class_sk_y_u_v_a_pixmap_info}{Sk\+Y\+U\+V\+A\+Pixmap\+Info}} $\ast$) const
\item 
\mbox{\Hypertarget{class_sk_codec_a6898760a0f653e2beabb17c492d4a62c}\label{class_sk_codec_a6898760a0f653e2beabb17c492d4a62c}} 
virtual \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} {\bfseries on\+Get\+Y\+U\+V\+A\+Planes} (const \mbox{\hyperlink{class_sk_y_u_v_a_pixmaps}{Sk\+Y\+U\+V\+A\+Pixmaps}} \&)
\item 
\mbox{\Hypertarget{class_sk_codec_ae6c281d62d2f9c86ee6da59ff5901863}\label{class_sk_codec_ae6c281d62d2f9c86ee6da59ff5901863}} 
virtual bool {\bfseries on\+Get\+Valid\+Subset} (\mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} $\ast$) const
\item 
bool S\+K\+\_\+\+W\+A\+R\+N\+\_\+\+U\+N\+U\+S\+E\+D\+\_\+\+R\+E\+S\+U\+LT \mbox{\hyperlink{class_sk_codec_a7030ce3cb132ac1653a6b6ba3cf46e26}{rewind\+If\+Needed}} ()
\item 
virtual bool \mbox{\hyperlink{class_sk_codec_a13f3174541928a80dfe8ec3ac9d555a9}{on\+Rewind}} ()
\item 
\mbox{\hyperlink{class_sk_stream}{Sk\+Stream}} $\ast$ \mbox{\hyperlink{class_sk_codec_adae675dae4722d5bcadfe93bf6f8ab42}{stream}} ()
\item 
virtual \mbox{\hyperlink{class_sk_codec_a77847b2f814711a4e08d1d10147bb884}{Sk\+Scanline\+Order}} \mbox{\hyperlink{class_sk_codec_a4f0e3e7003c6a5ca380a13be9bd71c86}{on\+Get\+Scanline\+Order}} () const
\item 
\mbox{\Hypertarget{class_sk_codec_addd385519b060c27d2f938f01793adcf}\label{class_sk_codec_addd385519b060c27d2f938f01793adcf}} 
const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \& {\bfseries dst\+Info} () const
\item 
\mbox{\Hypertarget{class_sk_codec_a92bb3c3b61d416b6eab718f179757f49}\label{class_sk_codec_a92bb3c3b61d416b6eab718f179757f49}} 
const \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}} \& {\bfseries options} () const
\item 
int \mbox{\hyperlink{class_sk_codec_a932c2f4ce92c8e7683514de6145d3e11}{curr\+Scanline}} () const
\item 
\mbox{\Hypertarget{class_sk_codec_ad005735716216519558b490ac5b27465}\label{class_sk_codec_ad005735716216519558b490ac5b27465}} 
virtual int {\bfseries on\+Output\+Scanline} (int input\+Scanline) const
\item 
virtual bool \mbox{\hyperlink{class_sk_codec_a9a9fad3de001df07534d56c80b785be5}{conversion\+Supported}} (const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&dst, bool src\+Is\+Opaque, bool needs\+Color\+Xform)
\item 
\mbox{\Hypertarget{class_sk_codec_aa3c019ce04b1e11c2aa2dc695b381b82}\label{class_sk_codec_aa3c019ce04b1e11c2aa2dc695b381b82}} 
virtual bool {\bfseries uses\+Color\+Xform} () const
\item 
\mbox{\Hypertarget{class_sk_codec_a52a301752a90f58d74103d60c8be6588}\label{class_sk_codec_a52a301752a90f58d74103d60c8be6588}} 
void {\bfseries apply\+Color\+Xform} (void $\ast$dst, const void $\ast$src, int count) const
\item 
\mbox{\Hypertarget{class_sk_codec_adc4bd2ffe1bc6cdfc685c640f9e19c46}\label{class_sk_codec_adc4bd2ffe1bc6cdfc685c640f9e19c46}} 
bool {\bfseries color\+Xform} () const
\item 
\mbox{\Hypertarget{class_sk_codec_a3fec65cb41e34965573878b29c371773}\label{class_sk_codec_a3fec65cb41e34965573878b29c371773}} 
bool {\bfseries xform\+On\+Decode} () const
\item 
\mbox{\Hypertarget{class_sk_codec_a8bc59f4ff13c3dbc0e9916b74bb4855f}\label{class_sk_codec_a8bc59f4ff13c3dbc0e9916b74bb4855f}} 
virtual int {\bfseries on\+Get\+Frame\+Count} ()
\item 
\mbox{\Hypertarget{class_sk_codec_a3ae0e4b7b36e3643a8e886c4c7a85593}\label{class_sk_codec_a3ae0e4b7b36e3643a8e886c4c7a85593}} 
virtual bool {\bfseries on\+Get\+Frame\+Info} (int, \mbox{\hyperlink{struct_sk_codec_1_1_frame_info}{Frame\+Info}} $\ast$) const
\item 
\mbox{\Hypertarget{class_sk_codec_a6dcff3cf2d9174695328fd3a27a37f7a}\label{class_sk_codec_a6dcff3cf2d9174695328fd3a27a37f7a}} 
virtual int {\bfseries on\+Get\+Repetition\+Count} ()
\end{DoxyCompactItemize}
\doxysubsection*{Friends}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_sk_codec_a1820206d2680c26ce73132f9a0c5350b}\label{class_sk_codec_a1820206d2680c26ce73132f9a0c5350b}} 
class {\bfseries D\+M\+::\+Codec\+Src}
\item 
\mbox{\Hypertarget{class_sk_codec_a2deb5590aca86113255c90b4eb83be4b}\label{class_sk_codec_a2deb5590aca86113255c90b4eb83be4b}} 
class {\bfseries Sk\+Sampled\+Codec}
\item 
\mbox{\Hypertarget{class_sk_codec_aa25c2d44ceabc930ced51c55062dfe27}\label{class_sk_codec_aa25c2d44ceabc930ced51c55062dfe27}} 
class {\bfseries Sk\+Ico\+Codec}
\item 
\mbox{\Hypertarget{class_sk_codec_a0a860e3aed81ec6a11fc97b56fb832d6}\label{class_sk_codec_a0a860e3aed81ec6a11fc97b56fb832d6}} 
class {\bfseries Sk\+Android\+Codec}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Abstraction layer directly on top of an image codec. 

\doxysubsection{Member Enumeration Documentation}
\mbox{\Hypertarget{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}\label{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}} 
\index{SkCodec@{SkCodec}!Result@{Result}}
\index{Result@{Result}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{Result}{Result}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Sk\+Codec\+::\+Result}}}

Error codes for various \mbox{\hyperlink{class_sk_codec}{Sk\+Codec}} methods. \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kSuccess@{kSuccess}!SkCodec@{SkCodec}}\index{SkCodec@{SkCodec}!kSuccess@{kSuccess}}}\mbox{\Hypertarget{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0af28b992d9388cc8642654166640ec1f5}\label{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0af28b992d9388cc8642654166640ec1f5}} 
k\+Success&General return value for success. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kIncompleteInput@{kIncompleteInput}!SkCodec@{SkCodec}}\index{SkCodec@{SkCodec}!kIncompleteInput@{kIncompleteInput}}}\mbox{\Hypertarget{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0a281db21a336583487cd0bd21a9c4ac7e}\label{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0a281db21a336583487cd0bd21a9c4ac7e}} 
k\+Incomplete\+Input&The input is incomplete. A partial image was generated. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kErrorInInput@{kErrorInInput}!SkCodec@{SkCodec}}\index{SkCodec@{SkCodec}!kErrorInInput@{kErrorInInput}}}\mbox{\Hypertarget{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0af58aff50960c54080c1601b94b43420a}\label{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0af58aff50960c54080c1601b94b43420a}} 
k\+Error\+In\+Input&Like k\+Incomplete\+Input, except the input had an error.

If returned from an incremental decode, decoding cannot continue, even with more data. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kInvalidConversion@{kInvalidConversion}!SkCodec@{SkCodec}}\index{SkCodec@{SkCodec}!kInvalidConversion@{kInvalidConversion}}}\mbox{\Hypertarget{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0a02c7eafb6cbb102d5e37da5adb243453}\label{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0a02c7eafb6cbb102d5e37da5adb243453}} 
k\+Invalid\+Conversion&The generator cannot convert to match the request, ignoring dimensions. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kInvalidScale@{kInvalidScale}!SkCodec@{SkCodec}}\index{SkCodec@{SkCodec}!kInvalidScale@{kInvalidScale}}}\mbox{\Hypertarget{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0a0f22b10314f4485a95b8de52c85c62e9}\label{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0a0f22b10314f4485a95b8de52c85c62e9}} 
k\+Invalid\+Scale&The generator cannot scale to requested size. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kInvalidParameters@{kInvalidParameters}!SkCodec@{SkCodec}}\index{SkCodec@{SkCodec}!kInvalidParameters@{kInvalidParameters}}}\mbox{\Hypertarget{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0aa164f152463ccb4d3eba3979de1d729b}\label{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0aa164f152463ccb4d3eba3979de1d729b}} 
k\+Invalid\+Parameters&Parameters (besides info) are invalid. e.\+g. N\+U\+LL pixels, row\+Bytes too small, etc. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kInvalidInput@{kInvalidInput}!SkCodec@{SkCodec}}\index{SkCodec@{SkCodec}!kInvalidInput@{kInvalidInput}}}\mbox{\Hypertarget{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0a9b5d53c120a6aa375a3226d23f1a77fb}\label{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0a9b5d53c120a6aa375a3226d23f1a77fb}} 
k\+Invalid\+Input&The input did not contain a valid image. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kCouldNotRewind@{kCouldNotRewind}!SkCodec@{SkCodec}}\index{SkCodec@{SkCodec}!kCouldNotRewind@{kCouldNotRewind}}}\mbox{\Hypertarget{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0aa749a4b6013200f97e945ee7d2029a10}\label{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0aa749a4b6013200f97e945ee7d2029a10}} 
k\+Could\+Not\+Rewind&Fulfilling this request requires rewinding the input, which is not supported for this input. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kInternalError@{kInternalError}!SkCodec@{SkCodec}}\index{SkCodec@{SkCodec}!kInternalError@{kInternalError}}}\mbox{\Hypertarget{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0aa3976b51cdb453b2b9a0a25621f58be0}\label{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0aa3976b51cdb453b2b9a0a25621f58be0}} 
k\+Internal\+Error&An internal error, such as O\+OM. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kUnimplemented@{kUnimplemented}!SkCodec@{SkCodec}}\index{SkCodec@{SkCodec}!kUnimplemented@{kUnimplemented}}}\mbox{\Hypertarget{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0abaeee713abd66d9a77ff5696a73d8805}\label{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0abaeee713abd66d9a77ff5696a73d8805}} 
k\+Unimplemented&This method is not implemented by this codec. F\+I\+X\+ME\+: Perhaps this should be k\+Unsupported? \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{class_sk_codec_ab54f614159c048c5fc7065e3558e966e}\label{class_sk_codec_ab54f614159c048c5fc7065e3558e966e}} 
\index{SkCodec@{SkCodec}!SelectionPolicy@{SelectionPolicy}}
\index{SelectionPolicy@{SelectionPolicy}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{SelectionPolicy}{SelectionPolicy}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{class_sk_codec_ab54f614159c048c5fc7065e3558e966e}{Sk\+Codec\+::\+Selection\+Policy}}\hspace{0.3cm}{\ttfamily [strong]}}

For container formats that contain both still images and image sequences, instruct the decoder how the output should be selected. (Refer to comments for each value for more details.) \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kPreferStillImage@{kPreferStillImage}!SkCodec@{SkCodec}}\index{SkCodec@{SkCodec}!kPreferStillImage@{kPreferStillImage}}}\mbox{\Hypertarget{class_sk_codec_ab54f614159c048c5fc7065e3558e966ea5136a0dddb26f4ca4844b54ca82fad5d}\label{class_sk_codec_ab54f614159c048c5fc7065e3558e966ea5136a0dddb26f4ca4844b54ca82fad5d}} 
k\+Prefer\+Still\+Image&If the container format contains both still images and image sequences, \mbox{\hyperlink{class_sk_codec}{Sk\+Codec}} should choose one of the still images. This is the default. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kPreferAnimation@{kPreferAnimation}!SkCodec@{SkCodec}}\index{SkCodec@{SkCodec}!kPreferAnimation@{kPreferAnimation}}}\mbox{\Hypertarget{class_sk_codec_ab54f614159c048c5fc7065e3558e966ea9c4e30992ac98b63be20b56930376d7f}\label{class_sk_codec_ab54f614159c048c5fc7065e3558e966ea9c4e30992ac98b63be20b56930376d7f}} 
k\+Prefer\+Animation&If the container format contains both still images and image sequences, \mbox{\hyperlink{class_sk_codec}{Sk\+Codec}} should choose one of the image sequences for animation. \\
\hline

\end{DoxyEnumFields}
\mbox{\Hypertarget{class_sk_codec_a77847b2f814711a4e08d1d10147bb884}\label{class_sk_codec_a77847b2f814711a4e08d1d10147bb884}} 
\index{SkCodec@{SkCodec}!SkScanlineOrder@{SkScanlineOrder}}
\index{SkScanlineOrder@{SkScanlineOrder}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{SkScanlineOrder}{SkScanlineOrder}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{class_sk_codec_a77847b2f814711a4e08d1d10147bb884}{Sk\+Codec\+::\+Sk\+Scanline\+Order}}}

The order in which rows are output from the scanline decoder is not the same for all variations of all image types. This explains the possible output row orderings. \mbox{\Hypertarget{class_sk_codec_a63868ae492c5effb2196d3f40f5b8ad8}\label{class_sk_codec_a63868ae492c5effb2196d3f40f5b8ad8}} 
\index{SkCodec@{SkCodec}!ZeroInitialized@{ZeroInitialized}}
\index{ZeroInitialized@{ZeroInitialized}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{ZeroInitialized}{ZeroInitialized}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{class_sk_codec_a63868ae492c5effb2196d3f40f5b8ad8}{Sk\+Codec\+::\+Zero\+Initialized}}}

Whether or not the memory passed to get\+Pixels is zero initialized. \begin{DoxyEnumFields}{Enumerator}
\raisebox{\heightof{T}}[0pt][0pt]{\index{kYes\_ZeroInitialized@{kYes\_ZeroInitialized}!SkCodec@{SkCodec}}\index{SkCodec@{SkCodec}!kYes\_ZeroInitialized@{kYes\_ZeroInitialized}}}\mbox{\Hypertarget{class_sk_codec_a63868ae492c5effb2196d3f40f5b8ad8a174e9e42ebf13bdec44f5676438872f5}\label{class_sk_codec_a63868ae492c5effb2196d3f40f5b8ad8a174e9e42ebf13bdec44f5676438872f5}} 
k\+Yes\+\_\+\+Zero\+Initialized&The memory passed to get\+Pixels is zero initialized. The \mbox{\hyperlink{class_sk_codec}{Sk\+Codec}} may take advantage of this by skipping writing zeroes. \\
\hline

\raisebox{\heightof{T}}[0pt][0pt]{\index{kNo\_ZeroInitialized@{kNo\_ZeroInitialized}!SkCodec@{SkCodec}}\index{SkCodec@{SkCodec}!kNo\_ZeroInitialized@{kNo\_ZeroInitialized}}}\mbox{\Hypertarget{class_sk_codec_a63868ae492c5effb2196d3f40f5b8ad8a5e57df28301694970868c2c9196bc4c9}\label{class_sk_codec_a63868ae492c5effb2196d3f40f5b8ad8a5e57df28301694970868c2c9196bc4c9}} 
k\+No\+\_\+\+Zero\+Initialized&The memory passed to get\+Pixels has not been initialized to zero, so the \mbox{\hyperlink{class_sk_codec}{Sk\+Codec}} must write all zeroes to memory.

This is the default. It will be used if no \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}} struct is used. \\
\hline

\end{DoxyEnumFields}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_codec_a9a9fad3de001df07534d56c80b785be5}\label{class_sk_codec_a9a9fad3de001df07534d56c80b785be5}} 
\index{SkCodec@{SkCodec}!conversionSupported@{conversionSupported}}
\index{conversionSupported@{conversionSupported}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{conversionSupported()}{conversionSupported()}}
{\footnotesize\ttfamily virtual bool Sk\+Codec\+::conversion\+Supported (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{dst,  }\item[{bool}]{src\+Is\+Opaque,  }\item[{bool}]{needs\+Color\+Xform }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}

Return whether we can convert to dst.

Will be called for the appropriate frame, prior to initializing the color\+Xform. \mbox{\Hypertarget{class_sk_codec_a932c2f4ce92c8e7683514de6145d3e11}\label{class_sk_codec_a932c2f4ce92c8e7683514de6145d3e11}} 
\index{SkCodec@{SkCodec}!currScanline@{currScanline}}
\index{currScanline@{currScanline}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{currScanline()}{currScanline()}}
{\footnotesize\ttfamily int Sk\+Codec\+::curr\+Scanline (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}

Returns the number of scanlines that have been decoded so far. This is unaffected by the Sk\+Scanline\+Order.

Returns -\/1 if we have not started a scanline decode. \mbox{\Hypertarget{class_sk_codec_aa7573e6b32c540dfc3f67b9eaeef1bd5}\label{class_sk_codec_aa7573e6b32c540dfc3f67b9eaeef1bd5}} 
\index{SkCodec@{SkCodec}!getEncodedFormat@{getEncodedFormat}}
\index{getEncodedFormat@{getEncodedFormat}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getEncodedFormat()}{getEncodedFormat()}}
{\footnotesize\ttfamily Sk\+Encoded\+Image\+Format Sk\+Codec\+::get\+Encoded\+Format (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Format of the encoded data. \mbox{\Hypertarget{class_sk_codec_a82806b5f7b331a4152cc529703afdf2b}\label{class_sk_codec_a82806b5f7b331a4152cc529703afdf2b}} 
\index{SkCodec@{SkCodec}!getFrameCount@{getFrameCount}}
\index{getFrameCount@{getFrameCount}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getFrameCount()}{getFrameCount()}}
{\footnotesize\ttfamily int Sk\+Codec\+::get\+Frame\+Count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Return the number of frames in the image.

May require reading through the stream. \mbox{\Hypertarget{class_sk_codec_a10d73b25fe06bdbc28a62abf7bc8ea66}\label{class_sk_codec_a10d73b25fe06bdbc28a62abf7bc8ea66}} 
\index{SkCodec@{SkCodec}!getFrameInfo@{getFrameInfo}}
\index{getFrameInfo@{getFrameInfo}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getFrameInfo()}{getFrameInfo()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily std\+::vector$<$\mbox{\hyperlink{struct_sk_codec_1_1_frame_info}{Frame\+Info}}$>$ Sk\+Codec\+::get\+Frame\+Info (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}

Return info about all the frames in the image.

May require reading through the stream to determine info about the frames (including the count).

As such, future decoding calls may require a rewind.

For still (non-\/animated) image codecs, this will return an empty vector. \mbox{\Hypertarget{class_sk_codec_a0365f020979f47404572d0e0e85e42f4}\label{class_sk_codec_a0365f020979f47404572d0e0e85e42f4}} 
\index{SkCodec@{SkCodec}!getFrameInfo@{getFrameInfo}}
\index{getFrameInfo@{getFrameInfo}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getFrameInfo()}{getFrameInfo()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily bool Sk\+Codec\+::get\+Frame\+Info (\begin{DoxyParamCaption}\item[{int}]{index,  }\item[{\mbox{\hyperlink{struct_sk_codec_1_1_frame_info}{Frame\+Info}} $\ast$}]{info }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return info about a single frame.

Only supported by multi-\/frame images. Does not read through the stream, so it should be called after \mbox{\hyperlink{class_sk_codec_a82806b5f7b331a4152cc529703afdf2b}{get\+Frame\+Count()}} to parse any frames that have not already been parsed. \mbox{\Hypertarget{class_sk_codec_a0f0138a8ac40a3dceddbcbbd5b9215e8}\label{class_sk_codec_a0f0138a8ac40a3dceddbcbbd5b9215e8}} 
\index{SkCodec@{SkCodec}!getICCProfile@{getICCProfile}}
\index{getICCProfile@{getICCProfile}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getICCProfile()}{getICCProfile()}}
{\footnotesize\ttfamily const \mbox{\hyperlink{structskcms___i_c_c_profile}{skcms\+\_\+\+I\+C\+C\+Profile}}$\ast$ Sk\+Codec\+::get\+I\+C\+C\+Profile (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return the I\+CC profile of the encoded data. \mbox{\Hypertarget{class_sk_codec_aa9f54973c7ea1d57062c3f9d49eea634}\label{class_sk_codec_aa9f54973c7ea1d57062c3f9d49eea634}} 
\index{SkCodec@{SkCodec}!getImage@{getImage}}
\index{getImage@{getImage}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getImage()}{getImage()}}
{\footnotesize\ttfamily std\+::tuple$<$\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$\mbox{\hyperlink{class_sk_image}{Sk\+Image}}$>$, \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Sk\+Codec\+::\+Result}}$>$ Sk\+Codec\+::get\+Image (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{info,  }\item[{const \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}} $\ast$}]{opts = {\ttfamily nullptr} }\end{DoxyParamCaption})}

Return an image containing the pixels. \mbox{\Hypertarget{class_sk_codec_af08867a592789e9577ae2e7d3933d292}\label{class_sk_codec_af08867a592789e9577ae2e7d3933d292}} 
\index{SkCodec@{SkCodec}!getInfo@{getInfo}}
\index{getInfo@{getInfo}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getInfo()}{getInfo()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} Sk\+Codec\+::get\+Info (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return a reasonable \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} to decode into.

If the image has an I\+CC profile that does not map to an \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}}, the returned \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} will use S\+R\+GB. \mbox{\Hypertarget{class_sk_codec_ae4f6e062472900190f71c56be5f43144}\label{class_sk_codec_ae4f6e062472900190f71c56be5f43144}} 
\index{SkCodec@{SkCodec}!getOrigin@{getOrigin}}
\index{getOrigin@{getOrigin}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getOrigin()}{getOrigin()}}
{\footnotesize\ttfamily Sk\+Encoded\+Origin Sk\+Codec\+::get\+Origin (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the image orientation stored in the E\+X\+IF data. If there is no E\+X\+IF data, or if we cannot read the E\+X\+IF data, returns k\+Top\+Left. \mbox{\Hypertarget{class_sk_codec_a6d622127e713e0f623e9defebca4f773}\label{class_sk_codec_a6d622127e713e0f623e9defebca4f773}} 
\index{SkCodec@{SkCodec}!getPixels@{getPixels}}
\index{getPixels@{getPixels}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getPixels()}{getPixels()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} Sk\+Codec\+::get\+Pixels (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{info,  }\item[{void $\ast$}]{pixels,  }\item[{size\+\_\+t}]{row\+Bytes }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Simplified version of \mbox{\hyperlink{class_sk_codec_affddeb85741238d2a275cedf1f627da5}{get\+Pixels()}} that uses the default \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}}. \mbox{\Hypertarget{class_sk_codec_affddeb85741238d2a275cedf1f627da5}\label{class_sk_codec_affddeb85741238d2a275cedf1f627da5}} 
\index{SkCodec@{SkCodec}!getPixels@{getPixels}}
\index{getPixels@{getPixels}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getPixels()}{getPixels()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} Sk\+Codec\+::get\+Pixels (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{info,  }\item[{void $\ast$}]{pixels,  }\item[{size\+\_\+t}]{row\+Bytes,  }\item[{const \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}} $\ast$}]{ }\end{DoxyParamCaption})}

Decode into the given pixels, a block of memory of size at least (info.\+f\+Height -\/ 1) $\ast$ row\+Bytes + (info.\+f\+Width $\ast$ bytes\+Per\+Pixel)

Repeated calls to this function should give the same results, allowing the Pixel\+Ref to be immutable.


\begin{DoxyParams}{Parameters}
{\em info} & A description of the format (config, size) expected by the caller. This can simply be identical to the info returned by \mbox{\hyperlink{class_sk_codec_af08867a592789e9577ae2e7d3933d292}{get\+Info()}}.\\
\hline
\end{DoxyParams}
This contract also allows the caller to specify different output-\/configs, which the implementation can decide to support or not.

A size that does not match \mbox{\hyperlink{class_sk_codec_af08867a592789e9577ae2e7d3933d292}{get\+Info()}} implies a request to scale. If the generator cannot perform this scale, it will return k\+Invalid\+Scale.

If the info contains a non-\/null \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}}, the codec will perform the appropriate color space transformation.

If the caller passes in the \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}} that maps to the I\+CC profile reported by \mbox{\hyperlink{class_sk_codec_a0f0138a8ac40a3dceddbcbbd5b9215e8}{get\+I\+C\+C\+Profile()}}, the color space transformation is a no-\/op.

If the caller passes a null \mbox{\hyperlink{class_sk_color_space}{Sk\+Color\+Space}}, no color space transformation will be done.

If a scanline decode is in progress, scanline mode will end, requiring the client to call \mbox{\hyperlink{class_sk_codec_a952a6ca87c12d4c2482bd54c4eda1ba9}{start\+Scanline\+Decode()}} in order to return to decoding scanlines.

\begin{DoxyReturn}{Returns}
Result k\+Success, or another value explaining the type of failure. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_codec_a3b34fa67ae57bca7dc50c717d7cdad09}\label{class_sk_codec_a3b34fa67ae57bca7dc50c717d7cdad09}} 
\index{SkCodec@{SkCodec}!getRepetitionCount@{getRepetitionCount}}
\index{getRepetitionCount@{getRepetitionCount}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getRepetitionCount()}{getRepetitionCount()}}
{\footnotesize\ttfamily int Sk\+Codec\+::get\+Repetition\+Count (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Return the number of times to repeat, if this image is animated. This number does not include the first play through of each frame. For example, a repetition count of 4 means that each frame is played 5 times and then the animation stops.

It can return k\+Repetition\+Count\+Infinite, a negative number, meaning that the animation should loop forever.

May require reading the stream to find the repetition count.

As such, future decoding calls may require a rewind.

For still (non-\/animated) image codecs, this will return 0. \mbox{\Hypertarget{class_sk_codec_ac4729235361cb7f387688c9ac40b79f3}\label{class_sk_codec_ac4729235361cb7f387688c9ac40b79f3}} 
\index{SkCodec@{SkCodec}!getScaledDimensions@{getScaledDimensions}}
\index{getScaledDimensions@{getScaledDimensions}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getScaledDimensions()}{getScaledDimensions()}}
{\footnotesize\ttfamily \mbox{\hyperlink{struct_sk_i_size}{Sk\+I\+Size}} Sk\+Codec\+::get\+Scaled\+Dimensions (\begin{DoxyParamCaption}\item[{float}]{desired\+Scale }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return a size that approximately supports the desired scale factor. The codec may not be able to scale efficiently to the exact scale factor requested, so return a size that approximates that scale. The returned value is the codec\textquotesingle{}s suggestion for the closest valid scale that it can natively support \mbox{\Hypertarget{class_sk_codec_a960496ac4d6f886b99878aaeb0901a5e}\label{class_sk_codec_a960496ac4d6f886b99878aaeb0901a5e}} 
\index{SkCodec@{SkCodec}!getScanlineOrder@{getScanlineOrder}}
\index{getScanlineOrder@{getScanlineOrder}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getScanlineOrder()}{getScanlineOrder()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_sk_codec_a77847b2f814711a4e08d1d10147bb884}{Sk\+Scanline\+Order}} Sk\+Codec\+::get\+Scanline\+Order (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

An enum representing the order in which scanlines will be returned by the scanline decoder.

This is undefined before \mbox{\hyperlink{class_sk_codec_a952a6ca87c12d4c2482bd54c4eda1ba9}{start\+Scanline\+Decode()}} is called. \mbox{\Hypertarget{class_sk_codec_a05d129c55ba6889be63c790918a0e374}\label{class_sk_codec_a05d129c55ba6889be63c790918a0e374}} 
\index{SkCodec@{SkCodec}!getScanlines@{getScanlines}}
\index{getScanlines@{getScanlines}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getScanlines()}{getScanlines()}}
{\footnotesize\ttfamily int Sk\+Codec\+::get\+Scanlines (\begin{DoxyParamCaption}\item[{void $\ast$}]{dst,  }\item[{int}]{count\+Lines,  }\item[{size\+\_\+t}]{row\+Bytes }\end{DoxyParamCaption})}

Write the next count\+Lines scanlines into dst.

Not valid to call before calling \mbox{\hyperlink{class_sk_codec_a952a6ca87c12d4c2482bd54c4eda1ba9}{start\+Scanline\+Decode()}}.


\begin{DoxyParams}{Parameters}
{\em dst} & Must be non-\/null, and large enough to hold count\+Lines scanlines of size row\+Bytes. \\
\hline
{\em count\+Lines} & Number of lines to write. \\
\hline
{\em row\+Bytes} & Number of bytes per row. Must be large enough to hold a scanline based on the \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} used to create this object. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of lines successfully decoded. If this value is less than count\+Lines, this will fill the remaining lines with a default value. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_codec_a1da8966fb6dabd6584f955c0f5e70aee}\label{class_sk_codec_a1da8966fb6dabd6584f955c0f5e70aee}} 
\index{SkCodec@{SkCodec}!getValidSubset@{getValidSubset}}
\index{getValidSubset@{getValidSubset}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getValidSubset()}{getValidSubset()}}
{\footnotesize\ttfamily bool Sk\+Codec\+::get\+Valid\+Subset (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{struct_sk_i_rect}{Sk\+I\+Rect}} $\ast$}]{desired\+Subset }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Return (via desired\+Subset) a subset which can decoded from this codec, or false if this codec cannot decode subsets or anything similar to desired\+Subset.


\begin{DoxyParams}{Parameters}
{\em desired\+Subset} & In/out parameter. As input, a desired subset of the original bounds (as specified by get\+Info). If true is returned, desired\+Subset may have been modified to a subset which is supported. Although a particular change may have been made to desired\+Subset to create something supported, it is possible other changes could result in a valid subset. If false is returned, desired\+Subset\textquotesingle{}s value is undefined. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if this codec supports decoding desired\+Subset (as returned, potentially modified) 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_codec_a3fa230b3f5cfd8baf4e12778c7264fd2}\label{class_sk_codec_a3fa230b3f5cfd8baf4e12778c7264fd2}} 
\index{SkCodec@{SkCodec}!getYUVAPlanes@{getYUVAPlanes}}
\index{getYUVAPlanes@{getYUVAPlanes}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{getYUVAPlanes()}{getYUVAPlanes()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} Sk\+Codec\+::get\+Y\+U\+V\+A\+Planes (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_y_u_v_a_pixmaps}{Sk\+Y\+U\+V\+A\+Pixmaps}} \&}]{yuva\+Pixmaps }\end{DoxyParamCaption})}

Returns k\+Success, or another value explaining the type of failure. This always attempts to perform a full decode. To get the planar configuration without decoding use \mbox{\hyperlink{class_sk_codec_a4fa1d1b5ac807579b98bf56678c87e7b}{query\+Y\+U\+V\+A\+Info()}}.


\begin{DoxyParams}{Parameters}
{\em yuva\+Pixmaps} & Contains preallocated pixmaps configured according to a successful call to \mbox{\hyperlink{class_sk_codec_a4fa1d1b5ac807579b98bf56678c87e7b}{query\+Y\+U\+V\+A\+Info()}}. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_codec_a9da5958ea146f27a624285cbd4e280ad}\label{class_sk_codec_a9da5958ea146f27a624285cbd4e280ad}} 
\index{SkCodec@{SkCodec}!incrementalDecode@{incrementalDecode}}
\index{incrementalDecode@{incrementalDecode}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{incrementalDecode()}{incrementalDecode()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} Sk\+Codec\+::incremental\+Decode (\begin{DoxyParamCaption}\item[{int $\ast$}]{rows\+Decoded = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Start/continue the incremental decode.

Not valid to call before a call to \mbox{\hyperlink{class_sk_codec_adc8b46291b91638c58391665f7a96b5b}{start\+Incremental\+Decode()}} returns k\+Success.

If k\+Incomplete\+Input is returned, may be called again after more data has been provided to the source \mbox{\hyperlink{class_sk_stream}{Sk\+Stream}}.

Unlike get\+Pixels and get\+Scanlines, this does not do any filling. This is left up to the caller, since they may be skipping lines or continuing the decode later. In the latter case, they may choose to initialize all lines first, or only initialize the remaining lines after the first call.


\begin{DoxyParams}{Parameters}
{\em rows\+Decoded} & Optional output variable returning the total number of lines initialized. Only meaningful if this method returns k\+Incomplete\+Input. Otherwise the implementation may not set it. Note that some implementations may have initialized this many rows, but not necessarily finished those rows (e.\+g. interlaced P\+NG). This may be useful for determining what rows the client needs to initialize. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
k\+Success if all lines requested in start\+Incremental\+Decode have been completely decoded. k\+Incomplete\+Input otherwise. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_codec_a7dc7c7b794754dfe2302a74553149980}\label{class_sk_codec_a7dc7c7b794754dfe2302a74553149980}} 
\index{SkCodec@{SkCodec}!MakeFromData@{MakeFromData}}
\index{MakeFromData@{MakeFromData}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{MakeFromData()}{MakeFromData()}}
{\footnotesize\ttfamily static std\+::unique\+\_\+ptr$<$\mbox{\hyperlink{class_sk_codec}{Sk\+Codec}}$>$ Sk\+Codec\+::\+Make\+From\+Data (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{classsk__sp}{sk\+\_\+sp}}$<$ \mbox{\hyperlink{class_sk_data}{Sk\+Data}} $>$}]{,  }\item[{\mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} $\ast$}]{ = {\ttfamily nullptr} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

If this data represents an encoded image that we know how to decode, return an \mbox{\hyperlink{class_sk_codec}{Sk\+Codec}} that can decode it. Otherwise return N\+U\+LL.

If the \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} is not N\+U\+LL then\+: If the image is not a P\+NG, the \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} will be ignored. If the image is a P\+NG, the \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} will be reffed. If the P\+NG has unknown chunks, the \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} will be used to handle these chunks. \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} will be called to read any unknown chunk at any point during the creation of the codec or the decode. Note that if \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} fails to read a chunk, this could result in a failure to create the codec or a failure to decode the image. If the P\+NG does not contain unknown chunks, the \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} will not be used or modified. \mbox{\Hypertarget{class_sk_codec_ab3704593dd81ecd2b5c2962c0687a309}\label{class_sk_codec_ab3704593dd81ecd2b5c2962c0687a309}} 
\index{SkCodec@{SkCodec}!MakeFromStream@{MakeFromStream}}
\index{MakeFromStream@{MakeFromStream}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{MakeFromStream()}{MakeFromStream()}}
{\footnotesize\ttfamily static std\+::unique\+\_\+ptr$<$\mbox{\hyperlink{class_sk_codec}{Sk\+Codec}}$>$ Sk\+Codec\+::\+Make\+From\+Stream (\begin{DoxyParamCaption}\item[{std\+::unique\+\_\+ptr$<$ \mbox{\hyperlink{class_sk_stream}{Sk\+Stream}} $>$}]{,  }\item[{\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} $\ast$}]{ = {\ttfamily nullptr},  }\item[{\mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} $\ast$}]{ = {\ttfamily nullptr},  }\item[{\mbox{\hyperlink{class_sk_codec_ab54f614159c048c5fc7065e3558e966e}{Selection\+Policy}}}]{selection\+Policy = {\ttfamily \mbox{\hyperlink{class_sk_codec_ab54f614159c048c5fc7065e3558e966ea5136a0dddb26f4ca4844b54ca82fad5d}{Selection\+Policy\+::k\+Prefer\+Still\+Image}}} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

If this stream represents an encoded image that we know how to decode, return an \mbox{\hyperlink{class_sk_codec}{Sk\+Codec}} that can decode it. Otherwise return N\+U\+LL.

As stated above, this call must be able to peek or read Min\+Buffered\+Bytes\+Needed to determine the correct format, and then start reading from the beginning. First it will attempt to peek, and it assumes that if less than Min\+Buffered\+Bytes\+Needed bytes (but more than zero) are returned, this is because the stream is shorter than this, so falling back to reading would not provide more data. If peek() returns zero bytes, this call will instead attempt to read(). This will require that the stream can be rewind()ed.

If Result is not N\+U\+LL, it will be set to either k\+Success if an \mbox{\hyperlink{class_sk_codec}{Sk\+Codec}} is returned or a reason for the failure if N\+U\+LL is returned.

If \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} is not N\+U\+LL, take a ref and pass it to libpng if the image is a png.

If the \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} is not N\+U\+LL then\+: If the image is not a P\+NG, the \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} will be ignored. If the image is a P\+NG, the \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} will be reffed. If the P\+NG has unknown chunks, the \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} will be used to handle these chunks. \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} will be called to read any unknown chunk at any point during the creation of the codec or the decode. Note that if \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} fails to read a chunk, this could result in a failure to create the codec or a failure to decode the image. If the P\+NG does not contain unknown chunks, the \mbox{\hyperlink{class_sk_png_chunk_reader}{Sk\+Png\+Chunk\+Reader}} will not be used or modified.

If N\+U\+LL is returned, the stream is deleted immediately. Otherwise, the \mbox{\hyperlink{class_sk_codec}{Sk\+Codec}} takes ownership of it, and will delete it when done with it. \mbox{\Hypertarget{class_sk_codec_a619e4149e0eeda445f561f1d850d70e9}\label{class_sk_codec_a619e4149e0eeda445f561f1d850d70e9}} 
\index{SkCodec@{SkCodec}!MinBufferedBytesNeeded@{MinBufferedBytesNeeded}}
\index{MinBufferedBytesNeeded@{MinBufferedBytesNeeded}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{MinBufferedBytesNeeded()}{MinBufferedBytesNeeded()}}
{\footnotesize\ttfamily static constexpr size\+\_\+t Sk\+Codec\+::\+Min\+Buffered\+Bytes\+Needed (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [constexpr]}}

Minimum number of bytes that must be buffered in \mbox{\hyperlink{class_sk_stream}{Sk\+Stream}} input.

An \mbox{\hyperlink{class_sk_stream}{Sk\+Stream}} passed to New\+From\+Stream must be able to use this many bytes to determine the image type. Then the same \mbox{\hyperlink{class_sk_stream}{Sk\+Stream}} must be passed to the correct decoder to read from the beginning.

This can be accomplished by implementing peek() to support peeking this many bytes, or by implementing rewind() to be able to rewind() after reading this many bytes. \mbox{\Hypertarget{class_sk_codec_af6c8cfaf7754ca3929626a010df66392}\label{class_sk_codec_af6c8cfaf7754ca3929626a010df66392}} 
\index{SkCodec@{SkCodec}!nextScanline@{nextScanline}}
\index{nextScanline@{nextScanline}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{nextScanline()}{nextScanline()}}
{\footnotesize\ttfamily int Sk\+Codec\+::next\+Scanline (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Returns the y-\/coordinate of the next row to be returned by the scanline decoder.

This will equal f\+Curr\+Scanline, except in the case of strangely encoded image types (bottom-\/up bmps).

Results are undefined when not in scanline decoding mode. \mbox{\Hypertarget{class_sk_codec_a4eca650de18970858729e32bad46f70f}\label{class_sk_codec_a4eca650de18970858729e32bad46f70f}} 
\index{SkCodec@{SkCodec}!onDimensionsSupported@{onDimensionsSupported}}
\index{onDimensionsSupported@{onDimensionsSupported}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{onDimensionsSupported()}{onDimensionsSupported()}}
{\footnotesize\ttfamily virtual bool Sk\+Codec\+::on\+Dimensions\+Supported (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_i_size}{Sk\+I\+Size}} \&}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

Subclasses should override if they support dimensions other than the src\+Info\textquotesingle{}s. \mbox{\Hypertarget{class_sk_codec_a058da1d38eac36ad2165e47758e0adca}\label{class_sk_codec_a058da1d38eac36ad2165e47758e0adca}} 
\index{SkCodec@{SkCodec}!onGetPixels@{onGetPixels}}
\index{onGetPixels@{onGetPixels}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{onGetPixels()}{onGetPixels()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} Sk\+Codec\+::on\+Get\+Pixels (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{info,  }\item[{void $\ast$}]{pixels,  }\item[{size\+\_\+t}]{row\+Bytes,  }\item[{const \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}} \&}]{,  }\item[{int $\ast$}]{rows\+Decoded }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}


\begin{DoxyParams}{Parameters}
{\em rows\+Decoded} & When the encoded image stream is incomplete, this function will return k\+Incomplete\+Input and rows\+Decoded will be set to the number of scanlines that were successfully decoded. This will allow \mbox{\hyperlink{class_sk_codec_affddeb85741238d2a275cedf1f627da5}{get\+Pixels()}} to fill the uninitialized memory. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_codec_a4f0e3e7003c6a5ca380a13be9bd71c86}\label{class_sk_codec_a4f0e3e7003c6a5ca380a13be9bd71c86}} 
\index{SkCodec@{SkCodec}!onGetScanlineOrder@{onGetScanlineOrder}}
\index{onGetScanlineOrder@{onGetScanlineOrder}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{onGetScanlineOrder()}{onGetScanlineOrder()}}
{\footnotesize\ttfamily virtual \mbox{\hyperlink{class_sk_codec_a77847b2f814711a4e08d1d10147bb884}{Sk\+Scanline\+Order}} Sk\+Codec\+::on\+Get\+Scanline\+Order (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

The remaining functions revolve around decoding scanlines. Most images types will be k\+Top\+Down and will not need to override this function. \mbox{\Hypertarget{class_sk_codec_a13f3174541928a80dfe8ec3ac9d555a9}\label{class_sk_codec_a13f3174541928a80dfe8ec3ac9d555a9}} 
\index{SkCodec@{SkCodec}!onRewind@{onRewind}}
\index{onRewind@{onRewind}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{onRewind()}{onRewind()}}
{\footnotesize\ttfamily virtual bool Sk\+Codec\+::on\+Rewind (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

Called by rewind\+If\+Needed, if the stream needed to be rewound.

Subclasses should do any set up needed after a rewind. \mbox{\Hypertarget{class_sk_codec_ad81cd31a6144db8eddf7b96246a1ec08}\label{class_sk_codec_ad81cd31a6144db8eddf7b96246a1ec08}} 
\index{SkCodec@{SkCodec}!outputScanline@{outputScanline}}
\index{outputScanline@{outputScanline}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{outputScanline()}{outputScanline()}}
{\footnotesize\ttfamily int Sk\+Codec\+::output\+Scanline (\begin{DoxyParamCaption}\item[{int}]{input\+Scanline }\end{DoxyParamCaption}) const}

Returns the output y-\/coordinate of the row that corresponds to an input y-\/coordinate. The input y-\/coordinate represents where the scanline is located in the encoded data.

This will equal input\+Scanline, except in the case of strangely encoded image types (bottom-\/up bmps, interlaced gifs). \mbox{\Hypertarget{class_sk_codec_a4fa1d1b5ac807579b98bf56678c87e7b}\label{class_sk_codec_a4fa1d1b5ac807579b98bf56678c87e7b}} 
\index{SkCodec@{SkCodec}!queryYUVAInfo@{queryYUVAInfo}}
\index{queryYUVAInfo@{queryYUVAInfo}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{queryYUVAInfo()}{queryYUVAInfo()}}
{\footnotesize\ttfamily bool Sk\+Codec\+::query\+Y\+U\+V\+A\+Info (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_sk_y_u_v_a_pixmap_info_1_1_supported_data_types}{Sk\+Y\+U\+V\+A\+Pixmap\+Info\+::\+Supported\+Data\+Types}} \&}]{supported\+Data\+Types,  }\item[{\mbox{\hyperlink{class_sk_y_u_v_a_pixmap_info}{Sk\+Y\+U\+V\+A\+Pixmap\+Info}} $\ast$}]{yuva\+Pixmap\+Info }\end{DoxyParamCaption}) const}

If decoding to Y\+UV is supported, this returns true. Otherwise, this returns false and the caller will ignore output parameter yuva\+Pixmap\+Info.


\begin{DoxyParams}{Parameters}
{\em supported\+Data\+Types} & Indicates the data type/planar config combinations that are supported by the caller. If the generator supports decoding to Y\+U\+V(\+A), but not as a type in supported\+Data\+Types, this method returns false. \\
\hline
{\em yuva\+Pixmap\+Info} & Output parameter that specifies the planar configuration, subsampling, orientation, chroma siting, plane color types, and row bytes. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_sk_codec_ab7733c4d013384bfec645aa0c9c8249e}\label{class_sk_codec_ab7733c4d013384bfec645aa0c9c8249e}} 
\index{SkCodec@{SkCodec}!ResultToString@{ResultToString}}
\index{ResultToString@{ResultToString}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{ResultToString()}{ResultToString()}}
{\footnotesize\ttfamily static const char$\ast$ Sk\+Codec\+::\+Result\+To\+String (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}}}]{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}

Readable string representing the error code. \mbox{\Hypertarget{class_sk_codec_a7030ce3cb132ac1653a6b6ba3cf46e26}\label{class_sk_codec_a7030ce3cb132ac1653a6b6ba3cf46e26}} 
\index{SkCodec@{SkCodec}!rewindIfNeeded@{rewindIfNeeded}}
\index{rewindIfNeeded@{rewindIfNeeded}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{rewindIfNeeded()}{rewindIfNeeded()}}
{\footnotesize\ttfamily bool S\+K\+\_\+\+W\+A\+R\+N\+\_\+\+U\+N\+U\+S\+E\+D\+\_\+\+R\+E\+S\+U\+LT Sk\+Codec\+::rewind\+If\+Needed (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

If the stream was previously read, attempt to rewind.

If the stream needed to be rewound, call on\+Rewind. \begin{DoxyReturn}{Returns}
true if the codec is at the right position and can be used. false if there was a failure to rewind.
\end{DoxyReturn}
This is called by \mbox{\hyperlink{class_sk_codec_affddeb85741238d2a275cedf1f627da5}{get\+Pixels()}}, get\+Y\+U\+V8\+Planes(), \mbox{\hyperlink{class_sk_codec_adc8b46291b91638c58391665f7a96b5b}{start\+Incremental\+Decode()}} and \mbox{\hyperlink{class_sk_codec_a952a6ca87c12d4c2482bd54c4eda1ba9}{start\+Scanline\+Decode()}}. Subclasses may call if they need to rewind at another time. \mbox{\Hypertarget{class_sk_codec_af07efc4311f76f25535969998b2d2377}\label{class_sk_codec_af07efc4311f76f25535969998b2d2377}} 
\index{SkCodec@{SkCodec}!skipScanlines@{skipScanlines}}
\index{skipScanlines@{skipScanlines}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{skipScanlines()}{skipScanlines()}}
{\footnotesize\ttfamily bool Sk\+Codec\+::skip\+Scanlines (\begin{DoxyParamCaption}\item[{int}]{count\+Lines }\end{DoxyParamCaption})}

Skip count scanlines.

Not valid to call before calling \mbox{\hyperlink{class_sk_codec_a952a6ca87c12d4c2482bd54c4eda1ba9}{start\+Scanline\+Decode()}}.

The default version just calls on\+Get\+Scanlines and discards the dst. N\+O\+TE\+: If skipped lines are the only lines with alpha, this default will make really\+Has\+Alpha return true, when it could have returned false.

\begin{DoxyReturn}{Returns}
true if the scanlines were successfully skipped false on failure, possible reasons for failure include\+: An incomplete input image stream. Calling this function before calling \mbox{\hyperlink{class_sk_codec_a952a6ca87c12d4c2482bd54c4eda1ba9}{start\+Scanline\+Decode()}}. If count\+Lines is less than zero or so large that it moves the current scanline past the end of the image. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_codec_adc8b46291b91638c58391665f7a96b5b}\label{class_sk_codec_adc8b46291b91638c58391665f7a96b5b}} 
\index{SkCodec@{SkCodec}!startIncrementalDecode@{startIncrementalDecode}}
\index{startIncrementalDecode@{startIncrementalDecode}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{startIncrementalDecode()}{startIncrementalDecode()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} Sk\+Codec\+::start\+Incremental\+Decode (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{dst\+Info,  }\item[{void $\ast$}]{dst,  }\item[{size\+\_\+t}]{row\+Bytes,  }\item[{const \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}} $\ast$}]{ }\end{DoxyParamCaption})}

Prepare for an incremental decode with the specified options.

This may require a rewind.

If k\+Incomplete\+Input is returned, may be called again after more data has been provided to the source \mbox{\hyperlink{class_sk_stream}{Sk\+Stream}}.


\begin{DoxyParams}{Parameters}
{\em dst\+Info} & Info of the destination. If the dimensions do not match those of get\+Info, this implies a scale. \\
\hline
{\em dst} & Memory to write to. Needs to be large enough to hold the subset, if present, or the full image as described in dst\+Info. \\
\hline
{\em options} & Contains decoding options, including if memory is zero initialized and whether to decode a subset. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Enum representing success or reason for failure. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_codec_ade349e283630bdf80d816e89f0d250cb}\label{class_sk_codec_ade349e283630bdf80d816e89f0d250cb}} 
\index{SkCodec@{SkCodec}!startScanlineDecode@{startScanlineDecode}}
\index{startScanlineDecode@{startScanlineDecode}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{startScanlineDecode()}{startScanlineDecode()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} Sk\+Codec\+::start\+Scanline\+Decode (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{dst\+Info }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Simplified version of \mbox{\hyperlink{class_sk_codec_a952a6ca87c12d4c2482bd54c4eda1ba9}{start\+Scanline\+Decode()}} that uses the default \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}}. \mbox{\Hypertarget{class_sk_codec_a952a6ca87c12d4c2482bd54c4eda1ba9}\label{class_sk_codec_a952a6ca87c12d4c2482bd54c4eda1ba9}} 
\index{SkCodec@{SkCodec}!startScanlineDecode@{startScanlineDecode}}
\index{startScanlineDecode@{startScanlineDecode}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{startScanlineDecode()}{startScanlineDecode()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_sk_codec_ab43dd53de9d731e34e7ce9e42cfad1f0}{Result}} Sk\+Codec\+::start\+Scanline\+Decode (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_sk_image_info}{Sk\+Image\+Info}} \&}]{dst\+Info,  }\item[{const \mbox{\hyperlink{struct_sk_codec_1_1_options}{Options}} $\ast$}]{options }\end{DoxyParamCaption})}

The remaining functions revolve around decoding scanlines. Prepare for a scanline decode with the specified options.

After this call, this class will be ready to decode the first scanline.

This must be called in order to call get\+Scanlines or skip\+Scanlines.

This may require rewinding the stream.

Not all Sk\+Codecs support this.


\begin{DoxyParams}{Parameters}
{\em dst\+Info} & Info of the destination. If the dimensions do not match those of get\+Info, this implies a scale. \\
\hline
{\em options} & Contains decoding options, including if memory is zero initialized. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Enum representing success or reason for failure. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_sk_codec_adae675dae4722d5bcadfe93bf6f8ab42}\label{class_sk_codec_adae675dae4722d5bcadfe93bf6f8ab42}} 
\index{SkCodec@{SkCodec}!stream@{stream}}
\index{stream@{stream}!SkCodec@{SkCodec}}
\doxysubsubsection{\texorpdfstring{stream()}{stream()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_sk_stream}{Sk\+Stream}}$\ast$ Sk\+Codec\+::stream (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}

Get method for the input stream 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/include/codec/Sk\+Codec.\+h\end{DoxyCompactItemize}
