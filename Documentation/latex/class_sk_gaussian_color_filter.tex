\hypertarget{class_sk_gaussian_color_filter}{}\doxysection{Sk\+Gaussian\+Color\+Filter Class Reference}
\label{class_sk_gaussian_color_filter}\index{SkGaussianColorFilter@{SkGaussianColorFilter}}
Inheritance diagram for Sk\+Gaussian\+Color\+Filter\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=6.000000cm]{class_sk_gaussian_color_filter}
\end{center}
\end{figure}
\doxysubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{class_sk_gaussian_color_filter_a4259bbeb3ae3ebfcb8dd2f52ebb5336d}{flatten}} (\mbox{\hyperlink{class_sk_write_buffer}{Sk\+Write\+Buffer}} \&) const override
\item 
\mbox{\Hypertarget{class_sk_gaussian_color_filter_aaa041f137f4f8e3ef6a396bb272e4c50}\label{class_sk_gaussian_color_filter_aaa041f137f4f8e3ef6a396bb272e4c50}} 
bool {\bfseries on\+Append\+Stages} (const \mbox{\hyperlink{struct_sk_stage_rec}{Sk\+Stage\+Rec}} \&rec, bool shader\+Is\+Opaque) const override
\item 
\mbox{\Hypertarget{class_sk_gaussian_color_filter_a9b5df7576cf33c3e95c0f8fdca0a19bc}\label{class_sk_gaussian_color_filter_a9b5df7576cf33c3e95c0f8fdca0a19bc}} 
\mbox{\hyperlink{structskvm_1_1_color}{skvm\+::\+Color}} {\bfseries on\+Program} (\mbox{\hyperlink{classskvm_1_1_builder}{skvm\+::\+Builder}} $\ast$p, \mbox{\hyperlink{structskvm_1_1_color}{skvm\+::\+Color}} c, const \mbox{\hyperlink{class_sk_color_info}{Sk\+Color\+Info}} \&dst, \mbox{\hyperlink{structskvm_1_1_uniforms}{skvm\+::\+Uniforms}} $\ast$, \mbox{\hyperlink{class_sk_arena_alloc}{Sk\+Arena\+Alloc}} $\ast$) const override
\end{DoxyCompactItemize}
\doxysubsection*{Additional Inherited Members}


\doxysubsection{Detailed Description}
Gaussian color filter -- produces a Gaussian ramp based on the color\textquotesingle{}s B value, then blends with the color\textquotesingle{}s \mbox{\hyperlink{struct_g}{G}} value. Final result is black with alpha of Gaussian(\+B)$\ast$G. The assumption is that the original color\textquotesingle{}s alpha is 1. 

\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_sk_gaussian_color_filter_a4259bbeb3ae3ebfcb8dd2f52ebb5336d}\label{class_sk_gaussian_color_filter_a4259bbeb3ae3ebfcb8dd2f52ebb5336d}} 
\index{SkGaussianColorFilter@{SkGaussianColorFilter}!flatten@{flatten}}
\index{flatten@{flatten}!SkGaussianColorFilter@{SkGaussianColorFilter}}
\doxysubsubsection{\texorpdfstring{flatten()}{flatten()}}
{\footnotesize\ttfamily void Sk\+Gaussian\+Color\+Filter\+::flatten (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_sk_write_buffer}{Sk\+Write\+Buffer}} \&}]{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}

Override this if your subclass needs to record data that it will need to recreate itself from its Create\+Proc (returned by \mbox{\hyperlink{class_sk_flattenable_afe739ff6d2a6737b05dad084f523cd87}{get\+Factory()}}).

D\+E\+P\+R\+E\+C\+A\+T\+ED public \+: will move to protected ... use serialize() instead 

Reimplemented from \mbox{\hyperlink{class_sk_flattenable_a12ed60c16e646c9d2acdcb7c47bb5cd0}{Sk\+Flattenable}}.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/src/skia/src/utils/Sk\+Shadow\+Utils.\+cpp\end{DoxyCompactItemize}
