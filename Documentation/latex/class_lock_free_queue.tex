\hypertarget{class_lock_free_queue}{}\doxysection{Lock\+Free\+Queue$<$ T, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$ Class Template Reference}
\label{class_lock_free_queue}\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}


{\ttfamily \#include $<$Lock\+Free\+Queue.\+h$>$}

\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
bool \mbox{\hyperlink{class_lock_free_queue_a87fd0d749b94d89734eea8bf0a1df6b7}{pop}} (\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&val)
\item 
bool \mbox{\hyperlink{class_lock_free_queue_adaf4b4d651197e1f6c870b5c6ceac7de}{push}} (const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&item)
\item 
bool \mbox{\hyperlink{class_lock_free_queue_a55c01b797392f37a804dd2f1933fcf9b}{peek}} (\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&item) const
\item 
I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE \mbox{\hyperlink{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}{size}} () const
\item 
bool \mbox{\hyperlink{class_lock_free_queue_a87fd0d749b94d89734eea8bf0a1df6b7}{pop}} (\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&val)
\item 
bool \mbox{\hyperlink{class_lock_free_queue_adaf4b4d651197e1f6c870b5c6ceac7de}{push}} (const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&item)
\item 
bool \mbox{\hyperlink{class_lock_free_queue_a55c01b797392f37a804dd2f1933fcf9b}{peek}} (\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&item) const
\item 
I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE \mbox{\hyperlink{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}{size}} () const
\item 
bool \mbox{\hyperlink{class_lock_free_queue_a87fd0d749b94d89734eea8bf0a1df6b7}{pop}} (\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&val)
\item 
bool \mbox{\hyperlink{class_lock_free_queue_adaf4b4d651197e1f6c870b5c6ceac7de}{push}} (const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&item)
\item 
bool \mbox{\hyperlink{class_lock_free_queue_a55c01b797392f37a804dd2f1933fcf9b}{peek}} (\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&item) const
\item 
I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE \mbox{\hyperlink{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}{size}} () const
\item 
bool \mbox{\hyperlink{class_lock_free_queue_a87fd0d749b94d89734eea8bf0a1df6b7}{pop}} (\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&val)
\item 
bool \mbox{\hyperlink{class_lock_free_queue_adaf4b4d651197e1f6c870b5c6ceac7de}{push}} (const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&item)
\item 
bool \mbox{\hyperlink{class_lock_free_queue_a55c01b797392f37a804dd2f1933fcf9b}{peek}} (\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&item) const
\item 
I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE \mbox{\hyperlink{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}{size}} () const
\end{DoxyCompactItemize}
\doxysubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static constexpr bool \mbox{\hyperlink{class_lock_free_queue_a5b4c2cac52e768cb40e1340d8f7d398f}{is\+Power\+Of\+Two}} (uint32\+\_\+t n)
\item 
static constexpr bool \mbox{\hyperlink{class_lock_free_queue_a5b4c2cac52e768cb40e1340d8f7d398f}{is\+Power\+Of\+Two}} (uint32\+\_\+t n)
\item 
static constexpr bool \mbox{\hyperlink{class_lock_free_queue_a5b4c2cac52e768cb40e1340d8f7d398f}{is\+Power\+Of\+Two}} (uint32\+\_\+t n)
\item 
static constexpr bool \mbox{\hyperlink{class_lock_free_queue_a5b4c2cac52e768cb40e1340d8f7d398f}{is\+Power\+Of\+Two}} (uint32\+\_\+t n)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename T, uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE = uint32\+\_\+t$>$\newline
class Lock\+Free\+Queue$<$ T, C\+A\+P\+A\+C\+I\+T\+Y, I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E $>$}

A lock-\/free queue for single consumer, single producer. Not thread-\/safe when using multiple consumers or producers.

Example code\+:

Lock\+Free\+Queue$<$int, 1024$>$ my\+Queue; int value = 123; my\+Queue.\+push(value); my\+Queue.\+pop(value);


\begin{DoxyTemplParams}{Template Parameters}
{\em T} & -\/ The item type \\
\hline
{\em C\+A\+P\+A\+C\+I\+TY} & -\/ Maximum number of items which can be held in the queue. Must be a power of 2. Must be less than the maximum value permissible in I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE \\
\hline
{\em I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE} & -\/ The internal index type, defaults to uint32\+\_\+t. Changing this will affect the maximum capacity. Included for ease of unit testing because testing queue lengths of U\+I\+N\+T32\+\_\+\+M\+AX can be time consuming and is not always possible. \\
\hline
\end{DoxyTemplParams}


\doxysubsection{Member Function Documentation}
\mbox{\Hypertarget{class_lock_free_queue_a5b4c2cac52e768cb40e1340d8f7d398f}\label{class_lock_free_queue_a5b4c2cac52e768cb40e1340d8f7d398f}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!isPowerOfTwo@{isPowerOfTwo}}
\index{isPowerOfTwo@{isPowerOfTwo}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{isPowerOfTwo()}{isPowerOfTwo()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
static constexpr bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::is\+Power\+Of\+Two (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [constexpr]}}

Implementation details\+:

We have 2 counters\+: read\+Counter and write\+Counter. Each will increment until it reaches I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+AX, then wrap to zero. Unsigned integer overflow is defined behaviour in C++.

Each time we need to access our data array we call \mbox{\hyperlink{group__gtc__bitfield_gad7eba518a0b71662114571ee76939f8a}{mask()}} which gives us the index into the array. This approach avoids having a \char`\"{}dead item\char`\"{} in the buffer to distinguish between full and empty states. It also allows us to have a \mbox{\hyperlink{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}{size()}} method which is easily calculated.

I\+M\+P\+O\+R\+T\+A\+NT\+: This implementation is only thread-\/safe with a single reader thread and a single writer thread. Have more than one of either will result in Bad Things™. \mbox{\Hypertarget{class_lock_free_queue_a5b4c2cac52e768cb40e1340d8f7d398f}\label{class_lock_free_queue_a5b4c2cac52e768cb40e1340d8f7d398f}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!isPowerOfTwo@{isPowerOfTwo}}
\index{isPowerOfTwo@{isPowerOfTwo}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{isPowerOfTwo()}{isPowerOfTwo()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
static constexpr bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::is\+Power\+Of\+Two (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [constexpr]}}

Implementation details\+:

We have 2 counters\+: read\+Counter and write\+Counter. Each will increment until it reaches I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+AX, then wrap to zero. Unsigned integer overflow is defined behaviour in C++.

Each time we need to access our data array we call \mbox{\hyperlink{group__gtc__bitfield_gad7eba518a0b71662114571ee76939f8a}{mask()}} which gives us the index into the array. This approach avoids having a \char`\"{}dead item\char`\"{} in the buffer to distinguish between full and empty states. It also allows us to have a \mbox{\hyperlink{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}{size()}} method which is easily calculated.

I\+M\+P\+O\+R\+T\+A\+NT\+: This implementation is only thread-\/safe with a single reader thread and a single writer thread. Have more than one of either will result in Bad Things™. \mbox{\Hypertarget{class_lock_free_queue_a5b4c2cac52e768cb40e1340d8f7d398f}\label{class_lock_free_queue_a5b4c2cac52e768cb40e1340d8f7d398f}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!isPowerOfTwo@{isPowerOfTwo}}
\index{isPowerOfTwo@{isPowerOfTwo}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{isPowerOfTwo()}{isPowerOfTwo()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
static constexpr bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::is\+Power\+Of\+Two (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [constexpr]}}

Implementation details\+:

We have 2 counters\+: read\+Counter and write\+Counter. Each will increment until it reaches I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+AX, then wrap to zero. Unsigned integer overflow is defined behaviour in C++.

Each time we need to access our data array we call \mbox{\hyperlink{group__gtc__bitfield_gad7eba518a0b71662114571ee76939f8a}{mask()}} which gives us the index into the array. This approach avoids having a \char`\"{}dead item\char`\"{} in the buffer to distinguish between full and empty states. It also allows us to have a \mbox{\hyperlink{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}{size()}} method which is easily calculated.

I\+M\+P\+O\+R\+T\+A\+NT\+: This implementation is only thread-\/safe with a single reader thread and a single writer thread. Have more than one of either will result in Bad Things™. \mbox{\Hypertarget{class_lock_free_queue_a5b4c2cac52e768cb40e1340d8f7d398f}\label{class_lock_free_queue_a5b4c2cac52e768cb40e1340d8f7d398f}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!isPowerOfTwo@{isPowerOfTwo}}
\index{isPowerOfTwo@{isPowerOfTwo}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{isPowerOfTwo()}{isPowerOfTwo()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
static constexpr bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::is\+Power\+Of\+Two (\begin{DoxyParamCaption}\item[{uint32\+\_\+t}]{n }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}, {\ttfamily [constexpr]}}

Implementation details\+:

We have 2 counters\+: read\+Counter and write\+Counter. Each will increment until it reaches I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+AX, then wrap to zero. Unsigned integer overflow is defined behaviour in C++.

Each time we need to access our data array we call \mbox{\hyperlink{group__gtc__bitfield_gad7eba518a0b71662114571ee76939f8a}{mask()}} which gives us the index into the array. This approach avoids having a \char`\"{}dead item\char`\"{} in the buffer to distinguish between full and empty states. It also allows us to have a \mbox{\hyperlink{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}{size()}} method which is easily calculated.

I\+M\+P\+O\+R\+T\+A\+NT\+: This implementation is only thread-\/safe with a single reader thread and a single writer thread. Have more than one of either will result in Bad Things™. \mbox{\Hypertarget{class_lock_free_queue_a55c01b797392f37a804dd2f1933fcf9b}\label{class_lock_free_queue_a55c01b797392f37a804dd2f1933fcf9b}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!peek@{peek}}
\index{peek@{peek}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{peek()}{peek()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::peek (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&}]{item }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Get the item at the front of the queue but do not remove it


\begin{DoxyParams}{Parameters}
{\em item} & -\/ item will be stored in this variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if item was stored, false if the queue was empty 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lock_free_queue_a55c01b797392f37a804dd2f1933fcf9b}\label{class_lock_free_queue_a55c01b797392f37a804dd2f1933fcf9b}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!peek@{peek}}
\index{peek@{peek}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{peek()}{peek()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::peek (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&}]{item }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Get the item at the front of the queue but do not remove it


\begin{DoxyParams}{Parameters}
{\em item} & -\/ item will be stored in this variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if item was stored, false if the queue was empty 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lock_free_queue_a55c01b797392f37a804dd2f1933fcf9b}\label{class_lock_free_queue_a55c01b797392f37a804dd2f1933fcf9b}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!peek@{peek}}
\index{peek@{peek}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{peek()}{peek()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::peek (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&}]{item }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Get the item at the front of the queue but do not remove it


\begin{DoxyParams}{Parameters}
{\em item} & -\/ item will be stored in this variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if item was stored, false if the queue was empty 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lock_free_queue_a55c01b797392f37a804dd2f1933fcf9b}\label{class_lock_free_queue_a55c01b797392f37a804dd2f1933fcf9b}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!peek@{peek}}
\index{peek@{peek}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{peek()}{peek()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::peek (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&}]{item }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Get the item at the front of the queue but do not remove it


\begin{DoxyParams}{Parameters}
{\em item} & -\/ item will be stored in this variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if item was stored, false if the queue was empty 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lock_free_queue_a87fd0d749b94d89734eea8bf0a1df6b7}\label{class_lock_free_queue_a87fd0d749b94d89734eea8bf0a1df6b7}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!pop@{pop}}
\index{pop@{pop}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{pop()}{pop()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::pop (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&}]{val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Pop a value off the head of the queue


\begin{DoxyParams}{Parameters}
{\em val} & -\/ element will be stored in this variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if value was popped successfully, false if the queue is empty 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lock_free_queue_a87fd0d749b94d89734eea8bf0a1df6b7}\label{class_lock_free_queue_a87fd0d749b94d89734eea8bf0a1df6b7}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!pop@{pop}}
\index{pop@{pop}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{pop()}{pop()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::pop (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&}]{val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Pop a value off the head of the queue


\begin{DoxyParams}{Parameters}
{\em val} & -\/ element will be stored in this variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if value was popped successfully, false if the queue is empty 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lock_free_queue_a87fd0d749b94d89734eea8bf0a1df6b7}\label{class_lock_free_queue_a87fd0d749b94d89734eea8bf0a1df6b7}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!pop@{pop}}
\index{pop@{pop}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{pop()}{pop()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::pop (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&}]{val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Pop a value off the head of the queue


\begin{DoxyParams}{Parameters}
{\em val} & -\/ element will be stored in this variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if value was popped successfully, false if the queue is empty 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lock_free_queue_a87fd0d749b94d89734eea8bf0a1df6b7}\label{class_lock_free_queue_a87fd0d749b94d89734eea8bf0a1df6b7}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!pop@{pop}}
\index{pop@{pop}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{pop()}{pop()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::pop (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&}]{val }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Pop a value off the head of the queue


\begin{DoxyParams}{Parameters}
{\em val} & -\/ element will be stored in this variable \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if value was popped successfully, false if the queue is empty 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lock_free_queue_adaf4b4d651197e1f6c870b5c6ceac7de}\label{class_lock_free_queue_adaf4b4d651197e1f6c870b5c6ceac7de}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!push@{push}}
\index{push@{push}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{push()}{push()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::push (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&}]{item }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Add an item to the back of the queue


\begin{DoxyParams}{Parameters}
{\em item} & -\/ The item to add \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if item was added, false if the queue was full 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lock_free_queue_adaf4b4d651197e1f6c870b5c6ceac7de}\label{class_lock_free_queue_adaf4b4d651197e1f6c870b5c6ceac7de}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!push@{push}}
\index{push@{push}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{push()}{push()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::push (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&}]{item }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Add an item to the back of the queue


\begin{DoxyParams}{Parameters}
{\em item} & -\/ The item to add \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if item was added, false if the queue was full 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lock_free_queue_adaf4b4d651197e1f6c870b5c6ceac7de}\label{class_lock_free_queue_adaf4b4d651197e1f6c870b5c6ceac7de}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!push@{push}}
\index{push@{push}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{push()}{push()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::push (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&}]{item }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Add an item to the back of the queue


\begin{DoxyParams}{Parameters}
{\em item} & -\/ The item to add \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if item was added, false if the queue was full 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lock_free_queue_adaf4b4d651197e1f6c870b5c6ceac7de}\label{class_lock_free_queue_adaf4b4d651197e1f6c870b5c6ceac7de}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!push@{push}}
\index{push@{push}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{push()}{push()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
bool \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::push (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \&}]{item }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Add an item to the back of the queue


\begin{DoxyParams}{Parameters}
{\em item} & -\/ The item to add \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if item was added, false if the queue was full 
\end{DoxyReturn}
\mbox{\Hypertarget{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}\label{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!size@{size}}
\index{size@{size}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{size()}{size()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Get the number of items in the queue

\begin{DoxyReturn}{Returns}
number of items in the queue 
\end{DoxyReturn}
This is worth some explanation\+:

Whilst write\+Counter is greater than read\+Counter the result of (write -\/ read) will always be positive. Simple.

But when write\+Counter is equal to I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+AX (e.\+g. U\+I\+N\+T32\+\_\+\+M\+AX) the next push will wrap it around to zero, the start of the buffer, making write\+Counter less than read\+Counter so the result of (write -\/ read) will be negative.

But because we\textquotesingle{}re returning an unsigned type return value will be as follows\+:

return\+Value = I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+AX -\/ (write -\/ read)

e.\+g. if write is 0, read is 150 and the I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE is uint8\+\_\+t where the max value is 255 the return value will be (255 -\/ (0 -\/ 150)) = 105.\mbox{\Hypertarget{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}\label{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!size@{size}}
\index{size@{size}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{size()}{size()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Get the number of items in the queue

\begin{DoxyReturn}{Returns}
number of items in the queue 
\end{DoxyReturn}
This is worth some explanation\+:

Whilst write\+Counter is greater than read\+Counter the result of (write -\/ read) will always be positive. Simple.

But when write\+Counter is equal to I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+AX (e.\+g. U\+I\+N\+T32\+\_\+\+M\+AX) the next push will wrap it around to zero, the start of the buffer, making write\+Counter less than read\+Counter so the result of (write -\/ read) will be negative.

But because we\textquotesingle{}re returning an unsigned type return value will be as follows\+:

return\+Value = I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+AX -\/ (write -\/ read)

e.\+g. if write is 0, read is 150 and the I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE is uint8\+\_\+t where the max value is 255 the return value will be (255 -\/ (0 -\/ 150)) = 105.\mbox{\Hypertarget{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}\label{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!size@{size}}
\index{size@{size}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{size()}{size()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Get the number of items in the queue

\begin{DoxyReturn}{Returns}
number of items in the queue 
\end{DoxyReturn}
This is worth some explanation\+:

Whilst write\+Counter is greater than read\+Counter the result of (write -\/ read) will always be positive. Simple.

But when write\+Counter is equal to I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+AX (e.\+g. U\+I\+N\+T32\+\_\+\+M\+AX) the next push will wrap it around to zero, the start of the buffer, making write\+Counter less than read\+Counter so the result of (write -\/ read) will be negative.

But because we\textquotesingle{}re returning an unsigned type return value will be as follows\+:

return\+Value = I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+AX -\/ (write -\/ read)

e.\+g. if write is 0, read is 150 and the I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE is uint8\+\_\+t where the max value is 255 the return value will be (255 -\/ (0 -\/ 150)) = 105.\mbox{\Hypertarget{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}\label{class_lock_free_queue_a6292a36f7b647a1f991d12422b2c7ed7}} 
\index{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}!size@{size}}
\index{size@{size}!LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$@{LockFreeQueue$<$ T, CAPACITY, INDEX\_TYPE $>$}}
\doxysubsubsection{\texorpdfstring{size()}{size()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename T , uint32\+\_\+t C\+A\+P\+A\+C\+I\+TY, typename I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE  = uint32\+\_\+t$>$ \\
I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE \mbox{\hyperlink{class_lock_free_queue}{Lock\+Free\+Queue}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, C\+A\+P\+A\+C\+I\+TY, I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE $>$\+::size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}

Get the number of items in the queue

\begin{DoxyReturn}{Returns}
number of items in the queue 
\end{DoxyReturn}
This is worth some explanation\+:

Whilst write\+Counter is greater than read\+Counter the result of (write -\/ read) will always be positive. Simple.

But when write\+Counter is equal to I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+AX (e.\+g. U\+I\+N\+T32\+\_\+\+M\+AX) the next push will wrap it around to zero, the start of the buffer, making write\+Counter less than read\+Counter so the result of (write -\/ read) will be negative.

But because we\textquotesingle{}re returning an unsigned type return value will be as follows\+:

return\+Value = I\+N\+D\+E\+X\+\_\+\+T\+Y\+P\+E\+\_\+\+M\+AX -\/ (write -\/ read)

e.\+g. if write is 0, read is 150 and the I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE is uint8\+\_\+t where the max value is 255 the return value will be (255 -\/ (0 -\/ 150)) = 105.

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/fab/src/\+Github/branches/\+Neural\+Amp\+Modeler\+Plugin/i\+Plug2/\+Dependencies/\+Build/win/\+Faust/faust/android/app/oboe/samples/\+Rhythm\+Game/src/main/cpp/utils/Lock\+Free\+Queue.\+h\end{DoxyCompactItemize}
