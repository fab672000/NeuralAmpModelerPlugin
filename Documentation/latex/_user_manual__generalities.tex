
\begin{DoxyItemize}
\item \mbox{\hyperlink{TopicFunctionTakingEigenTypes}{Writing Functions Taking Eigen Types as Parameters}}
\item \mbox{\hyperlink{TopicPreprocessorDirectives}{Preprocessor directives}}
\item \mbox{\hyperlink{TopicAssertions}{Assertions}}
\item \mbox{\hyperlink{TopicMultiThreading}{Eigen and multi-\/threading}}
\item \mbox{\hyperlink{TopicUsingBlasLapack}{Using B\+L\+A\+S/\+L\+A\+P\+A\+CK from Eigen}}
\item \mbox{\hyperlink{TopicUsingIntelMKL}{Using IntelÂ® M\+KL from Eigen}}
\item \mbox{\hyperlink{TopicCUDA}{Using Eigen in C\+U\+DA kernels}}
\item \mbox{\hyperlink{TopicPitfalls}{Common pitfalls}}
\item \mbox{\hyperlink{TopicTemplateKeyword}{The template and typename keywords in C++}}
\item \mbox{\hyperlink{UserManual_UnderstandingEigen}{Understanding Eigen}}
\item \mbox{\hyperlink{TopicCMakeGuide}{Using Eigen in C\+Make Projects}} 
\end{DoxyItemize}\hypertarget{TopicFunctionTakingEigenTypes}{}\doxysection{Writing Functions Taking Eigen Types as Parameters}\label{TopicFunctionTakingEigenTypes}
Eigen\textquotesingle{}s use of expression templates results in potentially every expression being of a different type. If you pass such an expression to a function taking a parameter of type \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, your expression will implicitly be evaluated into a temporary \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, which will then be passed to the function. This means that you lose the benefit of expression templates. Concretely, this has two drawbacks\+: \begin{DoxyItemize}
\item The evaluation into a temporary may be useless and inefficient; \item This only allows the function to read from the expression, not to write to it.\end{DoxyItemize}
Fortunately, all this myriad of expression types have in common that they all inherit a few common, templated base classes. By letting your function take templated parameters of these base types, you can let them play nicely with Eigen\textquotesingle{}s expression templates.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_function_taking_eigen_types_TopicFirstExamples}{}\doxysubsection{Some First Examples}\label{_topic_function_taking_eigen_types_TopicFirstExamples}
This section will provide simple examples for different types of objects Eigen is offering. Before starting with the actual examples, we need to recapitulate which base objects we can work with (see also \mbox{\hyperlink{TopicClassHierarchy}{The class hierarchy}}).

\begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}\+: The common base class for all dense matrix expressions (as opposed to array expressions, as opposed to sparse and special matrix classes). Use it in functions that are meant to work only on dense matrices. \item \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}}\+: The common base class for all dense array expressions (as opposed to matrix expressions, etc). Use it in functions that are meant to work only on arrays. \item \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}}\+: The common base class for all dense matrix expression, that is, the base class for both {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}} and {\ttfamily \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}}}. It can be used in functions that are meant to work on both matrices and arrays. \item \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}\+: The base class unifying all types of objects that can be evaluated into dense matrices or arrays, for example special matrix classes such as diagonal matrices, permutation matrices, etc. It can be used in functions that are meant to work on any such general type.\end{DoxyItemize}
{\bfseries{ Eigen\+Base Example }}~\newline
~\newline
 Prints the dimensions of the most generic object present in Eigen. It could be any matrix expressions, any dense or sparse matrix and any array. \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}
{\bfseries{ Dense\+Base Example }}~\newline
~\newline
 Prints a sub-\/block of the dense expression. Accepts any dense matrix or array expression, but no sparse objects and no special matrix classes such as \mbox{\hyperlink{class_eigen_1_1_diagonal_matrix}{Diagonal\+Matrix}}. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} print\_block(\textcolor{keyword}{const} DenseBase<Derived>\& b, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y, \textcolor{keywordtype}{int} r, \textcolor{keywordtype}{int} c)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"block: "} << b.block(x,y,r,c) << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 {\bfseries{ Array\+Base Example }}~\newline
~\newline
 Prints the maximum coefficient of the array or array-\/expression. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} print\_max\_coeff(\textcolor{keyword}{const} ArrayBase<Derived> \&a)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"max: "} << a.maxCoeff() << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 {\bfseries{ Matrix\+Base Example }}~\newline
~\newline
 Prints the inverse condition number of the given matrix or matrix-\/expression. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} print\_inv\_cond(\textcolor{keyword}{const} MatrixBase<Derived>\& a)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keyword}{typename} JacobiSVD<typename Derived::PlainObject>::SingularValuesType\&}
\DoxyCodeLine{    sing\_vals = a.jacobiSvd().singularValues();}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"inv cond: "} << sing\_vals(sing\_vals.size()-\/1) / sing\_vals(0) << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 {\bfseries{ Multiple templated arguments example }}~\newline
~\newline
 Calculate the Euclidean distance between two points. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} DerivedA,\textcolor{keyword}{typename} DerivedB>}
\DoxyCodeLine{\textcolor{keyword}{typename} DerivedA::Scalar squaredist(\textcolor{keyword}{const} MatrixBase<DerivedA>\& p1,\textcolor{keyword}{const} MatrixBase<DerivedB>\& p2)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} (p1-\/p2).squaredNorm();}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Notice that we used two template parameters, one per argument. This permits the function to handle inputs of different types, e.\+g., 
\begin{DoxyCode}{0}
\DoxyCodeLine{squaredist(v1,2*v2)}
\end{DoxyCode}
 where the first argument {\ttfamily v1} is a vector and the second argument {\ttfamily 2$\ast$v2} is an expression. ~\newline
~\newline


These examples are just intended to give the reader a first impression of how functions can be written which take a plain and constant \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} or \mbox{\hyperlink{class_eigen_1_1_array}{Array}} argument. They are also intended to give the reader an idea about the most common base classes being the optimal candidates for functions. In the next section we will look in more detail at an example and the different ways it can be implemented, while discussing each implementation\textquotesingle{}s problems and advantages. For the discussion below, \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} and \mbox{\hyperlink{class_eigen_1_1_array}{Array}} as well as \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} and \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} can be exchanged and all arguments still hold.\hypertarget{_topic_function_taking_eigen_types_TopicUsingRefClass}{}\doxysubsection{How to write generic, but non-\/templated function?}\label{_topic_function_taking_eigen_types_TopicUsingRefClass}
In all the previous examples, the functions had to be template functions. This approach allows to write very generic code, but it is often desirable to write non templated functions and still keep some level of genericity to avoid stupid copies of the arguments. The typical example is to write functions accepting both a Matrix\+Xf or a block of a Matrix\+Xf. This is exactly the purpose of the \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} class. Here is a simple example\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}
In the first two calls to inv\+\_\+cond, no copy occur because the memory layout of the arguments matches the memory layout accepted by Ref$<$\+Matrix\+Xf$>$. However, in the last call, we have a generic expression that will be automatically evaluated into a temporary Matrix\+Xf by the Ref$<$$>$ object.

A \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} object can also be writable. Here is an example of a function computing the covariance matrix of two input matrices where each row is an observation\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} Ref<const MatrixXf> x, \textcolor{keyword}{const} Ref<const MatrixXf> y, Ref<MatrixXf> C)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{float} num\_observations = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{  C = (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 and here are two examples calling cov without any copy\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf m1, m2, m3}
\DoxyCodeLine{cov(m1, m2, m3);}
\DoxyCodeLine{cov(m1.leftCols<3>(), m2.leftCols<3>(), m3.topLeftCorner<3,3>());}
\end{DoxyCode}
 The Ref$<$$>$ class has two other optional template arguments allowing to control the kind of memory layout that can be accepted without any copy. See the class \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} documentation for the details.\hypertarget{_topic_function_taking_eigen_types_TopicPlainFunctionsWorking}{}\doxysubsection{In which cases do functions taking plain Matrix or Array arguments work?}\label{_topic_function_taking_eigen_types_TopicPlainFunctionsWorking}
Without using template functions, and without the \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} class, a naive implementation of the previous cov function might look like this 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf cov(\textcolor{keyword}{const} MatrixXf\& x, \textcolor{keyword}{const} MatrixXf\& y)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{float} num\_observations = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keywordflow}{return} (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 and contrary to what one might think at first, this implementation is fine unless you require a generic implementation that works with double matrices too and unless you do not care about temporary objects. Why is that the case? Where are temporaries involved? How can code as given below compile? 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf x,y,z;}
\DoxyCodeLine{MatrixXf C = cov(x,y+z);}
\end{DoxyCode}
 In this special case, the example is fine and will be working because both parameters are declared as {\itshape const} references. The compiler creates a temporary and evaluates the expression x+z into this temporary. Once the function is processed, the temporary is released and the result is assigned to C.

{\bfseries{Note\+:}} Functions taking {\itshape const} references to \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} (or \mbox{\hyperlink{class_eigen_1_1_array}{Array}}) can process expressions at the cost of temporaries.\hypertarget{_topic_function_taking_eigen_types_TopicPlainFunctionsFailing}{}\doxysubsection{In which cases do functions taking a plain Matrix or Array argument fail?}\label{_topic_function_taking_eigen_types_TopicPlainFunctionsFailing}
Here, we consider a slightly modified version of the function given above. This time, we do not want to return the result but pass an additional non-\/const parameter which allows us to store the result. A first naive implementation might look as follows. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Note: This code is flawed!}}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} MatrixXf\& x, \textcolor{keyword}{const} MatrixXf\& y, MatrixXf\& C)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{float} num\_observations = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{  C = (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 When trying to execute the following code 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf C = MatrixXf::Zero(3,6);}
\DoxyCodeLine{cov(x,y, C.block(0,0,3,3));}
\end{DoxyCode}
 the compiler will fail, because it is not possible to convert the expression returned by {\ttfamily Matrix\+Xf\+::block()} into a non-\/const {\ttfamily Matrix\+Xf\&}. This is the case because the compiler wants to protect you from writing your result to a temporary object. In this special case this protection is not intended -- we want to write to a temporary object. So how can we overcome this problem?

The solution which is preferred at the moment is based on a little {\itshape hack}. One needs to pass a const reference to the matrix and internally the constness needs to be cast away. The correct implementation for C98 compliant compilers would be 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} MatrixBase<Derived>\& x, \textcolor{keyword}{const} MatrixBase<Derived>\& y, MatrixBase<OtherDerived> \textcolor{keyword}{const} \& C)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::plain\_row\_type<Derived>::type RowVectorType;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} Scalar num\_observations = \textcolor{keyword}{static\_cast<}Scalar\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const\_cast<} MatrixBase<OtherDerived>\& \textcolor{keyword}{>}(C) =}
\DoxyCodeLine{    (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 The implementation above does now not only work with temporary expressions but it also allows to use the function with matrices of arbitrary floating point scalar types.

{\bfseries{Note\+:}} The const cast hack will only work with templated functions. It will not work with the Matrix\+Xf implementation because it is not possible to cast a \mbox{\hyperlink{class_eigen_1_1_block}{Block}} expression to a \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} reference!\hypertarget{_topic_function_taking_eigen_types_TopicResizingInGenericImplementations}{}\doxysubsection{How to resize matrices in generic implementations?}\label{_topic_function_taking_eigen_types_TopicResizingInGenericImplementations}
One might think we are done now, right? This is not completely true because in order for our covariance function to be generically applicable, we want the following code to work 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf x = MatrixXf::Random(100,3);}
\DoxyCodeLine{MatrixXf y = MatrixXf::Random(100,3);}
\DoxyCodeLine{MatrixXf C;}
\DoxyCodeLine{cov(x, y, C);}
\end{DoxyCode}
 This is not the case anymore, when we are using an implementation taking \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} as a parameter. In general, Eigen supports automatic resizing but it is not possible to do so on expressions. Why should resizing of a matrix \mbox{\hyperlink{class_eigen_1_1_block}{Block}} be allowed? It is a reference to a sub-\/matrix and we definitely don\textquotesingle{}t want to resize that. So how can we incorporate resizing if we cannot resize on \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}? The solution is to resize the derived object as in this implementation. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} MatrixBase<Derived>\& x, \textcolor{keyword}{const} MatrixBase<Derived>\& y, MatrixBase<OtherDerived> \textcolor{keyword}{const} \& C\_)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::plain\_row\_type<Derived>::type RowVectorType;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} Scalar num\_observations = \textcolor{keyword}{static\_cast<}Scalar\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{}
\DoxyCodeLine{  MatrixBase<OtherDerived>\& C = \textcolor{keyword}{const\_cast<} MatrixBase<OtherDerived>\& \textcolor{keyword}{>}(C\_);}
\DoxyCodeLine{  }
\DoxyCodeLine{  C.derived().resize(x.cols(),x.cols()); \textcolor{comment}{// resize the derived object}}
\DoxyCodeLine{  C = (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 This implementation is now working for parameters being expressions and for parameters being matrices and having the wrong size. Resizing the expressions does not do any harm in this case unless they actually require resizing. That means, passing an expression with the wrong dimensions will result in a run-\/time error (in debug mode only) while passing expressions of the correct size will just work fine.

{\bfseries{Note\+:}} In the above discussion the terms \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} and \mbox{\hyperlink{class_eigen_1_1_array}{Array}} and \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} and \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} can be exchanged and all arguments still hold.\hypertarget{_topic_function_taking_eigen_types_TopicSummary}{}\doxysubsection{Summary}\label{_topic_function_taking_eigen_types_TopicSummary}

\begin{DoxyItemize}
\item To summarize, the implementation of functions taking non-\/writable (const referenced) objects is not a big issue and does not lead to problematic situations in terms of compiling and running your program. However, a naive implementation is likely to introduce unnecessary temporary objects in your code. In order to avoid evaluating parameters into temporaries, pass them as (const) references to \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} or \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} (so templatize your function).
\item Functions taking writable (non-\/const) parameters must take const references and cast away constness within the function body.
\item Functions that take as parameters \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} (or \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}}) objects, and potentially need to resize them (in the case where they are resizable), must call resize() on the derived class, as returned by derived().
\end{DoxyItemize}

Eigen\textquotesingle{}s use of expression templates results in potentially every expression being of a different type. If you pass such an expression to a function taking a parameter of type \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, your expression will implicitly be evaluated into a temporary \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, which will then be passed to the function. This means that you lose the benefit of expression templates. Concretely, this has two drawbacks\+: \begin{DoxyItemize}
\item The evaluation into a temporary may be useless and inefficient; \item This only allows the function to read from the expression, not to write to it.\end{DoxyItemize}
Fortunately, all this myriad of expression types have in common that they all inherit a few common, templated base classes. By letting your function take templated parameters of these base types, you can let them play nicely with Eigen\textquotesingle{}s expression templates.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_function_taking_eigen_types_TopicFirstExamples}{}\doxysubsection{Some First Examples}\label{_topic_function_taking_eigen_types_TopicFirstExamples}
This section will provide simple examples for different types of objects Eigen is offering. Before starting with the actual examples, we need to recapitulate which base objects we can work with (see also \mbox{\hyperlink{TopicClassHierarchy}{The class hierarchy}}).

\begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}\+: The common base class for all dense matrix expressions (as opposed to array expressions, as opposed to sparse and special matrix classes). Use it in functions that are meant to work only on dense matrices. \item \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}}\+: The common base class for all dense array expressions (as opposed to matrix expressions, etc). Use it in functions that are meant to work only on arrays. \item \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}}\+: The common base class for all dense matrix expression, that is, the base class for both {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}} and {\ttfamily \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}}}. It can be used in functions that are meant to work on both matrices and arrays. \item \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}\+: The base class unifying all types of objects that can be evaluated into dense matrices or arrays, for example special matrix classes such as diagonal matrices, permutation matrices, etc. It can be used in functions that are meant to work on any such general type.\end{DoxyItemize}
{\bfseries{ Eigen\+Base Example }}~\newline
~\newline
 Prints the dimensions of the most generic object present in Eigen. It could be any matrix expressions, any dense or sparse matrix and any array. \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}
{\bfseries{ Dense\+Base Example }}~\newline
~\newline
 Prints a sub-\/block of the dense expression. Accepts any dense matrix or array expression, but no sparse objects and no special matrix classes such as \mbox{\hyperlink{class_eigen_1_1_diagonal_matrix}{Diagonal\+Matrix}}. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} print\_block(\textcolor{keyword}{const} DenseBase<Derived>\& b, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y, \textcolor{keywordtype}{int} r, \textcolor{keywordtype}{int} c)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"block: "} << b.block(x,y,r,c) << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 {\bfseries{ Array\+Base Example }}~\newline
~\newline
 Prints the maximum coefficient of the array or array-\/expression. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} print\_max\_coeff(\textcolor{keyword}{const} ArrayBase<Derived> \&a)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"max: "} << a.maxCoeff() << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 {\bfseries{ Matrix\+Base Example }}~\newline
~\newline
 Prints the inverse condition number of the given matrix or matrix-\/expression. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} print\_inv\_cond(\textcolor{keyword}{const} MatrixBase<Derived>\& a)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keyword}{typename} JacobiSVD<typename Derived::PlainObject>::SingularValuesType\&}
\DoxyCodeLine{    sing\_vals = a.jacobiSvd().singularValues();}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"inv cond: "} << sing\_vals(sing\_vals.size()-\/1) / sing\_vals(0) << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 {\bfseries{ Multiple templated arguments example }}~\newline
~\newline
 Calculate the Euclidean distance between two points. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} DerivedA,\textcolor{keyword}{typename} DerivedB>}
\DoxyCodeLine{\textcolor{keyword}{typename} DerivedA::Scalar squaredist(\textcolor{keyword}{const} MatrixBase<DerivedA>\& p1,\textcolor{keyword}{const} MatrixBase<DerivedB>\& p2)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} (p1-\/p2).squaredNorm();}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Notice that we used two template parameters, one per argument. This permits the function to handle inputs of different types, e.\+g., 
\begin{DoxyCode}{0}
\DoxyCodeLine{squaredist(v1,2*v2)}
\end{DoxyCode}
 where the first argument {\ttfamily v1} is a vector and the second argument {\ttfamily 2$\ast$v2} is an expression. ~\newline
~\newline


These examples are just intended to give the reader a first impression of how functions can be written which take a plain and constant \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} or \mbox{\hyperlink{class_eigen_1_1_array}{Array}} argument. They are also intended to give the reader an idea about the most common base classes being the optimal candidates for functions. In the next section we will look in more detail at an example and the different ways it can be implemented, while discussing each implementation\textquotesingle{}s problems and advantages. For the discussion below, \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} and \mbox{\hyperlink{class_eigen_1_1_array}{Array}} as well as \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} and \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} can be exchanged and all arguments still hold.\hypertarget{_topic_function_taking_eigen_types_TopicUsingRefClass}{}\doxysubsection{How to write generic, but non-\/templated function?}\label{_topic_function_taking_eigen_types_TopicUsingRefClass}
In all the previous examples, the functions had to be template functions. This approach allows to write very generic code, but it is often desirable to write non templated functions and still keep some level of genericity to avoid stupid copies of the arguments. The typical example is to write functions accepting both a Matrix\+Xf or a block of a Matrix\+Xf. This is exactly the purpose of the \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} class. Here is a simple example\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}
In the first two calls to inv\+\_\+cond, no copy occur because the memory layout of the arguments matches the memory layout accepted by Ref$<$\+Matrix\+Xf$>$. However, in the last call, we have a generic expression that will be automatically evaluated into a temporary Matrix\+Xf by the Ref$<$$>$ object.

A \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} object can also be writable. Here is an example of a function computing the covariance matrix of two input matrices where each row is an observation\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} Ref<const MatrixXf> x, \textcolor{keyword}{const} Ref<const MatrixXf> y, Ref<MatrixXf> C)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{float} num\_observations = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{  C = (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 and here are two examples calling cov without any copy\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf m1, m2, m3}
\DoxyCodeLine{cov(m1, m2, m3);}
\DoxyCodeLine{cov(m1.leftCols<3>(), m2.leftCols<3>(), m3.topLeftCorner<3,3>());}
\end{DoxyCode}
 The Ref$<$$>$ class has two other optional template arguments allowing to control the kind of memory layout that can be accepted without any copy. See the class \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} documentation for the details.\hypertarget{_topic_function_taking_eigen_types_TopicPlainFunctionsWorking}{}\doxysubsection{In which cases do functions taking plain Matrix or Array arguments work?}\label{_topic_function_taking_eigen_types_TopicPlainFunctionsWorking}
Without using template functions, and without the \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} class, a naive implementation of the previous cov function might look like this 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf cov(\textcolor{keyword}{const} MatrixXf\& x, \textcolor{keyword}{const} MatrixXf\& y)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{float} num\_observations = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keywordflow}{return} (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 and contrary to what one might think at first, this implementation is fine unless you require a generic implementation that works with double matrices too and unless you do not care about temporary objects. Why is that the case? Where are temporaries involved? How can code as given below compile? 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf x,y,z;}
\DoxyCodeLine{MatrixXf C = cov(x,y+z);}
\end{DoxyCode}
 In this special case, the example is fine and will be working because both parameters are declared as {\itshape const} references. The compiler creates a temporary and evaluates the expression y+z into this temporary. Once the function is processed, the temporary is released and the result is assigned to C.

{\bfseries{Note\+:}} Functions taking {\itshape const} references to \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} (or \mbox{\hyperlink{class_eigen_1_1_array}{Array}}) can process expressions at the cost of temporaries.\hypertarget{_topic_function_taking_eigen_types_TopicPlainFunctionsFailing}{}\doxysubsection{In which cases do functions taking a plain Matrix or Array argument fail?}\label{_topic_function_taking_eigen_types_TopicPlainFunctionsFailing}
Here, we consider a slightly modified version of the function given above. This time, we do not want to return the result but pass an additional non-\/const parameter which allows us to store the result. A first naive implementation might look as follows. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Note: This code is flawed!}}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} MatrixXf\& x, \textcolor{keyword}{const} MatrixXf\& y, MatrixXf\& C)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{float} num\_observations = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{  C = (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 When trying to execute the following code 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf C = MatrixXf::Zero(3,6);}
\DoxyCodeLine{cov(x,y, C.block(0,0,3,3));}
\end{DoxyCode}
 the compiler will fail, because it is not possible to convert the expression returned by {\ttfamily Matrix\+Xf\+::block()} into a non-\/const {\ttfamily Matrix\+Xf\&}. This is the case because the compiler wants to protect you from writing your result to a temporary object. In this special case this protection is not intended -- we want to write to a temporary object. So how can we overcome this problem?

The solution which is preferred at the moment is based on a little {\itshape hack}. One needs to pass a const reference to the matrix and internally the constness needs to be cast away. The correct implementation for C98 compliant compilers would be 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} MatrixBase<Derived>\& x, \textcolor{keyword}{const} MatrixBase<Derived>\& y, MatrixBase<OtherDerived> \textcolor{keyword}{const} \& C)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::plain\_row\_type<Derived>::type RowVectorType;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} Scalar num\_observations = \textcolor{keyword}{static\_cast<}Scalar\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const\_cast<} MatrixBase<OtherDerived>\& \textcolor{keyword}{>}(C) =}
\DoxyCodeLine{    (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 The implementation above does now not only work with temporary expressions but it also allows to use the function with matrices of arbitrary floating point scalar types.

{\bfseries{Note\+:}} The const cast hack will only work with templated functions. It will not work with the Matrix\+Xf implementation because it is not possible to cast a \mbox{\hyperlink{class_eigen_1_1_block}{Block}} expression to a \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} reference!\hypertarget{_topic_function_taking_eigen_types_TopicResizingInGenericImplementations}{}\doxysubsection{How to resize matrices in generic implementations?}\label{_topic_function_taking_eigen_types_TopicResizingInGenericImplementations}
One might think we are done now, right? This is not completely true because in order for our covariance function to be generically applicable, we want the following code to work 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf x = MatrixXf::Random(100,3);}
\DoxyCodeLine{MatrixXf y = MatrixXf::Random(100,3);}
\DoxyCodeLine{MatrixXf C;}
\DoxyCodeLine{cov(x, y, C);}
\end{DoxyCode}
 This is not the case anymore, when we are using an implementation taking \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} as a parameter. In general, Eigen supports automatic resizing but it is not possible to do so on expressions. Why should resizing of a matrix \mbox{\hyperlink{class_eigen_1_1_block}{Block}} be allowed? It is a reference to a sub-\/matrix and we definitely don\textquotesingle{}t want to resize that. So how can we incorporate resizing if we cannot resize on \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}? The solution is to resize the derived object as in this implementation. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} MatrixBase<Derived>\& x, \textcolor{keyword}{const} MatrixBase<Derived>\& y, MatrixBase<OtherDerived> \textcolor{keyword}{const} \& C\_)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::plain\_row\_type<Derived>::type RowVectorType;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} Scalar num\_observations = \textcolor{keyword}{static\_cast<}Scalar\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{}
\DoxyCodeLine{  MatrixBase<OtherDerived>\& C = \textcolor{keyword}{const\_cast<} MatrixBase<OtherDerived>\& \textcolor{keyword}{>}(C\_);}
\DoxyCodeLine{  }
\DoxyCodeLine{  C.derived().resize(x.cols(),x.cols()); \textcolor{comment}{// resize the derived object}}
\DoxyCodeLine{  C = (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 This implementation is now working for parameters being expressions and for parameters being matrices and having the wrong size. Resizing the expressions does not do any harm in this case unless they actually require resizing. That means, passing an expression with the wrong dimensions will result in a run-\/time error (in debug mode only) while passing expressions of the correct size will just work fine.

{\bfseries{Note\+:}} In the above discussion the terms \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} and \mbox{\hyperlink{class_eigen_1_1_array}{Array}} and \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} and \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} can be exchanged and all arguments still hold.\hypertarget{_topic_function_taking_eigen_types_TopicSummary}{}\doxysubsection{Summary}\label{_topic_function_taking_eigen_types_TopicSummary}

\begin{DoxyItemize}
\item To summarize, the implementation of functions taking non-\/writable (const referenced) objects is not a big issue and does not lead to problematic situations in terms of compiling and running your program. However, a naive implementation is likely to introduce unnecessary temporary objects in your code. In order to avoid evaluating parameters into temporaries, pass them as (const) references to \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} or \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} (so templatize your function).
\item Functions taking writable (non-\/const) parameters must take const references and cast away constness within the function body.
\item Functions that take as parameters \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} (or \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}}) objects, and potentially need to resize them (in the case where they are resizable), must call resize() on the derived class, as returned by derived(). 
\end{DoxyItemize}\hypertarget{TopicPreprocessorDirectives}{}\doxysection{Preprocessor directives}\label{TopicPreprocessorDirectives}
You can control some aspects of Eigen by defining the preprocessor tokens using {\ttfamily \#define}. These macros should be defined before any Eigen headers are included. Often they are best set in the project options.

This page lists the preprocessor tokens recognized by Eigen.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesMajor}{}\doxysubsection{Macros with major effects}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesMajor}
These macros have a major effect and typically break the A\+PI (Application Programming Interface) and/or the A\+BI (Application Binary Interface). This can be rather dangerous\+: if parts of your program are compiled with one option, and other parts (or libraries that you use) are compiled with another option, your program may fail to link or exhibit subtle bugs. Nevertheless, these options can be useful for people who know what they are doing.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N2\+\_\+\+S\+U\+P\+P\+O\+RT}} and {\bfseries{E\+I\+G\+E\+N2\+\_\+\+S\+U\+P\+P\+O\+R\+T\+\_\+\+S\+T\+A\+G\+Enn\+\_\+xxx}} are disabled starting from the 3.\+3 release. Defining one of these will raise a compile-\/error. If you need to compile Eigen2 code, \href{http://eigen.tuxfamily.org/index.php?title=Eigen2}{\texttt{ check this site}}.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+D\+E\+N\+S\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE}} -\/ the type for column and row indices in matrices, vectors and array (Dense\+Base\+::\+Index). Set to {\ttfamily std\+::ptrdiff\+\_\+t} by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+I\+O\+\_\+\+F\+O\+R\+M\+AT}} -\/ the \mbox{\hyperlink{struct_eigen_1_1_i_o_format}{I\+O\+Format}} to use when printing a matrix if no I\+O\+Format is specified. Defaults to the I\+O\+Format constructed by the default constructor \mbox{\hyperlink{struct_eigen_1_1_i_o_format_acdcc91702d45c714b11ba42db5beddb5}{I\+O\+Format\+::\+I\+O\+Format()}}.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+A\+T\+R\+I\+C\+E\+S\+\_\+\+B\+Y\+\_\+\+Z\+E\+RO}} -\/ if defined, all entries of newly constructed matrices and arrays are initialized to zero, as are new entries in matrices and arrays after resizing. Not defined by default. \begin{DoxyWarning}{Warning}
The unary (resp. binary) constructor of {\ttfamily 1x1} (resp. {\ttfamily 2x1} or {\ttfamily 1x2}) fixed size matrices is always interpreted as an initialization constructor where the argument(s) are the coefficient values and not the sizes. For instance,
\begin{DoxyCode}{0}
\DoxyCodeLine{Vector2d v(2,1); }
\end{DoxyCode}
 will create a vector with coeficients \mbox{[}2,1\mbox{]}, and {\bfseries{not}} a {\ttfamily 2x1} vector initialized with zeros (i.\+e., \mbox{[}0,0\mbox{]}). If such cases might occur, then it is recommended to use the default constructor with a explicit call to resize\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Matrix<?,SizeAtCompileTime,1> v;}
\DoxyCodeLine{v.resize(size);}
\DoxyCodeLine{Matrix<?,RowsAtCompileTime,ColsAtCompileTime> m;}
\DoxyCodeLine{m.resize(rows,cols);}
\end{DoxyCode}

\end{DoxyWarning}

\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+A\+T\+R\+I\+C\+E\+S\+\_\+\+B\+Y\+\_\+\+N\+AN}} -\/ if defined, all entries of newly constructed matrices and arrays are initialized to NaN, as are new entries in matrices and arrays after resizing. This option is especially useful for debugging purpose, though a memory tool like \href{http://valgrind.org/}{\texttt{ valgrind}} is preferable. Not defined by default. \begin{DoxyWarning}{Warning}
See the documentation of {\ttfamily E\+I\+G\+E\+N\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+A\+T\+R\+I\+C\+E\+S\+\_\+\+B\+Y\+\_\+\+Z\+E\+RO} for a discussion on a limitations of these macros when applied to {\ttfamily 1x1}, {\ttfamily 1x2}, and {\ttfamily 2x1} fixed-\/size matrices.
\end{DoxyWarning}

\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+A\+U\+T\+O\+M\+A\+T\+I\+C\+\_\+\+R\+E\+S\+I\+Z\+I\+NG}} -\/ if defined, the matrices (or arrays) on both sides of an assignment {\ttfamily a = b} have to be of the same size; otherwise, Eigen automatically resizes {\ttfamily a} so that it is of the correct size. Not defined by default.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesCppVersion}{}\doxysubsection{C++ standard features}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesCppVersion}
By default, Eigen strive to automatically detect and enable language features at compile-\/time based on the information provided by the compiler.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER}} -\/ disables usage of C++ features requiring a version greater than E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER. Possible values are\+: 14, 17, etc. If not defined (the default), Eigen enables all features supported by the compiler.
\end{DoxyItemize}

Individual features can be explicitly enabled or disabled by defining the following token to 0 or 1 respectively. For instance, one might limit the C++ version to C++14 by defining E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER=14, but still enable C99 math functions by defining E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C99\+\_\+\+M\+A\+TH=1.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C99\+\_\+\+M\+A\+TH}} -\/ controls the usage of C99 math functions such as erf, erfc, lgamma, etc.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C\+X\+X11\+\_\+\+M\+A\+TH}} -\/ controls the implementation of some functions such as round, logp1, isinf, isnan, etc.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+S\+T\+D\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+OF}} -\/ defines whether std\+::result\+\_\+of is supported
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+IO}} -\/ Disables any usage and support for {\ttfamily $<$iostreams$>$}.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesAssertions}{}\doxysubsection{Assertions}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesAssertions}
The Eigen library contains many assertions to guard against programming errors, both at compile time and at run time. However, these assertions do cost time and can thus be turned off.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+D\+E\+B\+UG}} -\/ disables Eigen\textquotesingle{}s assertions if defined. Not defined by default, unless the {\ttfamily N\+D\+E\+B\+UG} macro is defined (this is a standard C++ macro which disables all asserts).
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+RT}} -\/ if defined, compile-\/time static assertions are replaced by runtime assertions; this saves compilation time. Not defined by default.
\item {\bfseries{eigen\+\_\+assert}} -\/ macro with one argument that is used inside Eigen for assertions. By default, it is basically defined to be {\ttfamily assert}, which aborts the program if the assertion is violated. Redefine this macro if you want to do something else, like throwing an exception.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+P\+L2\+\_\+\+O\+N\+LY}} -\/ disable non M\+P\+L2 compatible features, or in other words disable the features which are still under the L\+G\+PL.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}{}\doxysubsection{Alignment, vectorization and performance tweaking}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}

\begin{DoxyItemize}
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+L\+L\+O\+C\+\_\+\+A\+L\+R\+E\+A\+D\+Y\+\_\+\+A\+L\+I\+G\+N\+ED} -\/}} Can be set to 0 or 1 to tell whether default system {\ttfamily malloc} already returns aligned buffers. In not defined, then this information is automatically deduced from the compiler and system preprocessor tokens.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} -\/}} Must be a power of two, or 0. Defines an upper bound on the memory boundary in bytes on which dynamically and statically allocated data may be aligned by Eigen. If not defined, a default value is automatically computed based on architecture, compiler, and OS. This option is typically used to enforce binary compatibility between code/libraries compiled with different S\+I\+MD options. For instance, one may compile A\+VX code and enforce A\+BI compatibility with existing S\+SE code by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=16}. In the other way round, since by default A\+VX implies 32 bytes alignment for best performance, one can compile S\+SE code to be A\+BI compatible with A\+VX code by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=32}.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} -\/}} Same as {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} but for statically allocated data only. By default, if only {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} is defined, then {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} == {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES}, otherwise a default value is automatically computed based on architecture, compiler, and OS (can be smaller than the default value of E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES on architectures that do not support stack alignment). Let us emphasize that {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+$\ast$\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} define only a desirable upper bound. In practice data is aligned to largest power-\/of-\/two common divisor of {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} and the size of the data, such that memory is not wasted.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L\+I\+ZE} -\/}} if defined, this disables multi-\/threading. This is only relevant if you enabled Open\+MP. See \mbox{\hyperlink{TopicMultiThreading}{Eigen and multi-\/threading}} for details.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE} -\/}} disables explicit vectorization when defined. Not defined by default, unless alignment is disabled by Eigen\textquotesingle{}s platform test or the user defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN}.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+N\+A\+L\+I\+G\+N\+E\+D\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE} -\/}} disables/enables vectorization with unaligned stores. Default is 1 (enabled). If set to 0 (disabled), then expression for which the destination cannot be aligned are not vectorized (e.\+g., unaligned small fixed size vectors or matrices)
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+F\+A\+S\+T\+\_\+\+M\+A\+TH} -\/}} enables some optimizations which might affect the accuracy of the result. This currently enables the S\+SE vectorization of \mbox{\hyperlink{group__core__func__trigonometric_ga626e6663f52e5ffefd16ba0f52ccbd90}{sin()}} and \mbox{\hyperlink{group__core__func__trigonometric_ga9511f60b18cb8ce18d455029d7571219}{cos()}}, and speedups \mbox{\hyperlink{group__core__func__exponential_ga5c784ec51a1765be0a623104db2577b6}{sqrt()}} for single precision. Defined to 1 by default. Define it to 0 to disable.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+N\+R\+O\+L\+L\+I\+N\+G\+\_\+\+L\+I\+M\+IT} -\/}} defines the size of a loop to enable meta unrolling. Set it to zero to disable unrolling. The size of a loop here is expressed in Eigen\textquotesingle{}s own notion of \char`\"{}number of F\+L\+O\+P\+S\char`\"{}, it does not correspond to the number of iterations or the number of instructions. The default is value 110.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+C\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+L\+I\+M\+IT} -\/}} defines the maximum bytes for a buffer to be allocated on the stack. For internal temporary buffers, dynamic memory allocation is employed as a fall back. For fixed-\/size matrices or arrays, exceeding this threshold raises a compile time assertion. Use 0 to set no limit. Default is 128 KB.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+C\+U\+DA} -\/}} disables C\+U\+DA support when defined. Might be useful in .cu files for which \mbox{\hyperlink{namespace_eigen}{Eigen}} is used on the host only, and never called from device code.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+S\+T\+R\+O\+N\+G\+\_\+\+I\+N\+L\+I\+NE} -\/}} This macro is used to qualify critical functions and methods that we expect the compiler to inline. By default it is defined to {\ttfamily \+\_\+\+\_\+forceinline} for M\+S\+VC and I\+CC, and to {\ttfamily inline} for other compilers. A tipical usage is to define it to {\ttfamily inline} for M\+S\+VC users wanting faster compilation times, at the risk of performance degradations in some rare cases for which M\+S\+VC inliner fails to do a good job.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+L1\+\_\+\+C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE} -\/}} Sets the default L1 cache size that is used in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s G\+E\+BP kernel when the correct cache size cannot be determined at runtime.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+L2\+\_\+\+C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE} -\/}} Sets the default L2 cache size that is used in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s G\+E\+BP kernel when the correct cache size cannot be determined at runtime.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+L3\+\_\+\+C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE} -\/}} Sets the default L3 cache size that is used in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s G\+E\+BP kernel when the correct cache size cannot be determined at runtime.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN} -\/}} Deprecated, it is a synonym for {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=0}. It disables alignment completely. Eigen will not try to align its objects and does not expect that any objects passed to it are aligned. This will turn off vectorization if {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+N\+A\+L\+I\+G\+N\+E\+D\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE=1}.}} Not defined by default.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+G\+N\+\_\+\+S\+T\+A\+T\+I\+C\+A\+L\+LY} -\/}} Deprecated, it is a synonym for {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=0}. It disables alignment of arrays on the stack. Not defined by default, unless {\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN} is defined.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+A\+L\+T\+I\+V\+E\+C\+\_\+\+E\+N\+A\+B\+L\+E\+\_\+\+M\+M\+A\+\_\+\+D\+Y\+N\+A\+M\+I\+C\+\_\+\+D\+I\+S\+P\+A\+T\+CH} -\/}} Controls whether to use \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s dynamic dispatching for Altivec M\+MA or not.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+A\+L\+T\+I\+V\+E\+C\+\_\+\+D\+I\+S\+A\+B\+L\+E\+\_\+\+M\+MA} -\/}} Overrides the usage of Altivec M\+MA instructions.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+A\+L\+T\+I\+V\+E\+C\+\_\+\+U\+S\+E\+\_\+\+C\+U\+S\+T\+O\+M\+\_\+\+P\+A\+CK} -\/}} Controls whether to use \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s custom packing for Altivec or not.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesPlugins}{}\doxysubsection{Plugins}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesPlugins}
It is possible to add new methods to many fundamental classes in Eigen by writing a plugin. As explained in the section \mbox{\hyperlink{TopicCustomizing_Plugins}{Extending Matrix\+Base (and other classes)}}, the plugin is specified by defining a {\ttfamily E\+I\+G\+E\+N\+\_\+xxx\+\_\+\+P\+L\+U\+G\+IN} macro. The following macros are supported; none of them are defined by default.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+A\+R\+R\+A\+Y\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_array}{Array}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+A\+R\+R\+A\+Y\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+C\+W\+I\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the Cwise class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+N\+S\+E\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+Y\+N\+A\+M\+I\+C\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the Dynamic\+Sparse\+Matrix class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+F\+U\+N\+C\+T\+O\+R\+S\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for adding new functors and specializations of functor\+\_\+traits.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+P\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_map_base}{Map\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+T\+R\+I\+X\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+P\+L\+A\+I\+N\+O\+B\+J\+E\+C\+T\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{Plain\+Object\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+Q\+U\+A\+T\+E\+R\+N\+I\+O\+N\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_quaternion}{Quaternion}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+Q\+U\+A\+T\+E\+R\+N\+I\+O\+N\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_quaternion_base}{Quaternion\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_base}{Sparse\+Matrix\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+V\+E\+C\+T\+O\+R\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_sparse_vector}{Sparse\+Vector}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+T\+R\+A\+N\+S\+F\+O\+R\+M\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_transform}{Transform}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+V\+E\+C\+T\+O\+R\+W\+I\+S\+E\+O\+P\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_vectorwise_op}{Vectorwise\+Op}} class.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesDevelopers}{}\doxysubsection{Macros for Eigen developers}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesDevelopers}
These macros are mainly meant for people developing Eigen and for testing purposes. Even though, they might be useful for power users and the curious for debugging and testing purpose, they {\bfseries{should}} {\bfseries{not}} {\bfseries{be}} {\bfseries{used}} by real-\/word code.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+O\+\_\+\+R\+O\+W\+\_\+\+M\+A\+J\+OR}} -\/ when defined, the default storage order for matrices becomes row-\/major instead of column-\/major. Not defined by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+D\+E\+B\+U\+G\+G\+I\+NG}} -\/ if defined, enables assertions in Eigen\textquotesingle{}s internal routines. This is useful for debugging Eigen itself. Not defined by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+M\+A\+L\+L\+OC}} -\/ if defined, any request from inside the Eigen to allocate memory from the heap results in an assertion failure. This is useful to check that some routine does not allocate memory dynamically. Not defined by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+R\+U\+N\+T\+I\+M\+E\+\_\+\+N\+O\+\_\+\+M\+A\+L\+L\+OC}} -\/ if defined, a new switch is introduced which can be turned on and off by calling {\ttfamily set\+\_\+is\+\_\+malloc\+\_\+allowed(bool)}. If malloc is not allowed and Eigen tries to allocate memory dynamically anyway, an assertion failure results. Not defined by default.
\end{DoxyItemize}

You can control some aspects of Eigen by defining the preprocessor tokens using {\ttfamily \#define}. These macros should be defined before any Eigen headers are included. Often they are best set in the project options.

This page lists the preprocessor tokens recognized by Eigen.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesMajor}{}\doxysubsection{Macros with major effects}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesMajor}
These macros have a major effect and typically break the A\+PI (Application Programming Interface) and/or the A\+BI (Application Binary Interface). This can be rather dangerous\+: if parts of your program are compiled with one option, and other parts (or libraries that you use) are compiled with another option, your program may fail to link or exhibit subtle bugs. Nevertheless, these options can be useful for people who know what they are doing.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N2\+\_\+\+S\+U\+P\+P\+O\+RT}} and {\bfseries{E\+I\+G\+E\+N2\+\_\+\+S\+U\+P\+P\+O\+R\+T\+\_\+\+S\+T\+A\+G\+Enn\+\_\+xxx}} are disabled starting from the 3.\+3 release. Defining one of these will raise a compile-\/error. If you need to compile Eigen2 code, \href{http://eigen.tuxfamily.org/index.php?title=Eigen2}{\texttt{ check this site}}.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+D\+E\+N\+S\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE}} -\/ the type for column and row indices in matrices, vectors and array (Dense\+Base\+::\+Index). Set to {\ttfamily std\+::ptrdiff\+\_\+t} by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+I\+O\+\_\+\+F\+O\+R\+M\+AT}} -\/ the \mbox{\hyperlink{struct_eigen_1_1_i_o_format}{I\+O\+Format}} to use when printing a matrix if no I\+O\+Format is specified. Defaults to the I\+O\+Format constructed by the default constructor \mbox{\hyperlink{struct_eigen_1_1_i_o_format_acdcc91702d45c714b11ba42db5beddb5}{I\+O\+Format\+::\+I\+O\+Format()}}.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+A\+T\+R\+I\+C\+E\+S\+\_\+\+B\+Y\+\_\+\+Z\+E\+RO}} -\/ if defined, all entries of newly constructed matrices and arrays are initialized to zero, as are new entries in matrices and arrays after resizing. Not defined by default. \begin{DoxyWarning}{Warning}
The unary (resp. binary) constructor of {\ttfamily 1x1} (resp. {\ttfamily 2x1} or {\ttfamily 1x2}) fixed size matrices is always interpreted as an initialization constructor where the argument(s) are the coefficient values and not the sizes. For instance,
\begin{DoxyCode}{0}
\DoxyCodeLine{Vector2d v(2,1); }
\end{DoxyCode}
 will create a vector with coeficients \mbox{[}2,1\mbox{]}, and {\bfseries{not}} a {\ttfamily 2x1} vector initialized with zeros (i.\+e., \mbox{[}0,0\mbox{]}). If such cases might occur, then it is recommended to use the default constructor with a explicit call to resize\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Matrix<?,SizeAtCompileTime,1> v;}
\DoxyCodeLine{v.resize(size);}
\DoxyCodeLine{Matrix<?,RowsAtCompileTime,ColsAtCompileTime> m;}
\DoxyCodeLine{m.resize(rows,cols);}
\end{DoxyCode}

\end{DoxyWarning}

\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+A\+T\+R\+I\+C\+E\+S\+\_\+\+B\+Y\+\_\+\+N\+AN}} -\/ if defined, all entries of newly constructed matrices and arrays are initialized to NaN, as are new entries in matrices and arrays after resizing. This option is especially useful for debugging purpose, though a memory tool like \href{http://valgrind.org/}{\texttt{ valgrind}} is preferable. Not defined by default. \begin{DoxyWarning}{Warning}
See the documentation of {\ttfamily E\+I\+G\+E\+N\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+A\+T\+R\+I\+C\+E\+S\+\_\+\+B\+Y\+\_\+\+Z\+E\+RO} for a discussion on a limitations of these macros when applied to {\ttfamily 1x1}, {\ttfamily 1x2}, and {\ttfamily 2x1} fixed-\/size matrices.
\end{DoxyWarning}

\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+A\+U\+T\+O\+M\+A\+T\+I\+C\+\_\+\+R\+E\+S\+I\+Z\+I\+NG}} -\/ if defined, the matrices (or arrays) on both sides of an assignment {\ttfamily a = b} have to be of the same size; otherwise, Eigen automatically resizes {\ttfamily a} so that it is of the correct size. Not defined by default.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesCppVersion}{}\doxysubsection{C++ standard features}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesCppVersion}
By default, Eigen strive to automatically detect and enable language features at compile-\/time based on the information provided by the compiler.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER}} -\/ disables usage of C++ features requiring a version greater than E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER. Possible values are\+: 14, 17, etc. If not defined (the default), Eigen enables all features supported by the compiler.
\end{DoxyItemize}

Individual features can be explicitly enabled or disabled by defining the following token to 0 or 1 respectively. For instance, one might limit the C++ version to C++14 by defining E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER=14, but still enable C99 math functions by defining E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C99\+\_\+\+M\+A\+TH=1.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C99\+\_\+\+M\+A\+TH}} -\/ controls the usage of C99 math functions such as erf, erfc, lgamma, etc.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+S\+T\+D\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+OF}} -\/ defines whether std\+::result\+\_\+of is supported
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+IO}} -\/ Disables any usage and support for {\ttfamily $<$iostreams$>$}.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesAssertions}{}\doxysubsection{Assertions}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesAssertions}
The Eigen library contains many assertions to guard against programming errors, both at compile time and at run time. However, these assertions do cost time and can thus be turned off.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+D\+E\+B\+UG}} -\/ disables Eigen\textquotesingle{}s assertions if defined. Not defined by default, unless the {\ttfamily N\+D\+E\+B\+UG} macro is defined (this is a standard C++ macro which disables all asserts).
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+RT}} -\/ if defined, compile-\/time static assertions are replaced by runtime assertions; this saves compilation time. Not defined by default.
\item {\bfseries{eigen\+\_\+assert}} -\/ macro with one argument that is used inside Eigen for assertions. By default, it is basically defined to be {\ttfamily assert}, which aborts the program if the assertion is violated. Redefine this macro if you want to do something else, like throwing an exception.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}{}\doxysubsection{Alignment, vectorization and performance tweaking}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}

\begin{DoxyItemize}
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+L\+L\+O\+C\+\_\+\+A\+L\+R\+E\+A\+D\+Y\+\_\+\+A\+L\+I\+G\+N\+ED} -\/}} Can be set to 0 or 1 to tell whether default system {\ttfamily malloc} already returns aligned buffers. In not defined, then this information is automatically deduced from the compiler and system preprocessor tokens.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} -\/}} Must be a power of two, or 0. Defines an upper bound on the memory boundary in bytes on which dynamically and statically allocated data may be aligned by Eigen. If not defined, a default value is automatically computed based on architecture, compiler, and OS. This option is typically used to enforce binary compatibility between code/libraries compiled with different S\+I\+MD options. For instance, one may compile A\+VX code and enforce A\+BI compatibility with existing S\+SE code by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=16}. In the other way round, since by default A\+VX implies 32 bytes alignment for best performance, one can compile S\+SE code to be A\+BI compatible with A\+VX code by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=32}.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} -\/}} Same as {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} but for statically allocated data only. By default, if only {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} is defined, then {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} == {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES}, otherwise a default value is automatically computed based on architecture, compiler, and OS (can be smaller than the default value of E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES on architectures that do not support stack alignment). Let us emphasize that {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+$\ast$\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} define only a desirable upper bound. In practice data is aligned to largest power-\/of-\/two common divisor of {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} and the size of the data, such that memory is not wasted.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L\+I\+ZE} -\/}} if defined, this disables multi-\/threading. This is only relevant if you enabled Open\+MP. See \mbox{\hyperlink{TopicMultiThreading}{Eigen and multi-\/threading}} for details.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE} -\/}} disables explicit vectorization when defined. Not defined by default, unless alignment is disabled by Eigen\textquotesingle{}s platform test or the user defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN}.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+N\+A\+L\+I\+G\+N\+E\+D\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE} -\/}} disables/enables vectorization with unaligned stores. Default is 1 (enabled). If set to 0 (disabled), then expression for which the destination cannot be aligned are not vectorized (e.\+g., unaligned small fixed size vectors or matrices)
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+F\+A\+S\+T\+\_\+\+M\+A\+TH} -\/}} enables some optimizations which might affect the accuracy of the result. This currently enables the S\+SE vectorization of \mbox{\hyperlink{group__core__func__trigonometric_ga626e6663f52e5ffefd16ba0f52ccbd90}{sin()}} and \mbox{\hyperlink{group__core__func__trigonometric_ga9511f60b18cb8ce18d455029d7571219}{cos()}}, and speedups \mbox{\hyperlink{group__core__func__exponential_ga5c784ec51a1765be0a623104db2577b6}{sqrt()}} for single precision. Defined to 1 by default. Define it to 0 to disable.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+N\+R\+O\+L\+L\+I\+N\+G\+\_\+\+L\+I\+M\+IT} -\/}} defines the size of a loop to enable meta unrolling. Set it to zero to disable unrolling. The size of a loop here is expressed in Eigen\textquotesingle{}s own notion of \char`\"{}number of F\+L\+O\+P\+S\char`\"{}, it does not correspond to the number of iterations or the number of instructions. The default is value 110.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+C\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+L\+I\+M\+IT} -\/}} defines the maximum bytes for a buffer to be allocated on the stack. For internal temporary buffers, dynamic memory allocation is employed as a fall back. For fixed-\/size matrices or arrays, exceeding this threshold raises a compile time assertion. Use 0 to set no limit. Default is 128 KB.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+C\+U\+DA} -\/}} disables C\+U\+DA support when defined. Might be useful in .cu files for which \mbox{\hyperlink{namespace_eigen}{Eigen}} is used on the host only, and never called from device code.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+S\+T\+R\+O\+N\+G\+\_\+\+I\+N\+L\+I\+NE} -\/}} This macro is used to qualify critical functions and methods that we expect the compiler to inline. By default it is defined to {\ttfamily \+\_\+\+\_\+forceinline} for M\+S\+VC and I\+CC, and to {\ttfamily inline} for other compilers. A tipical usage is to define it to {\ttfamily inline} for M\+S\+VC users wanting faster compilation times, at the risk of performance degradations in some rare cases for which M\+S\+VC inliner fails to do a good job.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+L1\+\_\+\+C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE} -\/}} Sets the default L1 cache size that is used in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s G\+E\+BP kernel when the correct cache size cannot be determined at runtime.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+L2\+\_\+\+C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE} -\/}} Sets the default L2 cache size that is used in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s G\+E\+BP kernel when the correct cache size cannot be determined at runtime.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+L3\+\_\+\+C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE} -\/}} Sets the default L3 cache size that is used in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s G\+E\+BP kernel when the correct cache size cannot be determined at runtime.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN} -\/}} Deprecated, it is a synonym for {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=0}. It disables alignment completely. Eigen will not try to align its objects and does not expect that any objects passed to it are aligned. This will turn off vectorization if {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+N\+A\+L\+I\+G\+N\+E\+D\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE=1}.}} Not defined by default.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+G\+N\+\_\+\+S\+T\+A\+T\+I\+C\+A\+L\+LY} -\/}} Deprecated, it is a synonym for {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=0}. It disables alignment of arrays on the stack. Not defined by default, unless {\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN} is defined.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+A\+L\+T\+I\+V\+E\+C\+\_\+\+E\+N\+A\+B\+L\+E\+\_\+\+M\+M\+A\+\_\+\+D\+Y\+N\+A\+M\+I\+C\+\_\+\+D\+I\+S\+P\+A\+T\+CH} -\/}} Controls whether to use \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s dynamic dispatching for Altivec M\+MA or not.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+A\+L\+T\+I\+V\+E\+C\+\_\+\+D\+I\+S\+A\+B\+L\+E\+\_\+\+M\+MA} -\/}} Overrides the usage of Altivec M\+MA instructions.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+A\+L\+T\+I\+V\+E\+C\+\_\+\+U\+S\+E\+\_\+\+C\+U\+S\+T\+O\+M\+\_\+\+P\+A\+CK} -\/}} Controls whether to use \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s custom packing for Altivec or not.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesPlugins}{}\doxysubsection{Plugins}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesPlugins}
It is possible to add new methods to many fundamental classes in Eigen by writing a plugin. As explained in the section \mbox{\hyperlink{TopicCustomizing_Plugins}{Extending Matrix\+Base (and other classes)}}, the plugin is specified by defining a {\ttfamily E\+I\+G\+E\+N\+\_\+xxx\+\_\+\+P\+L\+U\+G\+IN} macro. The following macros are supported; none of them are defined by default.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+A\+R\+R\+A\+Y\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_array}{Array}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+A\+R\+R\+A\+Y\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+C\+W\+I\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the Cwise class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+N\+S\+E\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+Y\+N\+A\+M\+I\+C\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the Dynamic\+Sparse\+Matrix class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+F\+U\+N\+C\+T\+O\+R\+S\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for adding new functors and specializations of functor\+\_\+traits.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+P\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_map_base}{Map\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+T\+R\+I\+X\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+P\+L\+A\+I\+N\+O\+B\+J\+E\+C\+T\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{Plain\+Object\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+Q\+U\+A\+T\+E\+R\+N\+I\+O\+N\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_quaternion}{Quaternion}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+Q\+U\+A\+T\+E\+R\+N\+I\+O\+N\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_quaternion_base}{Quaternion\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_base}{Sparse\+Matrix\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+V\+E\+C\+T\+O\+R\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_sparse_vector}{Sparse\+Vector}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+T\+R\+A\+N\+S\+F\+O\+R\+M\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_transform}{Transform}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+V\+E\+C\+T\+O\+R\+W\+I\+S\+E\+O\+P\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_vectorwise_op}{Vectorwise\+Op}} class.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesDevelopers}{}\doxysubsection{Macros for Eigen developers}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesDevelopers}
These macros are mainly meant for people developing Eigen and for testing purposes. Even though, they might be useful for power users and the curious for debugging and testing purpose, they {\bfseries{should}} {\bfseries{not}} {\bfseries{be}} {\bfseries{used}} by real-\/word code.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+O\+\_\+\+R\+O\+W\+\_\+\+M\+A\+J\+OR}} -\/ when defined, the default storage order for matrices becomes row-\/major instead of column-\/major. Not defined by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+D\+E\+B\+U\+G\+G\+I\+NG}} -\/ if defined, enables assertions in Eigen\textquotesingle{}s internal routines. This is useful for debugging Eigen itself. Not defined by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+M\+A\+L\+L\+OC}} -\/ if defined, any request from inside the Eigen to allocate memory from the heap results in an assertion failure. This is useful to check that some routine does not allocate memory dynamically. Not defined by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+R\+U\+N\+T\+I\+M\+E\+\_\+\+N\+O\+\_\+\+M\+A\+L\+L\+OC}} -\/ if defined, a new switch is introduced which can be turned on and off by calling {\ttfamily set\+\_\+is\+\_\+malloc\+\_\+allowed(bool)}. If malloc is not allowed and Eigen tries to allocate memory dynamically anyway, an assertion failure results. Not defined by default. 
\end{DoxyItemize}\hypertarget{TopicAssertions}{}\doxysection{Assertions}\label{TopicAssertions}
\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_assertions_PlainAssert}{}\doxysubsection{Assertions}\label{_topic_assertions_PlainAssert}
The macro eigen\+\_\+assert is defined to be {\ttfamily eigen\+\_\+plain\+\_\+assert} by default. We use eigen\+\_\+plain\+\_\+assert instead of {\ttfamily assert} to work around a known bug for G\+CC $<$= 4.\+3. Basically, eigen\+\_\+plain\+\_\+assert {\itshape is} {\ttfamily assert}.\hypertarget{_topic_assertions_RedefineAssert}{}\doxysubsubsection{Redefining assertions}\label{_topic_assertions_RedefineAssert}
Both eigen\+\_\+assert and eigen\+\_\+plain\+\_\+assert are defined in Macros.\+h. Defining eigen\+\_\+assert indirectly gives you a chance to change its behavior. You can redefine this macro if you want to do something else such as throwing an exception, and fall back to its default behavior with eigen\+\_\+plain\+\_\+assert. The code below tells \mbox{\hyperlink{namespace_eigen}{Eigen}} to throw an std\+::runtime\+\_\+error\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#undef eigen\_assert}}
\DoxyCodeLine{\textcolor{preprocessor}{\#define eigen\_assert(x) \(\backslash\)}}
\DoxyCodeLine{\textcolor{preprocessor}{  if (!(x)) \{ throw (std::runtime\_error("Put your message here")); \}}}
\end{DoxyCode}
\hypertarget{_topic_assertions_DisableAssert}{}\doxysubsubsection{Disabling assertions}\label{_topic_assertions_DisableAssert}
Assertions cost run time and can be turned off. You can suppress eigen\+\_\+assert by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+D\+E\+B\+UG} {\bfseries{before}} including \mbox{\hyperlink{namespace_eigen}{Eigen}} headers. {\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+D\+E\+B\+UG} is undefined by default unless {\ttfamily N\+D\+E\+B\+UG} is defined.\hypertarget{_topic_assertions_StaticAssert}{}\doxysubsection{Static assertions}\label{_topic_assertions_StaticAssert}
Static assertions are not standardized until C++11. However, in the \mbox{\hyperlink{namespace_eigen}{Eigen}} library, there are many conditions can and should be detectedat compile time. For instance, we use static assertions to prevent the code below from compiling.


\begin{DoxyCode}{0}
\DoxyCodeLine{Matrix3d()  + Matrix4d();   \textcolor{comment}{// adding matrices of different sizes}}
\DoxyCodeLine{Matrix4cd() * Vector3cd();  \textcolor{comment}{// invalid product known at compile time}}
\end{DoxyCode}


Static assertions are defined in Static\+Assert.\+h. If there is native static\+\_\+assert, we use it. Otherwise, we have implemented an assertion macro that can show a limited range of messages.

One can easily come up with static assertions without messages, such as\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define STATIC\_ASSERT(x) \(\backslash\)}}
\DoxyCodeLine{\textcolor{preprocessor}{  switch(0) \{ case 0: case x:; \}}}
\end{DoxyCode}


However, the example above obviously cannot tell why the assertion failed. Therefore, we define a {\ttfamily struct} in namespace Eigen\+::internal to handle available messages.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keywordtype}{bool} condition>}
\DoxyCodeLine{\textcolor{keyword}{struct }static\_assertion \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<>}
\DoxyCodeLine{\textcolor{keyword}{struct }static\_assertion<true>}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{enum} \{}
\DoxyCodeLine{    YOU\_TRIED\_CALLING\_A\_VECTOR\_METHOD\_ON\_A\_MATRIX,}
\DoxyCodeLine{    YOU\_MIXED\_VECTORS\_OF\_DIFFERENT\_SIZES,}
\DoxyCodeLine{    \textcolor{comment}{// see StaticAssert.h for all enums.}}
\DoxyCodeLine{  \};}
\DoxyCodeLine{\};}
\end{DoxyCode}


And then, we define E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T(\+C\+O\+N\+D\+I\+T\+I\+O\+N,\+M\+S\+G) to access Eigen\+::internal\+::static\+\_\+assertion$<$bool(\+C\+O\+N\+D\+I\+T\+I\+O\+N)$>$\+::\+M\+SG. If the condition evaluates into {\ttfamily false}, your compiler displays a lot of messages explaining there is no \mbox{\hyperlink{struct_m_s_g}{M\+SG}} in static\+\_\+assert$<$false$>$. Nevertheless, this is {\itshape not} in what we are interested. As you can see, all members of static\+\_\+assert$<$true$>$ are A\+L\+L\+\_\+\+C\+A\+P\+S\+\_\+\+A\+N\+D\+\_\+\+T\+H\+E\+Y\+\_\+\+A\+R\+E\+\_\+\+S\+H\+O\+U\+T\+I\+NG.

\begin{DoxyWarning}{Warning}
When using this macro, \mbox{\hyperlink{struct_m_s_g}{M\+SG}} should be a member of static\+\_\+assertion$<$true$>$, or the static assertion {\bfseries{always}} fails. Currently, it can only be used in function scope.
\end{DoxyWarning}
\hypertarget{_topic_assertions_DerivedStaticAssert}{}\doxysubsubsection{Derived static assertions}\label{_topic_assertions_DerivedStaticAssert}
There are other macros derived from E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+RT to enhance readability. Their names are self-\/explanatory.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+F\+I\+X\+E\+D\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E)}} -\/ passes if {\itshape T\+Y\+PE} is fixed size.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+D\+Y\+N\+A\+M\+I\+C\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E)}} -\/ passes if {\itshape T\+Y\+PE} is dynamic size.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+L\+V\+A\+L\+U\+E(\+Derived)}} -\/ failes if {\itshape Derived} is read-\/only.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+A\+R\+R\+A\+Y\+X\+P\+R(\+Derived)}} -\/ passes if {\itshape Derived} is an array expression.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+S\+A\+M\+E\+\_\+\+X\+P\+R\+\_\+\+K\+I\+N\+D(\+Derived1, Derived2)}} -\/ failes if the two expressions are an array one and a matrix one.
\end{DoxyItemize}

Because \mbox{\hyperlink{namespace_eigen}{Eigen}} handles both fixed-\/size and dynamic-\/size expressions, some conditions cannot be clearly determined at compile time. We classify them into strict assertions and permissive assertions.\hypertarget{_topic_assertions_StrictAssertions}{}\doxyparagraph{Strict assertions}\label{_topic_assertions_StrictAssertions}
These assertions fail if the condition {\bfseries{may not}} be met. For example, Matrix\+Xd may not be a vector, so it fails E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+O\+N\+LY.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+O\+N\+L\+Y(\+T\+Y\+P\+E)}} -\/ passes if {\itshape T\+Y\+PE} must be a vector type.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+S\+P\+E\+C\+I\+F\+I\+C\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E, S\+I\+Z\+E)}} -\/ passes if {\itshape T\+Y\+PE} must be a vector of the given size.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+M\+A\+T\+R\+I\+X\+\_\+\+S\+P\+E\+C\+I\+F\+I\+C\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E, R\+O\+W\+S, C\+O\+L\+S)}} -\/ passes if {\itshape T\+Y\+PE} must be a matrix with given rows and columns.
\end{DoxyItemize}\hypertarget{_topic_assertions_PermissiveAssertions}{}\doxyparagraph{Permissive assertions}\label{_topic_assertions_PermissiveAssertions}
These assertions fail if the condition {\bfseries{cannot}} be met. For example, Matrix\+Xd and Matrix4d may have the same size, so they pass E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+S\+A\+M\+E\+\_\+\+M\+A\+T\+R\+I\+X\+\_\+\+S\+I\+ZE.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+S\+A\+M\+E\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E0,\+T\+Y\+P\+E1)}} -\/ fails if the two vector expression types must have different sizes.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+S\+A\+M\+E\+\_\+\+M\+A\+T\+R\+I\+X\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E0,\+T\+Y\+P\+E1)}} -\/ fails if the two matrix expression types must have different sizes.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+S\+I\+Z\+E\+\_\+1x1(\+T\+Y\+P\+E)}} -\/ fails if {\itshape T\+Y\+PE} cannot be an 1x1 expression.
\end{DoxyItemize}

See Static\+Assert.\+h for details such as what messages they throw.\hypertarget{_topic_assertions_DisableStaticAssert}{}\doxysubsubsection{Disabling static assertions}\label{_topic_assertions_DisableStaticAssert}
If {\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+RT} is defined, static assertions turn into {\ttfamily eigen\+\_\+assert}\textquotesingle{}s, working like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define EIGEN\_STATIC\_ASSERT(CONDITION,MSG) eigen\_assert((CONDITION) \&\& \#MSG);}}
\end{DoxyCode}


This saves compile time but consumes more run time. {\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+RT} is undefined by default. \hypertarget{TopicMultiThreading}{}\doxysection{Eigen and multi-\/threading}\label{TopicMultiThreading}
\hypertarget{_topic_multi_threading_TopicMultiThreading_MakingEigenMT}{}\doxysubsection{Make Eigen run in parallel}\label{_topic_multi_threading_TopicMultiThreading_MakingEigenMT}
Some Eigen\textquotesingle{}s algorithms can exploit the multiple cores present in your hardware. To this end, it is enough to enable Open\+MP on your compiler, for instance\+:
\begin{DoxyItemize}
\item G\+CC\+: {\ttfamily -\/fopenmp} 
\item I\+CC\+: {\ttfamily -\/openmp} 
\item M\+S\+VC\+: check the respective option in the build properties.
\end{DoxyItemize}

You can control the number of threads that will be used using either the Open\+MP A\+PI or Eigen\textquotesingle{}s A\+PI using the following priority\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{OMP\_NUM\_THREADS=n ./my\_program}
\DoxyCodeLine{omp\_set\_num\_threads(n);}
\DoxyCodeLine{\mbox{\hyperlink{namespace_eigen_af9cd17c2fe18204239cd11c88c120b50}{Eigen::setNbThreads}}(n);}
\end{DoxyCode}
 Unless {\ttfamily set\+Nb\+Threads} has been called, Eigen uses the number of threads specified by Open\+MP. You can restore this behavior by calling {\ttfamily set\+Nb\+Threads(0);}. You can query the number of threads that will be used with\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{n = \mbox{\hyperlink{namespace_eigen_a9aca97d83e21b91a04ec079360dfffeb}{Eigen::nbThreads}}( );}
\end{DoxyCode}
 You can disable Eigen\textquotesingle{}s multi threading at compile time by defining the \mbox{\hyperlink{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}{E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L\+I\+ZE }} preprocessor token.

Currently, the following algorithms can make use of multi-\/threading\+:
\begin{DoxyItemize}
\item general dense matrix -\/ matrix products
\item \mbox{\hyperlink{class_eigen_1_1_partial_piv_l_u}{Partial\+Piv\+LU}}
\item row-\/major-\/sparse $\ast$ dense vector/matrix products
\item \mbox{\hyperlink{class_eigen_1_1_conjugate_gradient}{Conjugate\+Gradient}} with {\ttfamily Lower$\vert$\+Upper} as the {\ttfamily Up\+Lo} template parameter.
\item \mbox{\hyperlink{class_eigen_1_1_bi_c_g_s_t_a_b}{Bi\+C\+G\+S\+T\+AB}} with a row-\/major sparse matrix format.
\item \mbox{\hyperlink{class_eigen_1_1_least_squares_conjugate_gradient}{Least\+Squares\+Conjugate\+Gradient}}
\end{DoxyItemize}

\begin{DoxyWarning}{Warning}
On most OS it is {\bfseries{very important}} to limit the number of threads to the number of physical cores, otherwise significant slowdowns are expected, especially for operations involving dense matrices.
\end{DoxyWarning}
Indeed, the principle of hyper-\/threading is to run multiple threads (in most cases 2) on a single core in an interleaved manner. However, Eigen\textquotesingle{}s matrix-\/matrix product kernel is fully optimized and already exploits nearly 100\% of the C\+PU capacity. Consequently, there is no room for running multiple such threads on a single core, and the performance would drops significantly because of cache pollution and other sources of overheads. At this stage of reading you\textquotesingle{}re probably wondering why Eigen does not limit itself to the number of physical cores? This is simply because Open\+MP does not allow to know the number of physical cores, and thus Eigen will launch as many threads as {\itshape cores} reported by Open\+MP.\hypertarget{_topic_multi_threading_TopicMultiThreading_UsingEigenWithMT}{}\doxysubsection{Using Eigen in a multi-\/threaded application}\label{_topic_multi_threading_TopicMultiThreading_UsingEigenWithMT}
In the case your own application is multithreaded, and multiple threads make calls to Eigen, then you have to initialize Eigen by calling the following routine {\bfseries{before}} creating the threads\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <Eigen/Core>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \mbox{\hyperlink{namespace_eigen_a820c0e0460934cc17eb6dacbad54a9f5}{Eigen::initParallel}}();}
\DoxyCodeLine{  }
\DoxyCodeLine{  ...}
\DoxyCodeLine{\}}
\end{DoxyCode}


\begin{DoxyNote}{Note}
With Eigen 3.\+3, and a fully C++11 compliant compiler (i.\+e., \href{http://en.cppreference.com/w/cpp/language/storage_duration\#Static_local_variables}{\texttt{ thread-\/safe static local variable initialization}}), then calling {\ttfamily \mbox{\hyperlink{namespace_eigen_a820c0e0460934cc17eb6dacbad54a9f5}{init\+Parallel()}}} is optional.
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
Note that all functions generating random matrices are {\bfseries{not}} re-\/entrant nor thread-\/safe. Those include \mbox{\hyperlink{class_eigen_1_1_dense_base_ae814abb451b48ed872819192dc188c19}{Dense\+Base\+::\+Random()}}, and \mbox{\hyperlink{class_eigen_1_1_dense_base_a39046dff78acbcb389ad0b018e587c8e}{Dense\+Base\+::set\+Random()}} despite a call to {\ttfamily \mbox{\hyperlink{namespace_eigen_a820c0e0460934cc17eb6dacbad54a9f5}{Eigen\+::init\+Parallel()}}}. This is because these functions are based on {\ttfamily std\+::rand} which is not re-\/entrant. For thread-\/safe random generator, we recommend the use of c++11 random generators (\mbox{\hyperlink{}{example }}) or {\ttfamily boost\+::random}.
\end{DoxyWarning}
In the case your application is parallelized with Open\+MP, you might want to disable Eigen\textquotesingle{}s own parallelization as detailed in the previous section.

\begin{DoxyWarning}{Warning}
Using Open\+MP with custom scalar types that might throw exceptions can lead to unexpected behaviour in the event of throwing. 
\end{DoxyWarning}
\hypertarget{TopicUsingBlasLapack}{}\doxysection{Using B\+L\+A\+S/\+L\+A\+P\+A\+CK from Eigen}\label{TopicUsingBlasLapack}
Since Eigen version 3.\+3 and later, any F77 compatible B\+L\+AS or L\+A\+P\+A\+CK libraries can be used as backends for dense matrix products and dense matrix decompositions. For instance, one can use \href{http://eigen.tuxfamily.org/Counter/redirect_to_mkl.php}{\texttt{ IntelÂ® M\+KL}}, Apple\textquotesingle{}s Accelerate framework on O\+SX, \href{http://www.openblas.net/}{\texttt{ Open\+B\+L\+AS}}, \href{http://www.netlib.org/lapack}{\texttt{ Netlib L\+A\+P\+A\+CK}}, etc.

Do not miss this \mbox{\hyperlink{_topic_using_intel_m_k_l}{page }} for further discussions on the specific use of IntelÂ® M\+KL (also includes V\+ML, P\+A\+R\+D\+I\+SO, etc.)

In order to use an external B\+L\+AS and/or L\+A\+P\+A\+CK library, you must link you own application to the respective libraries and their dependencies. For L\+A\+P\+A\+CK, you must also link to the standard \href{http://www.netlib.org/lapack/lapacke.html}{\texttt{ Lapacke}} library, which is used as a convenient think layer between Eigen\textquotesingle{}s C++ code and L\+A\+P\+A\+CK F77 interface. Then you must activate their usage by defining one or multiple of the following macros ({\bfseries{before}} including any Eigen\textquotesingle{}s header)\+:

\begin{DoxyNote}{Note}
For Mac users, in order to use the lapack version shipped with the Accelerate framework, you also need the lapacke library. Using \href{https://www.macports.org/}{\texttt{ Mac\+Ports}}, this is as easy as\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{sudo port install lapack}
\end{DoxyCode}
 and then use the following link flags\+: {\ttfamily -\/framework} {\ttfamily Accelerate} {\ttfamily /opt/local/lib/lapack/liblapacke}.dylib
\end{DoxyNote}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &Enables the use of external B\+L\+AS level 2 and 3 routines (compatible with any F77 B\+L\+AS interface) \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} &Enables the use of external Lapack routines via the \href{http://www.netlib.org/lapack/lapacke.html}{\texttt{ Lapacke}} C interface to Lapack (compatible with any F77 L\+A\+P\+A\+CK interface) \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &Same as {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} but algorithms of lower numerical robustness are disabled. ~\newline
 This currently concerns only \mbox{\hyperlink{class_eigen_1_1_jacobi_s_v_d}{Jacobi\+S\+VD}} which otherwise would be replaced by {\ttfamily gesvd} that is less robust than Jacobi rotations. \\\cline{1-2}
\end{longtabu}


When doing so, a number of Eigen\textquotesingle{}s algorithms are silently substituted with calls to B\+L\+AS or L\+A\+P\+A\+CK routines. These substitutions apply only for {\bfseries{Dynamic}} {\bfseries{or}} {\bfseries{large}} enough objects with one of the following four standard scalar types\+: {\ttfamily float}, {\ttfamily double}, {\ttfamily complex$<$float$>$}, and {\ttfamily complex$<$double$>$}. Operations on other scalar types or mixing reals and complexes will continue to use the built-\/in algorithms.

The breadth of Eigen functionality that can be substituted is listed in the table below. \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Functional domain}&\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ B\+L\+A\+S/\+L\+A\+P\+A\+CK routines }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Functional domain}&\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ B\+L\+A\+S/\+L\+A\+P\+A\+CK routines }\\\cline{1-3}
\endhead
Matrix-\/matrix operations ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1*m2.transpose();}
\DoxyCodeLine{m1.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}}>()*m2;}
\DoxyCodeLine{m1*m2.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}}>();}
\DoxyCodeLine{m1.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}}>().rankUpdate(m2,1.0);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gemm}
\DoxyCodeLine{?symm/?hemm}
\DoxyCodeLine{?trmm}
\DoxyCodeLine{dsyrk/ssyrk}
\end{DoxyCode}
 \\\cline{1-3}
Matrix-\/vector operations ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.adjoint()*b;}
\DoxyCodeLine{m1.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}}>()*b;}
\DoxyCodeLine{m1.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}}>()*b;}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gemv}
\DoxyCodeLine{?symv/?hemv}
\DoxyCodeLine{?trmv}
\end{DoxyCode}
 \\\cline{1-3}
LU decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{v1 = m1.lu().solve(v2);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?getrf}
\end{DoxyCode}
 \\\cline{1-3}
Cholesky decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{v1 = m2.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}}>().llt().solve(v2);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?potrf}
\end{DoxyCode}
 \\\cline{1-3}
QR decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.householderQr();}
\DoxyCodeLine{m1.colPivHouseholderQr();}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?geqrf}
\DoxyCodeLine{?geqp3}
\end{DoxyCode}
 \\\cline{1-3}
Singular value decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} &
\begin{DoxyCode}{0}
\DoxyCodeLine{JacobiSVD<MatrixXd, ComputeThinV> svd;}
\DoxyCodeLine{svd.compute(m1);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gesvd}
\end{DoxyCode}
 \\\cline{1-3}
Eigen-\/value decompositions ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{EigenSolver<MatrixXd> es(m1);}
\DoxyCodeLine{ComplexEigenSolver<MatrixXcd> ces(m1);}
\DoxyCodeLine{SelfAdjointEigenSolver<MatrixXd> saes(m1+m1.transpose());}
\DoxyCodeLine{GeneralizedSelfAdjointEigenSolver<MatrixXd>}
\DoxyCodeLine{    gsaes(m1+m1.transpose(),m2+m2.transpose());}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gees}
\DoxyCodeLine{?gees}
\DoxyCodeLine{?syev/?heev}
\DoxyCodeLine{?syev/?heev,}
\DoxyCodeLine{?potrf}
\end{DoxyCode}
 \\\cline{1-3}
Schur decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{RealSchur<MatrixXd> schurR(m1);}
\DoxyCodeLine{ComplexSchur<MatrixXcd> schurC(m1);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gees}
\end{DoxyCode}
 \\\cline{1-3}
\end{longtabu}
In the examples, m1 and m2 are dense matrices and v1 and v2 are dense vectors.

Since Eigen version 3.\+3 and later, any F77 compatible B\+L\+AS or L\+A\+P\+A\+CK libraries can be used as backends for dense matrix products and dense matrix decompositions. For instance, one can use \href{http://eigen.tuxfamily.org/Counter/redirect_to_mkl.php}{\texttt{ IntelÂ® M\+KL}}, Apple\textquotesingle{}s Accelerate framework on O\+SX, \href{http://www.openblas.net/}{\texttt{ Open\+B\+L\+AS}}, \href{http://www.netlib.org/lapack}{\texttt{ Netlib L\+A\+P\+A\+CK}}, etc.

Do not miss this \mbox{\hyperlink{_topic_using_intel_m_k_l}{page }} for further discussions on the specific use of IntelÂ® M\+KL (also includes V\+ML, P\+A\+R\+D\+I\+SO, etc.)

In order to use an external B\+L\+AS and/or L\+A\+P\+A\+CK library, you must link you own application to the respective libraries and their dependencies. For L\+A\+P\+A\+CK, you must also link to the standard \href{http://www.netlib.org/lapack/lapacke.html}{\texttt{ Lapacke}} library, which is used as a convenient think layer between Eigen\textquotesingle{}s C++ code and L\+A\+P\+A\+CK F77 interface. Then you must activate their usage by defining one or multiple of the following macros ({\bfseries{before}} including any Eigen\textquotesingle{}s header)\+:

\begin{DoxyNote}{Note}
For Mac users, in order to use the lapack version shipped with the Accelerate framework, you also need the lapacke library. Using \href{https://www.macports.org/}{\texttt{ Mac\+Ports}}, this is as easy as\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{sudo port install lapack}
\end{DoxyCode}
 and then use the following link flags\+: {\ttfamily -\/framework} {\ttfamily Accelerate} {\ttfamily /opt/local/lib/lapack/liblapacke}.dylib
\end{DoxyNote}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &Enables the use of external B\+L\+AS level 2 and 3 routines (compatible with any F77 B\+L\+AS interface) \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} &Enables the use of external Lapack routines via the \href{http://www.netlib.org/lapack/lapacke.html}{\texttt{ Lapacke}} C interface to Lapack (compatible with any F77 L\+A\+P\+A\+CK interface) \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &Same as {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} but algorithms of lower numerical robustness are disabled. ~\newline
 This currently concerns only \mbox{\hyperlink{class_eigen_1_1_jacobi_s_v_d}{Jacobi\+S\+VD}} which otherwise would be replaced by {\ttfamily gesvd} that is less robust than Jacobi rotations. \\\cline{1-2}
\end{longtabu}


When doing so, a number of Eigen\textquotesingle{}s algorithms are silently substituted with calls to B\+L\+AS or L\+A\+P\+A\+CK routines. These substitutions apply only for {\bfseries{Dynamic}} {\bfseries{or}} {\bfseries{large}} enough objects with one of the following four standard scalar types\+: {\ttfamily float}, {\ttfamily double}, {\ttfamily complex$<$float$>$}, and {\ttfamily complex$<$double$>$}. Operations on other scalar types or mixing reals and complexes will continue to use the built-\/in algorithms.

The breadth of Eigen functionality that can be substituted is listed in the table below. \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Functional domain}&\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ B\+L\+A\+S/\+L\+A\+P\+A\+CK routines }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Functional domain}&\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ B\+L\+A\+S/\+L\+A\+P\+A\+CK routines }\\\cline{1-3}
\endhead
Matrix-\/matrix operations ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1*m2.transpose();}
\DoxyCodeLine{m1.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}}>()*m2;}
\DoxyCodeLine{m1*m2.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}}>();}
\DoxyCodeLine{m1.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}}>().rankUpdate(m2,1.0);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gemm}
\DoxyCodeLine{?symm/?hemm}
\DoxyCodeLine{?trmm}
\DoxyCodeLine{dsyrk/ssyrk}
\end{DoxyCode}
 \\\cline{1-3}
Matrix-\/vector operations ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.adjoint()*b;}
\DoxyCodeLine{m1.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}}>()*b;}
\DoxyCodeLine{m1.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}}>()*b;}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gemv}
\DoxyCodeLine{?symv/?hemv}
\DoxyCodeLine{?trmv}
\end{DoxyCode}
 \\\cline{1-3}
LU decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{v1 = m1.lu().solve(v2);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?getrf}
\end{DoxyCode}
 \\\cline{1-3}
Cholesky decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{v1 = m2.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}}>().llt().solve(v2);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?potrf}
\end{DoxyCode}
 \\\cline{1-3}
QR decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.householderQr();}
\DoxyCodeLine{m1.colPivHouseholderQr();}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?geqrf}
\DoxyCodeLine{?geqp3}
\end{DoxyCode}
 \\\cline{1-3}
Singular value decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} &
\begin{DoxyCode}{0}
\DoxyCodeLine{JacobiSVD<MatrixXd, ComputeThinV> svd;}
\DoxyCodeLine{svd.compute(m1);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gesvd}
\end{DoxyCode}
 \\\cline{1-3}
Singular value decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{BDCSVD<MatrixXd> svd;}
\DoxyCodeLine{svd.compute(m1);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gesdd}
\end{DoxyCode}
 \\\cline{1-3}
Eigen-\/value decompositions ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{EigenSolver<MatrixXd> es(m1);}
\DoxyCodeLine{ComplexEigenSolver<MatrixXcd> ces(m1);}
\DoxyCodeLine{SelfAdjointEigenSolver<MatrixXd> saes(m1+m1.transpose());}
\DoxyCodeLine{GeneralizedSelfAdjointEigenSolver<MatrixXd>}
\DoxyCodeLine{    gsaes(m1+m1.transpose(),m2+m2.transpose());}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gees}
\DoxyCodeLine{?gees}
\DoxyCodeLine{?syev/?heev}
\DoxyCodeLine{?syev/?heev,}
\DoxyCodeLine{?potrf}
\end{DoxyCode}
 \\\cline{1-3}
Schur decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{RealSchur<MatrixXd> schurR(m1);}
\DoxyCodeLine{ComplexSchur<MatrixXcd> schurC(m1);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gees}
\end{DoxyCode}
 \\\cline{1-3}
\end{longtabu}
In the examples, m1 and m2 are dense matrices and v1 and v2 are dense vectors. \hypertarget{TopicUsingIntelMKL}{}\doxysection{Using IntelÂ® M\+KL from Eigen}\label{TopicUsingIntelMKL}
Since Eigen version 3.\+1 and later, users can benefit from built-\/in IntelÂ® Math Kernel Library (M\+KL) optimizations with an installed copy of Intel M\+KL 10.\+3 (or later).

\href{http://eigen.tuxfamily.org/Counter/redirect_to_mkl.php}{\texttt{ Intel M\+KL }} provides highly optimized multi-\/threaded mathematical routines for~x86-\/compatible architectures. Intel M\+KL is available on Linux, Mac and Windows for both Intel64 and I\+A32 architectures.

\begin{DoxyNote}{Note}
IntelÂ® M\+KL is a proprietary software and it is the responsibility of users to buy or register for community (free) Intel M\+KL licenses for their products. Moreover, the license of the user product has to allow linking to proprietary software that excludes any unmodified versions of the G\+PL.
\end{DoxyNote}
Using Intel M\+KL through Eigen is easy\+:
\begin{DoxyEnumerate}
\item define the {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+\+A\+LL} macro before including any Eigen\textquotesingle{}s header
\item link your program to M\+KL libraries (see the \href{http://software.intel.com/en-us/articles/intel-mkl-link-line-advisor/}{\texttt{ M\+KL linking advisor}})
\item on a 64bits system, you must use the L\+P64 interface (not the I\+L\+P64 one)
\end{DoxyEnumerate}

When doing so, a number of Eigen\textquotesingle{}s algorithms are silently substituted with calls to Intel M\+KL routines. These substitutions apply only for {\bfseries{Dynamic}} {\bfseries{or}} {\bfseries{large}} enough objects with one of the following four standard scalar types\+: {\ttfamily float}, {\ttfamily double}, {\ttfamily complex$<$float$>$}, and {\ttfamily complex$<$double$>$}. Operations on other scalar types or mixing reals and complexes will continue to use the built-\/in algorithms.

In addition you can choose which parts will be substituted by defining one or multiple of the following macros\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &Enables the use of external B\+L\+AS level 2 and 3 routines \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} &Enables the use of external Lapack routines via the \href{http://www.netlib.org/lapack/lapacke.html}{\texttt{ Lapacke}} C interface to Lapack \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &Same as {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} but algorithm of lower robustness are disabled. ~\newline
 This currently concerns only \mbox{\hyperlink{class_eigen_1_1_jacobi_s_v_d}{Jacobi\+S\+VD}} which otherwise would be replaced by {\ttfamily gesvd} that is less robust than Jacobi rotations. \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+\+V\+ML} &Enables the use of Intel V\+ML (vector operations) \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+\+A\+LL} &Defines {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS}, {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE}, and {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+\+V\+ML}  \\\cline{1-2}
\end{longtabu}


The {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} and {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E$\ast$} macros can be combined with {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+KL} to explicitly tell \mbox{\hyperlink{namespace_eigen}{Eigen}} that the underlying B\+L\+A\+S/\+Lapack implementation is Intel M\+KL. The main effect is to enable M\+KL direct call feature ({\ttfamily M\+K\+L\+\_\+\+D\+I\+R\+E\+C\+T\+\_\+\+C\+A\+LL}). This may help to increase performance of some M\+KL B\+L\+AS (?G\+E\+MM, ?G\+E\+MV, ?T\+R\+SM, ?A\+X\+PY and ?D\+OT) and L\+A\+P\+A\+CK (LU, Cholesky and QR) routines for very small matrices. M\+KL direct call can be disabled by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+K\+L\+\_\+\+N\+O\+\_\+\+D\+I\+R\+E\+C\+T\+\_\+\+C\+A\+LL}.

Note that the B\+L\+AS and L\+A\+P\+A\+C\+KE backends can be enabled for any F77 compatible B\+L\+AS and L\+A\+P\+A\+CK libraries. See this \mbox{\hyperlink{_topic_using_blas_lapack}{page }} for the details.

Finally, the P\+A\+R\+D\+I\+SO sparse solver shipped with Intel M\+KL can be used through the \mbox{\hyperlink{class_eigen_1_1_pardiso_l_u}{Pardiso\+LU}}, \mbox{\hyperlink{class_eigen_1_1_pardiso_l_l_t}{Pardiso\+L\+LT}} and \mbox{\hyperlink{class_eigen_1_1_pardiso_l_d_l_t}{Pardiso\+L\+D\+LT}} classes of the Pardiso\+Support\+\_\+\+Module.

The following table summarizes the list of functions covered by {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+\+V\+ML\+:} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ M\+KL routines }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ M\+KL routines }\\\cline{1-2}
\endhead

\begin{DoxyCode}{0}
\DoxyCodeLine{v2=v1.array().sin();}
\DoxyCodeLine{v2=v1.array().asin();}
\DoxyCodeLine{v2=v1.array().cos();}
\DoxyCodeLine{v2=v1.array().acos();}
\DoxyCodeLine{v2=v1.array().tan();}
\DoxyCodeLine{v2=v1.array().exp();}
\DoxyCodeLine{v2=v1.array().log();}
\DoxyCodeLine{v2=v1.array().sqrt();}
\DoxyCodeLine{v2=v1.array().square();}
\DoxyCodeLine{v2=v1.array().pow(1.5);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{v?Sin}
\DoxyCodeLine{v?Asin}
\DoxyCodeLine{v?Cos}
\DoxyCodeLine{v?Acos}
\DoxyCodeLine{v?Tan}
\DoxyCodeLine{v?Exp}
\DoxyCodeLine{v?Ln}
\DoxyCodeLine{v?Sqrt}
\DoxyCodeLine{v?Sqr}
\DoxyCodeLine{v?Powx}
\end{DoxyCode}
 \\\cline{1-2}
\end{longtabu}
In the examples, v1 and v2 are dense vectors.\hypertarget{_topic_using_intel_m_k_l_TopicUsingIntelMKL_Links}{}\doxysubsection{Links}\label{_topic_using_intel_m_k_l_TopicUsingIntelMKL_Links}

\begin{DoxyItemize}
\item Intel M\+KL can be purchased and downloaded \href{http://eigen.tuxfamily.org/Counter/redirect_to_mkl.php}{\texttt{ here}}.
\item Intel M\+KL is also bundled with \href{http://software.intel.com/en-us/articles/intel-composer-xe/}{\texttt{ Intel Composer XE}}. 
\end{DoxyItemize}\hypertarget{TopicCUDA}{}\doxysection{Using Eigen in C\+U\+DA kernels}\label{TopicCUDA}
Staring from C\+U\+DA 5.\+5 and \mbox{\hyperlink{namespace_eigen}{Eigen}} 3.\+3, it is possible to use \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s matrices, vectors, and arrays for fixed size within C\+U\+DA kernels. This is especially useful when working on numerous but small problems. By default, when \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s headers are included within a .cu file compiled by nvcc most \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s functions and methods are prefixed by the {\ttfamily {\bfseries{device}}} {\ttfamily {\bfseries{host}}} keywords making them callable from both host and device code. This support can be disabled by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+C\+U\+DA} before including any \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s header. This might be useful to disable some warnings when a .cu file makes use of \mbox{\hyperlink{namespace_eigen}{Eigen}} on the host side only. However, in both cases, host\textquotesingle{}s S\+I\+MD vectorization has to be disabled in .cu files. It is thus {\bfseries{strongly}} {\bfseries{recommended}} to properly move all costly host computation from your .cu files to regular .cpp files.

Known issues\+:


\begin{DoxyItemize}
\item {\ttfamily nvcc} with MS Visual Studio does not work (patch welcome)
\item {\ttfamily nvcc} 5.\+5 with gcc-\/4.\+7 (or greater) has issues with the standard {\ttfamily $<$limits$>$} header file. To workaround this, you can add the following before including any other files\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// workaround issue between gcc >= 4.7 and cuda 5.5}}
\DoxyCodeLine{\textcolor{preprocessor}{\#if (defined \_\_GNUC\_\_) \&\& (\_\_GNUC\_\_>4 || \_\_GNUC\_MINOR\_\_>=7)}}
\DoxyCodeLine{\textcolor{preprocessor}{  \#undef \_GLIBCXX\_ATOMIC\_BUILTINS}}
\DoxyCodeLine{\textcolor{preprocessor}{  \#undef \_GLIBCXX\_USE\_INT128}}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\end{DoxyCode}

\item On 64bits system \mbox{\hyperlink{namespace_eigen}{Eigen}} uses {\ttfamily long} {\ttfamily int} as the default type for indexes and sizes. On C\+U\+DA device, it would make sense to default to 32 bits {\ttfamily int}. However, to keep host and C\+U\+DA code compatible, this cannot be done automatically by Eigen, and the user is thus required to define {\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+D\+E\+N\+S\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE} to {\ttfamily int} throughout his code (or only for C\+U\+DA code if there is no interaction between host and C\+U\+DA code through Eigen\textquotesingle{}s object). 
\end{DoxyItemize}\hypertarget{TopicPitfalls}{}\doxysection{Common pitfalls}\label{TopicPitfalls}
\hypertarget{_topic_pitfalls_TopicPitfalls_template_keyword}{}\doxysubsection{Compilation error with template methods}\label{_topic_pitfalls_TopicPitfalls_template_keyword}
See this \mbox{\hyperlink{_topic_template_keyword}{page }}.\hypertarget{_topic_pitfalls_TopicPitfalls_aliasing}{}\doxysubsection{Aliasing}\label{_topic_pitfalls_TopicPitfalls_aliasing}
Don\textquotesingle{}t miss this \mbox{\hyperlink{group___topic_aliasing}{page }} on aliasing, especially if you got wrong results in statements where the destination appears on the right hand side of the expression.\hypertarget{_topic_pitfalls_TopicPitfalls_alignment_issue}{}\doxysubsection{Alignment Issues (runtime assertion)}\label{_topic_pitfalls_TopicPitfalls_alignment_issue}
Eigen does explicit vectorization, and while that is appreciated by many users, that also leads to some issues in special situations where data alignment is compromised. Indeed, prior to C++17, C++ does not have quite good enough support for explicit data alignment. In that case your program hits an assertion failure (that is, a \char`\"{}controlled crash\char`\"{}) with a message that tells you to consult this page\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{http:\textcolor{comment}{//eigen.tuxfamily.org/dox/group\_\_TopicUnalignedArrayAssert.html}}
\end{DoxyCode}
 Have a look at \mbox{\hyperlink{group___topic_unaligned_array_assert}{it }} and see for yourself if that\textquotesingle{}s something that you can cope with. It contains detailed information about how to deal with each known cause for that issue.

Now what if you don\textquotesingle{}t care about vectorization and so don\textquotesingle{}t want to be annoyed with these alignment issues? Then read \mbox{\hyperlink{getrid}{how to get rid of them }}.\hypertarget{_topic_pitfalls_TopicPitfalls_auto_keyword}{}\doxysubsection{C++11 and the auto keyword}\label{_topic_pitfalls_TopicPitfalls_auto_keyword}
In short\+: do not use the auto keywords with Eigen\textquotesingle{}s expressions, unless you are 100\% sure about what you are doing. In particular, do not use the auto keyword as a replacement for a {\ttfamily Matrix$<$$>$} type. Here is an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXd A, \mbox{\hyperlink{class_eigen_1_1_matrix}{B}};}
\DoxyCodeLine{\textcolor{keyword}{auto} C = A*\mbox{\hyperlink{class_eigen_1_1_matrix}{B}};}
\DoxyCodeLine{\textcolor{keywordflow}{for}(...) \{ ... w = C * v;  ...\}}
\end{DoxyCode}


In this example, the type of C is not a {\ttfamily Matrix\+Xd} but an abstract expression representing a matrix product and storing references to {\ttfamily A} and {\ttfamily B}. Therefore, the product of {\ttfamily A$\ast$B} will be carried out multiple times, once per iteration of the for loop. Moreover, if the coefficients of {\ttfamily A} or {\ttfamily B} change during the iteration, then {\ttfamily C} will evaluate to different values as in the following example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXd A = ..., \mbox{\hyperlink{class_eigen_1_1_matrix}{B}} = ...;}
\DoxyCodeLine{\textcolor{keyword}{auto} C = A*\mbox{\hyperlink{class_eigen_1_1_matrix}{B}};}
\DoxyCodeLine{MatrixXd R1 = C;}
\DoxyCodeLine{A = ...;}
\DoxyCodeLine{MatrixXd R2 = C;}
\end{DoxyCode}
 for which we end up with {\ttfamily R1} {$\ne$} {\ttfamily R2}.

Here is another example leading to a segfault\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} C = ((A+\mbox{\hyperlink{class_eigen_1_1_matrix}{B}}).eval()).transpose();}
\DoxyCodeLine{\textcolor{comment}{// do something with C}}
\end{DoxyCode}
 The problem is that {\ttfamily eval()} returns a temporary object (in this case a {\ttfamily Matrix\+Xd}) which is then referenced by the {\ttfamily Transpose$<$$>$} expression. However, this temporary is deleted right after the first line, and then the {\ttfamily C} expression references a dead object. One possible fix consists in applying {\ttfamily eval()} on the whole expression\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} C = (A+\mbox{\hyperlink{class_eigen_1_1_matrix}{B}}).transpose().eval();}
\end{DoxyCode}


The same issue might occur when sub expressions are automatically evaluated by Eigen as in the following example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{VectorXd u, v;}
\DoxyCodeLine{\textcolor{keyword}{auto} C = u + (A*v).normalized();}
\DoxyCodeLine{\textcolor{comment}{// do something with C}}
\end{DoxyCode}
 Here the {\ttfamily normalized()} method has to evaluate the expensive product {\ttfamily A$\ast$v} to avoid evaluating it twice. Again, one possible fix is to call {\ttfamily }.eval() on the whole expression\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} C = (u + (A*v).normalized()).eval();}
\end{DoxyCode}
 In this case, {\ttfamily C} will be a regular {\ttfamily Vector\+Xd} object. Note that \mbox{\hyperlink{class_eigen_1_1_dense_base_a5df64c66228ba75bbc66db2584185527}{Dense\+Base\+::eval()}} is smart enough to avoid copies when the underlying expression is already a plain {\ttfamily Matrix$<$$>$}.\hypertarget{_topic_pitfalls_TopicPitfalls_header_issues}{}\doxysubsection{Header Issues (failure to compile)}\label{_topic_pitfalls_TopicPitfalls_header_issues}
With all libraries, one must check the documentation for which header to include. The same is true with Eigen, but slightly worse\+: with Eigen, a method in a class may require an additional {\ttfamily \#include} over what the class itself requires! For example, if you want to use the {\ttfamily \mbox{\hyperlink{group__core__func__geometric_ga349f34d7cc9cd71393f96b953a91441a}{cross()}}} method on a vector (it computes a cross-\/product) then you need to\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include<Eigen/Geometry>}}
\end{DoxyCode}
 We try to always document this, but do tell us if we forgot an occurrence.\hypertarget{_topic_pitfalls_TopicPitfalls_ternary_operator}{}\doxysubsection{Ternary operator}\label{_topic_pitfalls_TopicPitfalls_ternary_operator}
In short\+: avoid the use of the ternary operator {\ttfamily (C\+O\+ND ? T\+H\+EN \+: E\+L\+SE)} with Eigen\textquotesingle{}s expressions for the {\ttfamily T\+H\+EN} and {\ttfamily E\+L\+SE} statements. To see why, let\textquotesingle{}s consider the following example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Vector3f A;}
\DoxyCodeLine{A << 1, 2, 3;}
\DoxyCodeLine{Vector3f \mbox{\hyperlink{class_eigen_1_1_matrix}{B}} = ((1 < 0) ? (A.reverse()) : A);}
\end{DoxyCode}
 This example will return {\ttfamily B = 3, 2, 1}. Do you see why? The reason is that in c++ the type of the {\ttfamily E\+L\+SE} statement is inferred from the type of the {\ttfamily T\+H\+EN} expression such that both match. Since {\ttfamily T\+H\+EN} is a {\ttfamily Reverse$<$\+Vector3f$>$}, the {\ttfamily E\+L\+SE} statement A is converted to a {\ttfamily Reverse$<$\+Vector3f$>$}, and the compiler thus generates\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Vector3f \mbox{\hyperlink{class_eigen_1_1_matrix}{B}} = ((1 < 0) ? (A.reverse()) : Reverse<Vector3f>(A));}
\end{DoxyCode}
 In this very particular case, a workaround would be to call A.\+reverse().eval() for the {\ttfamily T\+H\+EN} statement, but the safest and fastest is really to avoid this ternary operator with Eigen\textquotesingle{}s expressions and use a if/else construct.\hypertarget{_topic_pitfalls_TopicPitfalls_pass_by_value}{}\doxysubsection{Pass-\/by-\/value}\label{_topic_pitfalls_TopicPitfalls_pass_by_value}
If you don\textquotesingle{}t know why passing-\/by-\/value is wrong with Eigen, read this \mbox{\hyperlink{group___topic_passing_by_value}{page }} first.

While you may be extremely careful and use care to make sure that all of your code that explicitly uses Eigen types is pass-\/by-\/reference you have to watch out for templates which define the argument types at compile time.

If a template has a function that takes arguments pass-\/by-\/value, and the relevant template parameter ends up being an Eigen type, then you will of course have the same alignment problems that you would in an explicitly defined function passing Eigen types by reference.

Using Eigen types with other third party libraries or even the S\+TL can present the same problem. {\ttfamily boost\+::bind} for example uses pass-\/by-\/value to store arguments in the returned functor. This will of course be a problem.

There are at least two ways around this\+:
\begin{DoxyItemize}
\item If the value you are passing is guaranteed to be around for the life of the functor, you can use boost\+::ref() to wrap the value as you pass it to boost\+::bind. Generally this is not a solution for values on the stack as if the functor ever gets passed to a lower or independent scope, the object may be gone by the time it\textquotesingle{}s attempted to be used.
\item The other option is to make your functions take a reference counted pointer like boost\+::shared\+\_\+ptr as the argument. This avoids needing to worry about managing the lifetime of the object being passed.
\end{DoxyItemize}\hypertarget{_topic_pitfalls_TopicPitfalls_matrix_bool}{}\doxysubsection{Matrices with boolean coefficients}\label{_topic_pitfalls_TopicPitfalls_matrix_bool}
The current behaviour of using {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}} with boolean coefficients is inconsistent and likely to change in future versions of \mbox{\hyperlink{namespace_eigen}{Eigen}}, so please use it carefully!

A simple example for such an inconsistency is


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keywordtype}{int} Size>}
\DoxyCodeLine{\textcolor{keywordtype}{void} foo() \{}
\DoxyCodeLine{  \mbox{\hyperlink{class_eigen_1_1_matrix}{Eigen::Matrix<bool, Size, Size>}} A, \mbox{\hyperlink{class_eigen_1_1_matrix}{B}}, C;}
\DoxyCodeLine{  A.\mbox{\hyperlink{class_eigen_1_1_plain_object_base_a2871e88e1feb1cc665fa1f1cc800078b}{setOnes}}();}
\DoxyCodeLine{  \mbox{\hyperlink{class_eigen_1_1_matrix}{B}}.\mbox{\hyperlink{class_eigen_1_1_plain_object_base_a2871e88e1feb1cc665fa1f1cc800078b}{setOnes}}();}
\DoxyCodeLine{}
\DoxyCodeLine{  C = A * \mbox{\hyperlink{class_eigen_1_1_matrix}{B}} -\/ A * \mbox{\hyperlink{class_eigen_1_1_matrix}{B}};}
\DoxyCodeLine{  std::cout << C << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{\}}
\end{DoxyCode}


since calling {\ttfamily foo$<$3$>$()} prints the zero matrix while calling {\ttfamily foo$<$10$>$()} prints the identity matrix. \hypertarget{TopicTemplateKeyword}{}\doxysection{The template and typename keywords in C++}\label{TopicTemplateKeyword}
There are two uses for the {\ttfamily template} and {\ttfamily typename} keywords in C++. One of them is fairly well known amongst programmers\+: to define templates. The other use is more obscure\+: to specify that an expression refers to a template function or a type. This regularly trips up programmers that use the Eigen library, often leading to error messages from the compiler that are difficult to understand, such as \char`\"{}expected expression\char`\"{} or \char`\"{}no match for operator$<$\char`\"{}.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_template_keyword_TopicTemplateKeywordToDefineTemplates}{}\doxysubsection{Using the template and typename keywords to define templates}\label{_topic_template_keyword_TopicTemplateKeywordToDefineTemplates}
The {\ttfamily template} and {\ttfamily typename} keywords are routinely used to define templates. This is not the topic of this page as we assume that the reader is aware of this (otherwise consult a C++ book). The following example should illustrate this use of the {\ttfamily template} keyword.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\textcolor{keywordtype}{bool} isPositive(\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} x)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} x > 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


We could just as well have written {\ttfamily template $<$class T$>$}; the keywords {\ttfamily typename} and {\ttfamily class} have the same meaning in this context.\hypertarget{_topic_template_keyword_TopicTemplateKeywordExample}{}\doxysubsection{An example showing the second use of the template keyword}\label{_topic_template_keyword_TopicTemplateKeywordExample}
Let us illustrate the second use of the {\ttfamily template} keyword with an example. Suppose we want to write a function which copies all entries in the upper triangular part of a matrix into another matrix, while keeping the lower triangular part unchanged. A straightforward implementation would be as follows\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}


That works fine, but it is not very flexible. First, it only works with dynamic-\/size matrices of single-\/precision floats; the function {\ttfamily copy\+Upper\+Triangular\+Part()} does not accept static-\/size matrices or matrices with double-\/precision numbers. Second, if you use an expression such as {\ttfamily mat.\+top\+Left\+Corner(3,3)} as the parameter {\ttfamily src}, then this is copied into a temporary variable of type Matrix\+Xf; this copy can be avoided.

As explained in \mbox{\hyperlink{TopicFunctionTakingEigenTypes}{Writing Functions Taking Eigen Types as Parameters}}, both issues can be resolved by making {\ttfamily copy\+Upper\+Triangular\+Part()} accept any object of type \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. This leads to the following code\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}


The one line in the body of the function {\ttfamily copy\+Upper\+Triangular\+Part()} shows the second, more obscure use of the {\ttfamily template} keyword in C++. Even though it may look strange, the {\ttfamily template} keywords are necessary according to the standard. Without it, the compiler may reject the code with an error message like \char`\"{}no match
for operator$<$\char`\"{}.\hypertarget{_topic_template_keyword_TopicTemplateKeywordExplanation}{}\doxysubsection{Explanation}\label{_topic_template_keyword_TopicTemplateKeywordExplanation}
The reason that the {\ttfamily template} keyword is necessary in the last example has to do with the rules for how templates are supposed to be compiled in C++. The compiler has to check the code for correct syntax at the point where the template is defined, without knowing the actual value of the template arguments ({\ttfamily Derived1} and {\ttfamily Derived2} in the example). That means that the compiler cannot know that {\ttfamily dst.\+triangular\+View} is a member template and that the following $<$ symbol is part of the delimiter for the template parameter. Another possibility would be that {\ttfamily dst.\+triangular\+View} is a member variable with the $<$ symbol referring to the {\ttfamily operator$<$()} function. In fact, the compiler should choose the second possibility, according to the standard. If {\ttfamily dst.\+triangular\+View} is a member template (as in our case), the programmer should specify this explicitly with the {\ttfamily template} keyword and write {\ttfamily dst.\+template triangular\+View}.

The precise rules are rather complicated, but ignoring some subtleties we can summarize them as follows\+:
\begin{DoxyItemize}
\item A {\itshape dependent name} is name that depends (directly or indirectly) on a template parameter. In the example, {\ttfamily dst} is a dependent name because it is of type {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$Derived1$>$} which depends on the template parameter {\ttfamily Derived1}.
\item If the code contains either one of the constructs {\ttfamily xxx.\+yyy} or {\ttfamily xxx-\/$>$yyy} and {\ttfamily xxx} is a dependent name and {\ttfamily yyy} refers to a member template, then the {\ttfamily template} keyword must be used before {\ttfamily yyy}, leading to {\ttfamily xxx.\+template yyy} or {\ttfamily xxx-\/$>$template yyy}.
\item If the code contains the construct {\ttfamily xxx\+::yyy} and {\ttfamily xxx} is a dependent name and {\ttfamily yyy} refers to a member typedef, then the {\ttfamily typename} keyword must be used before the whole construct, leading to {\ttfamily typename xxx\+::yyy}.
\end{DoxyItemize}

As an example where the {\ttfamily typename} keyword is required, consider the following code in \mbox{\hyperlink{group___tutorial_sparse}{Tutorial\+Sparse}} for iterating over the non-\/zero entries of a sparse matrix type\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{SparseMatrixType mat(rows,cols);}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<mat.outerSize(); ++k)}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (SparseMatrixType::InnerIterator it(mat,k); it; ++it)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    \textcolor{comment}{/* ... */}}
\DoxyCodeLine{  \}}
\end{DoxyCode}


If {\ttfamily Sparse\+Matrix\+Type} depends on a template parameter, then the {\ttfamily typename} keyword is required\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\textcolor{keywordtype}{void} iterateOverSparseMatrix(\textcolor{keyword}{const} SparseMatrix<T>\& mat;}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<m1.outerSize(); ++k)}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} SparseMatrix<T>::InnerIterator it(mat,k); it; ++it)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      \textcolor{comment}{/* ... */}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{_topic_template_keyword_TopicTemplateKeywordResources}{}\doxysubsection{Resources for further reading}\label{_topic_template_keyword_TopicTemplateKeywordResources}
For more information and a fuller explanation of this topic, the reader may consult the following sources\+:
\begin{DoxyItemize}
\item The book \char`\"{}\+C++ Template Metaprogramming\char`\"{} by David Abrahams and Aleksey Gurtovoy contains a very good explanation in Appendix B (\char`\"{}\+The typename and template Keywords\char`\"{}) which formed the basis for this page.
\item \href{http://pages.cs.wisc.edu/~driscoll/typename.html}{\texttt{ http\+://pages.\+cs.\+wisc.\+edu/$\sim$driscoll/typename.\+html}}
\item \href{http://www.parashift.com/c++-faq-lite/templates.html\#faq-35.18}{\texttt{ http\+://www.\+parashift.\+com/c++-\/faq-\/lite/templates.\+html\#faq-\/35.\+18}}
\item \href{http://www.comeaucomputing.com/techtalk/templates/\#templateprefix}{\texttt{ http\+://www.\+comeaucomputing.\+com/techtalk/templates/\#templateprefix}}
\item \href{http://www.comeaucomputing.com/techtalk/templates/\#typename}{\texttt{ http\+://www.\+comeaucomputing.\+com/techtalk/templates/\#typename}} 
\end{DoxyItemize}\hypertarget{UserManual_UnderstandingEigen}{}\doxysection{Understanding Eigen}\label{UserManual_UnderstandingEigen}

\begin{DoxyItemize}
\item \mbox{\hyperlink{TopicInsideEigenExample}{What happens inside Eigen, on a simple example}}
\item \mbox{\hyperlink{TopicClassHierarchy}{The class hierarchy}}
\item \mbox{\hyperlink{TopicLazyEvaluation}{Lazy Evaluation and Aliasing}} 
\end{DoxyItemize}\hypertarget{TopicInsideEigenExample}{}\doxysubsection{What happens inside Eigen, on a simple example}\label{TopicInsideEigenExample}
\textbackslash{}eigen\+Auto\+Toc

\DoxyHorRuler{0}


Consider the following example program\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include<Eigen/Core>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordtype}{int} size = 50;}
\DoxyCodeLine{  \textcolor{comment}{// VectorXf is a vector of floats, with dynamic size.}}
\DoxyCodeLine{  Eigen::VectorXf u(size), v(size), w(size);}
\DoxyCodeLine{  u = v + w;}
\DoxyCodeLine{\}}
\end{DoxyCode}


The goal of this page is to understand how \mbox{\hyperlink{namespace_eigen}{Eigen}} compiles it, assuming that S\+S\+E2 vectorization is enabled (G\+CC option -\/msse2).\hypertarget{_topic_inside_eigen_example_WhyInteresting}{}\doxysubsubsection{Why it\textquotesingle{}s interesting}\label{_topic_inside_eigen_example_WhyInteresting}
Maybe you think, that the above example program is so simple, that compiling it shouldn\textquotesingle{}t involve anything interesting. So before starting, let us explain what is nontrivial in compiling it correctly -- that is, producing optimized code -- so that the complexity of \mbox{\hyperlink{namespace_eigen}{Eigen}}, that we\textquotesingle{}ll explain here, is really useful.

Look at the line of code 
\begin{DoxyCode}{0}
\DoxyCodeLine{u = v + w;   \textcolor{comment}{//   (*)}}
\end{DoxyCode}


The first important thing about compiling it, is that the arrays should be traversed only once, like 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) u[i] = v[i] + w[i];}
\end{DoxyCode}
 The problem is that if we make a naive C++ library where the Vector\+Xf class has an operator+ returning a Vector\+Xf, then the line of code ($\ast$) will amount to\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{VectorXf tmp = v + w;}
\DoxyCodeLine{VectorXf u = tmp;}
\end{DoxyCode}
 Obviously, the introduction of the temporary {\itshape tmp} here is useless. It has a very bad effect on performance, first because the creation of {\itshape tmp} requires a dynamic memory allocation in this context, and second as there are now two for loops\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) tmp[i] = v[i] + w[i];}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) u[i] = tmp[i];}
\end{DoxyCode}
 Traversing the arrays twice instead of once is terrible for performance, as it means that we do many redundant memory accesses.

The second important thing about compiling the above program, is to make correct use of S\+S\+E2 instructions. Notice that \mbox{\hyperlink{namespace_eigen}{Eigen}} also supports Alti\+Vec and that all the discussion that we make here applies also to Alti\+Vec.

S\+S\+E2, like Alti\+Vec, is a set of instructions allowing to perform computations on packets of 128 bits at once. Since a float is 32 bits, this means that S\+S\+E2 instructions can handle 4 floats at once. This means that, if correctly used, they can make our computation go up to 4x faster.

However, in the above program, we have chosen size=50, so our vectors consist of 50 float\textquotesingle{}s, and 50 is not a multiple of 4. This means that we cannot hope to do all of that computation using S\+S\+E2 instructions. The second best thing, to which we should aim, is to handle the 48 first coefficients with S\+S\+E2 instructions, since 48 is the biggest multiple of 4 below 50, and then handle separately, without S\+S\+E2, the 49th and 50th coefficients. Something like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 4*(size/4); i+=4) u.packet(i)  = v.packet(i) + w.packet(i);}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 4*(size/4); i < size; i++) u[i] = v[i] + w[i];}
\end{DoxyCode}


So let us look line by line at our example program, and let\textquotesingle{}s follow \mbox{\hyperlink{namespace_eigen}{Eigen}} as it compiles it.\hypertarget{_topic_inside_eigen_example_ConstructingVectors}{}\doxysubsubsection{Constructing vectors}\label{_topic_inside_eigen_example_ConstructingVectors}
Let\textquotesingle{}s analyze the first line\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Eigen::VectorXf u(size), v(size), w(size);}
\end{DoxyCode}


First of all, Vector\+Xf is the following typedef\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} Matrix<float, Dynamic, 1> VectorXf;}
\end{DoxyCode}


The class template \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} is declared in src/\+Core/util/\+Forward\+Declarations.\+h with 6 template parameters, but the last 3 are automatically determined by the first 3. So you don\textquotesingle{}t need to worry about them for now. Here, \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$<$float, Dynamic, 1$>$ means a matrix of floats, with a dynamic number of rows and 1 column.

The \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class inherits a base class, \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. Don\textquotesingle{}t worry about it, for now it suffices to say that \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} is what unifies matrices/vectors and all the expressions types -- more on that below.

When we do 
\begin{DoxyCode}{0}
\DoxyCodeLine{Eigen::VectorXf u(size);}
\end{DoxyCode}
 the constructor that is called is Matrix\+::\+Matrix(int), in src/\+Core/\+Matrix.\+h. Besides some assertions, all it does is to construct the {\itshape m\+\_\+storage} member, which is of type \mbox{\hyperlink{class_eigen_1_1_dense_storage}{Dense\+Storage}}$<$float, Dynamic, Dynamic, 1$>$.

You may wonder, isn\textquotesingle{}t it overengineering to have the storage in a separate class? The reason is that the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class template covers all kinds of matrices and vector\+: both fixed-\/size and dynamic-\/size. The storage method is not the same in these two cases. For fixed-\/size, the matrix coefficients are stored as a plain member array. For dynamic-\/size, the coefficients will be stored as a pointer to a dynamically-\/allocated array. Because of this, we need to abstract storage away from the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class. That\textquotesingle{}s \mbox{\hyperlink{class_eigen_1_1_dense_storage}{Dense\+Storage}}.

Let\textquotesingle{}s look at this constructor, in src/\+Core/\+Dense\+Storage.\+h. You can see that there are many partial template specializations of Dense\+Storages here, treating separately the cases where dimensions are Dynamic or fixed at compile-\/time. The partial specialization that we are looking at is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} Cols\_> \textcolor{keyword}{class }DenseStorage<\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, \mbox{\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}}, \mbox{\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}}, Cols\_>}
\end{DoxyCode}


Here, the constructor called is Dense\+Storage\+::\+Dense\+Storage(int size, int rows, int columns) with size=50, rows=50, columns=1.

Here is this constructor\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{inline} DenseStorage(\textcolor{keywordtype}{int} size, \textcolor{keywordtype}{int} rows, \textcolor{keywordtype}{int}) : m\_data(internal::aligned\_new<\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}>(size)), m\_rows(rows) \{\}}
\end{DoxyCode}


Here, the {\itshape m\+\_\+data} member is the actual array of coefficients of the matrix. As you see, it is dynamically allocated. Rather than calling new\mbox{[}\mbox{]} or malloc(), as you can see, we have our own internal\+::aligned\+\_\+new defined in src/\+Core/util/\+Memory.\+h. What it does is that if vectorization is enabled, then it uses a platform-\/specific call to allocate a 128-\/bit-\/aligned array, as that is very useful for vectorization with both S\+S\+E2 and Alti\+Vec. If vectorization is disabled, it amounts to the standard new\mbox{[}\mbox{]}.

As you can see, the constructor also sets the {\itshape m\+\_\+rows} member to {\itshape size}. Notice that there is no {\itshape m\+\_\+columns} member\+: indeed, in this partial specialization of \mbox{\hyperlink{class_eigen_1_1_dense_storage}{Dense\+Storage}}, we know the number of columns at compile-\/time, since the Cols\+\_\+ template parameter is different from Dynamic. Namely, in our case, Cols\+\_\+ is 1, which is to say that our vector is just a matrix with 1 column. Hence, there is no need to store the number of columns as a runtime variable.

When you call Vector\+Xf\+::data() to get the pointer to the array of coefficients, it returns Dense\+Storage\+::data() which returns the {\itshape m\+\_\+data} member.

When you call Vector\+Xf\+::size() to get the size of the vector, this is actually a method in the base class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. It determines that the vector is a column-\/vector, since Cols\+At\+Compile\+Time==1 (this comes from the template parameters in the typedef Vector\+Xf). It deduces that the size is the number of rows, so it returns Vector\+Xf\+::rows(), which returns Dense\+Storage\+::rows(), which returns the {\itshape m\+\_\+rows} member, which was set to {\itshape size} by the constructor.\hypertarget{_topic_inside_eigen_example_ConstructionOfSumXpr}{}\doxysubsubsection{Construction of the sum expression}\label{_topic_inside_eigen_example_ConstructionOfSumXpr}
Now that our vectors are constructed, let\textquotesingle{}s move on to the next line\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{u = v + w;}
\end{DoxyCode}


The executive summary is that operator+ returns a \char`\"{}sum of vectors\char`\"{} expression, but doesn\textquotesingle{}t actually perform the computation. It is the operator=, whose call occurs thereafter, that does the computation.

Let us now see what \mbox{\hyperlink{namespace_eigen}{Eigen}} does when it sees this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{v + w}
\end{DoxyCode}


Here, v and w are of type Vector\+Xf, which is a typedef for a specialization of \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} (as we explained above), which is a subclass of \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. So what is being called is


\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixBase::operator+(\textcolor{keyword}{const} MatrixBase\&)}
\end{DoxyCode}


The return type of this operator is 
\begin{DoxyCode}{0}
\DoxyCodeLine{CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\end{DoxyCode}
 The \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} class is our first encounter with an expression template. As we said, the operator+ doesn\textquotesingle{}t by itself perform any computation, it just returns an abstract \char`\"{}sum of vectors\char`\"{} expression. Since there are also \char`\"{}difference of vectors\char`\"{} and \char`\"{}coefficient-\/wise product of vectors\char`\"{} expressions, we unify them all as \char`\"{}coefficient-\/wise binary operations\char`\"{}, which we abbreviate as \char`\"{}\+Cwise\+Binary\+Op\char`\"{}. \char`\"{}\+Coefficient-\/wise\char`\"{} means that the operations is performed coefficient by coefficient. \char`\"{}binary\char`\"{} means that there are two operands -- we are adding two vectors with one another.

Now you might ask, what if we did something like


\begin{DoxyCode}{0}
\DoxyCodeLine{v + w + u;}
\end{DoxyCode}


The first v + w would return a \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} as above, so in order for this to compile, we\textquotesingle{}d need to define an operator+ also in the class \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}... at this point it starts looking like a nightmare\+: are we going to have to define all operators in each of the expression classes (as you guessed, \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} is only one of many) ? This looks like a dead end!

The solution is that \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} itself, as well as \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} and all the other expression types, is a subclass of \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. So it is enough to define once and for all the operators in class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}.

Since \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} is the common base class of different subclasses, the aspects that depend on the subclass must be abstracted from \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. This is called polymorphism.

The classical approach to polymorphism in C++ is by means of virtual functions. This is dynamic polymorphism. Here we don\textquotesingle{}t want dynamic polymorphism because the whole design of \mbox{\hyperlink{namespace_eigen}{Eigen}} is based around the assumption that all the complexity, all the abstraction, gets resolved at compile-\/time. This is crucial\+: if the abstraction can\textquotesingle{}t get resolved at compile-\/time, \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s compile-\/time optimization mechanisms become useless, not to mention that if that abstraction has to be resolved at runtime it\textquotesingle{}ll incur an overhead by itself.

Here, what we want is to have a single class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} as the base of many subclasses, in such a way that each \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} object (be it a matrix, or vector, or any kind of expression) knows at compile-\/time (as opposed to run-\/time) of which particular subclass it is an object (i.\+e. whether it is a matrix, or an expression, and what kind of expression).

The solution is the \href{http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern}{\texttt{ Curiously Recurring Template Pattern}}. Let\textquotesingle{}s do the break now. Hopefully you can read this wikipedia page during the break if needed, but it won\textquotesingle{}t be allowed during the exam.

In short, \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} takes a template parameter {\itshape Derived}. Whenever we define a subclass Subclass, we actually make Subclass inherit \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$Subclass$>$. The point is that different subclasses inherit different \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} types. Thanks to this, whenever we have an object of a subclass, and we call on it some \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} method, we still remember even from inside the \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} method which particular subclass we\textquotesingle{}re talking about.

This means that we can put almost all the methods and operators in the base class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}, and have only the bare minimum in the subclasses. If you look at the subclasses in \mbox{\hyperlink{namespace_eigen}{Eigen}}, like for instance the \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} class, they have very few methods. There are coeff() and sometimes coeff\+Ref() methods for access to the coefficients, there are rows() and cols() methods returning the number of rows and columns, but there isn\textquotesingle{}t much more than that. All the meat is in \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}, so it only needs to be coded once for all kinds of expressions, matrices, and vectors.

So let\textquotesingle{}s end this digression and come back to the piece of code from our example program that we were currently analyzing,


\begin{DoxyCode}{0}
\DoxyCodeLine{v + w}
\end{DoxyCode}


Now that \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} is a good friend, let\textquotesingle{}s write fully the prototype of the operator+ that gets called here (this code is from src/\+Core/\+Matrix\+Base.\+h)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{class }MatrixBase}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{  \textcolor{keyword}{const} CwiseBinaryOp<internal::scalar\_sum\_op<typename internal::traits<Derived>::Scalar>, Derived, OtherDerived>}
\DoxyCodeLine{  operator+(\textcolor{keyword}{const} MatrixBase<OtherDerived> \&other) \textcolor{keyword}{const};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Here of course, {\itshape Derived} and {\itshape Other\+Derived} are Vector\+Xf.

As we said, \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} is also used for other operations such as substration, so it takes another template parameter determining the operation that will be applied to coefficients. This template parameter is a functor, that is, a class in which we have an operator() so it behaves like a function. Here, the functor used is \mbox{\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal\+::scalar\+\_\+sum\+\_\+op}}. It is defined in src/\+Core/\+Functors.\+h.

Let us now explain the \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}} here. The \mbox{\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal\+::scalar\+\_\+sum\+\_\+op}} class takes one template parameter\+: the type of the numbers to handle. Here of course we want to pass the scalar type (a.\+k.\+a. numeric type) of Vector\+Xf, which is {\ttfamily float}. How do we determine which is the scalar type of {\itshape Derived} ? Throughout \mbox{\hyperlink{namespace_eigen}{Eigen}}, all matrix and expression types define a typedef {\itshape Scalar} which gives its scalar type. For example, Vector\+Xf\+::\+Scalar is a typedef for {\ttfamily float}. So here, if life was easy, we could find the numeric type of {\itshape Derived} as just 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typename} Derived::Scalar}
\end{DoxyCode}
 Unfortunately, we can\textquotesingle{}t do that here, as the compiler would complain that the type Derived hasn\textquotesingle{}t yet been defined. So we use a workaround\+: in src/\+Core/util/\+Forward\+Declarations.\+h, we declared (not defined!) all our subclasses, like \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, and we also declared the following class template\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }internal::traits;}
\end{DoxyCode}
 In src/\+Core/\+Matrix.\+h, right {\itshape before} the definition of class \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, we define a partial specialization of \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}} for T=\mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$<$any template parameters$>$. In this specialization of \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}}, we define the Scalar typedef. So when we actually define \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, it is legal to refer to \char`\"{}typename internal\+::traits\textbackslash{}$<$\+Matrix\textbackslash{}$>$\+::\+Scalar\char`\"{}.

Anyway, we have declared our operator+. In our case, where {\itshape Derived} and {\itshape Other\+Derived} are Vector\+Xf, the above declaration amounts to\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MatrixBase<VectorXf>}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\DoxyCodeLine{  operator+(\textcolor{keyword}{const} MatrixBase<VectorXf> \&other) \textcolor{keyword}{const};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Let\textquotesingle{}s now jump to src/\+Core/\+Cwise\+Binary\+Op.\+h to see how it is defined. As you can see there, all it does is to return a \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} object, and this object is just storing references to the left-\/hand-\/side and right-\/hand-\/side expressions -- here, these are the vectors {\itshape v} and {\itshape w}. Well, the \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} object is also storing an instance of the (empty) functor class, but you shouldn\textquotesingle{}t worry about it as that is a minor implementation detail.

Thus, the operator+ hasn\textquotesingle{}t performed any actual computation. To summarize, the operation {\itshape v} + {\itshape w} just returned an object of type \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} which did nothing else than just storing references to {\itshape v} and {\itshape w}.\hypertarget{_topic_inside_eigen_example_Assignment}{}\doxysubsubsection{The assignment}\label{_topic_inside_eigen_example_Assignment}
 {\bfseries{P\+L\+E\+A\+SE H\+E\+LP US I\+M\+P\+R\+O\+V\+I\+NG T\+H\+IS S\+E\+C\+T\+I\+ON.}} This page reflects how Eigen worked until 3.\+2, but since Eigen 3.\+3 the assignment is more sophisticated as it involves an Assignment expression, and the creation of so called evaluator which are responsible for the evaluation of each kind of expressions. 

At this point, the expression {\itshape v} + {\itshape w} has finished evaluating, so, in the process of compiling the line of code 
\begin{DoxyCode}{0}
\DoxyCodeLine{u = v + w;}
\end{DoxyCode}
 we now enter the operator=.

What operator= is being called here? The vector u is an object of class Vector\+Xf, i.\+e. \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}. In src/\+Core/\+Matrix.\+h, inside the definition of class \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, we see this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{inline} Matrix\& operator=(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  eigen\_assert(m\_storage.data()!=0 \&\& \textcolor{stringliteral}{"you cannot use operator= with a non initialized matrix (instead use set()"});}
\DoxyCodeLine{  \textcolor{keywordflow}{return} Base::operator=(other.derived());}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Here, Base is a typedef for \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$\mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$>$. So, what is being called is the operator= of \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. Let\textquotesingle{}s see its prototype in src/\+Core/\+Matrix\+Base.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{Derived\& operator=(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other);}
\end{DoxyCode}
 Here, {\itshape Derived} is Vector\+Xf (since u is a Vector\+Xf) and {\itshape Other\+Derived} is \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}. More specifically, as explained in the previous section, {\itshape Other\+Derived} is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\end{DoxyCode}
 So the full prototype of the operator= being called is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{VectorXf\& \mbox{\hyperlink{class_eigen_1_1_matrix_base_a706a4dd1ee54786e9210de1a4bf02600}{MatrixBase<VectorXf>::operator=}}(\textcolor{keyword}{const} MatrixBase<CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf> > \& other);}
\end{DoxyCode}
 This operator= literally reads \char`\"{}copying a sum of two Vector\+Xf\textquotesingle{}s into another Vector\+Xf\char`\"{}.

Let\textquotesingle{}s now look at the implementation of this operator=. It resides in the file src/\+Core/\+Assign.\+h.

What we can see there is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{inline} Derived\& \mbox{\hyperlink{class_eigen_1_1_matrix_base_a706a4dd1ee54786e9210de1a4bf02600}{MatrixBase<Derived>}}}
\DoxyCodeLine{\mbox{\hyperlink{class_eigen_1_1_matrix_base_a706a4dd1ee54786e9210de1a4bf02600}{  ::operator=}}(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} internal::assign\_selector<Derived,OtherDerived>::run(derived(), other.derived());}
\DoxyCodeLine{\}}
\end{DoxyCode}


OK so our next task is to understand internal\+::assign\+\_\+selector \+:)

Here is its declaration (all that is still in the same file src/\+Core/\+Assign.\+h) 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived,}
\DoxyCodeLine{         \textcolor{keywordtype}{bool} EvalBeforeAssigning = int(OtherDerived::Flags) \& \mbox{\hyperlink{group__flags_gae4b8ae7db0d83f9bbed26b261e60e139}{EvalBeforeAssigningBit}},}
\DoxyCodeLine{         \textcolor{keywordtype}{bool} NeedToTranspose = Derived::IsVectorAtCompileTime}
\DoxyCodeLine{                \&\& OtherDerived::IsVectorAtCompileTime}
\DoxyCodeLine{                \&\& int(Derived::RowsAtCompileTime) == int(OtherDerived::ColsAtCompileTime)}
\DoxyCodeLine{                \&\& int(Derived::ColsAtCompileTime) == int(OtherDerived::RowsAtCompileTime)}
\DoxyCodeLine{                \&\& int(Derived::SizeAtCompileTime) != 1>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_selector;}
\end{DoxyCode}


So internal\+::assign\+\_\+selector takes 4 template parameters, but the 2 last ones are automatically determined by the 2 first ones.

Eval\+Before\+Assigning is here to enforce the Eval\+Before\+Assigning\+Bit. As explained \href{TopicLazyEvaluation.html}{\texttt{ here}}, certain expressions have this flag which makes them automatically evaluate into temporaries before assigning them to another expression. This is the case of the \mbox{\hyperlink{class_eigen_1_1_product}{Product}} expression, in order to avoid strange aliasing effects when doing \char`\"{}m = m $\ast$ m;\char`\"{} However, of course here our \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} expression doesn\textquotesingle{}t have the Eval\+Before\+Assigning\+Bit\+: we said since the beginning that we didn\textquotesingle{}t want a temporary to be introduced here. So if you go to src/\+Core/\+Cwise\+Binary\+Op.\+h, you\textquotesingle{}ll see that the Flags in \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}}$<$\mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}$>$ don\textquotesingle{}t include the Eval\+Before\+Assigning\+Bit. The Flags member of \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} is then imported from the \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}} by the E\+I\+G\+E\+N\+\_\+\+G\+E\+N\+E\+R\+I\+C\+\_\+\+P\+U\+B\+L\+I\+C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE macro. Anyway, here the template parameter Eval\+Before\+Assigning has the value {\ttfamily false}.

Need\+To\+Transpose is here for the case where the user wants to copy a row-\/vector into a column-\/vector. We allow this as a special exception to the general rule that in assignments we require the dimesions to match. Anyway, here both the left-\/hand and right-\/hand sides are column vectors, in the sense that Cols\+At\+Compile\+Time is equal to 1. So Need\+To\+Transpose is {\ttfamily false} too.

So, here we are in the partial specialization\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal::assign\_selector<Derived, OtherDerived, false, false>}
\end{DoxyCode}


Here\textquotesingle{}s how it is defined\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_selector<Derived,OtherDerived,false,false> \{}
\DoxyCodeLine{  \textcolor{keyword}{static} Derived\& \mbox{\hyperlink{namespace_eigen_a1fb05f2dfd1e1974dc016cff6f349f98}{run}}(Derived\& dst, \textcolor{keyword}{const} OtherDerived\& other) \{ \textcolor{keywordflow}{return} dst.lazyAssign(other.derived()); \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


OK so now our next job is to understand how lazy\+Assign works \+:)


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{inline} Derived\& \mbox{\hyperlink{class_eigen_1_1_dense_base_adf691c9d5e89728815b91e42ebf9758d}{MatrixBase<Derived>}}}
\DoxyCodeLine{\mbox{\hyperlink{class_eigen_1_1_dense_base_adf691c9d5e89728815b91e42ebf9758d}{  ::lazyAssign}}(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  EIGEN\_STATIC\_ASSERT\_SAME\_MATRIX\_SIZE(Derived,OtherDerived)}
\DoxyCodeLine{  eigen\_assert(rows() == other.rows() \&\& cols() == other.cols());}
\DoxyCodeLine{  internal::assign\_impl<Derived, OtherDerived>::run(derived(),other.derived());}
\DoxyCodeLine{  \textcolor{keywordflow}{return} derived();}
\DoxyCodeLine{\}}
\end{DoxyCode}


What do we see here? Some assertions, and then the only interesting line is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal::assign\_impl<Derived, OtherDerived>::run(derived(),other.derived());}
\end{DoxyCode}


OK so now we want to know what is inside internal\+::assign\+\_\+impl.

Here is its declaration\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived1, \textcolor{keyword}{typename} Derived2,}
\DoxyCodeLine{         \textcolor{keywordtype}{int} Vectorization = internal::assign\_traits<Derived1, Derived2>::Vectorization,}
\DoxyCodeLine{         \textcolor{keywordtype}{int} Unrolling = internal::assign\_traits<Derived1, Derived2>::Unrolling>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_impl;}
\end{DoxyCode}
 Again, internal\+::assign\+\_\+selector takes 4 template parameters, but the 2 last ones are automatically determined by the 2 first ones.

These two parameters {\itshape Vectorization} and {\itshape Unrolling} are determined by a helper class internal\+::assign\+\_\+traits. Its job is to determine which vectorization strategy to use (that is {\itshape Vectorization}) and which unrolling strategy to use (that is {\itshape Unrolling}).

We\textquotesingle{}ll not enter into the details of how these strategies are chosen (this is in the implementation of internal\+::assign\+\_\+traits at the top of the same file). Let\textquotesingle{}s just say that here {\itshape Vectorization} has the value {\itshape Linear\+Vectorization}, and {\itshape Unrolling} has the value {\itshape No\+Unrolling} (the latter is obvious since our vectors have dynamic size so there\textquotesingle{}s no way to unroll the loop at compile-\/time).

So the partial specialization of internal\+::assign\+\_\+impl that we\textquotesingle{}re looking at is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal::assign\_impl<Derived1, Derived2, LinearVectorization, NoUnrolling>}
\end{DoxyCode}


Here is how it\textquotesingle{}s defined\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived1, \textcolor{keyword}{typename} Derived2>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_impl<Derived1, Derived2, LinearVectorization, NoUnrolling>}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespace_eigen_a1fb05f2dfd1e1974dc016cff6f349f98}{run}}(Derived1 \&dst, \textcolor{keyword}{const} Derived2 \&src)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} size = dst.size();}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} packetSize = internal::packet\_traits<typename Derived1::Scalar>::size;}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} alignedStart = internal::assign\_traits<Derived1,Derived2>::DstIsAligned ? 0}
\DoxyCodeLine{                           : internal::first\_aligned(\&dst.coeffRef(0), size);}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} alignedEnd = alignedStart + ((size-\/alignedStart)/packetSize)*packetSize;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = 0; index < alignedStart; index++)}
\DoxyCodeLine{      dst.copyCoeff(index, src);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedStart; index < alignedEnd; index += packetSize)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      dst.template copyPacket<Derived2, Aligned, internal::assign\_traits<Derived1,Derived2>::SrcAlignment>(index, src);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedEnd; index < size; index++)}
\DoxyCodeLine{      dst.copyCoeff(index, src);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Here\textquotesingle{}s how it works. {\itshape Linear\+Vectorization} means that the left-\/hand and right-\/hand side expression can be accessed linearly i.\+e. you can refer to their coefficients by one integer {\itshape index}, as opposed to having to refer to its coefficients by two integers {\itshape row}, {\itshape column}.

As we said at the beginning, vectorization works with blocks of 4 floats. Here, {\itshape Packet\+Size} is 4.

There are two potential problems that we need to deal with\+: \begin{DoxyItemize}
\item first, vectorization works much better if the packets are 128-\/bit-\/aligned. This is especially important for write access. So when writing to the coefficients of {\itshape dst}, we want to group these coefficients by packets of 4 such that each of these packets is 128-\/bit-\/aligned. In general, this requires to skip a few coefficients at the beginning of {\itshape dst}. This is the purpose of {\itshape aligned\+Start}. We then copy these first few coefficients one by one, not by packets. However, in our case, the {\itshape dst} expression is a Vector\+Xf and remember that in the construction of the vectors we allocated aligned arrays. Thanks to {\itshape Dst\+Is\+Aligned}, \mbox{\hyperlink{namespace_eigen}{Eigen}} remembers that without having to do any runtime check, so {\itshape aligned\+Start} is zero and this part is avoided altogether. \item second, the number of coefficients to copy is not in general a multiple of {\itshape packet\+Size}. Here, there are 50 coefficients to copy and {\itshape packet\+Size} is 4. So we\textquotesingle{}ll have to copy the last 2 coefficients one by one, not by packets. Here, {\itshape aligned\+End} is 48.\end{DoxyItemize}
Now come the actual loops.

First, the vectorized part\+: the 48 first coefficients out of 50 will be copied by packets of 4\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedStart; index < alignedEnd; index += packetSize)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  dst.template copyPacket<Derived2, Aligned, internal::assign\_traits<Derived1,Derived2>::SrcAlignment>(index, src);}
\DoxyCodeLine{\}}
\end{DoxyCode}


What is copy\+Packet? It is defined in src/\+Core/\+Coeffs.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived, \textcolor{keywordtype}{int} StoreMode, \textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} MatrixBase<Derived>::copyPacket(\textcolor{keywordtype}{int} index, \textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  eigen\_internal\_assert(index >= 0 \&\& index < size());}
\DoxyCodeLine{  derived().template writePacket<StoreMode>(index,}
\DoxyCodeLine{    other.derived().template packet<LoadMode>(index));}
\DoxyCodeLine{\}}
\end{DoxyCode}


OK, what are write\+Packet() and packet() here?

First, write\+Packet() here is a method on the left-\/hand side Vector\+Xf. So we go to src/\+Core/\+Matrix.\+h to look at its definition\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode>}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} writePacket(\textcolor{keywordtype}{int} index, \textcolor{keyword}{const} PacketScalar\& x)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  internal::pstoret<Scalar, PacketScalar, StoreMode>(m\_storage.data() + index, x);}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Here, {\itshape Store\+Mode} is {\itshape \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned}}}, indicating that we are doing a 128-\/bit-\/aligned write access, {\itshape Packet\+Scalar} is a type representing a \char`\"{}\+S\+S\+E packet of 4 floats\char`\"{} and internal\+::pstoret is a function writing such a packet in memory. Their definitions are architecture-\/specific, we find them in src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h\+:

The line in src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h that determines the Packet\+Scalar type (via a typedef in Matrix.\+h) is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{struct }internal::packet\_traits<float>  \{ \textcolor{keyword}{typedef} \_\_m128  type; \textcolor{keyword}{enum} \{size=4\}; \};}
\end{DoxyCode}
 Here, \+\_\+\+\_\+m128 is a S\+S\+E-\/specific type. Notice that the enum {\itshape size} here is what was used to define {\itshape packet\+Size} above.

And here is the implementation of internal\+::pstoret\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{void} internal::pstore(\textcolor{keywordtype}{float}*  to, \textcolor{keyword}{const} \_\_m128\&  from) \{ \_mm\_store\_ps(to, from); \}}
\end{DoxyCode}
 Here, \+\_\+\+\_\+mm\+\_\+store\+\_\+ps is a S\+S\+E-\/specific intrinsic function, representing a single S\+SE instruction. The difference between internal\+::pstore and internal\+::pstoret is that internal\+::pstoret is a dispatcher handling both the aligned and unaligned cases, you find its definition in src/\+Core/\+Generic\+Packet\+Math.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Packet, \textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} internal::pstoret(Scalar* to, \textcolor{keyword}{const} \mbox{\hyperlink{class_eigen_1_1_triplet}{Packet}}\& from)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{if}(LoadMode == \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned}})}
\DoxyCodeLine{    internal::pstore(to, from);}
\DoxyCodeLine{  \textcolor{keywordflow}{else}}
\DoxyCodeLine{    internal::pstoreu(to, from);}
\DoxyCodeLine{\}}
\end{DoxyCode}


OK, that explains how write\+Packet() works. Now let\textquotesingle{}s look into the packet() call. Remember that we are analyzing this line of code inside copy\+Packet()\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{derived().template writePacket<StoreMode>(index,}
\DoxyCodeLine{    other.derived().template packet<LoadMode>(index));}
\end{DoxyCode}


Here, {\itshape other} is our sum expression {\itshape v} + {\itshape w}. The .derived() is just casting from \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} to the subclass which here is \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}. So let\textquotesingle{}s go to src/\+Core/\+Cwise\+Binary\+Op.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }CwiseBinaryOp}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{    \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{    \textcolor{keyword}{inline} PacketScalar packet(\textcolor{keywordtype}{int} index)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{    }\{}
\DoxyCodeLine{      \textcolor{keywordflow}{return} m\_functor.packetOp(m\_lhs.template packet<LoadMode>(index), m\_rhs.template packet<LoadMode>(index));}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
 Here, {\itshape m\+\_\+lhs} is the vector {\itshape v}, and {\itshape m\+\_\+rhs} is the vector {\itshape w}. So the packet() function here is Matrix\+::packet(). The template parameter {\itshape Load\+Mode} is {\itshape \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned}}}. So we\textquotesingle{}re looking at 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }Matrix}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{    \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{    \textcolor{keyword}{inline} PacketScalar packet(\textcolor{keywordtype}{int} index)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{    }\{}
\DoxyCodeLine{      \textcolor{keywordflow}{return} internal::ploadt<Scalar, LoadMode>(m\_storage.data() + index);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
 We let you look up the definition of internal\+::ploadt in Generic\+Packet\+Math.\+h and the internal\+::pload in src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h. It is very similar to the above for internal\+::pstore.

Let\textquotesingle{}s go back to Cwise\+Binary\+Op\+::packet(). Once the packets from the vectors {\itshape v} and {\itshape w} have been returned, what does this function do? It calls m\+\_\+functor.\+packet\+Op() on them. What is m\+\_\+functor? Here we must remember what particular template specialization of \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} we\textquotesingle{}re dealing with\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\end{DoxyCode}
 So m\+\_\+functor is an object of the empty class internal\+::scalar\+\_\+sum\+\_\+op$<$float$>$. As we mentioned above, don\textquotesingle{}t worry about why we constructed an object of this empty class at all -- it\textquotesingle{}s an implementation detail, the point is that some other functors need to store member data.

Anyway, \mbox{\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal\+::scalar\+\_\+sum\+\_\+op}} is defined in src/\+Core/\+Functors.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }internal::scalar\_sum\_op EIGEN\_EMPTY\_STRUCT \{}
\DoxyCodeLine{  \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar\& a, \textcolor{keyword}{const} Scalar\& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a + b; \}}
\DoxyCodeLine{  \textcolor{keyword}{template}<\textcolor{keyword}{typename} PacketScalar>}
\DoxyCodeLine{  \textcolor{keyword}{inline} \textcolor{keyword}{const} PacketScalar packetOp(\textcolor{keyword}{const} PacketScalar\& a, \textcolor{keyword}{const} PacketScalar\& b)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::padd(a,b); \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
 As you can see, all what packet\+Op() does is to call internal\+::padd on the two packets. Here is the definition of internal\+::padd from src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{inline} \_\_m128  internal::padd(\textcolor{keyword}{const} \_\_m128\&  a, \textcolor{keyword}{const} \_\_m128\&  b) \{ \textcolor{keywordflow}{return} \_mm\_add\_ps(a,b); \}}
\end{DoxyCode}
 Here, \+\_\+mm\+\_\+add\+\_\+ps is a S\+S\+E-\/specific intrinsic function, representing a single S\+SE instruction.

To summarize, the loop 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedStart; index < alignedEnd; index += packetSize)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  dst.template copyPacket<Derived2, Aligned, internal::assign\_traits<Derived1,Derived2>::SrcAlignment>(index, src);}
\DoxyCodeLine{\}}
\end{DoxyCode}
 has been compiled to the following code\+: for {\itshape index} going from 0 to the 11 ( = 48/4 -\/ 1), read the i-\/th packet (of 4 floats) from the vector v and the i-\/th packet from the vector w using two \+\_\+\+\_\+mm\+\_\+load\+\_\+ps S\+SE instructions, then add them together using a \+\_\+\+\_\+mm\+\_\+add\+\_\+ps instruction, then store the result using a \+\_\+\+\_\+mm\+\_\+store\+\_\+ps instruction.

There remains the second loop handling the last few (here, the last 2) coefficients\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedEnd; index < size; index++)}
\DoxyCodeLine{  dst.copyCoeff(index, src);}
\end{DoxyCode}
 However, it works just like the one we just explained, it is just simpler because there is no S\+SE vectorization involved here. copy\+Packet() becomes copy\+Coeff(), packet() becomes coeff(), write\+Packet() becomes coeff\+Ref(). If you followed us this far, you can probably understand this part by yourself.

We see that all the C++ abstraction of \mbox{\hyperlink{namespace_eigen}{Eigen}} goes away during compilation and that we indeed are precisely controlling which assembly instructions we emit. Such is the beauty of C++! Since we have such precise control over the emitted assembly instructions, but such complex logic to choose the right instructions, we can say that \mbox{\hyperlink{namespace_eigen}{Eigen}} really behaves like an optimizing compiler. If you prefer, you could say that \mbox{\hyperlink{namespace_eigen}{Eigen}} behaves like a script for the compiler. In a sense, C++ template metaprogramming is scripting the compiler -- and it\textquotesingle{}s been shown that this scripting language is Turing-\/complete. See \href{http://en.wikipedia.org/wiki/Template_metaprogramming}{\texttt{ Wikipedia}}. \hypertarget{TopicClassHierarchy}{}\doxysubsection{The class hierarchy}\label{TopicClassHierarchy}
This page explains the design of the core classes in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s class hierarchy and how they fit together. Casual users probably need not concern themselves with these details, but it may be useful for both advanced users and \mbox{\hyperlink{namespace_eigen}{Eigen}} developers.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_class_hierarchy_TopicClassHierarchyPrinciples}{}\doxysubsubsection{Principles}\label{_topic_class_hierarchy_TopicClassHierarchyPrinciples}
\mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s class hierarchy is designed so that virtual functions are avoided where their overhead would significantly impair performance. Instead, \mbox{\hyperlink{namespace_eigen}{Eigen}} achieves polymorphism with the Curiously Recurring Template Pattern (C\+R\+TP). In this pattern, the base class (for instance, {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}}) is in fact a template class, and the derived class (for instance, {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}}) inherits the base class with the derived class itself as a template argument (in this case, {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}} inherits from {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$\mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$>$}). This allows \mbox{\hyperlink{namespace_eigen}{Eigen}} to resolve the polymorphic function calls at compile time.

In addition, the design avoids multiple inheritance. One reason for this is that in our experience, some compilers (like M\+S\+VC) fail to perform empty base class optimization, which is crucial for our fixed-\/size types.\hypertarget{_topic_class_hierarchy_TopicClassHierarchyCoreClasses}{}\doxysubsubsection{The core classes}\label{_topic_class_hierarchy_TopicClassHierarchyCoreClasses}
These are the classes that you need to know about if you want to write functions that accept or return \mbox{\hyperlink{namespace_eigen}{Eigen}} objects.


\begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} means plain dense matrix. If {\ttfamily m} is a {\ttfamily Matrix}, then, for instance, {\ttfamily m+m} is no longer a {\ttfamily Matrix}, it is a \char`\"{}matrix expression\char`\"{}.
\item \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} means dense matrix expression. This means that a {\ttfamily Matrix\+Base} is something that can be added, matrix-\/multiplied, L\+U-\/decomposed, Q\+R-\/decomposed... All matrix expression classes, including {\ttfamily Matrix} itself, inherit {\ttfamily Matrix\+Base}.
\item \mbox{\hyperlink{class_eigen_1_1_array}{Array}} means plain dense array. If {\ttfamily x} is an {\ttfamily Array}, then, for instance, {\ttfamily x+x} is no longer an {\ttfamily Array}, it is an \char`\"{}array expression\char`\"{}.
\item \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} means dense array expression. This means that an {\ttfamily Array\+Base} is something that can be added, array-\/multiplied, and on which you can perform all sorts of array operations... All array expression classes, including {\ttfamily Array} itself, inherit {\ttfamily Array\+Base}.
\item \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}} means dense (matrix or array) expression. Both {\ttfamily Array\+Base} and {\ttfamily Matrix\+Base} inherit {\ttfamily Dense\+Base}. {\ttfamily Dense\+Base} is where all the methods go that apply to dense expressions regardless of whether they are matrix or array expressions. For example, the \mbox{\hyperlink{}{block(...) }} methods are in {\ttfamily Dense\+Base}.
\end{DoxyItemize}\hypertarget{_topic_class_hierarchy_TopicClassHierarchyBaseClasses}{}\doxysubsubsection{Base classes}\label{_topic_class_hierarchy_TopicClassHierarchyBaseClasses}
These classes serve as base classes for the five core classes mentioned above. They are more internal and so less interesting for users of the \mbox{\hyperlink{namespace_eigen}{Eigen}} library.


\begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{Plain\+Object\+Base}} means dense (matrix or array) plain object, i.\+e. something that stores its own dense array of coefficients. This is where, for instance, the \mbox{\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize() }} methods go. {\ttfamily Plain\+Object\+Base} is inherited by {\ttfamily Matrix} and by {\ttfamily Array}. But above, we said that {\ttfamily Matrix} inherits {\ttfamily Matrix\+Base} and {\ttfamily Array} inherits {\ttfamily Array\+Base}. So does that mean multiple inheritance? No, because {\ttfamily Plain\+Object\+Base} {\itshape itself} inherits {\ttfamily Matrix\+Base} or {\ttfamily Array\+Base} depending on whether we are in the matrix or array case. When we said above that {\ttfamily Matrix} inherited {\ttfamily Matrix\+Base}, we omitted to say it does so indirectly via {\ttfamily Plain\+Object\+Base}. Same for {\ttfamily Array}.
\item \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{Dense\+Coeffs\+Base}} means something that has dense coefficient accessors. It is a base class for {\ttfamily Dense\+Base}. The reason for {\ttfamily Dense\+Coeffs\+Base} to exist is that the set of available coefficient accessors is very different depending on whether a dense expression has direct memory access or not (the {\ttfamily Direct\+Access\+Bit} flag). For example, if {\ttfamily x} is a plain matrix, then {\ttfamily x} has direct access, and {\ttfamily x.\+transpose()} and {\ttfamily x.\+block(...)} also have direct access, because their coefficients can be read right off memory, but for example, {\ttfamily x+x} does not have direct memory access, because obtaining any of its coefficients requires a computation (an addition), it can\textquotesingle{}t be just read off memory.
\item \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}} means anything that can be evaluated into a plain dense matrix or array (even if that would be a bad idea). {\ttfamily Eigen\+Base} is really the absolute base class for anything that remotely looks like a matrix or array. It is a base class for {\ttfamily Dense\+Coeffs\+Base}, so it sits below all our dense class hierarchy, but it is not limited to dense expressions. For example, {\ttfamily Eigen\+Base} is also inherited by diagonal matrices, sparse matrices, etc...
\end{DoxyItemize}\hypertarget{_topic_class_hierarchy_TopicClassHierarchyInheritanceDiagrams}{}\doxysubsubsection{Inheritance diagrams}\label{_topic_class_hierarchy_TopicClassHierarchyInheritanceDiagrams}
The inheritance diagram for \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<Matrix>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<Matrix>    (direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<Matrix>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_matrix_base}{MatrixBase}}<Matrix>
        <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{PlainObjectBase}}<Matrix>    (matrix case)
          <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}
\end{DoxyPre}


The inheritance diagram for \mbox{\hyperlink{class_eigen_1_1_array}{Array}} looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<Array>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<Array>    (direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<Array>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_array_base}{ArrayBase}}<Array>
        <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{PlainObjectBase}}<Array>    (array case)
          <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_array}{Array}}
\end{DoxyPre}


The inheritance diagram for some other matrix expression class, here denoted by {\ttfamily Some\+Matrix\+Xpr}, looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<SomeMatrixXpr>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<SomeMatrixXpr>    (direct access or no direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<SomeMatrixXpr>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_matrix_base}{MatrixBase}}<SomeMatrixXpr>
        <-\/-\/ SomeMatrixXpr
\end{DoxyPre}


The inheritance diagram for some other array expression class, here denoted by {\ttfamily Some\+Array\+Xpr}, looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<SomeArrayXpr>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<SomeArrayXpr>    (direct access or no direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<SomeArrayXpr>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_array_base}{ArrayBase}}<SomeArrayXpr>
        <-\/-\/ SomeArrayXpr
\end{DoxyPre}


Finally, consider an example of something that is not a dense expression, for instance a diagonal matrix. The corresponding inheritance diagram is\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<DiagonalMatrix>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_diagonal_base}{DiagonalBase}}<DiagonalMatrix>
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_diagonal_matrix}{DiagonalMatrix}}
\end{DoxyPre}
 \hypertarget{TopicLazyEvaluation}{}\doxysubsection{Lazy Evaluation and Aliasing}\label{TopicLazyEvaluation}
Executive summary\+: Eigen has intelligent compile-\/time mechanisms to enable lazy evaluation and removing temporaries where appropriate. It will handle aliasing automatically in most cases, for example with matrix products. The automatic behavior can be overridden manually by using the \mbox{\hyperlink{class_eigen_1_1_dense_base_a5df64c66228ba75bbc66db2584185527}{Matrix\+Base\+::eval()}} and \mbox{\hyperlink{class_eigen_1_1_matrix_base_a7f15120bb9c88c30aa5d993bd6d138e1}{Matrix\+Base\+::noalias()}} methods.

When you write a line of code involving a complex expression such as


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} * (\mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}} + mat5);}
\end{DoxyCode}


Eigen determines automatically, for each sub-\/expression, whether to evaluate it into a temporary variable. Indeed, in certain cases it is better to evaluate a sub-\/expression into a temporary variable, while in other cases it is better to avoid that.

A traditional math library without expression templates always evaluates all sub-\/expressions into temporaries. So with this code,


\begin{DoxyCode}{0}
\DoxyCodeLine{vec1 = \mbox{\hyperlink{group__core__types_gaa1618f51db67eaa145db101d8c8431d8}{vec2}} + \mbox{\hyperlink{group__core__types_ga1c47e8b3386109bc992b6c48e91b0be7}{vec3}};}
\end{DoxyCode}


a traditional library would evaluate {\ttfamily vec2} + vec3 into a temporary {\ttfamily vec4} and then copy {\ttfamily vec4} into {\ttfamily vec1}. This is of course inefficient\+: the arrays are traversed twice, so there are a lot of useless load/store operations.

Expression-\/templates-\/based libraries can avoid evaluating sub-\/expressions into temporaries, which in many cases results in large speed improvements. This is called {\itshape lazy evaluation} as an expression is getting evaluated as late as possible. In Eigen {\bfseries{all expressions are lazy-\/evaluated}}. More precisely, an expression starts to be evaluated once it is assigned to a matrix. Until then nothing happens beyond constructing the abstract expression tree. In contrast to most other expression-\/templates-\/based libraries, however, {\bfseries{Eigen might choose to evaluate some sub-\/expressions into temporaries}}. There are two reasons for that\+: first, pure lazy evaluation is not always a good choice for performance; second, pure lazy evaluation can be very dangerous, for example with matrix products\+: doing {\ttfamily mat = mat$\ast$mat} gives a wrong result if the matrix product is directly evaluated within the destination matrix, because of the way matrix product works.

For these reasons, Eigen has intelligent compile-\/time mechanisms to determine automatically which sub-\/expression should be evaluated into a temporary variable.

So in the basic example,


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}};}
\end{DoxyCode}


Eigen chooses not to introduce any temporary. Thus the arrays are traversed only once, producing optimized code. If you really want to force immediate evaluation, use \mbox{\hyperlink{class_eigen_1_1_dense_base_a5df64c66228ba75bbc66db2584185527}{eval()}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = (\mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}}).eval();}
\end{DoxyCode}


Here is now a more involved example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = -\/\mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} + 5 * \mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}};}
\end{DoxyCode}


Here again Eigen won\textquotesingle{}t introduce any temporary, thus producing a single {\bfseries{fused}} evaluation loop, which is clearly the correct choice.\hypertarget{_topic_lazy_evaluation_TopicLazyEvaluationWhichExpr}{}\doxysubsubsection{Which sub-\/expressions are evaluated into temporaries?}\label{_topic_lazy_evaluation_TopicLazyEvaluationWhichExpr}
The default evaluation strategy is to fuse the operations in a single loop, and Eigen will choose it except in a few circumstances.

{\bfseries{The first circumstance}} in which Eigen chooses to evaluate a sub-\/expression is when it sees an assignment {\ttfamily a = b;} and the expression {\ttfamily b} has the evaluate-\/before-\/assigning \mbox{\hyperlink{group__flags}{flag}}. The most important example of such an expression is the \mbox{\hyperlink{class_eigen_1_1_product}{matrix product expression}}. For example, when you do


\begin{DoxyCode}{0}
\DoxyCodeLine{mat = mat * mat;}
\end{DoxyCode}


Eigen will evaluate {\ttfamily mat $\ast$ mat} into a temporary matrix, and then copies it into the original {\ttfamily mat}. This guarantees a correct result as we saw above that lazy evaluation gives wrong results with matrix products. It also doesn\textquotesingle{}t cost much, as the cost of the matrix product itself is much higher. Note that this temporary is introduced at evaluation time only, that is, within operator= in this example. The expression {\ttfamily mat $\ast$ mat} still return a abstract product type.

What if you know that the result does no alias the operand of the product and want to force lazy evaluation? Then use \mbox{\hyperlink{class_eigen_1_1_matrix_base_a7f15120bb9c88c30aa5d993bd6d138e1}{.noalias()}} instead. Here is an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1.noalias() = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} * \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}};}
\end{DoxyCode}


Here, since we know that mat2 is not the same matrix as mat1, we know that lazy evaluation is not dangerous, so we may force lazy evaluation. Concretely, the effect of noalias() here is to bypass the evaluate-\/before-\/assigning \mbox{\hyperlink{group__flags}{flag}}.

{\bfseries{The second circumstance}} in which Eigen chooses to evaluate a sub-\/expression, is when it sees a nested expression such as {\ttfamily a + b} where {\ttfamily b} is already an expression having the evaluate-\/before-\/nesting \mbox{\hyperlink{group__flags}{flag}}. Again, the most important example of such an expression is the \mbox{\hyperlink{class_eigen_1_1_product}{matrix product expression}}. For example, when you do


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} * \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} + \mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}} * mat5;}
\end{DoxyCode}


the products {\ttfamily mat2 $\ast$ mat3} and {\ttfamily mat4 $\ast$ mat5} gets evaluated separately into temporary matrices before being summed up in {\ttfamily mat1}. Indeed, to be efficient matrix products need to be evaluated within a destination matrix at hand, and not as simple \char`\"{}dot products\char`\"{}. For small matrices, however, you might want to enforce a \char`\"{}dot-\/product\char`\"{} based lazy evaluation with lazy\+Product(). Again, it is important to understand that those temporaries are created at evaluation time only, that is in operator =. See Topic\+Pitfalls\+\_\+auto\+\_\+keyword for common pitfalls regarding this remark.

{\bfseries{The third circumstance}} in which Eigen chooses to evaluate a sub-\/expression, is when its cost model shows that the total cost of an operation is reduced if a sub-\/expression gets evaluated into a temporary. Indeed, in certain cases, an intermediate result is sufficiently costly to compute and is reused sufficiently many times, that is worth \char`\"{}caching\char`\"{}. Here is an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} * (\mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} + \mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}});}
\end{DoxyCode}


Here, provided the matrices have at least 2 rows and 2 columns, each coefficient of the expression {\ttfamily mat3 + mat4} is going to be used several times in the matrix product. Instead of computing the sum every time, it is much better to compute it once and store it in a temporary variable. Eigen understands this and evaluates {\ttfamily mat3 + mat4} into a temporary variable before evaluating the product. \hypertarget{TopicInsideEigenExample}{}\doxysubsection{What happens inside Eigen, on a simple example}\label{TopicInsideEigenExample}
\textbackslash{}eigen\+Auto\+Toc

\DoxyHorRuler{0}


Consider the following example program\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include<Eigen/Core>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordtype}{int} size = 50;}
\DoxyCodeLine{  \textcolor{comment}{// VectorXf is a vector of floats, with dynamic size.}}
\DoxyCodeLine{  Eigen::VectorXf u(size), v(size), w(size);}
\DoxyCodeLine{  u = v + w;}
\DoxyCodeLine{\}}
\end{DoxyCode}


The goal of this page is to understand how \mbox{\hyperlink{namespace_eigen}{Eigen}} compiles it, assuming that S\+S\+E2 vectorization is enabled (G\+CC option -\/msse2).\hypertarget{_topic_inside_eigen_example_WhyInteresting}{}\doxysubsubsection{Why it\textquotesingle{}s interesting}\label{_topic_inside_eigen_example_WhyInteresting}
Maybe you think, that the above example program is so simple, that compiling it shouldn\textquotesingle{}t involve anything interesting. So before starting, let us explain what is nontrivial in compiling it correctly -- that is, producing optimized code -- so that the complexity of \mbox{\hyperlink{namespace_eigen}{Eigen}}, that we\textquotesingle{}ll explain here, is really useful.

Look at the line of code 
\begin{DoxyCode}{0}
\DoxyCodeLine{u = v + w;   \textcolor{comment}{//   (*)}}
\end{DoxyCode}


The first important thing about compiling it, is that the arrays should be traversed only once, like 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) u[i] = v[i] + w[i];}
\end{DoxyCode}
 The problem is that if we make a naive C++ library where the Vector\+Xf class has an operator+ returning a Vector\+Xf, then the line of code ($\ast$) will amount to\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{VectorXf tmp = v + w;}
\DoxyCodeLine{VectorXf u = tmp;}
\end{DoxyCode}
 Obviously, the introduction of the temporary {\itshape tmp} here is useless. It has a very bad effect on performance, first because the creation of {\itshape tmp} requires a dynamic memory allocation in this context, and second as there are now two for loops\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) tmp[i] = v[i] + w[i];}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) u[i] = tmp[i];}
\end{DoxyCode}
 Traversing the arrays twice instead of once is terrible for performance, as it means that we do many redundant memory accesses.

The second important thing about compiling the above program, is to make correct use of S\+S\+E2 instructions. Notice that \mbox{\hyperlink{namespace_eigen}{Eigen}} also supports Alti\+Vec and that all the discussion that we make here applies also to Alti\+Vec.

S\+S\+E2, like Alti\+Vec, is a set of instructions allowing to perform computations on packets of 128 bits at once. Since a float is 32 bits, this means that S\+S\+E2 instructions can handle 4 floats at once. This means that, if correctly used, they can make our computation go up to 4x faster.

However, in the above program, we have chosen size=50, so our vectors consist of 50 float\textquotesingle{}s, and 50 is not a multiple of 4. This means that we cannot hope to do all of that computation using S\+S\+E2 instructions. The second best thing, to which we should aim, is to handle the 48 first coefficients with S\+S\+E2 instructions, since 48 is the biggest multiple of 4 below 50, and then handle separately, without S\+S\+E2, the 49th and 50th coefficients. Something like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 4*(size/4); i+=4) u.packet(i)  = v.packet(i) + w.packet(i);}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 4*(size/4); i < size; i++) u[i] = v[i] + w[i];}
\end{DoxyCode}


So let us look line by line at our example program, and let\textquotesingle{}s follow \mbox{\hyperlink{namespace_eigen}{Eigen}} as it compiles it.\hypertarget{_topic_inside_eigen_example_ConstructingVectors}{}\doxysubsubsection{Constructing vectors}\label{_topic_inside_eigen_example_ConstructingVectors}
Let\textquotesingle{}s analyze the first line\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Eigen::VectorXf u(size), v(size), w(size);}
\end{DoxyCode}


First of all, Vector\+Xf is the following typedef\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} Matrix<float, Dynamic, 1> VectorXf;}
\end{DoxyCode}


The class template \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} is declared in src/\+Core/util/\+Forward\+Declarations.\+h with 6 template parameters, but the last 3 are automatically determined by the first 3. So you don\textquotesingle{}t need to worry about them for now. Here, \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$<$float, Dynamic, 1$>$ means a matrix of floats, with a dynamic number of rows and 1 column.

The \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class inherits a base class, \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. Don\textquotesingle{}t worry about it, for now it suffices to say that \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} is what unifies matrices/vectors and all the expressions types -- more on that below.

When we do 
\begin{DoxyCode}{0}
\DoxyCodeLine{Eigen::VectorXf u(size);}
\end{DoxyCode}
 the constructor that is called is Matrix\+::\+Matrix(int), in src/\+Core/\+Matrix.\+h. Besides some assertions, all it does is to construct the {\itshape m\+\_\+storage} member, which is of type \mbox{\hyperlink{class_eigen_1_1_dense_storage}{Dense\+Storage}}$<$float, Dynamic, Dynamic, 1$>$.

You may wonder, isn\textquotesingle{}t it overengineering to have the storage in a separate class? The reason is that the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class template covers all kinds of matrices and vector\+: both fixed-\/size and dynamic-\/size. The storage method is not the same in these two cases. For fixed-\/size, the matrix coefficients are stored as a plain member array. For dynamic-\/size, the coefficients will be stored as a pointer to a dynamically-\/allocated array. Because of this, we need to abstract storage away from the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class. That\textquotesingle{}s \mbox{\hyperlink{class_eigen_1_1_dense_storage}{Dense\+Storage}}.

Let\textquotesingle{}s look at this constructor, in src/\+Core/\+Dense\+Storage.\+h. You can see that there are many partial template specializations of Dense\+Storages here, treating separately the cases where dimensions are Dynamic or fixed at compile-\/time. The partial specialization that we are looking at is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} Cols\_> \textcolor{keyword}{class }DenseStorage<\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, \mbox{\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}}, \mbox{\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}}, Cols\_>}
\end{DoxyCode}


Here, the constructor called is Dense\+Storage\+::\+Dense\+Storage(int size, int rows, int columns) with size=50, rows=50, columns=1.

Here is this constructor\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{inline} DenseStorage(\textcolor{keywordtype}{int} size, \textcolor{keywordtype}{int} rows, \textcolor{keywordtype}{int}) : m\_data(internal::aligned\_new<\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}>(size)), m\_rows(rows) \{\}}
\end{DoxyCode}


Here, the {\itshape m\+\_\+data} member is the actual array of coefficients of the matrix. As you see, it is dynamically allocated. Rather than calling new\mbox{[}\mbox{]} or malloc(), as you can see, we have our own internal\+::aligned\+\_\+new defined in src/\+Core/util/\+Memory.\+h. What it does is that if vectorization is enabled, then it uses a platform-\/specific call to allocate a 128-\/bit-\/aligned array, as that is very useful for vectorization with both S\+S\+E2 and Alti\+Vec. If vectorization is disabled, it amounts to the standard new\mbox{[}\mbox{]}.

As you can see, the constructor also sets the {\itshape m\+\_\+rows} member to {\itshape size}. Notice that there is no {\itshape m\+\_\+columns} member\+: indeed, in this partial specialization of \mbox{\hyperlink{class_eigen_1_1_dense_storage}{Dense\+Storage}}, we know the number of columns at compile-\/time, since the Cols\+\_\+ template parameter is different from Dynamic. Namely, in our case, Cols\+\_\+ is 1, which is to say that our vector is just a matrix with 1 column. Hence, there is no need to store the number of columns as a runtime variable.

When you call Vector\+Xf\+::data() to get the pointer to the array of coefficients, it returns Dense\+Storage\+::data() which returns the {\itshape m\+\_\+data} member.

When you call Vector\+Xf\+::size() to get the size of the vector, this is actually a method in the base class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. It determines that the vector is a column-\/vector, since Cols\+At\+Compile\+Time==1 (this comes from the template parameters in the typedef Vector\+Xf). It deduces that the size is the number of rows, so it returns Vector\+Xf\+::rows(), which returns Dense\+Storage\+::rows(), which returns the {\itshape m\+\_\+rows} member, which was set to {\itshape size} by the constructor.\hypertarget{_topic_inside_eigen_example_ConstructionOfSumXpr}{}\doxysubsubsection{Construction of the sum expression}\label{_topic_inside_eigen_example_ConstructionOfSumXpr}
Now that our vectors are constructed, let\textquotesingle{}s move on to the next line\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{u = v + w;}
\end{DoxyCode}


The executive summary is that operator+ returns a \char`\"{}sum of vectors\char`\"{} expression, but doesn\textquotesingle{}t actually perform the computation. It is the operator=, whose call occurs thereafter, that does the computation.

Let us now see what \mbox{\hyperlink{namespace_eigen}{Eigen}} does when it sees this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{v + w}
\end{DoxyCode}


Here, v and w are of type Vector\+Xf, which is a typedef for a specialization of \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} (as we explained above), which is a subclass of \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. So what is being called is


\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixBase::operator+(\textcolor{keyword}{const} MatrixBase\&)}
\end{DoxyCode}


The return type of this operator is 
\begin{DoxyCode}{0}
\DoxyCodeLine{CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\end{DoxyCode}
 The \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} class is our first encounter with an expression template. As we said, the operator+ doesn\textquotesingle{}t by itself perform any computation, it just returns an abstract \char`\"{}sum of vectors\char`\"{} expression. Since there are also \char`\"{}difference of vectors\char`\"{} and \char`\"{}coefficient-\/wise product of vectors\char`\"{} expressions, we unify them all as \char`\"{}coefficient-\/wise binary operations\char`\"{}, which we abbreviate as \char`\"{}\+Cwise\+Binary\+Op\char`\"{}. \char`\"{}\+Coefficient-\/wise\char`\"{} means that the operations is performed coefficient by coefficient. \char`\"{}binary\char`\"{} means that there are two operands -- we are adding two vectors with one another.

Now you might ask, what if we did something like


\begin{DoxyCode}{0}
\DoxyCodeLine{v + w + u;}
\end{DoxyCode}


The first v + w would return a \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} as above, so in order for this to compile, we\textquotesingle{}d need to define an operator+ also in the class \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}... at this point it starts looking like a nightmare\+: are we going to have to define all operators in each of the expression classes (as you guessed, \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} is only one of many) ? This looks like a dead end!

The solution is that \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} itself, as well as \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} and all the other expression types, is a subclass of \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. So it is enough to define once and for all the operators in class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}.

Since \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} is the common base class of different subclasses, the aspects that depend on the subclass must be abstracted from \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. This is called polymorphism.

The classical approach to polymorphism in C++ is by means of virtual functions. This is dynamic polymorphism. Here we don\textquotesingle{}t want dynamic polymorphism because the whole design of \mbox{\hyperlink{namespace_eigen}{Eigen}} is based around the assumption that all the complexity, all the abstraction, gets resolved at compile-\/time. This is crucial\+: if the abstraction can\textquotesingle{}t get resolved at compile-\/time, \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s compile-\/time optimization mechanisms become useless, not to mention that if that abstraction has to be resolved at runtime it\textquotesingle{}ll incur an overhead by itself.

Here, what we want is to have a single class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} as the base of many subclasses, in such a way that each \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} object (be it a matrix, or vector, or any kind of expression) knows at compile-\/time (as opposed to run-\/time) of which particular subclass it is an object (i.\+e. whether it is a matrix, or an expression, and what kind of expression).

The solution is the \href{http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern}{\texttt{ Curiously Recurring Template Pattern}}. Let\textquotesingle{}s do the break now. Hopefully you can read this wikipedia page during the break if needed, but it won\textquotesingle{}t be allowed during the exam.

In short, \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} takes a template parameter {\itshape Derived}. Whenever we define a subclass Subclass, we actually make Subclass inherit \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$Subclass$>$. The point is that different subclasses inherit different \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} types. Thanks to this, whenever we have an object of a subclass, and we call on it some \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} method, we still remember even from inside the \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} method which particular subclass we\textquotesingle{}re talking about.

This means that we can put almost all the methods and operators in the base class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}, and have only the bare minimum in the subclasses. If you look at the subclasses in \mbox{\hyperlink{namespace_eigen}{Eigen}}, like for instance the \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} class, they have very few methods. There are coeff() and sometimes coeff\+Ref() methods for access to the coefficients, there are rows() and cols() methods returning the number of rows and columns, but there isn\textquotesingle{}t much more than that. All the meat is in \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}, so it only needs to be coded once for all kinds of expressions, matrices, and vectors.

So let\textquotesingle{}s end this digression and come back to the piece of code from our example program that we were currently analyzing,


\begin{DoxyCode}{0}
\DoxyCodeLine{v + w}
\end{DoxyCode}


Now that \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} is a good friend, let\textquotesingle{}s write fully the prototype of the operator+ that gets called here (this code is from src/\+Core/\+Matrix\+Base.\+h)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{class }MatrixBase}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{  \textcolor{keyword}{const} CwiseBinaryOp<internal::scalar\_sum\_op<typename internal::traits<Derived>::Scalar>, Derived, OtherDerived>}
\DoxyCodeLine{  operator+(\textcolor{keyword}{const} MatrixBase<OtherDerived> \&other) \textcolor{keyword}{const};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Here of course, {\itshape Derived} and {\itshape Other\+Derived} are Vector\+Xf.

As we said, \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} is also used for other operations such as substration, so it takes another template parameter determining the operation that will be applied to coefficients. This template parameter is a functor, that is, a class in which we have an operator() so it behaves like a function. Here, the functor used is \mbox{\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal\+::scalar\+\_\+sum\+\_\+op}}. It is defined in src/\+Core/\+Functors.\+h.

Let us now explain the \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}} here. The \mbox{\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal\+::scalar\+\_\+sum\+\_\+op}} class takes one template parameter\+: the type of the numbers to handle. Here of course we want to pass the scalar type (a.\+k.\+a. numeric type) of Vector\+Xf, which is {\ttfamily float}. How do we determine which is the scalar type of {\itshape Derived} ? Throughout \mbox{\hyperlink{namespace_eigen}{Eigen}}, all matrix and expression types define a typedef {\itshape Scalar} which gives its scalar type. For example, Vector\+Xf\+::\+Scalar is a typedef for {\ttfamily float}. So here, if life was easy, we could find the numeric type of {\itshape Derived} as just 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typename} Derived::Scalar}
\end{DoxyCode}
 Unfortunately, we can\textquotesingle{}t do that here, as the compiler would complain that the type Derived hasn\textquotesingle{}t yet been defined. So we use a workaround\+: in src/\+Core/util/\+Forward\+Declarations.\+h, we declared (not defined!) all our subclasses, like \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, and we also declared the following class template\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }internal::traits;}
\end{DoxyCode}
 In src/\+Core/\+Matrix.\+h, right {\itshape before} the definition of class \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, we define a partial specialization of \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}} for T=\mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$<$any template parameters$>$. In this specialization of \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}}, we define the Scalar typedef. So when we actually define \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, it is legal to refer to \char`\"{}typename internal\+::traits\textbackslash{}$<$\+Matrix\textbackslash{}$>$\+::\+Scalar\char`\"{}.

Anyway, we have declared our operator+. In our case, where {\itshape Derived} and {\itshape Other\+Derived} are Vector\+Xf, the above declaration amounts to\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MatrixBase<VectorXf>}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\DoxyCodeLine{  operator+(\textcolor{keyword}{const} MatrixBase<VectorXf> \&other) \textcolor{keyword}{const};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Let\textquotesingle{}s now jump to src/\+Core/\+Cwise\+Binary\+Op.\+h to see how it is defined. As you can see there, all it does is to return a \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} object, and this object is just storing references to the left-\/hand-\/side and right-\/hand-\/side expressions -- here, these are the vectors {\itshape v} and {\itshape w}. Well, the \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} object is also storing an instance of the (empty) functor class, but you shouldn\textquotesingle{}t worry about it as that is a minor implementation detail.

Thus, the operator+ hasn\textquotesingle{}t performed any actual computation. To summarize, the operation {\itshape v} + {\itshape w} just returned an object of type \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} which did nothing else than just storing references to {\itshape v} and {\itshape w}.\hypertarget{_topic_inside_eigen_example_Assignment}{}\doxysubsubsection{The assignment}\label{_topic_inside_eigen_example_Assignment}
 {\bfseries{P\+L\+E\+A\+SE H\+E\+LP US I\+M\+P\+R\+O\+V\+I\+NG T\+H\+IS S\+E\+C\+T\+I\+ON.}} This page reflects how Eigen worked until 3.\+2, but since Eigen 3.\+3 the assignment is more sophisticated as it involves an Assignment expression, and the creation of so called evaluator which are responsible for the evaluation of each kind of expressions. 

At this point, the expression {\itshape v} + {\itshape w} has finished evaluating, so, in the process of compiling the line of code 
\begin{DoxyCode}{0}
\DoxyCodeLine{u = v + w;}
\end{DoxyCode}
 we now enter the operator=.

What operator= is being called here? The vector u is an object of class Vector\+Xf, i.\+e. \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}. In src/\+Core/\+Matrix.\+h, inside the definition of class \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, we see this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{inline} Matrix\& operator=(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  eigen\_assert(m\_storage.data()!=0 \&\& \textcolor{stringliteral}{"you cannot use operator= with a non initialized matrix (instead use set()"});}
\DoxyCodeLine{  \textcolor{keywordflow}{return} Base::operator=(other.derived());}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Here, Base is a typedef for \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$\mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$>$. So, what is being called is the operator= of \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. Let\textquotesingle{}s see its prototype in src/\+Core/\+Matrix\+Base.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{Derived\& operator=(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other);}
\end{DoxyCode}
 Here, {\itshape Derived} is Vector\+Xf (since u is a Vector\+Xf) and {\itshape Other\+Derived} is \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}. More specifically, as explained in the previous section, {\itshape Other\+Derived} is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\end{DoxyCode}
 So the full prototype of the operator= being called is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{VectorXf\& \mbox{\hyperlink{class_eigen_1_1_matrix_base_a706a4dd1ee54786e9210de1a4bf02600}{MatrixBase<VectorXf>::operator=}}(\textcolor{keyword}{const} MatrixBase<CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf> > \& other);}
\end{DoxyCode}
 This operator= literally reads \char`\"{}copying a sum of two Vector\+Xf\textquotesingle{}s into another Vector\+Xf\char`\"{}.

Let\textquotesingle{}s now look at the implementation of this operator=. It resides in the file src/\+Core/\+Assign.\+h.

What we can see there is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{inline} Derived\& \mbox{\hyperlink{class_eigen_1_1_matrix_base_a706a4dd1ee54786e9210de1a4bf02600}{MatrixBase<Derived>}}}
\DoxyCodeLine{\mbox{\hyperlink{class_eigen_1_1_matrix_base_a706a4dd1ee54786e9210de1a4bf02600}{  ::operator=}}(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} internal::assign\_selector<Derived,OtherDerived>::run(derived(), other.derived());}
\DoxyCodeLine{\}}
\end{DoxyCode}


OK so our next task is to understand internal\+::assign\+\_\+selector \+:)

Here is its declaration (all that is still in the same file src/\+Core/\+Assign.\+h) 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived,}
\DoxyCodeLine{         \textcolor{keywordtype}{bool} EvalBeforeAssigning = int(OtherDerived::Flags) \& \mbox{\hyperlink{group__flags_gae4b8ae7db0d83f9bbed26b261e60e139}{EvalBeforeAssigningBit}},}
\DoxyCodeLine{         \textcolor{keywordtype}{bool} NeedToTranspose = Derived::IsVectorAtCompileTime}
\DoxyCodeLine{                \&\& OtherDerived::IsVectorAtCompileTime}
\DoxyCodeLine{                \&\& int(Derived::RowsAtCompileTime) == int(OtherDerived::ColsAtCompileTime)}
\DoxyCodeLine{                \&\& int(Derived::ColsAtCompileTime) == int(OtherDerived::RowsAtCompileTime)}
\DoxyCodeLine{                \&\& int(Derived::SizeAtCompileTime) != 1>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_selector;}
\end{DoxyCode}


So internal\+::assign\+\_\+selector takes 4 template parameters, but the 2 last ones are automatically determined by the 2 first ones.

Eval\+Before\+Assigning is here to enforce the Eval\+Before\+Assigning\+Bit. As explained \href{TopicLazyEvaluation.html}{\texttt{ here}}, certain expressions have this flag which makes them automatically evaluate into temporaries before assigning them to another expression. This is the case of the \mbox{\hyperlink{class_eigen_1_1_product}{Product}} expression, in order to avoid strange aliasing effects when doing \char`\"{}m = m $\ast$ m;\char`\"{} However, of course here our \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} expression doesn\textquotesingle{}t have the Eval\+Before\+Assigning\+Bit\+: we said since the beginning that we didn\textquotesingle{}t want a temporary to be introduced here. So if you go to src/\+Core/\+Cwise\+Binary\+Op.\+h, you\textquotesingle{}ll see that the Flags in \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}}$<$\mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}$>$ don\textquotesingle{}t include the Eval\+Before\+Assigning\+Bit. The Flags member of \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} is then imported from the \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}} by the E\+I\+G\+E\+N\+\_\+\+G\+E\+N\+E\+R\+I\+C\+\_\+\+P\+U\+B\+L\+I\+C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE macro. Anyway, here the template parameter Eval\+Before\+Assigning has the value {\ttfamily false}.

Need\+To\+Transpose is here for the case where the user wants to copy a row-\/vector into a column-\/vector. We allow this as a special exception to the general rule that in assignments we require the dimesions to match. Anyway, here both the left-\/hand and right-\/hand sides are column vectors, in the sense that Cols\+At\+Compile\+Time is equal to 1. So Need\+To\+Transpose is {\ttfamily false} too.

So, here we are in the partial specialization\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal::assign\_selector<Derived, OtherDerived, false, false>}
\end{DoxyCode}


Here\textquotesingle{}s how it is defined\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_selector<Derived,OtherDerived,false,false> \{}
\DoxyCodeLine{  \textcolor{keyword}{static} Derived\& \mbox{\hyperlink{namespace_eigen_a1fb05f2dfd1e1974dc016cff6f349f98}{run}}(Derived\& dst, \textcolor{keyword}{const} OtherDerived\& other) \{ \textcolor{keywordflow}{return} dst.lazyAssign(other.derived()); \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


OK so now our next job is to understand how lazy\+Assign works \+:)


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{inline} Derived\& \mbox{\hyperlink{class_eigen_1_1_dense_base_adf691c9d5e89728815b91e42ebf9758d}{MatrixBase<Derived>}}}
\DoxyCodeLine{\mbox{\hyperlink{class_eigen_1_1_dense_base_adf691c9d5e89728815b91e42ebf9758d}{  ::lazyAssign}}(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  EIGEN\_STATIC\_ASSERT\_SAME\_MATRIX\_SIZE(Derived,OtherDerived)}
\DoxyCodeLine{  eigen\_assert(rows() == other.rows() \&\& cols() == other.cols());}
\DoxyCodeLine{  internal::assign\_impl<Derived, OtherDerived>::run(derived(),other.derived());}
\DoxyCodeLine{  \textcolor{keywordflow}{return} derived();}
\DoxyCodeLine{\}}
\end{DoxyCode}


What do we see here? Some assertions, and then the only interesting line is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal::assign\_impl<Derived, OtherDerived>::run(derived(),other.derived());}
\end{DoxyCode}


OK so now we want to know what is inside internal\+::assign\+\_\+impl.

Here is its declaration\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived1, \textcolor{keyword}{typename} Derived2,}
\DoxyCodeLine{         \textcolor{keywordtype}{int} Vectorization = internal::assign\_traits<Derived1, Derived2>::Vectorization,}
\DoxyCodeLine{         \textcolor{keywordtype}{int} Unrolling = internal::assign\_traits<Derived1, Derived2>::Unrolling>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_impl;}
\end{DoxyCode}
 Again, internal\+::assign\+\_\+selector takes 4 template parameters, but the 2 last ones are automatically determined by the 2 first ones.

These two parameters {\itshape Vectorization} and {\itshape Unrolling} are determined by a helper class internal\+::assign\+\_\+traits. Its job is to determine which vectorization strategy to use (that is {\itshape Vectorization}) and which unrolling strategy to use (that is {\itshape Unrolling}).

We\textquotesingle{}ll not enter into the details of how these strategies are chosen (this is in the implementation of internal\+::assign\+\_\+traits at the top of the same file). Let\textquotesingle{}s just say that here {\itshape Vectorization} has the value {\itshape Linear\+Vectorization}, and {\itshape Unrolling} has the value {\itshape No\+Unrolling} (the latter is obvious since our vectors have dynamic size so there\textquotesingle{}s no way to unroll the loop at compile-\/time).

So the partial specialization of internal\+::assign\+\_\+impl that we\textquotesingle{}re looking at is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal::assign\_impl<Derived1, Derived2, LinearVectorization, NoUnrolling>}
\end{DoxyCode}


Here is how it\textquotesingle{}s defined\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived1, \textcolor{keyword}{typename} Derived2>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_impl<Derived1, Derived2, LinearVectorization, NoUnrolling>}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespace_eigen_a1fb05f2dfd1e1974dc016cff6f349f98}{run}}(Derived1 \&dst, \textcolor{keyword}{const} Derived2 \&src)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} size = dst.size();}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} packetSize = internal::packet\_traits<typename Derived1::Scalar>::size;}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} alignedStart = internal::assign\_traits<Derived1,Derived2>::DstIsAligned ? 0}
\DoxyCodeLine{                           : internal::first\_aligned(\&dst.coeffRef(0), size);}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} alignedEnd = alignedStart + ((size-\/alignedStart)/packetSize)*packetSize;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = 0; index < alignedStart; index++)}
\DoxyCodeLine{      dst.copyCoeff(index, src);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedStart; index < alignedEnd; index += packetSize)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      dst.template copyPacket<Derived2, Aligned, internal::assign\_traits<Derived1,Derived2>::SrcAlignment>(index, src);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedEnd; index < size; index++)}
\DoxyCodeLine{      dst.copyCoeff(index, src);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Here\textquotesingle{}s how it works. {\itshape Linear\+Vectorization} means that the left-\/hand and right-\/hand side expression can be accessed linearly i.\+e. you can refer to their coefficients by one integer {\itshape index}, as opposed to having to refer to its coefficients by two integers {\itshape row}, {\itshape column}.

As we said at the beginning, vectorization works with blocks of 4 floats. Here, {\itshape Packet\+Size} is 4.

There are two potential problems that we need to deal with\+: \begin{DoxyItemize}
\item first, vectorization works much better if the packets are 128-\/bit-\/aligned. This is especially important for write access. So when writing to the coefficients of {\itshape dst}, we want to group these coefficients by packets of 4 such that each of these packets is 128-\/bit-\/aligned. In general, this requires to skip a few coefficients at the beginning of {\itshape dst}. This is the purpose of {\itshape aligned\+Start}. We then copy these first few coefficients one by one, not by packets. However, in our case, the {\itshape dst} expression is a Vector\+Xf and remember that in the construction of the vectors we allocated aligned arrays. Thanks to {\itshape Dst\+Is\+Aligned}, \mbox{\hyperlink{namespace_eigen}{Eigen}} remembers that without having to do any runtime check, so {\itshape aligned\+Start} is zero and this part is avoided altogether. \item second, the number of coefficients to copy is not in general a multiple of {\itshape packet\+Size}. Here, there are 50 coefficients to copy and {\itshape packet\+Size} is 4. So we\textquotesingle{}ll have to copy the last 2 coefficients one by one, not by packets. Here, {\itshape aligned\+End} is 48.\end{DoxyItemize}
Now come the actual loops.

First, the vectorized part\+: the 48 first coefficients out of 50 will be copied by packets of 4\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedStart; index < alignedEnd; index += packetSize)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  dst.template copyPacket<Derived2, Aligned, internal::assign\_traits<Derived1,Derived2>::SrcAlignment>(index, src);}
\DoxyCodeLine{\}}
\end{DoxyCode}


What is copy\+Packet? It is defined in src/\+Core/\+Coeffs.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived, \textcolor{keywordtype}{int} StoreMode, \textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} MatrixBase<Derived>::copyPacket(\textcolor{keywordtype}{int} index, \textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  eigen\_internal\_assert(index >= 0 \&\& index < size());}
\DoxyCodeLine{  derived().template writePacket<StoreMode>(index,}
\DoxyCodeLine{    other.derived().template packet<LoadMode>(index));}
\DoxyCodeLine{\}}
\end{DoxyCode}


OK, what are write\+Packet() and packet() here?

First, write\+Packet() here is a method on the left-\/hand side Vector\+Xf. So we go to src/\+Core/\+Matrix.\+h to look at its definition\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode>}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} writePacket(\textcolor{keywordtype}{int} index, \textcolor{keyword}{const} PacketScalar\& x)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  internal::pstoret<Scalar, PacketScalar, StoreMode>(m\_storage.data() + index, x);}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Here, {\itshape Store\+Mode} is {\itshape \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned}}}, indicating that we are doing a 128-\/bit-\/aligned write access, {\itshape Packet\+Scalar} is a type representing a \char`\"{}\+S\+S\+E packet of 4 floats\char`\"{} and internal\+::pstoret is a function writing such a packet in memory. Their definitions are architecture-\/specific, we find them in src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h\+:

The line in src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h that determines the Packet\+Scalar type (via a typedef in Matrix.\+h) is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{struct }internal::packet\_traits<float>  \{ \textcolor{keyword}{typedef} \_\_m128  type; \textcolor{keyword}{enum} \{size=4\}; \};}
\end{DoxyCode}
 Here, \+\_\+\+\_\+m128 is a S\+S\+E-\/specific type. Notice that the enum {\itshape size} here is what was used to define {\itshape packet\+Size} above.

And here is the implementation of internal\+::pstoret\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{void} internal::pstore(\textcolor{keywordtype}{float}*  to, \textcolor{keyword}{const} \_\_m128\&  from) \{ \_mm\_store\_ps(to, from); \}}
\end{DoxyCode}
 Here, \+\_\+\+\_\+mm\+\_\+store\+\_\+ps is a S\+S\+E-\/specific intrinsic function, representing a single S\+SE instruction. The difference between internal\+::pstore and internal\+::pstoret is that internal\+::pstoret is a dispatcher handling both the aligned and unaligned cases, you find its definition in src/\+Core/\+Generic\+Packet\+Math.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Packet, \textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} internal::pstoret(Scalar* to, \textcolor{keyword}{const} \mbox{\hyperlink{class_eigen_1_1_triplet}{Packet}}\& from)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{if}(LoadMode == \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned}})}
\DoxyCodeLine{    internal::pstore(to, from);}
\DoxyCodeLine{  \textcolor{keywordflow}{else}}
\DoxyCodeLine{    internal::pstoreu(to, from);}
\DoxyCodeLine{\}}
\end{DoxyCode}


OK, that explains how write\+Packet() works. Now let\textquotesingle{}s look into the packet() call. Remember that we are analyzing this line of code inside copy\+Packet()\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{derived().template writePacket<StoreMode>(index,}
\DoxyCodeLine{    other.derived().template packet<LoadMode>(index));}
\end{DoxyCode}


Here, {\itshape other} is our sum expression {\itshape v} + {\itshape w}. The .derived() is just casting from \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} to the subclass which here is \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}. So let\textquotesingle{}s go to src/\+Core/\+Cwise\+Binary\+Op.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }CwiseBinaryOp}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{    \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{    \textcolor{keyword}{inline} PacketScalar packet(\textcolor{keywordtype}{int} index)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{    }\{}
\DoxyCodeLine{      \textcolor{keywordflow}{return} m\_functor.packetOp(m\_lhs.template packet<LoadMode>(index), m\_rhs.template packet<LoadMode>(index));}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
 Here, {\itshape m\+\_\+lhs} is the vector {\itshape v}, and {\itshape m\+\_\+rhs} is the vector {\itshape w}. So the packet() function here is Matrix\+::packet(). The template parameter {\itshape Load\+Mode} is {\itshape \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned}}}. So we\textquotesingle{}re looking at 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }Matrix}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{    \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{    \textcolor{keyword}{inline} PacketScalar packet(\textcolor{keywordtype}{int} index)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{    }\{}
\DoxyCodeLine{      \textcolor{keywordflow}{return} internal::ploadt<Scalar, LoadMode>(m\_storage.data() + index);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
 We let you look up the definition of internal\+::ploadt in Generic\+Packet\+Math.\+h and the internal\+::pload in src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h. It is very similar to the above for internal\+::pstore.

Let\textquotesingle{}s go back to Cwise\+Binary\+Op\+::packet(). Once the packets from the vectors {\itshape v} and {\itshape w} have been returned, what does this function do? It calls m\+\_\+functor.\+packet\+Op() on them. What is m\+\_\+functor? Here we must remember what particular template specialization of \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} we\textquotesingle{}re dealing with\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\end{DoxyCode}
 So m\+\_\+functor is an object of the empty class internal\+::scalar\+\_\+sum\+\_\+op$<$float$>$. As we mentioned above, don\textquotesingle{}t worry about why we constructed an object of this empty class at all -- it\textquotesingle{}s an implementation detail, the point is that some other functors need to store member data.

Anyway, \mbox{\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal\+::scalar\+\_\+sum\+\_\+op}} is defined in src/\+Core/\+Functors.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }internal::scalar\_sum\_op EIGEN\_EMPTY\_STRUCT \{}
\DoxyCodeLine{  \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar\& a, \textcolor{keyword}{const} Scalar\& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a + b; \}}
\DoxyCodeLine{  \textcolor{keyword}{template}<\textcolor{keyword}{typename} PacketScalar>}
\DoxyCodeLine{  \textcolor{keyword}{inline} \textcolor{keyword}{const} PacketScalar packetOp(\textcolor{keyword}{const} PacketScalar\& a, \textcolor{keyword}{const} PacketScalar\& b)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::padd(a,b); \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
 As you can see, all what packet\+Op() does is to call internal\+::padd on the two packets. Here is the definition of internal\+::padd from src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{inline} \_\_m128  internal::padd(\textcolor{keyword}{const} \_\_m128\&  a, \textcolor{keyword}{const} \_\_m128\&  b) \{ \textcolor{keywordflow}{return} \_mm\_add\_ps(a,b); \}}
\end{DoxyCode}
 Here, \+\_\+mm\+\_\+add\+\_\+ps is a S\+S\+E-\/specific intrinsic function, representing a single S\+SE instruction.

To summarize, the loop 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedStart; index < alignedEnd; index += packetSize)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  dst.template copyPacket<Derived2, Aligned, internal::assign\_traits<Derived1,Derived2>::SrcAlignment>(index, src);}
\DoxyCodeLine{\}}
\end{DoxyCode}
 has been compiled to the following code\+: for {\itshape index} going from 0 to the 11 ( = 48/4 -\/ 1), read the i-\/th packet (of 4 floats) from the vector v and the i-\/th packet from the vector w using two \+\_\+\+\_\+mm\+\_\+load\+\_\+ps S\+SE instructions, then add them together using a \+\_\+\+\_\+mm\+\_\+add\+\_\+ps instruction, then store the result using a \+\_\+\+\_\+mm\+\_\+store\+\_\+ps instruction.

There remains the second loop handling the last few (here, the last 2) coefficients\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedEnd; index < size; index++)}
\DoxyCodeLine{  dst.copyCoeff(index, src);}
\end{DoxyCode}
 However, it works just like the one we just explained, it is just simpler because there is no S\+SE vectorization involved here. copy\+Packet() becomes copy\+Coeff(), packet() becomes coeff(), write\+Packet() becomes coeff\+Ref(). If you followed us this far, you can probably understand this part by yourself.

We see that all the C++ abstraction of \mbox{\hyperlink{namespace_eigen}{Eigen}} goes away during compilation and that we indeed are precisely controlling which assembly instructions we emit. Such is the beauty of C++! Since we have such precise control over the emitted assembly instructions, but such complex logic to choose the right instructions, we can say that \mbox{\hyperlink{namespace_eigen}{Eigen}} really behaves like an optimizing compiler. If you prefer, you could say that \mbox{\hyperlink{namespace_eigen}{Eigen}} behaves like a script for the compiler. In a sense, C++ template metaprogramming is scripting the compiler -- and it\textquotesingle{}s been shown that this scripting language is Turing-\/complete. See \href{http://en.wikipedia.org/wiki/Template_metaprogramming}{\texttt{ Wikipedia}}. \hypertarget{TopicClassHierarchy}{}\doxysubsection{The class hierarchy}\label{TopicClassHierarchy}
This page explains the design of the core classes in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s class hierarchy and how they fit together. Casual users probably need not concern themselves with these details, but it may be useful for both advanced users and \mbox{\hyperlink{namespace_eigen}{Eigen}} developers.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_class_hierarchy_TopicClassHierarchyPrinciples}{}\doxysubsubsection{Principles}\label{_topic_class_hierarchy_TopicClassHierarchyPrinciples}
\mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s class hierarchy is designed so that virtual functions are avoided where their overhead would significantly impair performance. Instead, \mbox{\hyperlink{namespace_eigen}{Eigen}} achieves polymorphism with the Curiously Recurring Template Pattern (C\+R\+TP). In this pattern, the base class (for instance, {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}}) is in fact a template class, and the derived class (for instance, {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}}) inherits the base class with the derived class itself as a template argument (in this case, {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}} inherits from {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$\mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$>$}). This allows \mbox{\hyperlink{namespace_eigen}{Eigen}} to resolve the polymorphic function calls at compile time.

In addition, the design avoids multiple inheritance. One reason for this is that in our experience, some compilers (like M\+S\+VC) fail to perform empty base class optimization, which is crucial for our fixed-\/size types.\hypertarget{_topic_class_hierarchy_TopicClassHierarchyCoreClasses}{}\doxysubsubsection{The core classes}\label{_topic_class_hierarchy_TopicClassHierarchyCoreClasses}
These are the classes that you need to know about if you want to write functions that accept or return \mbox{\hyperlink{namespace_eigen}{Eigen}} objects.


\begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} means plain dense matrix. If {\ttfamily m} is a {\ttfamily Matrix}, then, for instance, {\ttfamily m+m} is no longer a {\ttfamily Matrix}, it is a \char`\"{}matrix expression\char`\"{}.
\item \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} means dense matrix expression. This means that a {\ttfamily Matrix\+Base} is something that can be added, matrix-\/multiplied, L\+U-\/decomposed, Q\+R-\/decomposed... All matrix expression classes, including {\ttfamily Matrix} itself, inherit {\ttfamily Matrix\+Base}.
\item \mbox{\hyperlink{class_eigen_1_1_array}{Array}} means plain dense array. If {\ttfamily x} is an {\ttfamily Array}, then, for instance, {\ttfamily x+x} is no longer an {\ttfamily Array}, it is an \char`\"{}array expression\char`\"{}.
\item \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} means dense array expression. This means that an {\ttfamily Array\+Base} is something that can be added, array-\/multiplied, and on which you can perform all sorts of array operations... All array expression classes, including {\ttfamily Array} itself, inherit {\ttfamily Array\+Base}.
\item \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}} means dense (matrix or array) expression. Both {\ttfamily Array\+Base} and {\ttfamily Matrix\+Base} inherit {\ttfamily Dense\+Base}. {\ttfamily Dense\+Base} is where all the methods go that apply to dense expressions regardless of whether they are matrix or array expressions. For example, the \mbox{\hyperlink{}{block(...) }} methods are in {\ttfamily Dense\+Base}.
\end{DoxyItemize}\hypertarget{_topic_class_hierarchy_TopicClassHierarchyBaseClasses}{}\doxysubsubsection{Base classes}\label{_topic_class_hierarchy_TopicClassHierarchyBaseClasses}
These classes serve as base classes for the five core classes mentioned above. They are more internal and so less interesting for users of the \mbox{\hyperlink{namespace_eigen}{Eigen}} library.


\begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{Plain\+Object\+Base}} means dense (matrix or array) plain object, i.\+e. something that stores its own dense array of coefficients. This is where, for instance, the \mbox{\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize() }} methods go. {\ttfamily Plain\+Object\+Base} is inherited by {\ttfamily Matrix} and by {\ttfamily Array}. But above, we said that {\ttfamily Matrix} inherits {\ttfamily Matrix\+Base} and {\ttfamily Array} inherits {\ttfamily Array\+Base}. So does that mean multiple inheritance? No, because {\ttfamily Plain\+Object\+Base} {\itshape itself} inherits {\ttfamily Matrix\+Base} or {\ttfamily Array\+Base} depending on whether we are in the matrix or array case. When we said above that {\ttfamily Matrix} inherited {\ttfamily Matrix\+Base}, we omitted to say it does so indirectly via {\ttfamily Plain\+Object\+Base}. Same for {\ttfamily Array}.
\item \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{Dense\+Coeffs\+Base}} means something that has dense coefficient accessors. It is a base class for {\ttfamily Dense\+Base}. The reason for {\ttfamily Dense\+Coeffs\+Base} to exist is that the set of available coefficient accessors is very different depending on whether a dense expression has direct memory access or not (the {\ttfamily Direct\+Access\+Bit} flag). For example, if {\ttfamily x} is a plain matrix, then {\ttfamily x} has direct access, and {\ttfamily x.\+transpose()} and {\ttfamily x.\+block(...)} also have direct access, because their coefficients can be read right off memory, but for example, {\ttfamily x+x} does not have direct memory access, because obtaining any of its coefficients requires a computation (an addition), it can\textquotesingle{}t be just read off memory.
\item \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}} means anything that can be evaluated into a plain dense matrix or array (even if that would be a bad idea). {\ttfamily Eigen\+Base} is really the absolute base class for anything that remotely looks like a matrix or array. It is a base class for {\ttfamily Dense\+Coeffs\+Base}, so it sits below all our dense class hierarchy, but it is not limited to dense expressions. For example, {\ttfamily Eigen\+Base} is also inherited by diagonal matrices, sparse matrices, etc...
\end{DoxyItemize}\hypertarget{_topic_class_hierarchy_TopicClassHierarchyInheritanceDiagrams}{}\doxysubsubsection{Inheritance diagrams}\label{_topic_class_hierarchy_TopicClassHierarchyInheritanceDiagrams}
The inheritance diagram for \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<Matrix>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<Matrix>    (direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<Matrix>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_matrix_base}{MatrixBase}}<Matrix>
        <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{PlainObjectBase}}<Matrix>    (matrix case)
          <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}
\end{DoxyPre}


The inheritance diagram for \mbox{\hyperlink{class_eigen_1_1_array}{Array}} looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<Array>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<Array>    (direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<Array>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_array_base}{ArrayBase}}<Array>
        <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{PlainObjectBase}}<Array>    (array case)
          <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_array}{Array}}
\end{DoxyPre}


The inheritance diagram for some other matrix expression class, here denoted by {\ttfamily Some\+Matrix\+Xpr}, looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<SomeMatrixXpr>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<SomeMatrixXpr>    (direct access or no direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<SomeMatrixXpr>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_matrix_base}{MatrixBase}}<SomeMatrixXpr>
        <-\/-\/ SomeMatrixXpr
\end{DoxyPre}


The inheritance diagram for some other array expression class, here denoted by {\ttfamily Some\+Array\+Xpr}, looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<SomeArrayXpr>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<SomeArrayXpr>    (direct access or no direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<SomeArrayXpr>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_array_base}{ArrayBase}}<SomeArrayXpr>
        <-\/-\/ SomeArrayXpr
\end{DoxyPre}


Finally, consider an example of something that is not a dense expression, for instance a diagonal matrix. The corresponding inheritance diagram is\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<DiagonalMatrix>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_diagonal_base}{DiagonalBase}}<DiagonalMatrix>
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_diagonal_matrix}{DiagonalMatrix}}
\end{DoxyPre}
 \hypertarget{TopicLazyEvaluation}{}\doxysubsection{Lazy Evaluation and Aliasing}\label{TopicLazyEvaluation}
Executive summary\+: Eigen has intelligent compile-\/time mechanisms to enable lazy evaluation and removing temporaries where appropriate. It will handle aliasing automatically in most cases, for example with matrix products. The automatic behavior can be overridden manually by using the \mbox{\hyperlink{class_eigen_1_1_dense_base_a5df64c66228ba75bbc66db2584185527}{Matrix\+Base\+::eval()}} and \mbox{\hyperlink{class_eigen_1_1_matrix_base_a7f15120bb9c88c30aa5d993bd6d138e1}{Matrix\+Base\+::noalias()}} methods.

When you write a line of code involving a complex expression such as


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} * (\mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}} + mat5);}
\end{DoxyCode}


Eigen determines automatically, for each sub-\/expression, whether to evaluate it into a temporary variable. Indeed, in certain cases it is better to evaluate a sub-\/expression into a temporary variable, while in other cases it is better to avoid that.

A traditional math library without expression templates always evaluates all sub-\/expressions into temporaries. So with this code,


\begin{DoxyCode}{0}
\DoxyCodeLine{vec1 = \mbox{\hyperlink{group__core__types_gaa1618f51db67eaa145db101d8c8431d8}{vec2}} + \mbox{\hyperlink{group__core__types_ga1c47e8b3386109bc992b6c48e91b0be7}{vec3}};}
\end{DoxyCode}


a traditional library would evaluate {\ttfamily vec2} + vec3 into a temporary {\ttfamily vec4} and then copy {\ttfamily vec4} into {\ttfamily vec1}. This is of course inefficient\+: the arrays are traversed twice, so there are a lot of useless load/store operations.

Expression-\/templates-\/based libraries can avoid evaluating sub-\/expressions into temporaries, which in many cases results in large speed improvements. This is called {\itshape lazy evaluation} as an expression is getting evaluated as late as possible. In Eigen {\bfseries{all expressions are lazy-\/evaluated}}. More precisely, an expression starts to be evaluated once it is assigned to a matrix. Until then nothing happens beyond constructing the abstract expression tree. In contrast to most other expression-\/templates-\/based libraries, however, {\bfseries{Eigen might choose to evaluate some sub-\/expressions into temporaries}}. There are two reasons for that\+: first, pure lazy evaluation is not always a good choice for performance; second, pure lazy evaluation can be very dangerous, for example with matrix products\+: doing {\ttfamily mat = mat$\ast$mat} gives a wrong result if the matrix product is directly evaluated within the destination matrix, because of the way matrix product works.

For these reasons, Eigen has intelligent compile-\/time mechanisms to determine automatically which sub-\/expression should be evaluated into a temporary variable.

So in the basic example,


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}};}
\end{DoxyCode}


Eigen chooses not to introduce any temporary. Thus the arrays are traversed only once, producing optimized code. If you really want to force immediate evaluation, use \mbox{\hyperlink{class_eigen_1_1_dense_base_a5df64c66228ba75bbc66db2584185527}{eval()}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = (\mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}}).eval();}
\end{DoxyCode}


Here is now a more involved example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = -\/\mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} + 5 * \mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}};}
\end{DoxyCode}


Here again Eigen won\textquotesingle{}t introduce any temporary, thus producing a single {\bfseries{fused}} evaluation loop, which is clearly the correct choice.\hypertarget{_topic_lazy_evaluation_TopicLazyEvaluationWhichExpr}{}\doxysubsubsection{Which sub-\/expressions are evaluated into temporaries?}\label{_topic_lazy_evaluation_TopicLazyEvaluationWhichExpr}
The default evaluation strategy is to fuse the operations in a single loop, and Eigen will choose it except in a few circumstances.

{\bfseries{The first circumstance}} in which Eigen chooses to evaluate a sub-\/expression is when it sees an assignment {\ttfamily a = b;} and the expression {\ttfamily b} has the evaluate-\/before-\/assigning \mbox{\hyperlink{group__flags}{flag}}. The most important example of such an expression is the \mbox{\hyperlink{class_eigen_1_1_product}{matrix product expression}}. For example, when you do


\begin{DoxyCode}{0}
\DoxyCodeLine{mat = mat * mat;}
\end{DoxyCode}


Eigen will evaluate {\ttfamily mat $\ast$ mat} into a temporary matrix, and then copies it into the original {\ttfamily mat}. This guarantees a correct result as we saw above that lazy evaluation gives wrong results with matrix products. It also doesn\textquotesingle{}t cost much, as the cost of the matrix product itself is much higher. Note that this temporary is introduced at evaluation time only, that is, within operator= in this example. The expression {\ttfamily mat $\ast$ mat} still return a abstract product type.

What if you know that the result does no alias the operand of the product and want to force lazy evaluation? Then use \mbox{\hyperlink{class_eigen_1_1_matrix_base_a7f15120bb9c88c30aa5d993bd6d138e1}{.noalias()}} instead. Here is an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1.noalias() = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} * \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}};}
\end{DoxyCode}


Here, since we know that mat2 is not the same matrix as mat1, we know that lazy evaluation is not dangerous, so we may force lazy evaluation. Concretely, the effect of noalias() here is to bypass the evaluate-\/before-\/assigning \mbox{\hyperlink{group__flags}{flag}}.

{\bfseries{The second circumstance}} in which Eigen chooses to evaluate a sub-\/expression, is when it sees a nested expression such as {\ttfamily a + b} where {\ttfamily b} is already an expression having the evaluate-\/before-\/nesting \mbox{\hyperlink{group__flags}{flag}}. Again, the most important example of such an expression is the \mbox{\hyperlink{class_eigen_1_1_product}{matrix product expression}}. For example, when you do


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} * \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} + \mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}} * mat5;}
\end{DoxyCode}


the products {\ttfamily mat2 $\ast$ mat3} and {\ttfamily mat4 $\ast$ mat5} gets evaluated separately into temporary matrices before being summed up in {\ttfamily mat1}. Indeed, to be efficient matrix products need to be evaluated within a destination matrix at hand, and not as simple \char`\"{}dot products\char`\"{}. For small matrices, however, you might want to enforce a \char`\"{}dot-\/product\char`\"{} based lazy evaluation with lazy\+Product(). Again, it is important to understand that those temporaries are created at evaluation time only, that is in operator =. See Topic\+Pitfalls\+\_\+auto\+\_\+keyword for common pitfalls regarding this remark.

{\bfseries{The third circumstance}} in which Eigen chooses to evaluate a sub-\/expression, is when its cost model shows that the total cost of an operation is reduced if a sub-\/expression gets evaluated into a temporary. Indeed, in certain cases, an intermediate result is sufficiently costly to compute and is reused sufficiently many times, that is worth \char`\"{}caching\char`\"{}. Here is an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} * (\mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} + \mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}});}
\end{DoxyCode}


Here, provided the matrices have at least 2 rows and 2 columns, each coefficient of the expression {\ttfamily mat3 + mat4} is going to be used several times in the matrix product. Instead of computing the sum every time, it is much better to compute it once and store it in a temporary variable. Eigen understands this and evaluates {\ttfamily mat3 + mat4} into a temporary variable before evaluating the product. \hypertarget{TopicCMakeGuide}{}\doxysection{Using Eigen in C\+Make Projects}\label{TopicCMakeGuide}
Eigen provides native C\+Make support which allows the library to be easily used in C\+Make projects.

\begin{DoxyNote}{Note}
C\+Make 3.\+0 (or later) is required to enable this functionality.
\end{DoxyNote}
Eigen exports a C\+Make target called {\ttfamily Eigen3\+::\+Eigen} which can be imported using the {\ttfamily find\+\_\+package} C\+Make command and used by calling {\ttfamily target\+\_\+link\+\_\+libraries} as in the following example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake\_minimum\_required (VERSION 3.0)}
\DoxyCodeLine{project (myproject)}
\DoxyCodeLine{}
\DoxyCodeLine{find\_package (Eigen3 3.3 REQUIRED NO\_MODULE)}
\DoxyCodeLine{}
\DoxyCodeLine{add\_executable (example example.cpp)}
\DoxyCodeLine{target\_link\_libraries (example Eigen3::Eigen)}
\end{DoxyCode}


The above code snippet must be placed in a file called {\ttfamily C\+Make\+Lists.\+txt} alongside {\ttfamily example.\+cpp}. After running 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ cmake path-\/to-\/example-\/directory}
\end{DoxyCode}
 C\+Make will produce project files that generate an executable called {\ttfamily example} which requires at least version 3.\+3 of Eigen. Here, {\ttfamily path-\/to-\/example-\/directory} is the path to the directory that contains both {\ttfamily C\+Make\+Lists.\+txt} and {\ttfamily example.\+cpp}.

Do not forget to set the \href{https://cmake.org/cmake/help/v3.7/variable/CMAKE_PREFIX_PATH.html}{\texttt{ {\ttfamily C\+M\+A\+K\+E\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+P\+A\+TH} }} variable if \mbox{\hyperlink{namespace_eigen}{Eigen}} is not installed in a default location or if you want to pick a specific version. For instance\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ cmake path-\/to-\/example-\/directory -\/DCMAKE\_PREFIX\_PATH=\$HOME/mypackages}
\end{DoxyCode}
 An alternative is to set the {\ttfamily Eigen3\+\_\+\+D\+IR} cmake\textquotesingle{}s variable to the respective path containing the {\ttfamily Eigen3$\ast$}.cmake files. For instance\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ cmake path-\/to-\/example-\/directory -\/DEigen3\_DIR=\$HOME/mypackages/share/eigen3/cmake/}
\end{DoxyCode}


If the {\ttfamily R\+E\+Q\+U\+I\+R\+ED} option is omitted when locating Eigen using {\ttfamily find\+\_\+package}, one can check whether the package was found as follows\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{find\_package (Eigen3 3.3 NO\_MODULE)}
\DoxyCodeLine{}
\DoxyCodeLine{if (TARGET Eigen3::Eigen)}
\DoxyCodeLine{  \# Use the imported target}
\DoxyCodeLine{endif (TARGET Eigen3::Eigen)}
\end{DoxyCode}
 \hypertarget{TopicFunctionTakingEigenTypes}{}\doxysection{Writing Functions Taking Eigen Types as Parameters}\label{TopicFunctionTakingEigenTypes}
Eigen\textquotesingle{}s use of expression templates results in potentially every expression being of a different type. If you pass such an expression to a function taking a parameter of type \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, your expression will implicitly be evaluated into a temporary \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, which will then be passed to the function. This means that you lose the benefit of expression templates. Concretely, this has two drawbacks\+: \begin{DoxyItemize}
\item The evaluation into a temporary may be useless and inefficient; \item This only allows the function to read from the expression, not to write to it.\end{DoxyItemize}
Fortunately, all this myriad of expression types have in common that they all inherit a few common, templated base classes. By letting your function take templated parameters of these base types, you can let them play nicely with Eigen\textquotesingle{}s expression templates.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_function_taking_eigen_types_TopicFirstExamples}{}\doxysubsection{Some First Examples}\label{_topic_function_taking_eigen_types_TopicFirstExamples}
This section will provide simple examples for different types of objects Eigen is offering. Before starting with the actual examples, we need to recapitulate which base objects we can work with (see also \mbox{\hyperlink{TopicClassHierarchy}{The class hierarchy}}).

\begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}\+: The common base class for all dense matrix expressions (as opposed to array expressions, as opposed to sparse and special matrix classes). Use it in functions that are meant to work only on dense matrices. \item \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}}\+: The common base class for all dense array expressions (as opposed to matrix expressions, etc). Use it in functions that are meant to work only on arrays. \item \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}}\+: The common base class for all dense matrix expression, that is, the base class for both {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}} and {\ttfamily \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}}}. It can be used in functions that are meant to work on both matrices and arrays. \item \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}\+: The base class unifying all types of objects that can be evaluated into dense matrices or arrays, for example special matrix classes such as diagonal matrices, permutation matrices, etc. It can be used in functions that are meant to work on any such general type.\end{DoxyItemize}
{\bfseries{ Eigen\+Base Example }}~\newline
~\newline
 Prints the dimensions of the most generic object present in Eigen. It could be any matrix expressions, any dense or sparse matrix and any array. \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}
{\bfseries{ Dense\+Base Example }}~\newline
~\newline
 Prints a sub-\/block of the dense expression. Accepts any dense matrix or array expression, but no sparse objects and no special matrix classes such as \mbox{\hyperlink{class_eigen_1_1_diagonal_matrix}{Diagonal\+Matrix}}. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} print\_block(\textcolor{keyword}{const} DenseBase<Derived>\& b, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y, \textcolor{keywordtype}{int} r, \textcolor{keywordtype}{int} c)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"block: "} << b.block(x,y,r,c) << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 {\bfseries{ Array\+Base Example }}~\newline
~\newline
 Prints the maximum coefficient of the array or array-\/expression. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} print\_max\_coeff(\textcolor{keyword}{const} ArrayBase<Derived> \&a)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"max: "} << a.maxCoeff() << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 {\bfseries{ Matrix\+Base Example }}~\newline
~\newline
 Prints the inverse condition number of the given matrix or matrix-\/expression. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} print\_inv\_cond(\textcolor{keyword}{const} MatrixBase<Derived>\& a)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keyword}{typename} JacobiSVD<typename Derived::PlainObject>::SingularValuesType\&}
\DoxyCodeLine{    sing\_vals = a.jacobiSvd().singularValues();}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"inv cond: "} << sing\_vals(sing\_vals.size()-\/1) / sing\_vals(0) << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 {\bfseries{ Multiple templated arguments example }}~\newline
~\newline
 Calculate the Euclidean distance between two points. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} DerivedA,\textcolor{keyword}{typename} DerivedB>}
\DoxyCodeLine{\textcolor{keyword}{typename} DerivedA::Scalar squaredist(\textcolor{keyword}{const} MatrixBase<DerivedA>\& p1,\textcolor{keyword}{const} MatrixBase<DerivedB>\& p2)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} (p1-\/p2).squaredNorm();}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Notice that we used two template parameters, one per argument. This permits the function to handle inputs of different types, e.\+g., 
\begin{DoxyCode}{0}
\DoxyCodeLine{squaredist(v1,2*v2)}
\end{DoxyCode}
 where the first argument {\ttfamily v1} is a vector and the second argument {\ttfamily 2$\ast$v2} is an expression. ~\newline
~\newline


These examples are just intended to give the reader a first impression of how functions can be written which take a plain and constant \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} or \mbox{\hyperlink{class_eigen_1_1_array}{Array}} argument. They are also intended to give the reader an idea about the most common base classes being the optimal candidates for functions. In the next section we will look in more detail at an example and the different ways it can be implemented, while discussing each implementation\textquotesingle{}s problems and advantages. For the discussion below, \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} and \mbox{\hyperlink{class_eigen_1_1_array}{Array}} as well as \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} and \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} can be exchanged and all arguments still hold.\hypertarget{_topic_function_taking_eigen_types_TopicUsingRefClass}{}\doxysubsection{How to write generic, but non-\/templated function?}\label{_topic_function_taking_eigen_types_TopicUsingRefClass}
In all the previous examples, the functions had to be template functions. This approach allows to write very generic code, but it is often desirable to write non templated functions and still keep some level of genericity to avoid stupid copies of the arguments. The typical example is to write functions accepting both a Matrix\+Xf or a block of a Matrix\+Xf. This is exactly the purpose of the \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} class. Here is a simple example\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}
In the first two calls to inv\+\_\+cond, no copy occur because the memory layout of the arguments matches the memory layout accepted by Ref$<$\+Matrix\+Xf$>$. However, in the last call, we have a generic expression that will be automatically evaluated into a temporary Matrix\+Xf by the Ref$<$$>$ object.

A \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} object can also be writable. Here is an example of a function computing the covariance matrix of two input matrices where each row is an observation\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} Ref<const MatrixXf> x, \textcolor{keyword}{const} Ref<const MatrixXf> y, Ref<MatrixXf> C)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{float} num\_observations = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{  C = (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 and here are two examples calling cov without any copy\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf m1, m2, m3}
\DoxyCodeLine{cov(m1, m2, m3);}
\DoxyCodeLine{cov(m1.leftCols<3>(), m2.leftCols<3>(), m3.topLeftCorner<3,3>());}
\end{DoxyCode}
 The Ref$<$$>$ class has two other optional template arguments allowing to control the kind of memory layout that can be accepted without any copy. See the class \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} documentation for the details.\hypertarget{_topic_function_taking_eigen_types_TopicPlainFunctionsWorking}{}\doxysubsection{In which cases do functions taking plain Matrix or Array arguments work?}\label{_topic_function_taking_eigen_types_TopicPlainFunctionsWorking}
Without using template functions, and without the \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} class, a naive implementation of the previous cov function might look like this 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf cov(\textcolor{keyword}{const} MatrixXf\& x, \textcolor{keyword}{const} MatrixXf\& y)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{float} num\_observations = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keywordflow}{return} (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 and contrary to what one might think at first, this implementation is fine unless you require a generic implementation that works with double matrices too and unless you do not care about temporary objects. Why is that the case? Where are temporaries involved? How can code as given below compile? 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf x,y,z;}
\DoxyCodeLine{MatrixXf C = cov(x,y+z);}
\end{DoxyCode}
 In this special case, the example is fine and will be working because both parameters are declared as {\itshape const} references. The compiler creates a temporary and evaluates the expression x+z into this temporary. Once the function is processed, the temporary is released and the result is assigned to C.

{\bfseries{Note\+:}} Functions taking {\itshape const} references to \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} (or \mbox{\hyperlink{class_eigen_1_1_array}{Array}}) can process expressions at the cost of temporaries.\hypertarget{_topic_function_taking_eigen_types_TopicPlainFunctionsFailing}{}\doxysubsection{In which cases do functions taking a plain Matrix or Array argument fail?}\label{_topic_function_taking_eigen_types_TopicPlainFunctionsFailing}
Here, we consider a slightly modified version of the function given above. This time, we do not want to return the result but pass an additional non-\/const parameter which allows us to store the result. A first naive implementation might look as follows. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Note: This code is flawed!}}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} MatrixXf\& x, \textcolor{keyword}{const} MatrixXf\& y, MatrixXf\& C)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{float} num\_observations = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{  C = (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 When trying to execute the following code 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf C = MatrixXf::Zero(3,6);}
\DoxyCodeLine{cov(x,y, C.block(0,0,3,3));}
\end{DoxyCode}
 the compiler will fail, because it is not possible to convert the expression returned by {\ttfamily Matrix\+Xf\+::block()} into a non-\/const {\ttfamily Matrix\+Xf\&}. This is the case because the compiler wants to protect you from writing your result to a temporary object. In this special case this protection is not intended -- we want to write to a temporary object. So how can we overcome this problem?

The solution which is preferred at the moment is based on a little {\itshape hack}. One needs to pass a const reference to the matrix and internally the constness needs to be cast away. The correct implementation for C98 compliant compilers would be 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} MatrixBase<Derived>\& x, \textcolor{keyword}{const} MatrixBase<Derived>\& y, MatrixBase<OtherDerived> \textcolor{keyword}{const} \& C)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::plain\_row\_type<Derived>::type RowVectorType;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} Scalar num\_observations = \textcolor{keyword}{static\_cast<}Scalar\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const\_cast<} MatrixBase<OtherDerived>\& \textcolor{keyword}{>}(C) =}
\DoxyCodeLine{    (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 The implementation above does now not only work with temporary expressions but it also allows to use the function with matrices of arbitrary floating point scalar types.

{\bfseries{Note\+:}} The const cast hack will only work with templated functions. It will not work with the Matrix\+Xf implementation because it is not possible to cast a \mbox{\hyperlink{class_eigen_1_1_block}{Block}} expression to a \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} reference!\hypertarget{_topic_function_taking_eigen_types_TopicResizingInGenericImplementations}{}\doxysubsection{How to resize matrices in generic implementations?}\label{_topic_function_taking_eigen_types_TopicResizingInGenericImplementations}
One might think we are done now, right? This is not completely true because in order for our covariance function to be generically applicable, we want the following code to work 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf x = MatrixXf::Random(100,3);}
\DoxyCodeLine{MatrixXf y = MatrixXf::Random(100,3);}
\DoxyCodeLine{MatrixXf C;}
\DoxyCodeLine{cov(x, y, C);}
\end{DoxyCode}
 This is not the case anymore, when we are using an implementation taking \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} as a parameter. In general, Eigen supports automatic resizing but it is not possible to do so on expressions. Why should resizing of a matrix \mbox{\hyperlink{class_eigen_1_1_block}{Block}} be allowed? It is a reference to a sub-\/matrix and we definitely don\textquotesingle{}t want to resize that. So how can we incorporate resizing if we cannot resize on \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}? The solution is to resize the derived object as in this implementation. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} MatrixBase<Derived>\& x, \textcolor{keyword}{const} MatrixBase<Derived>\& y, MatrixBase<OtherDerived> \textcolor{keyword}{const} \& C\_)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::plain\_row\_type<Derived>::type RowVectorType;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} Scalar num\_observations = \textcolor{keyword}{static\_cast<}Scalar\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{}
\DoxyCodeLine{  MatrixBase<OtherDerived>\& C = \textcolor{keyword}{const\_cast<} MatrixBase<OtherDerived>\& \textcolor{keyword}{>}(C\_);}
\DoxyCodeLine{  }
\DoxyCodeLine{  C.derived().resize(x.cols(),x.cols()); \textcolor{comment}{// resize the derived object}}
\DoxyCodeLine{  C = (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 This implementation is now working for parameters being expressions and for parameters being matrices and having the wrong size. Resizing the expressions does not do any harm in this case unless they actually require resizing. That means, passing an expression with the wrong dimensions will result in a run-\/time error (in debug mode only) while passing expressions of the correct size will just work fine.

{\bfseries{Note\+:}} In the above discussion the terms \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} and \mbox{\hyperlink{class_eigen_1_1_array}{Array}} and \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} and \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} can be exchanged and all arguments still hold.\hypertarget{_topic_function_taking_eigen_types_TopicSummary}{}\doxysubsection{Summary}\label{_topic_function_taking_eigen_types_TopicSummary}

\begin{DoxyItemize}
\item To summarize, the implementation of functions taking non-\/writable (const referenced) objects is not a big issue and does not lead to problematic situations in terms of compiling and running your program. However, a naive implementation is likely to introduce unnecessary temporary objects in your code. In order to avoid evaluating parameters into temporaries, pass them as (const) references to \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} or \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} (so templatize your function).
\item Functions taking writable (non-\/const) parameters must take const references and cast away constness within the function body.
\item Functions that take as parameters \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} (or \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}}) objects, and potentially need to resize them (in the case where they are resizable), must call resize() on the derived class, as returned by derived().
\end{DoxyItemize}

Eigen\textquotesingle{}s use of expression templates results in potentially every expression being of a different type. If you pass such an expression to a function taking a parameter of type \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, your expression will implicitly be evaluated into a temporary \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, which will then be passed to the function. This means that you lose the benefit of expression templates. Concretely, this has two drawbacks\+: \begin{DoxyItemize}
\item The evaluation into a temporary may be useless and inefficient; \item This only allows the function to read from the expression, not to write to it.\end{DoxyItemize}
Fortunately, all this myriad of expression types have in common that they all inherit a few common, templated base classes. By letting your function take templated parameters of these base types, you can let them play nicely with Eigen\textquotesingle{}s expression templates.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_function_taking_eigen_types_TopicFirstExamples}{}\doxysubsection{Some First Examples}\label{_topic_function_taking_eigen_types_TopicFirstExamples}
This section will provide simple examples for different types of objects Eigen is offering. Before starting with the actual examples, we need to recapitulate which base objects we can work with (see also \mbox{\hyperlink{TopicClassHierarchy}{The class hierarchy}}).

\begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}\+: The common base class for all dense matrix expressions (as opposed to array expressions, as opposed to sparse and special matrix classes). Use it in functions that are meant to work only on dense matrices. \item \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}}\+: The common base class for all dense array expressions (as opposed to matrix expressions, etc). Use it in functions that are meant to work only on arrays. \item \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}}\+: The common base class for all dense matrix expression, that is, the base class for both {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}} and {\ttfamily \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}}}. It can be used in functions that are meant to work on both matrices and arrays. \item \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}\+: The base class unifying all types of objects that can be evaluated into dense matrices or arrays, for example special matrix classes such as diagonal matrices, permutation matrices, etc. It can be used in functions that are meant to work on any such general type.\end{DoxyItemize}
{\bfseries{ Eigen\+Base Example }}~\newline
~\newline
 Prints the dimensions of the most generic object present in Eigen. It could be any matrix expressions, any dense or sparse matrix and any array. \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}
{\bfseries{ Dense\+Base Example }}~\newline
~\newline
 Prints a sub-\/block of the dense expression. Accepts any dense matrix or array expression, but no sparse objects and no special matrix classes such as \mbox{\hyperlink{class_eigen_1_1_diagonal_matrix}{Diagonal\+Matrix}}. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} print\_block(\textcolor{keyword}{const} DenseBase<Derived>\& b, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y, \textcolor{keywordtype}{int} r, \textcolor{keywordtype}{int} c)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"block: "} << b.block(x,y,r,c) << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 {\bfseries{ Array\+Base Example }}~\newline
~\newline
 Prints the maximum coefficient of the array or array-\/expression. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} print\_max\_coeff(\textcolor{keyword}{const} ArrayBase<Derived> \&a)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"max: "} << a.maxCoeff() << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 {\bfseries{ Matrix\+Base Example }}~\newline
~\newline
 Prints the inverse condition number of the given matrix or matrix-\/expression. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} print\_inv\_cond(\textcolor{keyword}{const} MatrixBase<Derived>\& a)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keyword}{typename} JacobiSVD<typename Derived::PlainObject>::SingularValuesType\&}
\DoxyCodeLine{    sing\_vals = a.jacobiSvd().singularValues();}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"inv cond: "} << sing\_vals(sing\_vals.size()-\/1) / sing\_vals(0) << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 {\bfseries{ Multiple templated arguments example }}~\newline
~\newline
 Calculate the Euclidean distance between two points. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} DerivedA,\textcolor{keyword}{typename} DerivedB>}
\DoxyCodeLine{\textcolor{keyword}{typename} DerivedA::Scalar squaredist(\textcolor{keyword}{const} MatrixBase<DerivedA>\& p1,\textcolor{keyword}{const} MatrixBase<DerivedB>\& p2)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} (p1-\/p2).squaredNorm();}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Notice that we used two template parameters, one per argument. This permits the function to handle inputs of different types, e.\+g., 
\begin{DoxyCode}{0}
\DoxyCodeLine{squaredist(v1,2*v2)}
\end{DoxyCode}
 where the first argument {\ttfamily v1} is a vector and the second argument {\ttfamily 2$\ast$v2} is an expression. ~\newline
~\newline


These examples are just intended to give the reader a first impression of how functions can be written which take a plain and constant \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} or \mbox{\hyperlink{class_eigen_1_1_array}{Array}} argument. They are also intended to give the reader an idea about the most common base classes being the optimal candidates for functions. In the next section we will look in more detail at an example and the different ways it can be implemented, while discussing each implementation\textquotesingle{}s problems and advantages. For the discussion below, \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} and \mbox{\hyperlink{class_eigen_1_1_array}{Array}} as well as \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} and \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} can be exchanged and all arguments still hold.\hypertarget{_topic_function_taking_eigen_types_TopicUsingRefClass}{}\doxysubsection{How to write generic, but non-\/templated function?}\label{_topic_function_taking_eigen_types_TopicUsingRefClass}
In all the previous examples, the functions had to be template functions. This approach allows to write very generic code, but it is often desirable to write non templated functions and still keep some level of genericity to avoid stupid copies of the arguments. The typical example is to write functions accepting both a Matrix\+Xf or a block of a Matrix\+Xf. This is exactly the purpose of the \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} class. Here is a simple example\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}
In the first two calls to inv\+\_\+cond, no copy occur because the memory layout of the arguments matches the memory layout accepted by Ref$<$\+Matrix\+Xf$>$. However, in the last call, we have a generic expression that will be automatically evaluated into a temporary Matrix\+Xf by the Ref$<$$>$ object.

A \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} object can also be writable. Here is an example of a function computing the covariance matrix of two input matrices where each row is an observation\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} Ref<const MatrixXf> x, \textcolor{keyword}{const} Ref<const MatrixXf> y, Ref<MatrixXf> C)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{float} num\_observations = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{  C = (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 and here are two examples calling cov without any copy\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf m1, m2, m3}
\DoxyCodeLine{cov(m1, m2, m3);}
\DoxyCodeLine{cov(m1.leftCols<3>(), m2.leftCols<3>(), m3.topLeftCorner<3,3>());}
\end{DoxyCode}
 The Ref$<$$>$ class has two other optional template arguments allowing to control the kind of memory layout that can be accepted without any copy. See the class \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} documentation for the details.\hypertarget{_topic_function_taking_eigen_types_TopicPlainFunctionsWorking}{}\doxysubsection{In which cases do functions taking plain Matrix or Array arguments work?}\label{_topic_function_taking_eigen_types_TopicPlainFunctionsWorking}
Without using template functions, and without the \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} class, a naive implementation of the previous cov function might look like this 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf cov(\textcolor{keyword}{const} MatrixXf\& x, \textcolor{keyword}{const} MatrixXf\& y)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{float} num\_observations = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keywordflow}{return} (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 and contrary to what one might think at first, this implementation is fine unless you require a generic implementation that works with double matrices too and unless you do not care about temporary objects. Why is that the case? Where are temporaries involved? How can code as given below compile? 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf x,y,z;}
\DoxyCodeLine{MatrixXf C = cov(x,y+z);}
\end{DoxyCode}
 In this special case, the example is fine and will be working because both parameters are declared as {\itshape const} references. The compiler creates a temporary and evaluates the expression y+z into this temporary. Once the function is processed, the temporary is released and the result is assigned to C.

{\bfseries{Note\+:}} Functions taking {\itshape const} references to \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} (or \mbox{\hyperlink{class_eigen_1_1_array}{Array}}) can process expressions at the cost of temporaries.\hypertarget{_topic_function_taking_eigen_types_TopicPlainFunctionsFailing}{}\doxysubsection{In which cases do functions taking a plain Matrix or Array argument fail?}\label{_topic_function_taking_eigen_types_TopicPlainFunctionsFailing}
Here, we consider a slightly modified version of the function given above. This time, we do not want to return the result but pass an additional non-\/const parameter which allows us to store the result. A first naive implementation might look as follows. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Note: This code is flawed!}}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} MatrixXf\& x, \textcolor{keyword}{const} MatrixXf\& y, MatrixXf\& C)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{float} num\_observations = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{  C = (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 When trying to execute the following code 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf C = MatrixXf::Zero(3,6);}
\DoxyCodeLine{cov(x,y, C.block(0,0,3,3));}
\end{DoxyCode}
 the compiler will fail, because it is not possible to convert the expression returned by {\ttfamily Matrix\+Xf\+::block()} into a non-\/const {\ttfamily Matrix\+Xf\&}. This is the case because the compiler wants to protect you from writing your result to a temporary object. In this special case this protection is not intended -- we want to write to a temporary object. So how can we overcome this problem?

The solution which is preferred at the moment is based on a little {\itshape hack}. One needs to pass a const reference to the matrix and internally the constness needs to be cast away. The correct implementation for C98 compliant compilers would be 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} MatrixBase<Derived>\& x, \textcolor{keyword}{const} MatrixBase<Derived>\& y, MatrixBase<OtherDerived> \textcolor{keyword}{const} \& C)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::plain\_row\_type<Derived>::type RowVectorType;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} Scalar num\_observations = \textcolor{keyword}{static\_cast<}Scalar\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const\_cast<} MatrixBase<OtherDerived>\& \textcolor{keyword}{>}(C) =}
\DoxyCodeLine{    (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 The implementation above does now not only work with temporary expressions but it also allows to use the function with matrices of arbitrary floating point scalar types.

{\bfseries{Note\+:}} The const cast hack will only work with templated functions. It will not work with the Matrix\+Xf implementation because it is not possible to cast a \mbox{\hyperlink{class_eigen_1_1_block}{Block}} expression to a \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} reference!\hypertarget{_topic_function_taking_eigen_types_TopicResizingInGenericImplementations}{}\doxysubsection{How to resize matrices in generic implementations?}\label{_topic_function_taking_eigen_types_TopicResizingInGenericImplementations}
One might think we are done now, right? This is not completely true because in order for our covariance function to be generically applicable, we want the following code to work 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf x = MatrixXf::Random(100,3);}
\DoxyCodeLine{MatrixXf y = MatrixXf::Random(100,3);}
\DoxyCodeLine{MatrixXf C;}
\DoxyCodeLine{cov(x, y, C);}
\end{DoxyCode}
 This is not the case anymore, when we are using an implementation taking \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} as a parameter. In general, Eigen supports automatic resizing but it is not possible to do so on expressions. Why should resizing of a matrix \mbox{\hyperlink{class_eigen_1_1_block}{Block}} be allowed? It is a reference to a sub-\/matrix and we definitely don\textquotesingle{}t want to resize that. So how can we incorporate resizing if we cannot resize on \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}? The solution is to resize the derived object as in this implementation. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} MatrixBase<Derived>\& x, \textcolor{keyword}{const} MatrixBase<Derived>\& y, MatrixBase<OtherDerived> \textcolor{keyword}{const} \& C\_)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::plain\_row\_type<Derived>::type RowVectorType;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} Scalar num\_observations = \textcolor{keyword}{static\_cast<}Scalar\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{}
\DoxyCodeLine{  MatrixBase<OtherDerived>\& C = \textcolor{keyword}{const\_cast<} MatrixBase<OtherDerived>\& \textcolor{keyword}{>}(C\_);}
\DoxyCodeLine{  }
\DoxyCodeLine{  C.derived().resize(x.cols(),x.cols()); \textcolor{comment}{// resize the derived object}}
\DoxyCodeLine{  C = (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 This implementation is now working for parameters being expressions and for parameters being matrices and having the wrong size. Resizing the expressions does not do any harm in this case unless they actually require resizing. That means, passing an expression with the wrong dimensions will result in a run-\/time error (in debug mode only) while passing expressions of the correct size will just work fine.

{\bfseries{Note\+:}} In the above discussion the terms \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} and \mbox{\hyperlink{class_eigen_1_1_array}{Array}} and \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} and \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} can be exchanged and all arguments still hold.\hypertarget{_topic_function_taking_eigen_types_TopicSummary}{}\doxysubsection{Summary}\label{_topic_function_taking_eigen_types_TopicSummary}

\begin{DoxyItemize}
\item To summarize, the implementation of functions taking non-\/writable (const referenced) objects is not a big issue and does not lead to problematic situations in terms of compiling and running your program. However, a naive implementation is likely to introduce unnecessary temporary objects in your code. In order to avoid evaluating parameters into temporaries, pass them as (const) references to \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} or \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} (so templatize your function).
\item Functions taking writable (non-\/const) parameters must take const references and cast away constness within the function body.
\item Functions that take as parameters \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} (or \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}}) objects, and potentially need to resize them (in the case where they are resizable), must call resize() on the derived class, as returned by derived(). 
\end{DoxyItemize}\hypertarget{TopicPreprocessorDirectives}{}\doxysection{Preprocessor directives}\label{TopicPreprocessorDirectives}
You can control some aspects of Eigen by defining the preprocessor tokens using {\ttfamily \#define}. These macros should be defined before any Eigen headers are included. Often they are best set in the project options.

This page lists the preprocessor tokens recognized by Eigen.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesMajor}{}\doxysubsection{Macros with major effects}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesMajor}
These macros have a major effect and typically break the A\+PI (Application Programming Interface) and/or the A\+BI (Application Binary Interface). This can be rather dangerous\+: if parts of your program are compiled with one option, and other parts (or libraries that you use) are compiled with another option, your program may fail to link or exhibit subtle bugs. Nevertheless, these options can be useful for people who know what they are doing.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N2\+\_\+\+S\+U\+P\+P\+O\+RT}} and {\bfseries{E\+I\+G\+E\+N2\+\_\+\+S\+U\+P\+P\+O\+R\+T\+\_\+\+S\+T\+A\+G\+Enn\+\_\+xxx}} are disabled starting from the 3.\+3 release. Defining one of these will raise a compile-\/error. If you need to compile Eigen2 code, \href{http://eigen.tuxfamily.org/index.php?title=Eigen2}{\texttt{ check this site}}.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+D\+E\+N\+S\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE}} -\/ the type for column and row indices in matrices, vectors and array (Dense\+Base\+::\+Index). Set to {\ttfamily std\+::ptrdiff\+\_\+t} by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+I\+O\+\_\+\+F\+O\+R\+M\+AT}} -\/ the \mbox{\hyperlink{struct_eigen_1_1_i_o_format}{I\+O\+Format}} to use when printing a matrix if no I\+O\+Format is specified. Defaults to the I\+O\+Format constructed by the default constructor \mbox{\hyperlink{struct_eigen_1_1_i_o_format_acdcc91702d45c714b11ba42db5beddb5}{I\+O\+Format\+::\+I\+O\+Format()}}.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+A\+T\+R\+I\+C\+E\+S\+\_\+\+B\+Y\+\_\+\+Z\+E\+RO}} -\/ if defined, all entries of newly constructed matrices and arrays are initialized to zero, as are new entries in matrices and arrays after resizing. Not defined by default. \begin{DoxyWarning}{Warning}
The unary (resp. binary) constructor of {\ttfamily 1x1} (resp. {\ttfamily 2x1} or {\ttfamily 1x2}) fixed size matrices is always interpreted as an initialization constructor where the argument(s) are the coefficient values and not the sizes. For instance,
\begin{DoxyCode}{0}
\DoxyCodeLine{Vector2d v(2,1); }
\end{DoxyCode}
 will create a vector with coeficients \mbox{[}2,1\mbox{]}, and {\bfseries{not}} a {\ttfamily 2x1} vector initialized with zeros (i.\+e., \mbox{[}0,0\mbox{]}). If such cases might occur, then it is recommended to use the default constructor with a explicit call to resize\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Matrix<?,SizeAtCompileTime,1> v;}
\DoxyCodeLine{v.resize(size);}
\DoxyCodeLine{Matrix<?,RowsAtCompileTime,ColsAtCompileTime> m;}
\DoxyCodeLine{m.resize(rows,cols);}
\end{DoxyCode}

\end{DoxyWarning}

\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+A\+T\+R\+I\+C\+E\+S\+\_\+\+B\+Y\+\_\+\+N\+AN}} -\/ if defined, all entries of newly constructed matrices and arrays are initialized to NaN, as are new entries in matrices and arrays after resizing. This option is especially useful for debugging purpose, though a memory tool like \href{http://valgrind.org/}{\texttt{ valgrind}} is preferable. Not defined by default. \begin{DoxyWarning}{Warning}
See the documentation of {\ttfamily E\+I\+G\+E\+N\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+A\+T\+R\+I\+C\+E\+S\+\_\+\+B\+Y\+\_\+\+Z\+E\+RO} for a discussion on a limitations of these macros when applied to {\ttfamily 1x1}, {\ttfamily 1x2}, and {\ttfamily 2x1} fixed-\/size matrices.
\end{DoxyWarning}

\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+A\+U\+T\+O\+M\+A\+T\+I\+C\+\_\+\+R\+E\+S\+I\+Z\+I\+NG}} -\/ if defined, the matrices (or arrays) on both sides of an assignment {\ttfamily a = b} have to be of the same size; otherwise, Eigen automatically resizes {\ttfamily a} so that it is of the correct size. Not defined by default.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesCppVersion}{}\doxysubsection{C++ standard features}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesCppVersion}
By default, Eigen strive to automatically detect and enable language features at compile-\/time based on the information provided by the compiler.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER}} -\/ disables usage of C++ features requiring a version greater than E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER. Possible values are\+: 14, 17, etc. If not defined (the default), Eigen enables all features supported by the compiler.
\end{DoxyItemize}

Individual features can be explicitly enabled or disabled by defining the following token to 0 or 1 respectively. For instance, one might limit the C++ version to C++14 by defining E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER=14, but still enable C99 math functions by defining E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C99\+\_\+\+M\+A\+TH=1.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C99\+\_\+\+M\+A\+TH}} -\/ controls the usage of C99 math functions such as erf, erfc, lgamma, etc.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C\+X\+X11\+\_\+\+M\+A\+TH}} -\/ controls the implementation of some functions such as round, logp1, isinf, isnan, etc.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+S\+T\+D\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+OF}} -\/ defines whether std\+::result\+\_\+of is supported
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+IO}} -\/ Disables any usage and support for {\ttfamily $<$iostreams$>$}.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesAssertions}{}\doxysubsection{Assertions}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesAssertions}
The Eigen library contains many assertions to guard against programming errors, both at compile time and at run time. However, these assertions do cost time and can thus be turned off.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+D\+E\+B\+UG}} -\/ disables Eigen\textquotesingle{}s assertions if defined. Not defined by default, unless the {\ttfamily N\+D\+E\+B\+UG} macro is defined (this is a standard C++ macro which disables all asserts).
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+RT}} -\/ if defined, compile-\/time static assertions are replaced by runtime assertions; this saves compilation time. Not defined by default.
\item {\bfseries{eigen\+\_\+assert}} -\/ macro with one argument that is used inside Eigen for assertions. By default, it is basically defined to be {\ttfamily assert}, which aborts the program if the assertion is violated. Redefine this macro if you want to do something else, like throwing an exception.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+P\+L2\+\_\+\+O\+N\+LY}} -\/ disable non M\+P\+L2 compatible features, or in other words disable the features which are still under the L\+G\+PL.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}{}\doxysubsection{Alignment, vectorization and performance tweaking}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}

\begin{DoxyItemize}
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+L\+L\+O\+C\+\_\+\+A\+L\+R\+E\+A\+D\+Y\+\_\+\+A\+L\+I\+G\+N\+ED} -\/}} Can be set to 0 or 1 to tell whether default system {\ttfamily malloc} already returns aligned buffers. In not defined, then this information is automatically deduced from the compiler and system preprocessor tokens.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} -\/}} Must be a power of two, or 0. Defines an upper bound on the memory boundary in bytes on which dynamically and statically allocated data may be aligned by Eigen. If not defined, a default value is automatically computed based on architecture, compiler, and OS. This option is typically used to enforce binary compatibility between code/libraries compiled with different S\+I\+MD options. For instance, one may compile A\+VX code and enforce A\+BI compatibility with existing S\+SE code by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=16}. In the other way round, since by default A\+VX implies 32 bytes alignment for best performance, one can compile S\+SE code to be A\+BI compatible with A\+VX code by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=32}.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} -\/}} Same as {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} but for statically allocated data only. By default, if only {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} is defined, then {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} == {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES}, otherwise a default value is automatically computed based on architecture, compiler, and OS (can be smaller than the default value of E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES on architectures that do not support stack alignment). Let us emphasize that {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+$\ast$\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} define only a desirable upper bound. In practice data is aligned to largest power-\/of-\/two common divisor of {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} and the size of the data, such that memory is not wasted.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L\+I\+ZE} -\/}} if defined, this disables multi-\/threading. This is only relevant if you enabled Open\+MP. See \mbox{\hyperlink{TopicMultiThreading}{Eigen and multi-\/threading}} for details.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE} -\/}} disables explicit vectorization when defined. Not defined by default, unless alignment is disabled by Eigen\textquotesingle{}s platform test or the user defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN}.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+N\+A\+L\+I\+G\+N\+E\+D\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE} -\/}} disables/enables vectorization with unaligned stores. Default is 1 (enabled). If set to 0 (disabled), then expression for which the destination cannot be aligned are not vectorized (e.\+g., unaligned small fixed size vectors or matrices)
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+F\+A\+S\+T\+\_\+\+M\+A\+TH} -\/}} enables some optimizations which might affect the accuracy of the result. This currently enables the S\+SE vectorization of \mbox{\hyperlink{group__core__func__trigonometric_ga626e6663f52e5ffefd16ba0f52ccbd90}{sin()}} and \mbox{\hyperlink{group__core__func__trigonometric_ga9511f60b18cb8ce18d455029d7571219}{cos()}}, and speedups \mbox{\hyperlink{group__core__func__exponential_ga5c784ec51a1765be0a623104db2577b6}{sqrt()}} for single precision. Defined to 1 by default. Define it to 0 to disable.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+N\+R\+O\+L\+L\+I\+N\+G\+\_\+\+L\+I\+M\+IT} -\/}} defines the size of a loop to enable meta unrolling. Set it to zero to disable unrolling. The size of a loop here is expressed in Eigen\textquotesingle{}s own notion of \char`\"{}number of F\+L\+O\+P\+S\char`\"{}, it does not correspond to the number of iterations or the number of instructions. The default is value 110.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+C\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+L\+I\+M\+IT} -\/}} defines the maximum bytes for a buffer to be allocated on the stack. For internal temporary buffers, dynamic memory allocation is employed as a fall back. For fixed-\/size matrices or arrays, exceeding this threshold raises a compile time assertion. Use 0 to set no limit. Default is 128 KB.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+C\+U\+DA} -\/}} disables C\+U\+DA support when defined. Might be useful in .cu files for which \mbox{\hyperlink{namespace_eigen}{Eigen}} is used on the host only, and never called from device code.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+S\+T\+R\+O\+N\+G\+\_\+\+I\+N\+L\+I\+NE} -\/}} This macro is used to qualify critical functions and methods that we expect the compiler to inline. By default it is defined to {\ttfamily \+\_\+\+\_\+forceinline} for M\+S\+VC and I\+CC, and to {\ttfamily inline} for other compilers. A tipical usage is to define it to {\ttfamily inline} for M\+S\+VC users wanting faster compilation times, at the risk of performance degradations in some rare cases for which M\+S\+VC inliner fails to do a good job.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+L1\+\_\+\+C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE} -\/}} Sets the default L1 cache size that is used in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s G\+E\+BP kernel when the correct cache size cannot be determined at runtime.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+L2\+\_\+\+C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE} -\/}} Sets the default L2 cache size that is used in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s G\+E\+BP kernel when the correct cache size cannot be determined at runtime.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+L3\+\_\+\+C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE} -\/}} Sets the default L3 cache size that is used in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s G\+E\+BP kernel when the correct cache size cannot be determined at runtime.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN} -\/}} Deprecated, it is a synonym for {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=0}. It disables alignment completely. Eigen will not try to align its objects and does not expect that any objects passed to it are aligned. This will turn off vectorization if {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+N\+A\+L\+I\+G\+N\+E\+D\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE=1}.}} Not defined by default.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+G\+N\+\_\+\+S\+T\+A\+T\+I\+C\+A\+L\+LY} -\/}} Deprecated, it is a synonym for {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=0}. It disables alignment of arrays on the stack. Not defined by default, unless {\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN} is defined.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+A\+L\+T\+I\+V\+E\+C\+\_\+\+E\+N\+A\+B\+L\+E\+\_\+\+M\+M\+A\+\_\+\+D\+Y\+N\+A\+M\+I\+C\+\_\+\+D\+I\+S\+P\+A\+T\+CH} -\/}} Controls whether to use \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s dynamic dispatching for Altivec M\+MA or not.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+A\+L\+T\+I\+V\+E\+C\+\_\+\+D\+I\+S\+A\+B\+L\+E\+\_\+\+M\+MA} -\/}} Overrides the usage of Altivec M\+MA instructions.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+A\+L\+T\+I\+V\+E\+C\+\_\+\+U\+S\+E\+\_\+\+C\+U\+S\+T\+O\+M\+\_\+\+P\+A\+CK} -\/}} Controls whether to use \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s custom packing for Altivec or not.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesPlugins}{}\doxysubsection{Plugins}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesPlugins}
It is possible to add new methods to many fundamental classes in Eigen by writing a plugin. As explained in the section \mbox{\hyperlink{TopicCustomizing_Plugins}{Extending Matrix\+Base (and other classes)}}, the plugin is specified by defining a {\ttfamily E\+I\+G\+E\+N\+\_\+xxx\+\_\+\+P\+L\+U\+G\+IN} macro. The following macros are supported; none of them are defined by default.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+A\+R\+R\+A\+Y\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_array}{Array}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+A\+R\+R\+A\+Y\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+C\+W\+I\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the Cwise class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+N\+S\+E\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+Y\+N\+A\+M\+I\+C\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the Dynamic\+Sparse\+Matrix class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+F\+U\+N\+C\+T\+O\+R\+S\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for adding new functors and specializations of functor\+\_\+traits.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+P\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_map_base}{Map\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+T\+R\+I\+X\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+P\+L\+A\+I\+N\+O\+B\+J\+E\+C\+T\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{Plain\+Object\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+Q\+U\+A\+T\+E\+R\+N\+I\+O\+N\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_quaternion}{Quaternion}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+Q\+U\+A\+T\+E\+R\+N\+I\+O\+N\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_quaternion_base}{Quaternion\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_base}{Sparse\+Matrix\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+V\+E\+C\+T\+O\+R\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_sparse_vector}{Sparse\+Vector}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+T\+R\+A\+N\+S\+F\+O\+R\+M\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_transform}{Transform}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+V\+E\+C\+T\+O\+R\+W\+I\+S\+E\+O\+P\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_vectorwise_op}{Vectorwise\+Op}} class.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesDevelopers}{}\doxysubsection{Macros for Eigen developers}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesDevelopers}
These macros are mainly meant for people developing Eigen and for testing purposes. Even though, they might be useful for power users and the curious for debugging and testing purpose, they {\bfseries{should}} {\bfseries{not}} {\bfseries{be}} {\bfseries{used}} by real-\/word code.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+O\+\_\+\+R\+O\+W\+\_\+\+M\+A\+J\+OR}} -\/ when defined, the default storage order for matrices becomes row-\/major instead of column-\/major. Not defined by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+D\+E\+B\+U\+G\+G\+I\+NG}} -\/ if defined, enables assertions in Eigen\textquotesingle{}s internal routines. This is useful for debugging Eigen itself. Not defined by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+M\+A\+L\+L\+OC}} -\/ if defined, any request from inside the Eigen to allocate memory from the heap results in an assertion failure. This is useful to check that some routine does not allocate memory dynamically. Not defined by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+R\+U\+N\+T\+I\+M\+E\+\_\+\+N\+O\+\_\+\+M\+A\+L\+L\+OC}} -\/ if defined, a new switch is introduced which can be turned on and off by calling {\ttfamily set\+\_\+is\+\_\+malloc\+\_\+allowed(bool)}. If malloc is not allowed and Eigen tries to allocate memory dynamically anyway, an assertion failure results. Not defined by default.
\end{DoxyItemize}

You can control some aspects of Eigen by defining the preprocessor tokens using {\ttfamily \#define}. These macros should be defined before any Eigen headers are included. Often they are best set in the project options.

This page lists the preprocessor tokens recognized by Eigen.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesMajor}{}\doxysubsection{Macros with major effects}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesMajor}
These macros have a major effect and typically break the A\+PI (Application Programming Interface) and/or the A\+BI (Application Binary Interface). This can be rather dangerous\+: if parts of your program are compiled with one option, and other parts (or libraries that you use) are compiled with another option, your program may fail to link or exhibit subtle bugs. Nevertheless, these options can be useful for people who know what they are doing.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N2\+\_\+\+S\+U\+P\+P\+O\+RT}} and {\bfseries{E\+I\+G\+E\+N2\+\_\+\+S\+U\+P\+P\+O\+R\+T\+\_\+\+S\+T\+A\+G\+Enn\+\_\+xxx}} are disabled starting from the 3.\+3 release. Defining one of these will raise a compile-\/error. If you need to compile Eigen2 code, \href{http://eigen.tuxfamily.org/index.php?title=Eigen2}{\texttt{ check this site}}.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+D\+E\+N\+S\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE}} -\/ the type for column and row indices in matrices, vectors and array (Dense\+Base\+::\+Index). Set to {\ttfamily std\+::ptrdiff\+\_\+t} by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+I\+O\+\_\+\+F\+O\+R\+M\+AT}} -\/ the \mbox{\hyperlink{struct_eigen_1_1_i_o_format}{I\+O\+Format}} to use when printing a matrix if no I\+O\+Format is specified. Defaults to the I\+O\+Format constructed by the default constructor \mbox{\hyperlink{struct_eigen_1_1_i_o_format_acdcc91702d45c714b11ba42db5beddb5}{I\+O\+Format\+::\+I\+O\+Format()}}.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+A\+T\+R\+I\+C\+E\+S\+\_\+\+B\+Y\+\_\+\+Z\+E\+RO}} -\/ if defined, all entries of newly constructed matrices and arrays are initialized to zero, as are new entries in matrices and arrays after resizing. Not defined by default. \begin{DoxyWarning}{Warning}
The unary (resp. binary) constructor of {\ttfamily 1x1} (resp. {\ttfamily 2x1} or {\ttfamily 1x2}) fixed size matrices is always interpreted as an initialization constructor where the argument(s) are the coefficient values and not the sizes. For instance,
\begin{DoxyCode}{0}
\DoxyCodeLine{Vector2d v(2,1); }
\end{DoxyCode}
 will create a vector with coeficients \mbox{[}2,1\mbox{]}, and {\bfseries{not}} a {\ttfamily 2x1} vector initialized with zeros (i.\+e., \mbox{[}0,0\mbox{]}). If such cases might occur, then it is recommended to use the default constructor with a explicit call to resize\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Matrix<?,SizeAtCompileTime,1> v;}
\DoxyCodeLine{v.resize(size);}
\DoxyCodeLine{Matrix<?,RowsAtCompileTime,ColsAtCompileTime> m;}
\DoxyCodeLine{m.resize(rows,cols);}
\end{DoxyCode}

\end{DoxyWarning}

\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+A\+T\+R\+I\+C\+E\+S\+\_\+\+B\+Y\+\_\+\+N\+AN}} -\/ if defined, all entries of newly constructed matrices and arrays are initialized to NaN, as are new entries in matrices and arrays after resizing. This option is especially useful for debugging purpose, though a memory tool like \href{http://valgrind.org/}{\texttt{ valgrind}} is preferable. Not defined by default. \begin{DoxyWarning}{Warning}
See the documentation of {\ttfamily E\+I\+G\+E\+N\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+A\+T\+R\+I\+C\+E\+S\+\_\+\+B\+Y\+\_\+\+Z\+E\+RO} for a discussion on a limitations of these macros when applied to {\ttfamily 1x1}, {\ttfamily 1x2}, and {\ttfamily 2x1} fixed-\/size matrices.
\end{DoxyWarning}

\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+A\+U\+T\+O\+M\+A\+T\+I\+C\+\_\+\+R\+E\+S\+I\+Z\+I\+NG}} -\/ if defined, the matrices (or arrays) on both sides of an assignment {\ttfamily a = b} have to be of the same size; otherwise, Eigen automatically resizes {\ttfamily a} so that it is of the correct size. Not defined by default.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesCppVersion}{}\doxysubsection{C++ standard features}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesCppVersion}
By default, Eigen strive to automatically detect and enable language features at compile-\/time based on the information provided by the compiler.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER}} -\/ disables usage of C++ features requiring a version greater than E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER. Possible values are\+: 14, 17, etc. If not defined (the default), Eigen enables all features supported by the compiler.
\end{DoxyItemize}

Individual features can be explicitly enabled or disabled by defining the following token to 0 or 1 respectively. For instance, one might limit the C++ version to C++14 by defining E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER=14, but still enable C99 math functions by defining E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C99\+\_\+\+M\+A\+TH=1.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C99\+\_\+\+M\+A\+TH}} -\/ controls the usage of C99 math functions such as erf, erfc, lgamma, etc.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+S\+T\+D\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+OF}} -\/ defines whether std\+::result\+\_\+of is supported
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+IO}} -\/ Disables any usage and support for {\ttfamily $<$iostreams$>$}.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesAssertions}{}\doxysubsection{Assertions}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesAssertions}
The Eigen library contains many assertions to guard against programming errors, both at compile time and at run time. However, these assertions do cost time and can thus be turned off.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+D\+E\+B\+UG}} -\/ disables Eigen\textquotesingle{}s assertions if defined. Not defined by default, unless the {\ttfamily N\+D\+E\+B\+UG} macro is defined (this is a standard C++ macro which disables all asserts).
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+RT}} -\/ if defined, compile-\/time static assertions are replaced by runtime assertions; this saves compilation time. Not defined by default.
\item {\bfseries{eigen\+\_\+assert}} -\/ macro with one argument that is used inside Eigen for assertions. By default, it is basically defined to be {\ttfamily assert}, which aborts the program if the assertion is violated. Redefine this macro if you want to do something else, like throwing an exception.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}{}\doxysubsection{Alignment, vectorization and performance tweaking}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}

\begin{DoxyItemize}
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+L\+L\+O\+C\+\_\+\+A\+L\+R\+E\+A\+D\+Y\+\_\+\+A\+L\+I\+G\+N\+ED} -\/}} Can be set to 0 or 1 to tell whether default system {\ttfamily malloc} already returns aligned buffers. In not defined, then this information is automatically deduced from the compiler and system preprocessor tokens.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} -\/}} Must be a power of two, or 0. Defines an upper bound on the memory boundary in bytes on which dynamically and statically allocated data may be aligned by Eigen. If not defined, a default value is automatically computed based on architecture, compiler, and OS. This option is typically used to enforce binary compatibility between code/libraries compiled with different S\+I\+MD options. For instance, one may compile A\+VX code and enforce A\+BI compatibility with existing S\+SE code by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=16}. In the other way round, since by default A\+VX implies 32 bytes alignment for best performance, one can compile S\+SE code to be A\+BI compatible with A\+VX code by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=32}.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} -\/}} Same as {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} but for statically allocated data only. By default, if only {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} is defined, then {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} == {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES}, otherwise a default value is automatically computed based on architecture, compiler, and OS (can be smaller than the default value of E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES on architectures that do not support stack alignment). Let us emphasize that {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+$\ast$\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} define only a desirable upper bound. In practice data is aligned to largest power-\/of-\/two common divisor of {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} and the size of the data, such that memory is not wasted.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L\+I\+ZE} -\/}} if defined, this disables multi-\/threading. This is only relevant if you enabled Open\+MP. See \mbox{\hyperlink{TopicMultiThreading}{Eigen and multi-\/threading}} for details.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE} -\/}} disables explicit vectorization when defined. Not defined by default, unless alignment is disabled by Eigen\textquotesingle{}s platform test or the user defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN}.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+N\+A\+L\+I\+G\+N\+E\+D\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE} -\/}} disables/enables vectorization with unaligned stores. Default is 1 (enabled). If set to 0 (disabled), then expression for which the destination cannot be aligned are not vectorized (e.\+g., unaligned small fixed size vectors or matrices)
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+F\+A\+S\+T\+\_\+\+M\+A\+TH} -\/}} enables some optimizations which might affect the accuracy of the result. This currently enables the S\+SE vectorization of \mbox{\hyperlink{group__core__func__trigonometric_ga626e6663f52e5ffefd16ba0f52ccbd90}{sin()}} and \mbox{\hyperlink{group__core__func__trigonometric_ga9511f60b18cb8ce18d455029d7571219}{cos()}}, and speedups \mbox{\hyperlink{group__core__func__exponential_ga5c784ec51a1765be0a623104db2577b6}{sqrt()}} for single precision. Defined to 1 by default. Define it to 0 to disable.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+N\+R\+O\+L\+L\+I\+N\+G\+\_\+\+L\+I\+M\+IT} -\/}} defines the size of a loop to enable meta unrolling. Set it to zero to disable unrolling. The size of a loop here is expressed in Eigen\textquotesingle{}s own notion of \char`\"{}number of F\+L\+O\+P\+S\char`\"{}, it does not correspond to the number of iterations or the number of instructions. The default is value 110.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+C\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+L\+I\+M\+IT} -\/}} defines the maximum bytes for a buffer to be allocated on the stack. For internal temporary buffers, dynamic memory allocation is employed as a fall back. For fixed-\/size matrices or arrays, exceeding this threshold raises a compile time assertion. Use 0 to set no limit. Default is 128 KB.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+C\+U\+DA} -\/}} disables C\+U\+DA support when defined. Might be useful in .cu files for which \mbox{\hyperlink{namespace_eigen}{Eigen}} is used on the host only, and never called from device code.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+S\+T\+R\+O\+N\+G\+\_\+\+I\+N\+L\+I\+NE} -\/}} This macro is used to qualify critical functions and methods that we expect the compiler to inline. By default it is defined to {\ttfamily \+\_\+\+\_\+forceinline} for M\+S\+VC and I\+CC, and to {\ttfamily inline} for other compilers. A tipical usage is to define it to {\ttfamily inline} for M\+S\+VC users wanting faster compilation times, at the risk of performance degradations in some rare cases for which M\+S\+VC inliner fails to do a good job.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+L1\+\_\+\+C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE} -\/}} Sets the default L1 cache size that is used in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s G\+E\+BP kernel when the correct cache size cannot be determined at runtime.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+L2\+\_\+\+C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE} -\/}} Sets the default L2 cache size that is used in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s G\+E\+BP kernel when the correct cache size cannot be determined at runtime.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+L3\+\_\+\+C\+A\+C\+H\+E\+\_\+\+S\+I\+ZE} -\/}} Sets the default L3 cache size that is used in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s G\+E\+BP kernel when the correct cache size cannot be determined at runtime.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN} -\/}} Deprecated, it is a synonym for {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=0}. It disables alignment completely. Eigen will not try to align its objects and does not expect that any objects passed to it are aligned. This will turn off vectorization if {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+N\+A\+L\+I\+G\+N\+E\+D\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE=1}.}} Not defined by default.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+G\+N\+\_\+\+S\+T\+A\+T\+I\+C\+A\+L\+LY} -\/}} Deprecated, it is a synonym for {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=0}. It disables alignment of arrays on the stack. Not defined by default, unless {\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN} is defined.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+A\+L\+T\+I\+V\+E\+C\+\_\+\+E\+N\+A\+B\+L\+E\+\_\+\+M\+M\+A\+\_\+\+D\+Y\+N\+A\+M\+I\+C\+\_\+\+D\+I\+S\+P\+A\+T\+CH} -\/}} Controls whether to use \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s dynamic dispatching for Altivec M\+MA or not.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+A\+L\+T\+I\+V\+E\+C\+\_\+\+D\+I\+S\+A\+B\+L\+E\+\_\+\+M\+MA} -\/}} Overrides the usage of Altivec M\+MA instructions.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+A\+L\+T\+I\+V\+E\+C\+\_\+\+U\+S\+E\+\_\+\+C\+U\+S\+T\+O\+M\+\_\+\+P\+A\+CK} -\/}} Controls whether to use \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s custom packing for Altivec or not.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesPlugins}{}\doxysubsection{Plugins}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesPlugins}
It is possible to add new methods to many fundamental classes in Eigen by writing a plugin. As explained in the section \mbox{\hyperlink{TopicCustomizing_Plugins}{Extending Matrix\+Base (and other classes)}}, the plugin is specified by defining a {\ttfamily E\+I\+G\+E\+N\+\_\+xxx\+\_\+\+P\+L\+U\+G\+IN} macro. The following macros are supported; none of them are defined by default.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+A\+R\+R\+A\+Y\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_array}{Array}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+A\+R\+R\+A\+Y\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+C\+W\+I\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the Cwise class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+N\+S\+E\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+Y\+N\+A\+M\+I\+C\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the Dynamic\+Sparse\+Matrix class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+F\+U\+N\+C\+T\+O\+R\+S\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for adding new functors and specializations of functor\+\_\+traits.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+P\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_map_base}{Map\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+T\+R\+I\+X\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+P\+L\+A\+I\+N\+O\+B\+J\+E\+C\+T\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{Plain\+Object\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+Q\+U\+A\+T\+E\+R\+N\+I\+O\+N\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_quaternion}{Quaternion}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+Q\+U\+A\+T\+E\+R\+N\+I\+O\+N\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_quaternion_base}{Quaternion\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_base}{Sparse\+Matrix\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+V\+E\+C\+T\+O\+R\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_sparse_vector}{Sparse\+Vector}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+T\+R\+A\+N\+S\+F\+O\+R\+M\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_transform}{Transform}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+V\+E\+C\+T\+O\+R\+W\+I\+S\+E\+O\+P\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_vectorwise_op}{Vectorwise\+Op}} class.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesDevelopers}{}\doxysubsection{Macros for Eigen developers}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesDevelopers}
These macros are mainly meant for people developing Eigen and for testing purposes. Even though, they might be useful for power users and the curious for debugging and testing purpose, they {\bfseries{should}} {\bfseries{not}} {\bfseries{be}} {\bfseries{used}} by real-\/word code.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+O\+\_\+\+R\+O\+W\+\_\+\+M\+A\+J\+OR}} -\/ when defined, the default storage order for matrices becomes row-\/major instead of column-\/major. Not defined by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+D\+E\+B\+U\+G\+G\+I\+NG}} -\/ if defined, enables assertions in Eigen\textquotesingle{}s internal routines. This is useful for debugging Eigen itself. Not defined by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+M\+A\+L\+L\+OC}} -\/ if defined, any request from inside the Eigen to allocate memory from the heap results in an assertion failure. This is useful to check that some routine does not allocate memory dynamically. Not defined by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+R\+U\+N\+T\+I\+M\+E\+\_\+\+N\+O\+\_\+\+M\+A\+L\+L\+OC}} -\/ if defined, a new switch is introduced which can be turned on and off by calling {\ttfamily set\+\_\+is\+\_\+malloc\+\_\+allowed(bool)}. If malloc is not allowed and Eigen tries to allocate memory dynamically anyway, an assertion failure results. Not defined by default. 
\end{DoxyItemize}\hypertarget{TopicAssertions}{}\doxysection{Assertions}\label{TopicAssertions}
\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_assertions_PlainAssert}{}\doxysubsection{Assertions}\label{_topic_assertions_PlainAssert}
The macro eigen\+\_\+assert is defined to be {\ttfamily eigen\+\_\+plain\+\_\+assert} by default. We use eigen\+\_\+plain\+\_\+assert instead of {\ttfamily assert} to work around a known bug for G\+CC $<$= 4.\+3. Basically, eigen\+\_\+plain\+\_\+assert {\itshape is} {\ttfamily assert}.\hypertarget{_topic_assertions_RedefineAssert}{}\doxysubsubsection{Redefining assertions}\label{_topic_assertions_RedefineAssert}
Both eigen\+\_\+assert and eigen\+\_\+plain\+\_\+assert are defined in Macros.\+h. Defining eigen\+\_\+assert indirectly gives you a chance to change its behavior. You can redefine this macro if you want to do something else such as throwing an exception, and fall back to its default behavior with eigen\+\_\+plain\+\_\+assert. The code below tells \mbox{\hyperlink{namespace_eigen}{Eigen}} to throw an std\+::runtime\+\_\+error\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#undef eigen\_assert}}
\DoxyCodeLine{\textcolor{preprocessor}{\#define eigen\_assert(x) \(\backslash\)}}
\DoxyCodeLine{\textcolor{preprocessor}{  if (!(x)) \{ throw (std::runtime\_error("Put your message here")); \}}}
\end{DoxyCode}
\hypertarget{_topic_assertions_DisableAssert}{}\doxysubsubsection{Disabling assertions}\label{_topic_assertions_DisableAssert}
Assertions cost run time and can be turned off. You can suppress eigen\+\_\+assert by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+D\+E\+B\+UG} {\bfseries{before}} including \mbox{\hyperlink{namespace_eigen}{Eigen}} headers. {\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+D\+E\+B\+UG} is undefined by default unless {\ttfamily N\+D\+E\+B\+UG} is defined.\hypertarget{_topic_assertions_StaticAssert}{}\doxysubsection{Static assertions}\label{_topic_assertions_StaticAssert}
Static assertions are not standardized until C++11. However, in the \mbox{\hyperlink{namespace_eigen}{Eigen}} library, there are many conditions can and should be detectedat compile time. For instance, we use static assertions to prevent the code below from compiling.


\begin{DoxyCode}{0}
\DoxyCodeLine{Matrix3d()  + Matrix4d();   \textcolor{comment}{// adding matrices of different sizes}}
\DoxyCodeLine{Matrix4cd() * Vector3cd();  \textcolor{comment}{// invalid product known at compile time}}
\end{DoxyCode}


Static assertions are defined in Static\+Assert.\+h. If there is native static\+\_\+assert, we use it. Otherwise, we have implemented an assertion macro that can show a limited range of messages.

One can easily come up with static assertions without messages, such as\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define STATIC\_ASSERT(x) \(\backslash\)}}
\DoxyCodeLine{\textcolor{preprocessor}{  switch(0) \{ case 0: case x:; \}}}
\end{DoxyCode}


However, the example above obviously cannot tell why the assertion failed. Therefore, we define a {\ttfamily struct} in namespace Eigen\+::internal to handle available messages.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keywordtype}{bool} condition>}
\DoxyCodeLine{\textcolor{keyword}{struct }static\_assertion \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<>}
\DoxyCodeLine{\textcolor{keyword}{struct }static\_assertion<true>}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{enum} \{}
\DoxyCodeLine{    YOU\_TRIED\_CALLING\_A\_VECTOR\_METHOD\_ON\_A\_MATRIX,}
\DoxyCodeLine{    YOU\_MIXED\_VECTORS\_OF\_DIFFERENT\_SIZES,}
\DoxyCodeLine{    \textcolor{comment}{// see StaticAssert.h for all enums.}}
\DoxyCodeLine{  \};}
\DoxyCodeLine{\};}
\end{DoxyCode}


And then, we define E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T(\+C\+O\+N\+D\+I\+T\+I\+O\+N,\+M\+S\+G) to access Eigen\+::internal\+::static\+\_\+assertion$<$bool(\+C\+O\+N\+D\+I\+T\+I\+O\+N)$>$\+::\+M\+SG. If the condition evaluates into {\ttfamily false}, your compiler displays a lot of messages explaining there is no \mbox{\hyperlink{struct_m_s_g}{M\+SG}} in static\+\_\+assert$<$false$>$. Nevertheless, this is {\itshape not} in what we are interested. As you can see, all members of static\+\_\+assert$<$true$>$ are A\+L\+L\+\_\+\+C\+A\+P\+S\+\_\+\+A\+N\+D\+\_\+\+T\+H\+E\+Y\+\_\+\+A\+R\+E\+\_\+\+S\+H\+O\+U\+T\+I\+NG.

\begin{DoxyWarning}{Warning}
When using this macro, \mbox{\hyperlink{struct_m_s_g}{M\+SG}} should be a member of static\+\_\+assertion$<$true$>$, or the static assertion {\bfseries{always}} fails. Currently, it can only be used in function scope.
\end{DoxyWarning}
\hypertarget{_topic_assertions_DerivedStaticAssert}{}\doxysubsubsection{Derived static assertions}\label{_topic_assertions_DerivedStaticAssert}
There are other macros derived from E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+RT to enhance readability. Their names are self-\/explanatory.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+F\+I\+X\+E\+D\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E)}} -\/ passes if {\itshape T\+Y\+PE} is fixed size.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+D\+Y\+N\+A\+M\+I\+C\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E)}} -\/ passes if {\itshape T\+Y\+PE} is dynamic size.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+L\+V\+A\+L\+U\+E(\+Derived)}} -\/ failes if {\itshape Derived} is read-\/only.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+A\+R\+R\+A\+Y\+X\+P\+R(\+Derived)}} -\/ passes if {\itshape Derived} is an array expression.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+S\+A\+M\+E\+\_\+\+X\+P\+R\+\_\+\+K\+I\+N\+D(\+Derived1, Derived2)}} -\/ failes if the two expressions are an array one and a matrix one.
\end{DoxyItemize}

Because \mbox{\hyperlink{namespace_eigen}{Eigen}} handles both fixed-\/size and dynamic-\/size expressions, some conditions cannot be clearly determined at compile time. We classify them into strict assertions and permissive assertions.\hypertarget{_topic_assertions_StrictAssertions}{}\doxyparagraph{Strict assertions}\label{_topic_assertions_StrictAssertions}
These assertions fail if the condition {\bfseries{may not}} be met. For example, Matrix\+Xd may not be a vector, so it fails E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+O\+N\+LY.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+O\+N\+L\+Y(\+T\+Y\+P\+E)}} -\/ passes if {\itshape T\+Y\+PE} must be a vector type.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+S\+P\+E\+C\+I\+F\+I\+C\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E, S\+I\+Z\+E)}} -\/ passes if {\itshape T\+Y\+PE} must be a vector of the given size.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+M\+A\+T\+R\+I\+X\+\_\+\+S\+P\+E\+C\+I\+F\+I\+C\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E, R\+O\+W\+S, C\+O\+L\+S)}} -\/ passes if {\itshape T\+Y\+PE} must be a matrix with given rows and columns.
\end{DoxyItemize}\hypertarget{_topic_assertions_PermissiveAssertions}{}\doxyparagraph{Permissive assertions}\label{_topic_assertions_PermissiveAssertions}
These assertions fail if the condition {\bfseries{cannot}} be met. For example, Matrix\+Xd and Matrix4d may have the same size, so they pass E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+S\+A\+M\+E\+\_\+\+M\+A\+T\+R\+I\+X\+\_\+\+S\+I\+ZE.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+S\+A\+M\+E\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E0,\+T\+Y\+P\+E1)}} -\/ fails if the two vector expression types must have different sizes.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+S\+A\+M\+E\+\_\+\+M\+A\+T\+R\+I\+X\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E0,\+T\+Y\+P\+E1)}} -\/ fails if the two matrix expression types must have different sizes.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+S\+I\+Z\+E\+\_\+1x1(\+T\+Y\+P\+E)}} -\/ fails if {\itshape T\+Y\+PE} cannot be an 1x1 expression.
\end{DoxyItemize}

See Static\+Assert.\+h for details such as what messages they throw.\hypertarget{_topic_assertions_DisableStaticAssert}{}\doxysubsubsection{Disabling static assertions}\label{_topic_assertions_DisableStaticAssert}
If {\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+RT} is defined, static assertions turn into {\ttfamily eigen\+\_\+assert}\textquotesingle{}s, working like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define EIGEN\_STATIC\_ASSERT(CONDITION,MSG) eigen\_assert((CONDITION) \&\& \#MSG);}}
\end{DoxyCode}


This saves compile time but consumes more run time. {\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+RT} is undefined by default. \hypertarget{TopicMultiThreading}{}\doxysection{Eigen and multi-\/threading}\label{TopicMultiThreading}
\hypertarget{_topic_multi_threading_TopicMultiThreading_MakingEigenMT}{}\doxysubsection{Make Eigen run in parallel}\label{_topic_multi_threading_TopicMultiThreading_MakingEigenMT}
Some Eigen\textquotesingle{}s algorithms can exploit the multiple cores present in your hardware. To this end, it is enough to enable Open\+MP on your compiler, for instance\+:
\begin{DoxyItemize}
\item G\+CC\+: {\ttfamily -\/fopenmp} 
\item I\+CC\+: {\ttfamily -\/openmp} 
\item M\+S\+VC\+: check the respective option in the build properties.
\end{DoxyItemize}

You can control the number of threads that will be used using either the Open\+MP A\+PI or Eigen\textquotesingle{}s A\+PI using the following priority\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{OMP\_NUM\_THREADS=n ./my\_program}
\DoxyCodeLine{omp\_set\_num\_threads(n);}
\DoxyCodeLine{\mbox{\hyperlink{namespace_eigen_af9cd17c2fe18204239cd11c88c120b50}{Eigen::setNbThreads}}(n);}
\end{DoxyCode}
 Unless {\ttfamily set\+Nb\+Threads} has been called, Eigen uses the number of threads specified by Open\+MP. You can restore this behavior by calling {\ttfamily set\+Nb\+Threads(0);}. You can query the number of threads that will be used with\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{n = \mbox{\hyperlink{namespace_eigen_a9aca97d83e21b91a04ec079360dfffeb}{Eigen::nbThreads}}( );}
\end{DoxyCode}
 You can disable Eigen\textquotesingle{}s multi threading at compile time by defining the \mbox{\hyperlink{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}{E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L\+I\+ZE }} preprocessor token.

Currently, the following algorithms can make use of multi-\/threading\+:
\begin{DoxyItemize}
\item general dense matrix -\/ matrix products
\item \mbox{\hyperlink{class_eigen_1_1_partial_piv_l_u}{Partial\+Piv\+LU}}
\item row-\/major-\/sparse $\ast$ dense vector/matrix products
\item \mbox{\hyperlink{class_eigen_1_1_conjugate_gradient}{Conjugate\+Gradient}} with {\ttfamily Lower$\vert$\+Upper} as the {\ttfamily Up\+Lo} template parameter.
\item \mbox{\hyperlink{class_eigen_1_1_bi_c_g_s_t_a_b}{Bi\+C\+G\+S\+T\+AB}} with a row-\/major sparse matrix format.
\item \mbox{\hyperlink{class_eigen_1_1_least_squares_conjugate_gradient}{Least\+Squares\+Conjugate\+Gradient}}
\end{DoxyItemize}

\begin{DoxyWarning}{Warning}
On most OS it is {\bfseries{very important}} to limit the number of threads to the number of physical cores, otherwise significant slowdowns are expected, especially for operations involving dense matrices.
\end{DoxyWarning}
Indeed, the principle of hyper-\/threading is to run multiple threads (in most cases 2) on a single core in an interleaved manner. However, Eigen\textquotesingle{}s matrix-\/matrix product kernel is fully optimized and already exploits nearly 100\% of the C\+PU capacity. Consequently, there is no room for running multiple such threads on a single core, and the performance would drops significantly because of cache pollution and other sources of overheads. At this stage of reading you\textquotesingle{}re probably wondering why Eigen does not limit itself to the number of physical cores? This is simply because Open\+MP does not allow to know the number of physical cores, and thus Eigen will launch as many threads as {\itshape cores} reported by Open\+MP.\hypertarget{_topic_multi_threading_TopicMultiThreading_UsingEigenWithMT}{}\doxysubsection{Using Eigen in a multi-\/threaded application}\label{_topic_multi_threading_TopicMultiThreading_UsingEigenWithMT}
In the case your own application is multithreaded, and multiple threads make calls to Eigen, then you have to initialize Eigen by calling the following routine {\bfseries{before}} creating the threads\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <Eigen/Core>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \mbox{\hyperlink{namespace_eigen_a820c0e0460934cc17eb6dacbad54a9f5}{Eigen::initParallel}}();}
\DoxyCodeLine{  }
\DoxyCodeLine{  ...}
\DoxyCodeLine{\}}
\end{DoxyCode}


\begin{DoxyNote}{Note}
With Eigen 3.\+3, and a fully C++11 compliant compiler (i.\+e., \href{http://en.cppreference.com/w/cpp/language/storage_duration\#Static_local_variables}{\texttt{ thread-\/safe static local variable initialization}}), then calling {\ttfamily \mbox{\hyperlink{namespace_eigen_a820c0e0460934cc17eb6dacbad54a9f5}{init\+Parallel()}}} is optional.
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
Note that all functions generating random matrices are {\bfseries{not}} re-\/entrant nor thread-\/safe. Those include \mbox{\hyperlink{class_eigen_1_1_dense_base_ae814abb451b48ed872819192dc188c19}{Dense\+Base\+::\+Random()}}, and \mbox{\hyperlink{class_eigen_1_1_dense_base_a39046dff78acbcb389ad0b018e587c8e}{Dense\+Base\+::set\+Random()}} despite a call to {\ttfamily \mbox{\hyperlink{namespace_eigen_a820c0e0460934cc17eb6dacbad54a9f5}{Eigen\+::init\+Parallel()}}}. This is because these functions are based on {\ttfamily std\+::rand} which is not re-\/entrant. For thread-\/safe random generator, we recommend the use of c++11 random generators (\mbox{\hyperlink{}{example }}) or {\ttfamily boost\+::random}.
\end{DoxyWarning}
In the case your application is parallelized with Open\+MP, you might want to disable Eigen\textquotesingle{}s own parallelization as detailed in the previous section.

\begin{DoxyWarning}{Warning}
Using Open\+MP with custom scalar types that might throw exceptions can lead to unexpected behaviour in the event of throwing. 
\end{DoxyWarning}
\hypertarget{TopicUsingBlasLapack}{}\doxysection{Using B\+L\+A\+S/\+L\+A\+P\+A\+CK from Eigen}\label{TopicUsingBlasLapack}
Since Eigen version 3.\+3 and later, any F77 compatible B\+L\+AS or L\+A\+P\+A\+CK libraries can be used as backends for dense matrix products and dense matrix decompositions. For instance, one can use \href{http://eigen.tuxfamily.org/Counter/redirect_to_mkl.php}{\texttt{ IntelÂ® M\+KL}}, Apple\textquotesingle{}s Accelerate framework on O\+SX, \href{http://www.openblas.net/}{\texttt{ Open\+B\+L\+AS}}, \href{http://www.netlib.org/lapack}{\texttt{ Netlib L\+A\+P\+A\+CK}}, etc.

Do not miss this \mbox{\hyperlink{_topic_using_intel_m_k_l}{page }} for further discussions on the specific use of IntelÂ® M\+KL (also includes V\+ML, P\+A\+R\+D\+I\+SO, etc.)

In order to use an external B\+L\+AS and/or L\+A\+P\+A\+CK library, you must link you own application to the respective libraries and their dependencies. For L\+A\+P\+A\+CK, you must also link to the standard \href{http://www.netlib.org/lapack/lapacke.html}{\texttt{ Lapacke}} library, which is used as a convenient think layer between Eigen\textquotesingle{}s C++ code and L\+A\+P\+A\+CK F77 interface. Then you must activate their usage by defining one or multiple of the following macros ({\bfseries{before}} including any Eigen\textquotesingle{}s header)\+:

\begin{DoxyNote}{Note}
For Mac users, in order to use the lapack version shipped with the Accelerate framework, you also need the lapacke library. Using \href{https://www.macports.org/}{\texttt{ Mac\+Ports}}, this is as easy as\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{sudo port install lapack}
\end{DoxyCode}
 and then use the following link flags\+: {\ttfamily -\/framework} {\ttfamily Accelerate} {\ttfamily /opt/local/lib/lapack/liblapacke}.dylib
\end{DoxyNote}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &Enables the use of external B\+L\+AS level 2 and 3 routines (compatible with any F77 B\+L\+AS interface) \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} &Enables the use of external Lapack routines via the \href{http://www.netlib.org/lapack/lapacke.html}{\texttt{ Lapacke}} C interface to Lapack (compatible with any F77 L\+A\+P\+A\+CK interface) \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &Same as {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} but algorithms of lower numerical robustness are disabled. ~\newline
 This currently concerns only \mbox{\hyperlink{class_eigen_1_1_jacobi_s_v_d}{Jacobi\+S\+VD}} which otherwise would be replaced by {\ttfamily gesvd} that is less robust than Jacobi rotations. \\\cline{1-2}
\end{longtabu}


When doing so, a number of Eigen\textquotesingle{}s algorithms are silently substituted with calls to B\+L\+AS or L\+A\+P\+A\+CK routines. These substitutions apply only for {\bfseries{Dynamic}} {\bfseries{or}} {\bfseries{large}} enough objects with one of the following four standard scalar types\+: {\ttfamily float}, {\ttfamily double}, {\ttfamily complex$<$float$>$}, and {\ttfamily complex$<$double$>$}. Operations on other scalar types or mixing reals and complexes will continue to use the built-\/in algorithms.

The breadth of Eigen functionality that can be substituted is listed in the table below. \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Functional domain}&\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ B\+L\+A\+S/\+L\+A\+P\+A\+CK routines }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Functional domain}&\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ B\+L\+A\+S/\+L\+A\+P\+A\+CK routines }\\\cline{1-3}
\endhead
Matrix-\/matrix operations ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1*m2.transpose();}
\DoxyCodeLine{m1.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}}>()*m2;}
\DoxyCodeLine{m1*m2.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}}>();}
\DoxyCodeLine{m1.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}}>().rankUpdate(m2,1.0);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gemm}
\DoxyCodeLine{?symm/?hemm}
\DoxyCodeLine{?trmm}
\DoxyCodeLine{dsyrk/ssyrk}
\end{DoxyCode}
 \\\cline{1-3}
Matrix-\/vector operations ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.adjoint()*b;}
\DoxyCodeLine{m1.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}}>()*b;}
\DoxyCodeLine{m1.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}}>()*b;}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gemv}
\DoxyCodeLine{?symv/?hemv}
\DoxyCodeLine{?trmv}
\end{DoxyCode}
 \\\cline{1-3}
LU decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{v1 = m1.lu().solve(v2);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?getrf}
\end{DoxyCode}
 \\\cline{1-3}
Cholesky decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{v1 = m2.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}}>().llt().solve(v2);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?potrf}
\end{DoxyCode}
 \\\cline{1-3}
QR decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.householderQr();}
\DoxyCodeLine{m1.colPivHouseholderQr();}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?geqrf}
\DoxyCodeLine{?geqp3}
\end{DoxyCode}
 \\\cline{1-3}
Singular value decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} &
\begin{DoxyCode}{0}
\DoxyCodeLine{JacobiSVD<MatrixXd, ComputeThinV> svd;}
\DoxyCodeLine{svd.compute(m1);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gesvd}
\end{DoxyCode}
 \\\cline{1-3}
Eigen-\/value decompositions ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{EigenSolver<MatrixXd> es(m1);}
\DoxyCodeLine{ComplexEigenSolver<MatrixXcd> ces(m1);}
\DoxyCodeLine{SelfAdjointEigenSolver<MatrixXd> saes(m1+m1.transpose());}
\DoxyCodeLine{GeneralizedSelfAdjointEigenSolver<MatrixXd>}
\DoxyCodeLine{    gsaes(m1+m1.transpose(),m2+m2.transpose());}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gees}
\DoxyCodeLine{?gees}
\DoxyCodeLine{?syev/?heev}
\DoxyCodeLine{?syev/?heev,}
\DoxyCodeLine{?potrf}
\end{DoxyCode}
 \\\cline{1-3}
Schur decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{RealSchur<MatrixXd> schurR(m1);}
\DoxyCodeLine{ComplexSchur<MatrixXcd> schurC(m1);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gees}
\end{DoxyCode}
 \\\cline{1-3}
\end{longtabu}
In the examples, m1 and m2 are dense matrices and v1 and v2 are dense vectors.

Since Eigen version 3.\+3 and later, any F77 compatible B\+L\+AS or L\+A\+P\+A\+CK libraries can be used as backends for dense matrix products and dense matrix decompositions. For instance, one can use \href{http://eigen.tuxfamily.org/Counter/redirect_to_mkl.php}{\texttt{ IntelÂ® M\+KL}}, Apple\textquotesingle{}s Accelerate framework on O\+SX, \href{http://www.openblas.net/}{\texttt{ Open\+B\+L\+AS}}, \href{http://www.netlib.org/lapack}{\texttt{ Netlib L\+A\+P\+A\+CK}}, etc.

Do not miss this \mbox{\hyperlink{_topic_using_intel_m_k_l}{page }} for further discussions on the specific use of IntelÂ® M\+KL (also includes V\+ML, P\+A\+R\+D\+I\+SO, etc.)

In order to use an external B\+L\+AS and/or L\+A\+P\+A\+CK library, you must link you own application to the respective libraries and their dependencies. For L\+A\+P\+A\+CK, you must also link to the standard \href{http://www.netlib.org/lapack/lapacke.html}{\texttt{ Lapacke}} library, which is used as a convenient think layer between Eigen\textquotesingle{}s C++ code and L\+A\+P\+A\+CK F77 interface. Then you must activate their usage by defining one or multiple of the following macros ({\bfseries{before}} including any Eigen\textquotesingle{}s header)\+:

\begin{DoxyNote}{Note}
For Mac users, in order to use the lapack version shipped with the Accelerate framework, you also need the lapacke library. Using \href{https://www.macports.org/}{\texttt{ Mac\+Ports}}, this is as easy as\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{sudo port install lapack}
\end{DoxyCode}
 and then use the following link flags\+: {\ttfamily -\/framework} {\ttfamily Accelerate} {\ttfamily /opt/local/lib/lapack/liblapacke}.dylib
\end{DoxyNote}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &Enables the use of external B\+L\+AS level 2 and 3 routines (compatible with any F77 B\+L\+AS interface) \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} &Enables the use of external Lapack routines via the \href{http://www.netlib.org/lapack/lapacke.html}{\texttt{ Lapacke}} C interface to Lapack (compatible with any F77 L\+A\+P\+A\+CK interface) \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &Same as {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} but algorithms of lower numerical robustness are disabled. ~\newline
 This currently concerns only \mbox{\hyperlink{class_eigen_1_1_jacobi_s_v_d}{Jacobi\+S\+VD}} which otherwise would be replaced by {\ttfamily gesvd} that is less robust than Jacobi rotations. \\\cline{1-2}
\end{longtabu}


When doing so, a number of Eigen\textquotesingle{}s algorithms are silently substituted with calls to B\+L\+AS or L\+A\+P\+A\+CK routines. These substitutions apply only for {\bfseries{Dynamic}} {\bfseries{or}} {\bfseries{large}} enough objects with one of the following four standard scalar types\+: {\ttfamily float}, {\ttfamily double}, {\ttfamily complex$<$float$>$}, and {\ttfamily complex$<$double$>$}. Operations on other scalar types or mixing reals and complexes will continue to use the built-\/in algorithms.

The breadth of Eigen functionality that can be substituted is listed in the table below. \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Functional domain}&\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ B\+L\+A\+S/\+L\+A\+P\+A\+CK routines }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Functional domain}&\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ B\+L\+A\+S/\+L\+A\+P\+A\+CK routines }\\\cline{1-3}
\endhead
Matrix-\/matrix operations ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1*m2.transpose();}
\DoxyCodeLine{m1.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}}>()*m2;}
\DoxyCodeLine{m1*m2.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}}>();}
\DoxyCodeLine{m1.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}}>().rankUpdate(m2,1.0);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gemm}
\DoxyCodeLine{?symm/?hemm}
\DoxyCodeLine{?trmm}
\DoxyCodeLine{dsyrk/ssyrk}
\end{DoxyCode}
 \\\cline{1-3}
Matrix-\/vector operations ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.adjoint()*b;}
\DoxyCodeLine{m1.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda891792b8ed394f7607ab16dd716f60e6}{Lower}}>()*b;}
\DoxyCodeLine{m1.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}}>()*b;}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gemv}
\DoxyCodeLine{?symv/?hemv}
\DoxyCodeLine{?trmv}
\end{DoxyCode}
 \\\cline{1-3}
LU decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{v1 = m1.lu().solve(v2);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?getrf}
\end{DoxyCode}
 \\\cline{1-3}
Cholesky decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{v1 = m2.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda6bcb58be3b8b8ec84859ce0c5ac0aaec}{Upper}}>().llt().solve(v2);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?potrf}
\end{DoxyCode}
 \\\cline{1-3}
QR decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.householderQr();}
\DoxyCodeLine{m1.colPivHouseholderQr();}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?geqrf}
\DoxyCodeLine{?geqp3}
\end{DoxyCode}
 \\\cline{1-3}
Singular value decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} &
\begin{DoxyCode}{0}
\DoxyCodeLine{JacobiSVD<MatrixXd, ComputeThinV> svd;}
\DoxyCodeLine{svd.compute(m1);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gesvd}
\end{DoxyCode}
 \\\cline{1-3}
Singular value decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{BDCSVD<MatrixXd> svd;}
\DoxyCodeLine{svd.compute(m1);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gesdd}
\end{DoxyCode}
 \\\cline{1-3}
Eigen-\/value decompositions ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{EigenSolver<MatrixXd> es(m1);}
\DoxyCodeLine{ComplexEigenSolver<MatrixXcd> ces(m1);}
\DoxyCodeLine{SelfAdjointEigenSolver<MatrixXd> saes(m1+m1.transpose());}
\DoxyCodeLine{GeneralizedSelfAdjointEigenSolver<MatrixXd>}
\DoxyCodeLine{    gsaes(m1+m1.transpose(),m2+m2.transpose());}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gees}
\DoxyCodeLine{?gees}
\DoxyCodeLine{?syev/?heev}
\DoxyCodeLine{?syev/?heev,}
\DoxyCodeLine{?potrf}
\end{DoxyCode}
 \\\cline{1-3}
Schur decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{RealSchur<MatrixXd> schurR(m1);}
\DoxyCodeLine{ComplexSchur<MatrixXcd> schurC(m1);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gees}
\end{DoxyCode}
 \\\cline{1-3}
\end{longtabu}
In the examples, m1 and m2 are dense matrices and v1 and v2 are dense vectors. \hypertarget{TopicUsingIntelMKL}{}\doxysection{Using IntelÂ® M\+KL from Eigen}\label{TopicUsingIntelMKL}
Since Eigen version 3.\+1 and later, users can benefit from built-\/in IntelÂ® Math Kernel Library (M\+KL) optimizations with an installed copy of Intel M\+KL 10.\+3 (or later).

\href{http://eigen.tuxfamily.org/Counter/redirect_to_mkl.php}{\texttt{ Intel M\+KL }} provides highly optimized multi-\/threaded mathematical routines for~x86-\/compatible architectures. Intel M\+KL is available on Linux, Mac and Windows for both Intel64 and I\+A32 architectures.

\begin{DoxyNote}{Note}
IntelÂ® M\+KL is a proprietary software and it is the responsibility of users to buy or register for community (free) Intel M\+KL licenses for their products. Moreover, the license of the user product has to allow linking to proprietary software that excludes any unmodified versions of the G\+PL.
\end{DoxyNote}
Using Intel M\+KL through Eigen is easy\+:
\begin{DoxyEnumerate}
\item define the {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+\+A\+LL} macro before including any Eigen\textquotesingle{}s header
\item link your program to M\+KL libraries (see the \href{http://software.intel.com/en-us/articles/intel-mkl-link-line-advisor/}{\texttt{ M\+KL linking advisor}})
\item on a 64bits system, you must use the L\+P64 interface (not the I\+L\+P64 one)
\end{DoxyEnumerate}

When doing so, a number of Eigen\textquotesingle{}s algorithms are silently substituted with calls to Intel M\+KL routines. These substitutions apply only for {\bfseries{Dynamic}} {\bfseries{or}} {\bfseries{large}} enough objects with one of the following four standard scalar types\+: {\ttfamily float}, {\ttfamily double}, {\ttfamily complex$<$float$>$}, and {\ttfamily complex$<$double$>$}. Operations on other scalar types or mixing reals and complexes will continue to use the built-\/in algorithms.

In addition you can choose which parts will be substituted by defining one or multiple of the following macros\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &Enables the use of external B\+L\+AS level 2 and 3 routines \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} &Enables the use of external Lapack routines via the \href{http://www.netlib.org/lapack/lapacke.html}{\texttt{ Lapacke}} C interface to Lapack \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &Same as {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} but algorithm of lower robustness are disabled. ~\newline
 This currently concerns only \mbox{\hyperlink{class_eigen_1_1_jacobi_s_v_d}{Jacobi\+S\+VD}} which otherwise would be replaced by {\ttfamily gesvd} that is less robust than Jacobi rotations. \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+\+V\+ML} &Enables the use of Intel V\+ML (vector operations) \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+\+A\+LL} &Defines {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS}, {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE}, and {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+\+V\+ML}  \\\cline{1-2}
\end{longtabu}


The {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} and {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E$\ast$} macros can be combined with {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+KL} to explicitly tell \mbox{\hyperlink{namespace_eigen}{Eigen}} that the underlying B\+L\+A\+S/\+Lapack implementation is Intel M\+KL. The main effect is to enable M\+KL direct call feature ({\ttfamily M\+K\+L\+\_\+\+D\+I\+R\+E\+C\+T\+\_\+\+C\+A\+LL}). This may help to increase performance of some M\+KL B\+L\+AS (?G\+E\+MM, ?G\+E\+MV, ?T\+R\+SM, ?A\+X\+PY and ?D\+OT) and L\+A\+P\+A\+CK (LU, Cholesky and QR) routines for very small matrices. M\+KL direct call can be disabled by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+K\+L\+\_\+\+N\+O\+\_\+\+D\+I\+R\+E\+C\+T\+\_\+\+C\+A\+LL}.

Note that the B\+L\+AS and L\+A\+P\+A\+C\+KE backends can be enabled for any F77 compatible B\+L\+AS and L\+A\+P\+A\+CK libraries. See this \mbox{\hyperlink{_topic_using_blas_lapack}{page }} for the details.

Finally, the P\+A\+R\+D\+I\+SO sparse solver shipped with Intel M\+KL can be used through the \mbox{\hyperlink{class_eigen_1_1_pardiso_l_u}{Pardiso\+LU}}, \mbox{\hyperlink{class_eigen_1_1_pardiso_l_l_t}{Pardiso\+L\+LT}} and \mbox{\hyperlink{class_eigen_1_1_pardiso_l_d_l_t}{Pardiso\+L\+D\+LT}} classes of the Pardiso\+Support\+\_\+\+Module.

The following table summarizes the list of functions covered by {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+\+V\+ML\+:} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ M\+KL routines }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ M\+KL routines }\\\cline{1-2}
\endhead

\begin{DoxyCode}{0}
\DoxyCodeLine{v2=v1.array().sin();}
\DoxyCodeLine{v2=v1.array().asin();}
\DoxyCodeLine{v2=v1.array().cos();}
\DoxyCodeLine{v2=v1.array().acos();}
\DoxyCodeLine{v2=v1.array().tan();}
\DoxyCodeLine{v2=v1.array().exp();}
\DoxyCodeLine{v2=v1.array().log();}
\DoxyCodeLine{v2=v1.array().sqrt();}
\DoxyCodeLine{v2=v1.array().square();}
\DoxyCodeLine{v2=v1.array().pow(1.5);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{v?Sin}
\DoxyCodeLine{v?Asin}
\DoxyCodeLine{v?Cos}
\DoxyCodeLine{v?Acos}
\DoxyCodeLine{v?Tan}
\DoxyCodeLine{v?Exp}
\DoxyCodeLine{v?Ln}
\DoxyCodeLine{v?Sqrt}
\DoxyCodeLine{v?Sqr}
\DoxyCodeLine{v?Powx}
\end{DoxyCode}
 \\\cline{1-2}
\end{longtabu}
In the examples, v1 and v2 are dense vectors.\hypertarget{_topic_using_intel_m_k_l_TopicUsingIntelMKL_Links}{}\doxysubsection{Links}\label{_topic_using_intel_m_k_l_TopicUsingIntelMKL_Links}

\begin{DoxyItemize}
\item Intel M\+KL can be purchased and downloaded \href{http://eigen.tuxfamily.org/Counter/redirect_to_mkl.php}{\texttt{ here}}.
\item Intel M\+KL is also bundled with \href{http://software.intel.com/en-us/articles/intel-composer-xe/}{\texttt{ Intel Composer XE}}. 
\end{DoxyItemize}\hypertarget{TopicCUDA}{}\doxysection{Using Eigen in C\+U\+DA kernels}\label{TopicCUDA}
Staring from C\+U\+DA 5.\+5 and \mbox{\hyperlink{namespace_eigen}{Eigen}} 3.\+3, it is possible to use \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s matrices, vectors, and arrays for fixed size within C\+U\+DA kernels. This is especially useful when working on numerous but small problems. By default, when \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s headers are included within a .cu file compiled by nvcc most \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s functions and methods are prefixed by the {\ttfamily {\bfseries{device}}} {\ttfamily {\bfseries{host}}} keywords making them callable from both host and device code. This support can be disabled by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+C\+U\+DA} before including any \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s header. This might be useful to disable some warnings when a .cu file makes use of \mbox{\hyperlink{namespace_eigen}{Eigen}} on the host side only. However, in both cases, host\textquotesingle{}s S\+I\+MD vectorization has to be disabled in .cu files. It is thus {\bfseries{strongly}} {\bfseries{recommended}} to properly move all costly host computation from your .cu files to regular .cpp files.

Known issues\+:


\begin{DoxyItemize}
\item {\ttfamily nvcc} with MS Visual Studio does not work (patch welcome)
\item {\ttfamily nvcc} 5.\+5 with gcc-\/4.\+7 (or greater) has issues with the standard {\ttfamily $<$limits$>$} header file. To workaround this, you can add the following before including any other files\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// workaround issue between gcc >= 4.7 and cuda 5.5}}
\DoxyCodeLine{\textcolor{preprocessor}{\#if (defined \_\_GNUC\_\_) \&\& (\_\_GNUC\_\_>4 || \_\_GNUC\_MINOR\_\_>=7)}}
\DoxyCodeLine{\textcolor{preprocessor}{  \#undef \_GLIBCXX\_ATOMIC\_BUILTINS}}
\DoxyCodeLine{\textcolor{preprocessor}{  \#undef \_GLIBCXX\_USE\_INT128}}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\end{DoxyCode}

\item On 64bits system \mbox{\hyperlink{namespace_eigen}{Eigen}} uses {\ttfamily long} {\ttfamily int} as the default type for indexes and sizes. On C\+U\+DA device, it would make sense to default to 32 bits {\ttfamily int}. However, to keep host and C\+U\+DA code compatible, this cannot be done automatically by Eigen, and the user is thus required to define {\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+D\+E\+N\+S\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE} to {\ttfamily int} throughout his code (or only for C\+U\+DA code if there is no interaction between host and C\+U\+DA code through Eigen\textquotesingle{}s object). 
\end{DoxyItemize}\hypertarget{TopicPitfalls}{}\doxysection{Common pitfalls}\label{TopicPitfalls}
\hypertarget{_topic_pitfalls_TopicPitfalls_template_keyword}{}\doxysubsection{Compilation error with template methods}\label{_topic_pitfalls_TopicPitfalls_template_keyword}
See this \mbox{\hyperlink{_topic_template_keyword}{page }}.\hypertarget{_topic_pitfalls_TopicPitfalls_aliasing}{}\doxysubsection{Aliasing}\label{_topic_pitfalls_TopicPitfalls_aliasing}
Don\textquotesingle{}t miss this \mbox{\hyperlink{group___topic_aliasing}{page }} on aliasing, especially if you got wrong results in statements where the destination appears on the right hand side of the expression.\hypertarget{_topic_pitfalls_TopicPitfalls_alignment_issue}{}\doxysubsection{Alignment Issues (runtime assertion)}\label{_topic_pitfalls_TopicPitfalls_alignment_issue}
Eigen does explicit vectorization, and while that is appreciated by many users, that also leads to some issues in special situations where data alignment is compromised. Indeed, prior to C++17, C++ does not have quite good enough support for explicit data alignment. In that case your program hits an assertion failure (that is, a \char`\"{}controlled crash\char`\"{}) with a message that tells you to consult this page\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{http:\textcolor{comment}{//eigen.tuxfamily.org/dox/group\_\_TopicUnalignedArrayAssert.html}}
\end{DoxyCode}
 Have a look at \mbox{\hyperlink{group___topic_unaligned_array_assert}{it }} and see for yourself if that\textquotesingle{}s something that you can cope with. It contains detailed information about how to deal with each known cause for that issue.

Now what if you don\textquotesingle{}t care about vectorization and so don\textquotesingle{}t want to be annoyed with these alignment issues? Then read \mbox{\hyperlink{getrid}{how to get rid of them }}.\hypertarget{_topic_pitfalls_TopicPitfalls_auto_keyword}{}\doxysubsection{C++11 and the auto keyword}\label{_topic_pitfalls_TopicPitfalls_auto_keyword}
In short\+: do not use the auto keywords with Eigen\textquotesingle{}s expressions, unless you are 100\% sure about what you are doing. In particular, do not use the auto keyword as a replacement for a {\ttfamily Matrix$<$$>$} type. Here is an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXd A, \mbox{\hyperlink{class_eigen_1_1_matrix}{B}};}
\DoxyCodeLine{\textcolor{keyword}{auto} C = A*\mbox{\hyperlink{class_eigen_1_1_matrix}{B}};}
\DoxyCodeLine{\textcolor{keywordflow}{for}(...) \{ ... w = C * v;  ...\}}
\end{DoxyCode}


In this example, the type of C is not a {\ttfamily Matrix\+Xd} but an abstract expression representing a matrix product and storing references to {\ttfamily A} and {\ttfamily B}. Therefore, the product of {\ttfamily A$\ast$B} will be carried out multiple times, once per iteration of the for loop. Moreover, if the coefficients of {\ttfamily A} or {\ttfamily B} change during the iteration, then {\ttfamily C} will evaluate to different values as in the following example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXd A = ..., \mbox{\hyperlink{class_eigen_1_1_matrix}{B}} = ...;}
\DoxyCodeLine{\textcolor{keyword}{auto} C = A*\mbox{\hyperlink{class_eigen_1_1_matrix}{B}};}
\DoxyCodeLine{MatrixXd R1 = C;}
\DoxyCodeLine{A = ...;}
\DoxyCodeLine{MatrixXd R2 = C;}
\end{DoxyCode}
 for which we end up with {\ttfamily R1} {$\ne$} {\ttfamily R2}.

Here is another example leading to a segfault\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} C = ((A+\mbox{\hyperlink{class_eigen_1_1_matrix}{B}}).eval()).transpose();}
\DoxyCodeLine{\textcolor{comment}{// do something with C}}
\end{DoxyCode}
 The problem is that {\ttfamily eval()} returns a temporary object (in this case a {\ttfamily Matrix\+Xd}) which is then referenced by the {\ttfamily Transpose$<$$>$} expression. However, this temporary is deleted right after the first line, and then the {\ttfamily C} expression references a dead object. One possible fix consists in applying {\ttfamily eval()} on the whole expression\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} C = (A+\mbox{\hyperlink{class_eigen_1_1_matrix}{B}}).transpose().eval();}
\end{DoxyCode}


The same issue might occur when sub expressions are automatically evaluated by Eigen as in the following example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{VectorXd u, v;}
\DoxyCodeLine{\textcolor{keyword}{auto} C = u + (A*v).normalized();}
\DoxyCodeLine{\textcolor{comment}{// do something with C}}
\end{DoxyCode}
 Here the {\ttfamily normalized()} method has to evaluate the expensive product {\ttfamily A$\ast$v} to avoid evaluating it twice. Again, one possible fix is to call {\ttfamily }.eval() on the whole expression\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} C = (u + (A*v).normalized()).eval();}
\end{DoxyCode}
 In this case, {\ttfamily C} will be a regular {\ttfamily Vector\+Xd} object. Note that \mbox{\hyperlink{class_eigen_1_1_dense_base_a5df64c66228ba75bbc66db2584185527}{Dense\+Base\+::eval()}} is smart enough to avoid copies when the underlying expression is already a plain {\ttfamily Matrix$<$$>$}.\hypertarget{_topic_pitfalls_TopicPitfalls_header_issues}{}\doxysubsection{Header Issues (failure to compile)}\label{_topic_pitfalls_TopicPitfalls_header_issues}
With all libraries, one must check the documentation for which header to include. The same is true with Eigen, but slightly worse\+: with Eigen, a method in a class may require an additional {\ttfamily \#include} over what the class itself requires! For example, if you want to use the {\ttfamily \mbox{\hyperlink{group__core__func__geometric_ga349f34d7cc9cd71393f96b953a91441a}{cross()}}} method on a vector (it computes a cross-\/product) then you need to\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include<Eigen/Geometry>}}
\end{DoxyCode}
 We try to always document this, but do tell us if we forgot an occurrence.\hypertarget{_topic_pitfalls_TopicPitfalls_ternary_operator}{}\doxysubsection{Ternary operator}\label{_topic_pitfalls_TopicPitfalls_ternary_operator}
In short\+: avoid the use of the ternary operator {\ttfamily (C\+O\+ND ? T\+H\+EN \+: E\+L\+SE)} with Eigen\textquotesingle{}s expressions for the {\ttfamily T\+H\+EN} and {\ttfamily E\+L\+SE} statements. To see why, let\textquotesingle{}s consider the following example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Vector3f A;}
\DoxyCodeLine{A << 1, 2, 3;}
\DoxyCodeLine{Vector3f \mbox{\hyperlink{class_eigen_1_1_matrix}{B}} = ((1 < 0) ? (A.reverse()) : A);}
\end{DoxyCode}
 This example will return {\ttfamily B = 3, 2, 1}. Do you see why? The reason is that in c++ the type of the {\ttfamily E\+L\+SE} statement is inferred from the type of the {\ttfamily T\+H\+EN} expression such that both match. Since {\ttfamily T\+H\+EN} is a {\ttfamily Reverse$<$\+Vector3f$>$}, the {\ttfamily E\+L\+SE} statement A is converted to a {\ttfamily Reverse$<$\+Vector3f$>$}, and the compiler thus generates\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Vector3f \mbox{\hyperlink{class_eigen_1_1_matrix}{B}} = ((1 < 0) ? (A.reverse()) : Reverse<Vector3f>(A));}
\end{DoxyCode}
 In this very particular case, a workaround would be to call A.\+reverse().eval() for the {\ttfamily T\+H\+EN} statement, but the safest and fastest is really to avoid this ternary operator with Eigen\textquotesingle{}s expressions and use a if/else construct.\hypertarget{_topic_pitfalls_TopicPitfalls_pass_by_value}{}\doxysubsection{Pass-\/by-\/value}\label{_topic_pitfalls_TopicPitfalls_pass_by_value}
If you don\textquotesingle{}t know why passing-\/by-\/value is wrong with Eigen, read this \mbox{\hyperlink{group___topic_passing_by_value}{page }} first.

While you may be extremely careful and use care to make sure that all of your code that explicitly uses Eigen types is pass-\/by-\/reference you have to watch out for templates which define the argument types at compile time.

If a template has a function that takes arguments pass-\/by-\/value, and the relevant template parameter ends up being an Eigen type, then you will of course have the same alignment problems that you would in an explicitly defined function passing Eigen types by reference.

Using Eigen types with other third party libraries or even the S\+TL can present the same problem. {\ttfamily boost\+::bind} for example uses pass-\/by-\/value to store arguments in the returned functor. This will of course be a problem.

There are at least two ways around this\+:
\begin{DoxyItemize}
\item If the value you are passing is guaranteed to be around for the life of the functor, you can use boost\+::ref() to wrap the value as you pass it to boost\+::bind. Generally this is not a solution for values on the stack as if the functor ever gets passed to a lower or independent scope, the object may be gone by the time it\textquotesingle{}s attempted to be used.
\item The other option is to make your functions take a reference counted pointer like boost\+::shared\+\_\+ptr as the argument. This avoids needing to worry about managing the lifetime of the object being passed.
\end{DoxyItemize}\hypertarget{_topic_pitfalls_TopicPitfalls_matrix_bool}{}\doxysubsection{Matrices with boolean coefficients}\label{_topic_pitfalls_TopicPitfalls_matrix_bool}
The current behaviour of using {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}} with boolean coefficients is inconsistent and likely to change in future versions of \mbox{\hyperlink{namespace_eigen}{Eigen}}, so please use it carefully!

A simple example for such an inconsistency is


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keywordtype}{int} Size>}
\DoxyCodeLine{\textcolor{keywordtype}{void} foo() \{}
\DoxyCodeLine{  \mbox{\hyperlink{class_eigen_1_1_matrix}{Eigen::Matrix<bool, Size, Size>}} A, \mbox{\hyperlink{class_eigen_1_1_matrix}{B}}, C;}
\DoxyCodeLine{  A.\mbox{\hyperlink{class_eigen_1_1_plain_object_base_a2871e88e1feb1cc665fa1f1cc800078b}{setOnes}}();}
\DoxyCodeLine{  \mbox{\hyperlink{class_eigen_1_1_matrix}{B}}.\mbox{\hyperlink{class_eigen_1_1_plain_object_base_a2871e88e1feb1cc665fa1f1cc800078b}{setOnes}}();}
\DoxyCodeLine{}
\DoxyCodeLine{  C = A * \mbox{\hyperlink{class_eigen_1_1_matrix}{B}} -\/ A * \mbox{\hyperlink{class_eigen_1_1_matrix}{B}};}
\DoxyCodeLine{  std::cout << C << \textcolor{stringliteral}{"\(\backslash\)n"};}
\DoxyCodeLine{\}}
\end{DoxyCode}


since calling {\ttfamily foo$<$3$>$()} prints the zero matrix while calling {\ttfamily foo$<$10$>$()} prints the identity matrix. \hypertarget{TopicTemplateKeyword}{}\doxysection{The template and typename keywords in C++}\label{TopicTemplateKeyword}
There are two uses for the {\ttfamily template} and {\ttfamily typename} keywords in C++. One of them is fairly well known amongst programmers\+: to define templates. The other use is more obscure\+: to specify that an expression refers to a template function or a type. This regularly trips up programmers that use the Eigen library, often leading to error messages from the compiler that are difficult to understand, such as \char`\"{}expected expression\char`\"{} or \char`\"{}no match for operator$<$\char`\"{}.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_template_keyword_TopicTemplateKeywordToDefineTemplates}{}\doxysubsection{Using the template and typename keywords to define templates}\label{_topic_template_keyword_TopicTemplateKeywordToDefineTemplates}
The {\ttfamily template} and {\ttfamily typename} keywords are routinely used to define templates. This is not the topic of this page as we assume that the reader is aware of this (otherwise consult a C++ book). The following example should illustrate this use of the {\ttfamily template} keyword.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\textcolor{keywordtype}{bool} isPositive(\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} x)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} x > 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


We could just as well have written {\ttfamily template $<$class T$>$}; the keywords {\ttfamily typename} and {\ttfamily class} have the same meaning in this context.\hypertarget{_topic_template_keyword_TopicTemplateKeywordExample}{}\doxysubsection{An example showing the second use of the template keyword}\label{_topic_template_keyword_TopicTemplateKeywordExample}
Let us illustrate the second use of the {\ttfamily template} keyword with an example. Suppose we want to write a function which copies all entries in the upper triangular part of a matrix into another matrix, while keeping the lower triangular part unchanged. A straightforward implementation would be as follows\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}


That works fine, but it is not very flexible. First, it only works with dynamic-\/size matrices of single-\/precision floats; the function {\ttfamily copy\+Upper\+Triangular\+Part()} does not accept static-\/size matrices or matrices with double-\/precision numbers. Second, if you use an expression such as {\ttfamily mat.\+top\+Left\+Corner(3,3)} as the parameter {\ttfamily src}, then this is copied into a temporary variable of type Matrix\+Xf; this copy can be avoided.

As explained in \mbox{\hyperlink{TopicFunctionTakingEigenTypes}{Writing Functions Taking Eigen Types as Parameters}}, both issues can be resolved by making {\ttfamily copy\+Upper\+Triangular\+Part()} accept any object of type \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. This leads to the following code\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}


The one line in the body of the function {\ttfamily copy\+Upper\+Triangular\+Part()} shows the second, more obscure use of the {\ttfamily template} keyword in C++. Even though it may look strange, the {\ttfamily template} keywords are necessary according to the standard. Without it, the compiler may reject the code with an error message like \char`\"{}no match
for operator$<$\char`\"{}.\hypertarget{_topic_template_keyword_TopicTemplateKeywordExplanation}{}\doxysubsection{Explanation}\label{_topic_template_keyword_TopicTemplateKeywordExplanation}
The reason that the {\ttfamily template} keyword is necessary in the last example has to do with the rules for how templates are supposed to be compiled in C++. The compiler has to check the code for correct syntax at the point where the template is defined, without knowing the actual value of the template arguments ({\ttfamily Derived1} and {\ttfamily Derived2} in the example). That means that the compiler cannot know that {\ttfamily dst.\+triangular\+View} is a member template and that the following $<$ symbol is part of the delimiter for the template parameter. Another possibility would be that {\ttfamily dst.\+triangular\+View} is a member variable with the $<$ symbol referring to the {\ttfamily operator$<$()} function. In fact, the compiler should choose the second possibility, according to the standard. If {\ttfamily dst.\+triangular\+View} is a member template (as in our case), the programmer should specify this explicitly with the {\ttfamily template} keyword and write {\ttfamily dst.\+template triangular\+View}.

The precise rules are rather complicated, but ignoring some subtleties we can summarize them as follows\+:
\begin{DoxyItemize}
\item A {\itshape dependent name} is name that depends (directly or indirectly) on a template parameter. In the example, {\ttfamily dst} is a dependent name because it is of type {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$Derived1$>$} which depends on the template parameter {\ttfamily Derived1}.
\item If the code contains either one of the constructs {\ttfamily xxx.\+yyy} or {\ttfamily xxx-\/$>$yyy} and {\ttfamily xxx} is a dependent name and {\ttfamily yyy} refers to a member template, then the {\ttfamily template} keyword must be used before {\ttfamily yyy}, leading to {\ttfamily xxx.\+template yyy} or {\ttfamily xxx-\/$>$template yyy}.
\item If the code contains the construct {\ttfamily xxx\+::yyy} and {\ttfamily xxx} is a dependent name and {\ttfamily yyy} refers to a member typedef, then the {\ttfamily typename} keyword must be used before the whole construct, leading to {\ttfamily typename xxx\+::yyy}.
\end{DoxyItemize}

As an example where the {\ttfamily typename} keyword is required, consider the following code in \mbox{\hyperlink{group___tutorial_sparse}{Tutorial\+Sparse}} for iterating over the non-\/zero entries of a sparse matrix type\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{SparseMatrixType mat(rows,cols);}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<mat.outerSize(); ++k)}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (SparseMatrixType::InnerIterator it(mat,k); it; ++it)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    \textcolor{comment}{/* ... */}}
\DoxyCodeLine{  \}}
\end{DoxyCode}


If {\ttfamily Sparse\+Matrix\+Type} depends on a template parameter, then the {\ttfamily typename} keyword is required\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\textcolor{keywordtype}{void} iterateOverSparseMatrix(\textcolor{keyword}{const} SparseMatrix<T>\& mat;}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<m1.outerSize(); ++k)}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} SparseMatrix<T>::InnerIterator it(mat,k); it; ++it)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      \textcolor{comment}{/* ... */}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{_topic_template_keyword_TopicTemplateKeywordResources}{}\doxysubsection{Resources for further reading}\label{_topic_template_keyword_TopicTemplateKeywordResources}
For more information and a fuller explanation of this topic, the reader may consult the following sources\+:
\begin{DoxyItemize}
\item The book \char`\"{}\+C++ Template Metaprogramming\char`\"{} by David Abrahams and Aleksey Gurtovoy contains a very good explanation in Appendix B (\char`\"{}\+The typename and template Keywords\char`\"{}) which formed the basis for this page.
\item \href{http://pages.cs.wisc.edu/~driscoll/typename.html}{\texttt{ http\+://pages.\+cs.\+wisc.\+edu/$\sim$driscoll/typename.\+html}}
\item \href{http://www.parashift.com/c++-faq-lite/templates.html\#faq-35.18}{\texttt{ http\+://www.\+parashift.\+com/c++-\/faq-\/lite/templates.\+html\#faq-\/35.\+18}}
\item \href{http://www.comeaucomputing.com/techtalk/templates/\#templateprefix}{\texttt{ http\+://www.\+comeaucomputing.\+com/techtalk/templates/\#templateprefix}}
\item \href{http://www.comeaucomputing.com/techtalk/templates/\#typename}{\texttt{ http\+://www.\+comeaucomputing.\+com/techtalk/templates/\#typename}} 
\end{DoxyItemize}\hypertarget{UserManual_UnderstandingEigen}{}\doxysection{Understanding Eigen}\label{UserManual_UnderstandingEigen}

\begin{DoxyItemize}
\item \mbox{\hyperlink{TopicInsideEigenExample}{What happens inside Eigen, on a simple example}}
\item \mbox{\hyperlink{TopicClassHierarchy}{The class hierarchy}}
\item \mbox{\hyperlink{TopicLazyEvaluation}{Lazy Evaluation and Aliasing}} 
\end{DoxyItemize}\hypertarget{TopicInsideEigenExample}{}\doxysubsection{What happens inside Eigen, on a simple example}\label{TopicInsideEigenExample}
\textbackslash{}eigen\+Auto\+Toc

\DoxyHorRuler{0}


Consider the following example program\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include<Eigen/Core>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordtype}{int} size = 50;}
\DoxyCodeLine{  \textcolor{comment}{// VectorXf is a vector of floats, with dynamic size.}}
\DoxyCodeLine{  Eigen::VectorXf u(size), v(size), w(size);}
\DoxyCodeLine{  u = v + w;}
\DoxyCodeLine{\}}
\end{DoxyCode}


The goal of this page is to understand how \mbox{\hyperlink{namespace_eigen}{Eigen}} compiles it, assuming that S\+S\+E2 vectorization is enabled (G\+CC option -\/msse2).\hypertarget{_topic_inside_eigen_example_WhyInteresting}{}\doxysubsubsection{Why it\textquotesingle{}s interesting}\label{_topic_inside_eigen_example_WhyInteresting}
Maybe you think, that the above example program is so simple, that compiling it shouldn\textquotesingle{}t involve anything interesting. So before starting, let us explain what is nontrivial in compiling it correctly -- that is, producing optimized code -- so that the complexity of \mbox{\hyperlink{namespace_eigen}{Eigen}}, that we\textquotesingle{}ll explain here, is really useful.

Look at the line of code 
\begin{DoxyCode}{0}
\DoxyCodeLine{u = v + w;   \textcolor{comment}{//   (*)}}
\end{DoxyCode}


The first important thing about compiling it, is that the arrays should be traversed only once, like 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) u[i] = v[i] + w[i];}
\end{DoxyCode}
 The problem is that if we make a naive C++ library where the Vector\+Xf class has an operator+ returning a Vector\+Xf, then the line of code ($\ast$) will amount to\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{VectorXf tmp = v + w;}
\DoxyCodeLine{VectorXf u = tmp;}
\end{DoxyCode}
 Obviously, the introduction of the temporary {\itshape tmp} here is useless. It has a very bad effect on performance, first because the creation of {\itshape tmp} requires a dynamic memory allocation in this context, and second as there are now two for loops\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) tmp[i] = v[i] + w[i];}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) u[i] = tmp[i];}
\end{DoxyCode}
 Traversing the arrays twice instead of once is terrible for performance, as it means that we do many redundant memory accesses.

The second important thing about compiling the above program, is to make correct use of S\+S\+E2 instructions. Notice that \mbox{\hyperlink{namespace_eigen}{Eigen}} also supports Alti\+Vec and that all the discussion that we make here applies also to Alti\+Vec.

S\+S\+E2, like Alti\+Vec, is a set of instructions allowing to perform computations on packets of 128 bits at once. Since a float is 32 bits, this means that S\+S\+E2 instructions can handle 4 floats at once. This means that, if correctly used, they can make our computation go up to 4x faster.

However, in the above program, we have chosen size=50, so our vectors consist of 50 float\textquotesingle{}s, and 50 is not a multiple of 4. This means that we cannot hope to do all of that computation using S\+S\+E2 instructions. The second best thing, to which we should aim, is to handle the 48 first coefficients with S\+S\+E2 instructions, since 48 is the biggest multiple of 4 below 50, and then handle separately, without S\+S\+E2, the 49th and 50th coefficients. Something like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 4*(size/4); i+=4) u.packet(i)  = v.packet(i) + w.packet(i);}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 4*(size/4); i < size; i++) u[i] = v[i] + w[i];}
\end{DoxyCode}


So let us look line by line at our example program, and let\textquotesingle{}s follow \mbox{\hyperlink{namespace_eigen}{Eigen}} as it compiles it.\hypertarget{_topic_inside_eigen_example_ConstructingVectors}{}\doxysubsubsection{Constructing vectors}\label{_topic_inside_eigen_example_ConstructingVectors}
Let\textquotesingle{}s analyze the first line\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Eigen::VectorXf u(size), v(size), w(size);}
\end{DoxyCode}


First of all, Vector\+Xf is the following typedef\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} Matrix<float, Dynamic, 1> VectorXf;}
\end{DoxyCode}


The class template \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} is declared in src/\+Core/util/\+Forward\+Declarations.\+h with 6 template parameters, but the last 3 are automatically determined by the first 3. So you don\textquotesingle{}t need to worry about them for now. Here, \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$<$float, Dynamic, 1$>$ means a matrix of floats, with a dynamic number of rows and 1 column.

The \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class inherits a base class, \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. Don\textquotesingle{}t worry about it, for now it suffices to say that \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} is what unifies matrices/vectors and all the expressions types -- more on that below.

When we do 
\begin{DoxyCode}{0}
\DoxyCodeLine{Eigen::VectorXf u(size);}
\end{DoxyCode}
 the constructor that is called is Matrix\+::\+Matrix(int), in src/\+Core/\+Matrix.\+h. Besides some assertions, all it does is to construct the {\itshape m\+\_\+storage} member, which is of type \mbox{\hyperlink{class_eigen_1_1_dense_storage}{Dense\+Storage}}$<$float, Dynamic, Dynamic, 1$>$.

You may wonder, isn\textquotesingle{}t it overengineering to have the storage in a separate class? The reason is that the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class template covers all kinds of matrices and vector\+: both fixed-\/size and dynamic-\/size. The storage method is not the same in these two cases. For fixed-\/size, the matrix coefficients are stored as a plain member array. For dynamic-\/size, the coefficients will be stored as a pointer to a dynamically-\/allocated array. Because of this, we need to abstract storage away from the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class. That\textquotesingle{}s \mbox{\hyperlink{class_eigen_1_1_dense_storage}{Dense\+Storage}}.

Let\textquotesingle{}s look at this constructor, in src/\+Core/\+Dense\+Storage.\+h. You can see that there are many partial template specializations of Dense\+Storages here, treating separately the cases where dimensions are Dynamic or fixed at compile-\/time. The partial specialization that we are looking at is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} Cols\_> \textcolor{keyword}{class }DenseStorage<\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, \mbox{\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}}, \mbox{\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}}, Cols\_>}
\end{DoxyCode}


Here, the constructor called is Dense\+Storage\+::\+Dense\+Storage(int size, int rows, int columns) with size=50, rows=50, columns=1.

Here is this constructor\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{inline} DenseStorage(\textcolor{keywordtype}{int} size, \textcolor{keywordtype}{int} rows, \textcolor{keywordtype}{int}) : m\_data(internal::aligned\_new<\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}>(size)), m\_rows(rows) \{\}}
\end{DoxyCode}


Here, the {\itshape m\+\_\+data} member is the actual array of coefficients of the matrix. As you see, it is dynamically allocated. Rather than calling new\mbox{[}\mbox{]} or malloc(), as you can see, we have our own internal\+::aligned\+\_\+new defined in src/\+Core/util/\+Memory.\+h. What it does is that if vectorization is enabled, then it uses a platform-\/specific call to allocate a 128-\/bit-\/aligned array, as that is very useful for vectorization with both S\+S\+E2 and Alti\+Vec. If vectorization is disabled, it amounts to the standard new\mbox{[}\mbox{]}.

As you can see, the constructor also sets the {\itshape m\+\_\+rows} member to {\itshape size}. Notice that there is no {\itshape m\+\_\+columns} member\+: indeed, in this partial specialization of \mbox{\hyperlink{class_eigen_1_1_dense_storage}{Dense\+Storage}}, we know the number of columns at compile-\/time, since the Cols\+\_\+ template parameter is different from Dynamic. Namely, in our case, Cols\+\_\+ is 1, which is to say that our vector is just a matrix with 1 column. Hence, there is no need to store the number of columns as a runtime variable.

When you call Vector\+Xf\+::data() to get the pointer to the array of coefficients, it returns Dense\+Storage\+::data() which returns the {\itshape m\+\_\+data} member.

When you call Vector\+Xf\+::size() to get the size of the vector, this is actually a method in the base class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. It determines that the vector is a column-\/vector, since Cols\+At\+Compile\+Time==1 (this comes from the template parameters in the typedef Vector\+Xf). It deduces that the size is the number of rows, so it returns Vector\+Xf\+::rows(), which returns Dense\+Storage\+::rows(), which returns the {\itshape m\+\_\+rows} member, which was set to {\itshape size} by the constructor.\hypertarget{_topic_inside_eigen_example_ConstructionOfSumXpr}{}\doxysubsubsection{Construction of the sum expression}\label{_topic_inside_eigen_example_ConstructionOfSumXpr}
Now that our vectors are constructed, let\textquotesingle{}s move on to the next line\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{u = v + w;}
\end{DoxyCode}


The executive summary is that operator+ returns a \char`\"{}sum of vectors\char`\"{} expression, but doesn\textquotesingle{}t actually perform the computation. It is the operator=, whose call occurs thereafter, that does the computation.

Let us now see what \mbox{\hyperlink{namespace_eigen}{Eigen}} does when it sees this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{v + w}
\end{DoxyCode}


Here, v and w are of type Vector\+Xf, which is a typedef for a specialization of \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} (as we explained above), which is a subclass of \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. So what is being called is


\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixBase::operator+(\textcolor{keyword}{const} MatrixBase\&)}
\end{DoxyCode}


The return type of this operator is 
\begin{DoxyCode}{0}
\DoxyCodeLine{CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\end{DoxyCode}
 The \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} class is our first encounter with an expression template. As we said, the operator+ doesn\textquotesingle{}t by itself perform any computation, it just returns an abstract \char`\"{}sum of vectors\char`\"{} expression. Since there are also \char`\"{}difference of vectors\char`\"{} and \char`\"{}coefficient-\/wise product of vectors\char`\"{} expressions, we unify them all as \char`\"{}coefficient-\/wise binary operations\char`\"{}, which we abbreviate as \char`\"{}\+Cwise\+Binary\+Op\char`\"{}. \char`\"{}\+Coefficient-\/wise\char`\"{} means that the operations is performed coefficient by coefficient. \char`\"{}binary\char`\"{} means that there are two operands -- we are adding two vectors with one another.

Now you might ask, what if we did something like


\begin{DoxyCode}{0}
\DoxyCodeLine{v + w + u;}
\end{DoxyCode}


The first v + w would return a \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} as above, so in order for this to compile, we\textquotesingle{}d need to define an operator+ also in the class \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}... at this point it starts looking like a nightmare\+: are we going to have to define all operators in each of the expression classes (as you guessed, \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} is only one of many) ? This looks like a dead end!

The solution is that \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} itself, as well as \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} and all the other expression types, is a subclass of \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. So it is enough to define once and for all the operators in class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}.

Since \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} is the common base class of different subclasses, the aspects that depend on the subclass must be abstracted from \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. This is called polymorphism.

The classical approach to polymorphism in C++ is by means of virtual functions. This is dynamic polymorphism. Here we don\textquotesingle{}t want dynamic polymorphism because the whole design of \mbox{\hyperlink{namespace_eigen}{Eigen}} is based around the assumption that all the complexity, all the abstraction, gets resolved at compile-\/time. This is crucial\+: if the abstraction can\textquotesingle{}t get resolved at compile-\/time, \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s compile-\/time optimization mechanisms become useless, not to mention that if that abstraction has to be resolved at runtime it\textquotesingle{}ll incur an overhead by itself.

Here, what we want is to have a single class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} as the base of many subclasses, in such a way that each \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} object (be it a matrix, or vector, or any kind of expression) knows at compile-\/time (as opposed to run-\/time) of which particular subclass it is an object (i.\+e. whether it is a matrix, or an expression, and what kind of expression).

The solution is the \href{http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern}{\texttt{ Curiously Recurring Template Pattern}}. Let\textquotesingle{}s do the break now. Hopefully you can read this wikipedia page during the break if needed, but it won\textquotesingle{}t be allowed during the exam.

In short, \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} takes a template parameter {\itshape Derived}. Whenever we define a subclass Subclass, we actually make Subclass inherit \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$Subclass$>$. The point is that different subclasses inherit different \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} types. Thanks to this, whenever we have an object of a subclass, and we call on it some \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} method, we still remember even from inside the \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} method which particular subclass we\textquotesingle{}re talking about.

This means that we can put almost all the methods and operators in the base class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}, and have only the bare minimum in the subclasses. If you look at the subclasses in \mbox{\hyperlink{namespace_eigen}{Eigen}}, like for instance the \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} class, they have very few methods. There are coeff() and sometimes coeff\+Ref() methods for access to the coefficients, there are rows() and cols() methods returning the number of rows and columns, but there isn\textquotesingle{}t much more than that. All the meat is in \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}, so it only needs to be coded once for all kinds of expressions, matrices, and vectors.

So let\textquotesingle{}s end this digression and come back to the piece of code from our example program that we were currently analyzing,


\begin{DoxyCode}{0}
\DoxyCodeLine{v + w}
\end{DoxyCode}


Now that \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} is a good friend, let\textquotesingle{}s write fully the prototype of the operator+ that gets called here (this code is from src/\+Core/\+Matrix\+Base.\+h)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{class }MatrixBase}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{  \textcolor{keyword}{const} CwiseBinaryOp<internal::scalar\_sum\_op<typename internal::traits<Derived>::Scalar>, Derived, OtherDerived>}
\DoxyCodeLine{  operator+(\textcolor{keyword}{const} MatrixBase<OtherDerived> \&other) \textcolor{keyword}{const};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Here of course, {\itshape Derived} and {\itshape Other\+Derived} are Vector\+Xf.

As we said, \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} is also used for other operations such as substration, so it takes another template parameter determining the operation that will be applied to coefficients. This template parameter is a functor, that is, a class in which we have an operator() so it behaves like a function. Here, the functor used is \mbox{\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal\+::scalar\+\_\+sum\+\_\+op}}. It is defined in src/\+Core/\+Functors.\+h.

Let us now explain the \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}} here. The \mbox{\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal\+::scalar\+\_\+sum\+\_\+op}} class takes one template parameter\+: the type of the numbers to handle. Here of course we want to pass the scalar type (a.\+k.\+a. numeric type) of Vector\+Xf, which is {\ttfamily float}. How do we determine which is the scalar type of {\itshape Derived} ? Throughout \mbox{\hyperlink{namespace_eigen}{Eigen}}, all matrix and expression types define a typedef {\itshape Scalar} which gives its scalar type. For example, Vector\+Xf\+::\+Scalar is a typedef for {\ttfamily float}. So here, if life was easy, we could find the numeric type of {\itshape Derived} as just 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typename} Derived::Scalar}
\end{DoxyCode}
 Unfortunately, we can\textquotesingle{}t do that here, as the compiler would complain that the type Derived hasn\textquotesingle{}t yet been defined. So we use a workaround\+: in src/\+Core/util/\+Forward\+Declarations.\+h, we declared (not defined!) all our subclasses, like \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, and we also declared the following class template\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }internal::traits;}
\end{DoxyCode}
 In src/\+Core/\+Matrix.\+h, right {\itshape before} the definition of class \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, we define a partial specialization of \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}} for T=\mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$<$any template parameters$>$. In this specialization of \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}}, we define the Scalar typedef. So when we actually define \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, it is legal to refer to \char`\"{}typename internal\+::traits\textbackslash{}$<$\+Matrix\textbackslash{}$>$\+::\+Scalar\char`\"{}.

Anyway, we have declared our operator+. In our case, where {\itshape Derived} and {\itshape Other\+Derived} are Vector\+Xf, the above declaration amounts to\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MatrixBase<VectorXf>}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\DoxyCodeLine{  operator+(\textcolor{keyword}{const} MatrixBase<VectorXf> \&other) \textcolor{keyword}{const};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Let\textquotesingle{}s now jump to src/\+Core/\+Cwise\+Binary\+Op.\+h to see how it is defined. As you can see there, all it does is to return a \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} object, and this object is just storing references to the left-\/hand-\/side and right-\/hand-\/side expressions -- here, these are the vectors {\itshape v} and {\itshape w}. Well, the \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} object is also storing an instance of the (empty) functor class, but you shouldn\textquotesingle{}t worry about it as that is a minor implementation detail.

Thus, the operator+ hasn\textquotesingle{}t performed any actual computation. To summarize, the operation {\itshape v} + {\itshape w} just returned an object of type \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} which did nothing else than just storing references to {\itshape v} and {\itshape w}.\hypertarget{_topic_inside_eigen_example_Assignment}{}\doxysubsubsection{The assignment}\label{_topic_inside_eigen_example_Assignment}
 {\bfseries{P\+L\+E\+A\+SE H\+E\+LP US I\+M\+P\+R\+O\+V\+I\+NG T\+H\+IS S\+E\+C\+T\+I\+ON.}} This page reflects how Eigen worked until 3.\+2, but since Eigen 3.\+3 the assignment is more sophisticated as it involves an Assignment expression, and the creation of so called evaluator which are responsible for the evaluation of each kind of expressions. 

At this point, the expression {\itshape v} + {\itshape w} has finished evaluating, so, in the process of compiling the line of code 
\begin{DoxyCode}{0}
\DoxyCodeLine{u = v + w;}
\end{DoxyCode}
 we now enter the operator=.

What operator= is being called here? The vector u is an object of class Vector\+Xf, i.\+e. \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}. In src/\+Core/\+Matrix.\+h, inside the definition of class \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, we see this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{inline} Matrix\& operator=(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  eigen\_assert(m\_storage.data()!=0 \&\& \textcolor{stringliteral}{"you cannot use operator= with a non initialized matrix (instead use set()"});}
\DoxyCodeLine{  \textcolor{keywordflow}{return} Base::operator=(other.derived());}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Here, Base is a typedef for \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$\mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$>$. So, what is being called is the operator= of \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. Let\textquotesingle{}s see its prototype in src/\+Core/\+Matrix\+Base.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{Derived\& operator=(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other);}
\end{DoxyCode}
 Here, {\itshape Derived} is Vector\+Xf (since u is a Vector\+Xf) and {\itshape Other\+Derived} is \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}. More specifically, as explained in the previous section, {\itshape Other\+Derived} is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\end{DoxyCode}
 So the full prototype of the operator= being called is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{VectorXf\& \mbox{\hyperlink{class_eigen_1_1_matrix_base_a706a4dd1ee54786e9210de1a4bf02600}{MatrixBase<VectorXf>::operator=}}(\textcolor{keyword}{const} MatrixBase<CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf> > \& other);}
\end{DoxyCode}
 This operator= literally reads \char`\"{}copying a sum of two Vector\+Xf\textquotesingle{}s into another Vector\+Xf\char`\"{}.

Let\textquotesingle{}s now look at the implementation of this operator=. It resides in the file src/\+Core/\+Assign.\+h.

What we can see there is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{inline} Derived\& \mbox{\hyperlink{class_eigen_1_1_matrix_base_a706a4dd1ee54786e9210de1a4bf02600}{MatrixBase<Derived>}}}
\DoxyCodeLine{\mbox{\hyperlink{class_eigen_1_1_matrix_base_a706a4dd1ee54786e9210de1a4bf02600}{  ::operator=}}(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} internal::assign\_selector<Derived,OtherDerived>::run(derived(), other.derived());}
\DoxyCodeLine{\}}
\end{DoxyCode}


OK so our next task is to understand internal\+::assign\+\_\+selector \+:)

Here is its declaration (all that is still in the same file src/\+Core/\+Assign.\+h) 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived,}
\DoxyCodeLine{         \textcolor{keywordtype}{bool} EvalBeforeAssigning = int(OtherDerived::Flags) \& \mbox{\hyperlink{group__flags_gae4b8ae7db0d83f9bbed26b261e60e139}{EvalBeforeAssigningBit}},}
\DoxyCodeLine{         \textcolor{keywordtype}{bool} NeedToTranspose = Derived::IsVectorAtCompileTime}
\DoxyCodeLine{                \&\& OtherDerived::IsVectorAtCompileTime}
\DoxyCodeLine{                \&\& int(Derived::RowsAtCompileTime) == int(OtherDerived::ColsAtCompileTime)}
\DoxyCodeLine{                \&\& int(Derived::ColsAtCompileTime) == int(OtherDerived::RowsAtCompileTime)}
\DoxyCodeLine{                \&\& int(Derived::SizeAtCompileTime) != 1>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_selector;}
\end{DoxyCode}


So internal\+::assign\+\_\+selector takes 4 template parameters, but the 2 last ones are automatically determined by the 2 first ones.

Eval\+Before\+Assigning is here to enforce the Eval\+Before\+Assigning\+Bit. As explained \href{TopicLazyEvaluation.html}{\texttt{ here}}, certain expressions have this flag which makes them automatically evaluate into temporaries before assigning them to another expression. This is the case of the \mbox{\hyperlink{class_eigen_1_1_product}{Product}} expression, in order to avoid strange aliasing effects when doing \char`\"{}m = m $\ast$ m;\char`\"{} However, of course here our \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} expression doesn\textquotesingle{}t have the Eval\+Before\+Assigning\+Bit\+: we said since the beginning that we didn\textquotesingle{}t want a temporary to be introduced here. So if you go to src/\+Core/\+Cwise\+Binary\+Op.\+h, you\textquotesingle{}ll see that the Flags in \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}}$<$\mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}$>$ don\textquotesingle{}t include the Eval\+Before\+Assigning\+Bit. The Flags member of \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} is then imported from the \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}} by the E\+I\+G\+E\+N\+\_\+\+G\+E\+N\+E\+R\+I\+C\+\_\+\+P\+U\+B\+L\+I\+C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE macro. Anyway, here the template parameter Eval\+Before\+Assigning has the value {\ttfamily false}.

Need\+To\+Transpose is here for the case where the user wants to copy a row-\/vector into a column-\/vector. We allow this as a special exception to the general rule that in assignments we require the dimesions to match. Anyway, here both the left-\/hand and right-\/hand sides are column vectors, in the sense that Cols\+At\+Compile\+Time is equal to 1. So Need\+To\+Transpose is {\ttfamily false} too.

So, here we are in the partial specialization\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal::assign\_selector<Derived, OtherDerived, false, false>}
\end{DoxyCode}


Here\textquotesingle{}s how it is defined\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_selector<Derived,OtherDerived,false,false> \{}
\DoxyCodeLine{  \textcolor{keyword}{static} Derived\& \mbox{\hyperlink{namespace_eigen_a1fb05f2dfd1e1974dc016cff6f349f98}{run}}(Derived\& dst, \textcolor{keyword}{const} OtherDerived\& other) \{ \textcolor{keywordflow}{return} dst.lazyAssign(other.derived()); \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


OK so now our next job is to understand how lazy\+Assign works \+:)


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{inline} Derived\& \mbox{\hyperlink{class_eigen_1_1_dense_base_adf691c9d5e89728815b91e42ebf9758d}{MatrixBase<Derived>}}}
\DoxyCodeLine{\mbox{\hyperlink{class_eigen_1_1_dense_base_adf691c9d5e89728815b91e42ebf9758d}{  ::lazyAssign}}(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  EIGEN\_STATIC\_ASSERT\_SAME\_MATRIX\_SIZE(Derived,OtherDerived)}
\DoxyCodeLine{  eigen\_assert(rows() == other.rows() \&\& cols() == other.cols());}
\DoxyCodeLine{  internal::assign\_impl<Derived, OtherDerived>::run(derived(),other.derived());}
\DoxyCodeLine{  \textcolor{keywordflow}{return} derived();}
\DoxyCodeLine{\}}
\end{DoxyCode}


What do we see here? Some assertions, and then the only interesting line is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal::assign\_impl<Derived, OtherDerived>::run(derived(),other.derived());}
\end{DoxyCode}


OK so now we want to know what is inside internal\+::assign\+\_\+impl.

Here is its declaration\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived1, \textcolor{keyword}{typename} Derived2,}
\DoxyCodeLine{         \textcolor{keywordtype}{int} Vectorization = internal::assign\_traits<Derived1, Derived2>::Vectorization,}
\DoxyCodeLine{         \textcolor{keywordtype}{int} Unrolling = internal::assign\_traits<Derived1, Derived2>::Unrolling>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_impl;}
\end{DoxyCode}
 Again, internal\+::assign\+\_\+selector takes 4 template parameters, but the 2 last ones are automatically determined by the 2 first ones.

These two parameters {\itshape Vectorization} and {\itshape Unrolling} are determined by a helper class internal\+::assign\+\_\+traits. Its job is to determine which vectorization strategy to use (that is {\itshape Vectorization}) and which unrolling strategy to use (that is {\itshape Unrolling}).

We\textquotesingle{}ll not enter into the details of how these strategies are chosen (this is in the implementation of internal\+::assign\+\_\+traits at the top of the same file). Let\textquotesingle{}s just say that here {\itshape Vectorization} has the value {\itshape Linear\+Vectorization}, and {\itshape Unrolling} has the value {\itshape No\+Unrolling} (the latter is obvious since our vectors have dynamic size so there\textquotesingle{}s no way to unroll the loop at compile-\/time).

So the partial specialization of internal\+::assign\+\_\+impl that we\textquotesingle{}re looking at is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal::assign\_impl<Derived1, Derived2, LinearVectorization, NoUnrolling>}
\end{DoxyCode}


Here is how it\textquotesingle{}s defined\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived1, \textcolor{keyword}{typename} Derived2>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_impl<Derived1, Derived2, LinearVectorization, NoUnrolling>}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespace_eigen_a1fb05f2dfd1e1974dc016cff6f349f98}{run}}(Derived1 \&dst, \textcolor{keyword}{const} Derived2 \&src)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} size = dst.size();}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} packetSize = internal::packet\_traits<typename Derived1::Scalar>::size;}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} alignedStart = internal::assign\_traits<Derived1,Derived2>::DstIsAligned ? 0}
\DoxyCodeLine{                           : internal::first\_aligned(\&dst.coeffRef(0), size);}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} alignedEnd = alignedStart + ((size-\/alignedStart)/packetSize)*packetSize;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = 0; index < alignedStart; index++)}
\DoxyCodeLine{      dst.copyCoeff(index, src);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedStart; index < alignedEnd; index += packetSize)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      dst.template copyPacket<Derived2, Aligned, internal::assign\_traits<Derived1,Derived2>::SrcAlignment>(index, src);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedEnd; index < size; index++)}
\DoxyCodeLine{      dst.copyCoeff(index, src);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Here\textquotesingle{}s how it works. {\itshape Linear\+Vectorization} means that the left-\/hand and right-\/hand side expression can be accessed linearly i.\+e. you can refer to their coefficients by one integer {\itshape index}, as opposed to having to refer to its coefficients by two integers {\itshape row}, {\itshape column}.

As we said at the beginning, vectorization works with blocks of 4 floats. Here, {\itshape Packet\+Size} is 4.

There are two potential problems that we need to deal with\+: \begin{DoxyItemize}
\item first, vectorization works much better if the packets are 128-\/bit-\/aligned. This is especially important for write access. So when writing to the coefficients of {\itshape dst}, we want to group these coefficients by packets of 4 such that each of these packets is 128-\/bit-\/aligned. In general, this requires to skip a few coefficients at the beginning of {\itshape dst}. This is the purpose of {\itshape aligned\+Start}. We then copy these first few coefficients one by one, not by packets. However, in our case, the {\itshape dst} expression is a Vector\+Xf and remember that in the construction of the vectors we allocated aligned arrays. Thanks to {\itshape Dst\+Is\+Aligned}, \mbox{\hyperlink{namespace_eigen}{Eigen}} remembers that without having to do any runtime check, so {\itshape aligned\+Start} is zero and this part is avoided altogether. \item second, the number of coefficients to copy is not in general a multiple of {\itshape packet\+Size}. Here, there are 50 coefficients to copy and {\itshape packet\+Size} is 4. So we\textquotesingle{}ll have to copy the last 2 coefficients one by one, not by packets. Here, {\itshape aligned\+End} is 48.\end{DoxyItemize}
Now come the actual loops.

First, the vectorized part\+: the 48 first coefficients out of 50 will be copied by packets of 4\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedStart; index < alignedEnd; index += packetSize)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  dst.template copyPacket<Derived2, Aligned, internal::assign\_traits<Derived1,Derived2>::SrcAlignment>(index, src);}
\DoxyCodeLine{\}}
\end{DoxyCode}


What is copy\+Packet? It is defined in src/\+Core/\+Coeffs.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived, \textcolor{keywordtype}{int} StoreMode, \textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} MatrixBase<Derived>::copyPacket(\textcolor{keywordtype}{int} index, \textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  eigen\_internal\_assert(index >= 0 \&\& index < size());}
\DoxyCodeLine{  derived().template writePacket<StoreMode>(index,}
\DoxyCodeLine{    other.derived().template packet<LoadMode>(index));}
\DoxyCodeLine{\}}
\end{DoxyCode}


OK, what are write\+Packet() and packet() here?

First, write\+Packet() here is a method on the left-\/hand side Vector\+Xf. So we go to src/\+Core/\+Matrix.\+h to look at its definition\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode>}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} writePacket(\textcolor{keywordtype}{int} index, \textcolor{keyword}{const} PacketScalar\& x)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  internal::pstoret<Scalar, PacketScalar, StoreMode>(m\_storage.data() + index, x);}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Here, {\itshape Store\+Mode} is {\itshape \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned}}}, indicating that we are doing a 128-\/bit-\/aligned write access, {\itshape Packet\+Scalar} is a type representing a \char`\"{}\+S\+S\+E packet of 4 floats\char`\"{} and internal\+::pstoret is a function writing such a packet in memory. Their definitions are architecture-\/specific, we find them in src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h\+:

The line in src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h that determines the Packet\+Scalar type (via a typedef in Matrix.\+h) is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{struct }internal::packet\_traits<float>  \{ \textcolor{keyword}{typedef} \_\_m128  type; \textcolor{keyword}{enum} \{size=4\}; \};}
\end{DoxyCode}
 Here, \+\_\+\+\_\+m128 is a S\+S\+E-\/specific type. Notice that the enum {\itshape size} here is what was used to define {\itshape packet\+Size} above.

And here is the implementation of internal\+::pstoret\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{void} internal::pstore(\textcolor{keywordtype}{float}*  to, \textcolor{keyword}{const} \_\_m128\&  from) \{ \_mm\_store\_ps(to, from); \}}
\end{DoxyCode}
 Here, \+\_\+\+\_\+mm\+\_\+store\+\_\+ps is a S\+S\+E-\/specific intrinsic function, representing a single S\+SE instruction. The difference between internal\+::pstore and internal\+::pstoret is that internal\+::pstoret is a dispatcher handling both the aligned and unaligned cases, you find its definition in src/\+Core/\+Generic\+Packet\+Math.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Packet, \textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} internal::pstoret(Scalar* to, \textcolor{keyword}{const} \mbox{\hyperlink{class_eigen_1_1_triplet}{Packet}}\& from)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{if}(LoadMode == \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned}})}
\DoxyCodeLine{    internal::pstore(to, from);}
\DoxyCodeLine{  \textcolor{keywordflow}{else}}
\DoxyCodeLine{    internal::pstoreu(to, from);}
\DoxyCodeLine{\}}
\end{DoxyCode}


OK, that explains how write\+Packet() works. Now let\textquotesingle{}s look into the packet() call. Remember that we are analyzing this line of code inside copy\+Packet()\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{derived().template writePacket<StoreMode>(index,}
\DoxyCodeLine{    other.derived().template packet<LoadMode>(index));}
\end{DoxyCode}


Here, {\itshape other} is our sum expression {\itshape v} + {\itshape w}. The .derived() is just casting from \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} to the subclass which here is \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}. So let\textquotesingle{}s go to src/\+Core/\+Cwise\+Binary\+Op.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }CwiseBinaryOp}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{    \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{    \textcolor{keyword}{inline} PacketScalar packet(\textcolor{keywordtype}{int} index)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{    }\{}
\DoxyCodeLine{      \textcolor{keywordflow}{return} m\_functor.packetOp(m\_lhs.template packet<LoadMode>(index), m\_rhs.template packet<LoadMode>(index));}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
 Here, {\itshape m\+\_\+lhs} is the vector {\itshape v}, and {\itshape m\+\_\+rhs} is the vector {\itshape w}. So the packet() function here is Matrix\+::packet(). The template parameter {\itshape Load\+Mode} is {\itshape \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned}}}. So we\textquotesingle{}re looking at 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }Matrix}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{    \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{    \textcolor{keyword}{inline} PacketScalar packet(\textcolor{keywordtype}{int} index)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{    }\{}
\DoxyCodeLine{      \textcolor{keywordflow}{return} internal::ploadt<Scalar, LoadMode>(m\_storage.data() + index);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
 We let you look up the definition of internal\+::ploadt in Generic\+Packet\+Math.\+h and the internal\+::pload in src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h. It is very similar to the above for internal\+::pstore.

Let\textquotesingle{}s go back to Cwise\+Binary\+Op\+::packet(). Once the packets from the vectors {\itshape v} and {\itshape w} have been returned, what does this function do? It calls m\+\_\+functor.\+packet\+Op() on them. What is m\+\_\+functor? Here we must remember what particular template specialization of \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} we\textquotesingle{}re dealing with\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\end{DoxyCode}
 So m\+\_\+functor is an object of the empty class internal\+::scalar\+\_\+sum\+\_\+op$<$float$>$. As we mentioned above, don\textquotesingle{}t worry about why we constructed an object of this empty class at all -- it\textquotesingle{}s an implementation detail, the point is that some other functors need to store member data.

Anyway, \mbox{\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal\+::scalar\+\_\+sum\+\_\+op}} is defined in src/\+Core/\+Functors.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }internal::scalar\_sum\_op EIGEN\_EMPTY\_STRUCT \{}
\DoxyCodeLine{  \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar\& a, \textcolor{keyword}{const} Scalar\& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a + b; \}}
\DoxyCodeLine{  \textcolor{keyword}{template}<\textcolor{keyword}{typename} PacketScalar>}
\DoxyCodeLine{  \textcolor{keyword}{inline} \textcolor{keyword}{const} PacketScalar packetOp(\textcolor{keyword}{const} PacketScalar\& a, \textcolor{keyword}{const} PacketScalar\& b)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::padd(a,b); \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
 As you can see, all what packet\+Op() does is to call internal\+::padd on the two packets. Here is the definition of internal\+::padd from src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{inline} \_\_m128  internal::padd(\textcolor{keyword}{const} \_\_m128\&  a, \textcolor{keyword}{const} \_\_m128\&  b) \{ \textcolor{keywordflow}{return} \_mm\_add\_ps(a,b); \}}
\end{DoxyCode}
 Here, \+\_\+mm\+\_\+add\+\_\+ps is a S\+S\+E-\/specific intrinsic function, representing a single S\+SE instruction.

To summarize, the loop 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedStart; index < alignedEnd; index += packetSize)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  dst.template copyPacket<Derived2, Aligned, internal::assign\_traits<Derived1,Derived2>::SrcAlignment>(index, src);}
\DoxyCodeLine{\}}
\end{DoxyCode}
 has been compiled to the following code\+: for {\itshape index} going from 0 to the 11 ( = 48/4 -\/ 1), read the i-\/th packet (of 4 floats) from the vector v and the i-\/th packet from the vector w using two \+\_\+\+\_\+mm\+\_\+load\+\_\+ps S\+SE instructions, then add them together using a \+\_\+\+\_\+mm\+\_\+add\+\_\+ps instruction, then store the result using a \+\_\+\+\_\+mm\+\_\+store\+\_\+ps instruction.

There remains the second loop handling the last few (here, the last 2) coefficients\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedEnd; index < size; index++)}
\DoxyCodeLine{  dst.copyCoeff(index, src);}
\end{DoxyCode}
 However, it works just like the one we just explained, it is just simpler because there is no S\+SE vectorization involved here. copy\+Packet() becomes copy\+Coeff(), packet() becomes coeff(), write\+Packet() becomes coeff\+Ref(). If you followed us this far, you can probably understand this part by yourself.

We see that all the C++ abstraction of \mbox{\hyperlink{namespace_eigen}{Eigen}} goes away during compilation and that we indeed are precisely controlling which assembly instructions we emit. Such is the beauty of C++! Since we have such precise control over the emitted assembly instructions, but such complex logic to choose the right instructions, we can say that \mbox{\hyperlink{namespace_eigen}{Eigen}} really behaves like an optimizing compiler. If you prefer, you could say that \mbox{\hyperlink{namespace_eigen}{Eigen}} behaves like a script for the compiler. In a sense, C++ template metaprogramming is scripting the compiler -- and it\textquotesingle{}s been shown that this scripting language is Turing-\/complete. See \href{http://en.wikipedia.org/wiki/Template_metaprogramming}{\texttt{ Wikipedia}}. \hypertarget{TopicClassHierarchy}{}\doxysubsection{The class hierarchy}\label{TopicClassHierarchy}
This page explains the design of the core classes in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s class hierarchy and how they fit together. Casual users probably need not concern themselves with these details, but it may be useful for both advanced users and \mbox{\hyperlink{namespace_eigen}{Eigen}} developers.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_class_hierarchy_TopicClassHierarchyPrinciples}{}\doxysubsubsection{Principles}\label{_topic_class_hierarchy_TopicClassHierarchyPrinciples}
\mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s class hierarchy is designed so that virtual functions are avoided where their overhead would significantly impair performance. Instead, \mbox{\hyperlink{namespace_eigen}{Eigen}} achieves polymorphism with the Curiously Recurring Template Pattern (C\+R\+TP). In this pattern, the base class (for instance, {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}}) is in fact a template class, and the derived class (for instance, {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}}) inherits the base class with the derived class itself as a template argument (in this case, {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}} inherits from {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$\mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$>$}). This allows \mbox{\hyperlink{namespace_eigen}{Eigen}} to resolve the polymorphic function calls at compile time.

In addition, the design avoids multiple inheritance. One reason for this is that in our experience, some compilers (like M\+S\+VC) fail to perform empty base class optimization, which is crucial for our fixed-\/size types.\hypertarget{_topic_class_hierarchy_TopicClassHierarchyCoreClasses}{}\doxysubsubsection{The core classes}\label{_topic_class_hierarchy_TopicClassHierarchyCoreClasses}
These are the classes that you need to know about if you want to write functions that accept or return \mbox{\hyperlink{namespace_eigen}{Eigen}} objects.


\begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} means plain dense matrix. If {\ttfamily m} is a {\ttfamily Matrix}, then, for instance, {\ttfamily m+m} is no longer a {\ttfamily Matrix}, it is a \char`\"{}matrix expression\char`\"{}.
\item \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} means dense matrix expression. This means that a {\ttfamily Matrix\+Base} is something that can be added, matrix-\/multiplied, L\+U-\/decomposed, Q\+R-\/decomposed... All matrix expression classes, including {\ttfamily Matrix} itself, inherit {\ttfamily Matrix\+Base}.
\item \mbox{\hyperlink{class_eigen_1_1_array}{Array}} means plain dense array. If {\ttfamily x} is an {\ttfamily Array}, then, for instance, {\ttfamily x+x} is no longer an {\ttfamily Array}, it is an \char`\"{}array expression\char`\"{}.
\item \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} means dense array expression. This means that an {\ttfamily Array\+Base} is something that can be added, array-\/multiplied, and on which you can perform all sorts of array operations... All array expression classes, including {\ttfamily Array} itself, inherit {\ttfamily Array\+Base}.
\item \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}} means dense (matrix or array) expression. Both {\ttfamily Array\+Base} and {\ttfamily Matrix\+Base} inherit {\ttfamily Dense\+Base}. {\ttfamily Dense\+Base} is where all the methods go that apply to dense expressions regardless of whether they are matrix or array expressions. For example, the \mbox{\hyperlink{}{block(...) }} methods are in {\ttfamily Dense\+Base}.
\end{DoxyItemize}\hypertarget{_topic_class_hierarchy_TopicClassHierarchyBaseClasses}{}\doxysubsubsection{Base classes}\label{_topic_class_hierarchy_TopicClassHierarchyBaseClasses}
These classes serve as base classes for the five core classes mentioned above. They are more internal and so less interesting for users of the \mbox{\hyperlink{namespace_eigen}{Eigen}} library.


\begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{Plain\+Object\+Base}} means dense (matrix or array) plain object, i.\+e. something that stores its own dense array of coefficients. This is where, for instance, the \mbox{\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize() }} methods go. {\ttfamily Plain\+Object\+Base} is inherited by {\ttfamily Matrix} and by {\ttfamily Array}. But above, we said that {\ttfamily Matrix} inherits {\ttfamily Matrix\+Base} and {\ttfamily Array} inherits {\ttfamily Array\+Base}. So does that mean multiple inheritance? No, because {\ttfamily Plain\+Object\+Base} {\itshape itself} inherits {\ttfamily Matrix\+Base} or {\ttfamily Array\+Base} depending on whether we are in the matrix or array case. When we said above that {\ttfamily Matrix} inherited {\ttfamily Matrix\+Base}, we omitted to say it does so indirectly via {\ttfamily Plain\+Object\+Base}. Same for {\ttfamily Array}.
\item \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{Dense\+Coeffs\+Base}} means something that has dense coefficient accessors. It is a base class for {\ttfamily Dense\+Base}. The reason for {\ttfamily Dense\+Coeffs\+Base} to exist is that the set of available coefficient accessors is very different depending on whether a dense expression has direct memory access or not (the {\ttfamily Direct\+Access\+Bit} flag). For example, if {\ttfamily x} is a plain matrix, then {\ttfamily x} has direct access, and {\ttfamily x.\+transpose()} and {\ttfamily x.\+block(...)} also have direct access, because their coefficients can be read right off memory, but for example, {\ttfamily x+x} does not have direct memory access, because obtaining any of its coefficients requires a computation (an addition), it can\textquotesingle{}t be just read off memory.
\item \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}} means anything that can be evaluated into a plain dense matrix or array (even if that would be a bad idea). {\ttfamily Eigen\+Base} is really the absolute base class for anything that remotely looks like a matrix or array. It is a base class for {\ttfamily Dense\+Coeffs\+Base}, so it sits below all our dense class hierarchy, but it is not limited to dense expressions. For example, {\ttfamily Eigen\+Base} is also inherited by diagonal matrices, sparse matrices, etc...
\end{DoxyItemize}\hypertarget{_topic_class_hierarchy_TopicClassHierarchyInheritanceDiagrams}{}\doxysubsubsection{Inheritance diagrams}\label{_topic_class_hierarchy_TopicClassHierarchyInheritanceDiagrams}
The inheritance diagram for \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<Matrix>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<Matrix>    (direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<Matrix>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_matrix_base}{MatrixBase}}<Matrix>
        <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{PlainObjectBase}}<Matrix>    (matrix case)
          <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}
\end{DoxyPre}


The inheritance diagram for \mbox{\hyperlink{class_eigen_1_1_array}{Array}} looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<Array>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<Array>    (direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<Array>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_array_base}{ArrayBase}}<Array>
        <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{PlainObjectBase}}<Array>    (array case)
          <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_array}{Array}}
\end{DoxyPre}


The inheritance diagram for some other matrix expression class, here denoted by {\ttfamily Some\+Matrix\+Xpr}, looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<SomeMatrixXpr>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<SomeMatrixXpr>    (direct access or no direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<SomeMatrixXpr>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_matrix_base}{MatrixBase}}<SomeMatrixXpr>
        <-\/-\/ SomeMatrixXpr
\end{DoxyPre}


The inheritance diagram for some other array expression class, here denoted by {\ttfamily Some\+Array\+Xpr}, looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<SomeArrayXpr>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<SomeArrayXpr>    (direct access or no direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<SomeArrayXpr>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_array_base}{ArrayBase}}<SomeArrayXpr>
        <-\/-\/ SomeArrayXpr
\end{DoxyPre}


Finally, consider an example of something that is not a dense expression, for instance a diagonal matrix. The corresponding inheritance diagram is\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<DiagonalMatrix>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_diagonal_base}{DiagonalBase}}<DiagonalMatrix>
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_diagonal_matrix}{DiagonalMatrix}}
\end{DoxyPre}
 \hypertarget{TopicLazyEvaluation}{}\doxysubsection{Lazy Evaluation and Aliasing}\label{TopicLazyEvaluation}
Executive summary\+: Eigen has intelligent compile-\/time mechanisms to enable lazy evaluation and removing temporaries where appropriate. It will handle aliasing automatically in most cases, for example with matrix products. The automatic behavior can be overridden manually by using the \mbox{\hyperlink{class_eigen_1_1_dense_base_a5df64c66228ba75bbc66db2584185527}{Matrix\+Base\+::eval()}} and \mbox{\hyperlink{class_eigen_1_1_matrix_base_a7f15120bb9c88c30aa5d993bd6d138e1}{Matrix\+Base\+::noalias()}} methods.

When you write a line of code involving a complex expression such as


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} * (\mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}} + mat5);}
\end{DoxyCode}


Eigen determines automatically, for each sub-\/expression, whether to evaluate it into a temporary variable. Indeed, in certain cases it is better to evaluate a sub-\/expression into a temporary variable, while in other cases it is better to avoid that.

A traditional math library without expression templates always evaluates all sub-\/expressions into temporaries. So with this code,


\begin{DoxyCode}{0}
\DoxyCodeLine{vec1 = \mbox{\hyperlink{group__core__types_gaa1618f51db67eaa145db101d8c8431d8}{vec2}} + \mbox{\hyperlink{group__core__types_ga1c47e8b3386109bc992b6c48e91b0be7}{vec3}};}
\end{DoxyCode}


a traditional library would evaluate {\ttfamily vec2} + vec3 into a temporary {\ttfamily vec4} and then copy {\ttfamily vec4} into {\ttfamily vec1}. This is of course inefficient\+: the arrays are traversed twice, so there are a lot of useless load/store operations.

Expression-\/templates-\/based libraries can avoid evaluating sub-\/expressions into temporaries, which in many cases results in large speed improvements. This is called {\itshape lazy evaluation} as an expression is getting evaluated as late as possible. In Eigen {\bfseries{all expressions are lazy-\/evaluated}}. More precisely, an expression starts to be evaluated once it is assigned to a matrix. Until then nothing happens beyond constructing the abstract expression tree. In contrast to most other expression-\/templates-\/based libraries, however, {\bfseries{Eigen might choose to evaluate some sub-\/expressions into temporaries}}. There are two reasons for that\+: first, pure lazy evaluation is not always a good choice for performance; second, pure lazy evaluation can be very dangerous, for example with matrix products\+: doing {\ttfamily mat = mat$\ast$mat} gives a wrong result if the matrix product is directly evaluated within the destination matrix, because of the way matrix product works.

For these reasons, Eigen has intelligent compile-\/time mechanisms to determine automatically which sub-\/expression should be evaluated into a temporary variable.

So in the basic example,


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}};}
\end{DoxyCode}


Eigen chooses not to introduce any temporary. Thus the arrays are traversed only once, producing optimized code. If you really want to force immediate evaluation, use \mbox{\hyperlink{class_eigen_1_1_dense_base_a5df64c66228ba75bbc66db2584185527}{eval()}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = (\mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}}).eval();}
\end{DoxyCode}


Here is now a more involved example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = -\/\mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} + 5 * \mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}};}
\end{DoxyCode}


Here again Eigen won\textquotesingle{}t introduce any temporary, thus producing a single {\bfseries{fused}} evaluation loop, which is clearly the correct choice.\hypertarget{_topic_lazy_evaluation_TopicLazyEvaluationWhichExpr}{}\doxysubsubsection{Which sub-\/expressions are evaluated into temporaries?}\label{_topic_lazy_evaluation_TopicLazyEvaluationWhichExpr}
The default evaluation strategy is to fuse the operations in a single loop, and Eigen will choose it except in a few circumstances.

{\bfseries{The first circumstance}} in which Eigen chooses to evaluate a sub-\/expression is when it sees an assignment {\ttfamily a = b;} and the expression {\ttfamily b} has the evaluate-\/before-\/assigning \mbox{\hyperlink{group__flags}{flag}}. The most important example of such an expression is the \mbox{\hyperlink{class_eigen_1_1_product}{matrix product expression}}. For example, when you do


\begin{DoxyCode}{0}
\DoxyCodeLine{mat = mat * mat;}
\end{DoxyCode}


Eigen will evaluate {\ttfamily mat $\ast$ mat} into a temporary matrix, and then copies it into the original {\ttfamily mat}. This guarantees a correct result as we saw above that lazy evaluation gives wrong results with matrix products. It also doesn\textquotesingle{}t cost much, as the cost of the matrix product itself is much higher. Note that this temporary is introduced at evaluation time only, that is, within operator= in this example. The expression {\ttfamily mat $\ast$ mat} still return a abstract product type.

What if you know that the result does no alias the operand of the product and want to force lazy evaluation? Then use \mbox{\hyperlink{class_eigen_1_1_matrix_base_a7f15120bb9c88c30aa5d993bd6d138e1}{.noalias()}} instead. Here is an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1.noalias() = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} * \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}};}
\end{DoxyCode}


Here, since we know that mat2 is not the same matrix as mat1, we know that lazy evaluation is not dangerous, so we may force lazy evaluation. Concretely, the effect of noalias() here is to bypass the evaluate-\/before-\/assigning \mbox{\hyperlink{group__flags}{flag}}.

{\bfseries{The second circumstance}} in which Eigen chooses to evaluate a sub-\/expression, is when it sees a nested expression such as {\ttfamily a + b} where {\ttfamily b} is already an expression having the evaluate-\/before-\/nesting \mbox{\hyperlink{group__flags}{flag}}. Again, the most important example of such an expression is the \mbox{\hyperlink{class_eigen_1_1_product}{matrix product expression}}. For example, when you do


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} * \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} + \mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}} * mat5;}
\end{DoxyCode}


the products {\ttfamily mat2 $\ast$ mat3} and {\ttfamily mat4 $\ast$ mat5} gets evaluated separately into temporary matrices before being summed up in {\ttfamily mat1}. Indeed, to be efficient matrix products need to be evaluated within a destination matrix at hand, and not as simple \char`\"{}dot products\char`\"{}. For small matrices, however, you might want to enforce a \char`\"{}dot-\/product\char`\"{} based lazy evaluation with lazy\+Product(). Again, it is important to understand that those temporaries are created at evaluation time only, that is in operator =. See Topic\+Pitfalls\+\_\+auto\+\_\+keyword for common pitfalls regarding this remark.

{\bfseries{The third circumstance}} in which Eigen chooses to evaluate a sub-\/expression, is when its cost model shows that the total cost of an operation is reduced if a sub-\/expression gets evaluated into a temporary. Indeed, in certain cases, an intermediate result is sufficiently costly to compute and is reused sufficiently many times, that is worth \char`\"{}caching\char`\"{}. Here is an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} * (\mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} + \mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}});}
\end{DoxyCode}


Here, provided the matrices have at least 2 rows and 2 columns, each coefficient of the expression {\ttfamily mat3 + mat4} is going to be used several times in the matrix product. Instead of computing the sum every time, it is much better to compute it once and store it in a temporary variable. Eigen understands this and evaluates {\ttfamily mat3 + mat4} into a temporary variable before evaluating the product. \hypertarget{TopicInsideEigenExample}{}\doxysubsection{What happens inside Eigen, on a simple example}\label{TopicInsideEigenExample}
\textbackslash{}eigen\+Auto\+Toc

\DoxyHorRuler{0}


Consider the following example program\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include<Eigen/Core>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordtype}{int} size = 50;}
\DoxyCodeLine{  \textcolor{comment}{// VectorXf is a vector of floats, with dynamic size.}}
\DoxyCodeLine{  Eigen::VectorXf u(size), v(size), w(size);}
\DoxyCodeLine{  u = v + w;}
\DoxyCodeLine{\}}
\end{DoxyCode}


The goal of this page is to understand how \mbox{\hyperlink{namespace_eigen}{Eigen}} compiles it, assuming that S\+S\+E2 vectorization is enabled (G\+CC option -\/msse2).\hypertarget{_topic_inside_eigen_example_WhyInteresting}{}\doxysubsubsection{Why it\textquotesingle{}s interesting}\label{_topic_inside_eigen_example_WhyInteresting}
Maybe you think, that the above example program is so simple, that compiling it shouldn\textquotesingle{}t involve anything interesting. So before starting, let us explain what is nontrivial in compiling it correctly -- that is, producing optimized code -- so that the complexity of \mbox{\hyperlink{namespace_eigen}{Eigen}}, that we\textquotesingle{}ll explain here, is really useful.

Look at the line of code 
\begin{DoxyCode}{0}
\DoxyCodeLine{u = v + w;   \textcolor{comment}{//   (*)}}
\end{DoxyCode}


The first important thing about compiling it, is that the arrays should be traversed only once, like 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) u[i] = v[i] + w[i];}
\end{DoxyCode}
 The problem is that if we make a naive C++ library where the Vector\+Xf class has an operator+ returning a Vector\+Xf, then the line of code ($\ast$) will amount to\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{VectorXf tmp = v + w;}
\DoxyCodeLine{VectorXf u = tmp;}
\end{DoxyCode}
 Obviously, the introduction of the temporary {\itshape tmp} here is useless. It has a very bad effect on performance, first because the creation of {\itshape tmp} requires a dynamic memory allocation in this context, and second as there are now two for loops\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) tmp[i] = v[i] + w[i];}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) u[i] = tmp[i];}
\end{DoxyCode}
 Traversing the arrays twice instead of once is terrible for performance, as it means that we do many redundant memory accesses.

The second important thing about compiling the above program, is to make correct use of S\+S\+E2 instructions. Notice that \mbox{\hyperlink{namespace_eigen}{Eigen}} also supports Alti\+Vec and that all the discussion that we make here applies also to Alti\+Vec.

S\+S\+E2, like Alti\+Vec, is a set of instructions allowing to perform computations on packets of 128 bits at once. Since a float is 32 bits, this means that S\+S\+E2 instructions can handle 4 floats at once. This means that, if correctly used, they can make our computation go up to 4x faster.

However, in the above program, we have chosen size=50, so our vectors consist of 50 float\textquotesingle{}s, and 50 is not a multiple of 4. This means that we cannot hope to do all of that computation using S\+S\+E2 instructions. The second best thing, to which we should aim, is to handle the 48 first coefficients with S\+S\+E2 instructions, since 48 is the biggest multiple of 4 below 50, and then handle separately, without S\+S\+E2, the 49th and 50th coefficients. Something like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 4*(size/4); i+=4) u.packet(i)  = v.packet(i) + w.packet(i);}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 4*(size/4); i < size; i++) u[i] = v[i] + w[i];}
\end{DoxyCode}


So let us look line by line at our example program, and let\textquotesingle{}s follow \mbox{\hyperlink{namespace_eigen}{Eigen}} as it compiles it.\hypertarget{_topic_inside_eigen_example_ConstructingVectors}{}\doxysubsubsection{Constructing vectors}\label{_topic_inside_eigen_example_ConstructingVectors}
Let\textquotesingle{}s analyze the first line\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Eigen::VectorXf u(size), v(size), w(size);}
\end{DoxyCode}


First of all, Vector\+Xf is the following typedef\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} Matrix<float, Dynamic, 1> VectorXf;}
\end{DoxyCode}


The class template \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} is declared in src/\+Core/util/\+Forward\+Declarations.\+h with 6 template parameters, but the last 3 are automatically determined by the first 3. So you don\textquotesingle{}t need to worry about them for now. Here, \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$<$float, Dynamic, 1$>$ means a matrix of floats, with a dynamic number of rows and 1 column.

The \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class inherits a base class, \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. Don\textquotesingle{}t worry about it, for now it suffices to say that \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} is what unifies matrices/vectors and all the expressions types -- more on that below.

When we do 
\begin{DoxyCode}{0}
\DoxyCodeLine{Eigen::VectorXf u(size);}
\end{DoxyCode}
 the constructor that is called is Matrix\+::\+Matrix(int), in src/\+Core/\+Matrix.\+h. Besides some assertions, all it does is to construct the {\itshape m\+\_\+storage} member, which is of type \mbox{\hyperlink{class_eigen_1_1_dense_storage}{Dense\+Storage}}$<$float, Dynamic, Dynamic, 1$>$.

You may wonder, isn\textquotesingle{}t it overengineering to have the storage in a separate class? The reason is that the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class template covers all kinds of matrices and vector\+: both fixed-\/size and dynamic-\/size. The storage method is not the same in these two cases. For fixed-\/size, the matrix coefficients are stored as a plain member array. For dynamic-\/size, the coefficients will be stored as a pointer to a dynamically-\/allocated array. Because of this, we need to abstract storage away from the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class. That\textquotesingle{}s \mbox{\hyperlink{class_eigen_1_1_dense_storage}{Dense\+Storage}}.

Let\textquotesingle{}s look at this constructor, in src/\+Core/\+Dense\+Storage.\+h. You can see that there are many partial template specializations of Dense\+Storages here, treating separately the cases where dimensions are Dynamic or fixed at compile-\/time. The partial specialization that we are looking at is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} Cols\_> \textcolor{keyword}{class }DenseStorage<\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, \mbox{\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}}, \mbox{\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}}, Cols\_>}
\end{DoxyCode}


Here, the constructor called is Dense\+Storage\+::\+Dense\+Storage(int size, int rows, int columns) with size=50, rows=50, columns=1.

Here is this constructor\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{inline} DenseStorage(\textcolor{keywordtype}{int} size, \textcolor{keywordtype}{int} rows, \textcolor{keywordtype}{int}) : m\_data(internal::aligned\_new<\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}>(size)), m\_rows(rows) \{\}}
\end{DoxyCode}


Here, the {\itshape m\+\_\+data} member is the actual array of coefficients of the matrix. As you see, it is dynamically allocated. Rather than calling new\mbox{[}\mbox{]} or malloc(), as you can see, we have our own internal\+::aligned\+\_\+new defined in src/\+Core/util/\+Memory.\+h. What it does is that if vectorization is enabled, then it uses a platform-\/specific call to allocate a 128-\/bit-\/aligned array, as that is very useful for vectorization with both S\+S\+E2 and Alti\+Vec. If vectorization is disabled, it amounts to the standard new\mbox{[}\mbox{]}.

As you can see, the constructor also sets the {\itshape m\+\_\+rows} member to {\itshape size}. Notice that there is no {\itshape m\+\_\+columns} member\+: indeed, in this partial specialization of \mbox{\hyperlink{class_eigen_1_1_dense_storage}{Dense\+Storage}}, we know the number of columns at compile-\/time, since the Cols\+\_\+ template parameter is different from Dynamic. Namely, in our case, Cols\+\_\+ is 1, which is to say that our vector is just a matrix with 1 column. Hence, there is no need to store the number of columns as a runtime variable.

When you call Vector\+Xf\+::data() to get the pointer to the array of coefficients, it returns Dense\+Storage\+::data() which returns the {\itshape m\+\_\+data} member.

When you call Vector\+Xf\+::size() to get the size of the vector, this is actually a method in the base class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. It determines that the vector is a column-\/vector, since Cols\+At\+Compile\+Time==1 (this comes from the template parameters in the typedef Vector\+Xf). It deduces that the size is the number of rows, so it returns Vector\+Xf\+::rows(), which returns Dense\+Storage\+::rows(), which returns the {\itshape m\+\_\+rows} member, which was set to {\itshape size} by the constructor.\hypertarget{_topic_inside_eigen_example_ConstructionOfSumXpr}{}\doxysubsubsection{Construction of the sum expression}\label{_topic_inside_eigen_example_ConstructionOfSumXpr}
Now that our vectors are constructed, let\textquotesingle{}s move on to the next line\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{u = v + w;}
\end{DoxyCode}


The executive summary is that operator+ returns a \char`\"{}sum of vectors\char`\"{} expression, but doesn\textquotesingle{}t actually perform the computation. It is the operator=, whose call occurs thereafter, that does the computation.

Let us now see what \mbox{\hyperlink{namespace_eigen}{Eigen}} does when it sees this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{v + w}
\end{DoxyCode}


Here, v and w are of type Vector\+Xf, which is a typedef for a specialization of \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} (as we explained above), which is a subclass of \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. So what is being called is


\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixBase::operator+(\textcolor{keyword}{const} MatrixBase\&)}
\end{DoxyCode}


The return type of this operator is 
\begin{DoxyCode}{0}
\DoxyCodeLine{CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\end{DoxyCode}
 The \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} class is our first encounter with an expression template. As we said, the operator+ doesn\textquotesingle{}t by itself perform any computation, it just returns an abstract \char`\"{}sum of vectors\char`\"{} expression. Since there are also \char`\"{}difference of vectors\char`\"{} and \char`\"{}coefficient-\/wise product of vectors\char`\"{} expressions, we unify them all as \char`\"{}coefficient-\/wise binary operations\char`\"{}, which we abbreviate as \char`\"{}\+Cwise\+Binary\+Op\char`\"{}. \char`\"{}\+Coefficient-\/wise\char`\"{} means that the operations is performed coefficient by coefficient. \char`\"{}binary\char`\"{} means that there are two operands -- we are adding two vectors with one another.

Now you might ask, what if we did something like


\begin{DoxyCode}{0}
\DoxyCodeLine{v + w + u;}
\end{DoxyCode}


The first v + w would return a \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} as above, so in order for this to compile, we\textquotesingle{}d need to define an operator+ also in the class \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}... at this point it starts looking like a nightmare\+: are we going to have to define all operators in each of the expression classes (as you guessed, \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} is only one of many) ? This looks like a dead end!

The solution is that \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} itself, as well as \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} and all the other expression types, is a subclass of \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. So it is enough to define once and for all the operators in class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}.

Since \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} is the common base class of different subclasses, the aspects that depend on the subclass must be abstracted from \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. This is called polymorphism.

The classical approach to polymorphism in C++ is by means of virtual functions. This is dynamic polymorphism. Here we don\textquotesingle{}t want dynamic polymorphism because the whole design of \mbox{\hyperlink{namespace_eigen}{Eigen}} is based around the assumption that all the complexity, all the abstraction, gets resolved at compile-\/time. This is crucial\+: if the abstraction can\textquotesingle{}t get resolved at compile-\/time, \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s compile-\/time optimization mechanisms become useless, not to mention that if that abstraction has to be resolved at runtime it\textquotesingle{}ll incur an overhead by itself.

Here, what we want is to have a single class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} as the base of many subclasses, in such a way that each \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} object (be it a matrix, or vector, or any kind of expression) knows at compile-\/time (as opposed to run-\/time) of which particular subclass it is an object (i.\+e. whether it is a matrix, or an expression, and what kind of expression).

The solution is the \href{http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern}{\texttt{ Curiously Recurring Template Pattern}}. Let\textquotesingle{}s do the break now. Hopefully you can read this wikipedia page during the break if needed, but it won\textquotesingle{}t be allowed during the exam.

In short, \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} takes a template parameter {\itshape Derived}. Whenever we define a subclass Subclass, we actually make Subclass inherit \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$Subclass$>$. The point is that different subclasses inherit different \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} types. Thanks to this, whenever we have an object of a subclass, and we call on it some \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} method, we still remember even from inside the \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} method which particular subclass we\textquotesingle{}re talking about.

This means that we can put almost all the methods and operators in the base class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}, and have only the bare minimum in the subclasses. If you look at the subclasses in \mbox{\hyperlink{namespace_eigen}{Eigen}}, like for instance the \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} class, they have very few methods. There are coeff() and sometimes coeff\+Ref() methods for access to the coefficients, there are rows() and cols() methods returning the number of rows and columns, but there isn\textquotesingle{}t much more than that. All the meat is in \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}, so it only needs to be coded once for all kinds of expressions, matrices, and vectors.

So let\textquotesingle{}s end this digression and come back to the piece of code from our example program that we were currently analyzing,


\begin{DoxyCode}{0}
\DoxyCodeLine{v + w}
\end{DoxyCode}


Now that \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} is a good friend, let\textquotesingle{}s write fully the prototype of the operator+ that gets called here (this code is from src/\+Core/\+Matrix\+Base.\+h)\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{class }MatrixBase}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{  \textcolor{keyword}{const} CwiseBinaryOp<internal::scalar\_sum\_op<typename internal::traits<Derived>::Scalar>, Derived, OtherDerived>}
\DoxyCodeLine{  operator+(\textcolor{keyword}{const} MatrixBase<OtherDerived> \&other) \textcolor{keyword}{const};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Here of course, {\itshape Derived} and {\itshape Other\+Derived} are Vector\+Xf.

As we said, \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} is also used for other operations such as substration, so it takes another template parameter determining the operation that will be applied to coefficients. This template parameter is a functor, that is, a class in which we have an operator() so it behaves like a function. Here, the functor used is \mbox{\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal\+::scalar\+\_\+sum\+\_\+op}}. It is defined in src/\+Core/\+Functors.\+h.

Let us now explain the \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}} here. The \mbox{\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal\+::scalar\+\_\+sum\+\_\+op}} class takes one template parameter\+: the type of the numbers to handle. Here of course we want to pass the scalar type (a.\+k.\+a. numeric type) of Vector\+Xf, which is {\ttfamily float}. How do we determine which is the scalar type of {\itshape Derived} ? Throughout \mbox{\hyperlink{namespace_eigen}{Eigen}}, all matrix and expression types define a typedef {\itshape Scalar} which gives its scalar type. For example, Vector\+Xf\+::\+Scalar is a typedef for {\ttfamily float}. So here, if life was easy, we could find the numeric type of {\itshape Derived} as just 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typename} Derived::Scalar}
\end{DoxyCode}
 Unfortunately, we can\textquotesingle{}t do that here, as the compiler would complain that the type Derived hasn\textquotesingle{}t yet been defined. So we use a workaround\+: in src/\+Core/util/\+Forward\+Declarations.\+h, we declared (not defined!) all our subclasses, like \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, and we also declared the following class template\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }internal::traits;}
\end{DoxyCode}
 In src/\+Core/\+Matrix.\+h, right {\itshape before} the definition of class \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, we define a partial specialization of \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}} for T=\mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$<$any template parameters$>$. In this specialization of \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}}, we define the Scalar typedef. So when we actually define \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, it is legal to refer to \char`\"{}typename internal\+::traits\textbackslash{}$<$\+Matrix\textbackslash{}$>$\+::\+Scalar\char`\"{}.

Anyway, we have declared our operator+. In our case, where {\itshape Derived} and {\itshape Other\+Derived} are Vector\+Xf, the above declaration amounts to\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MatrixBase<VectorXf>}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\DoxyCodeLine{  operator+(\textcolor{keyword}{const} MatrixBase<VectorXf> \&other) \textcolor{keyword}{const};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Let\textquotesingle{}s now jump to src/\+Core/\+Cwise\+Binary\+Op.\+h to see how it is defined. As you can see there, all it does is to return a \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} object, and this object is just storing references to the left-\/hand-\/side and right-\/hand-\/side expressions -- here, these are the vectors {\itshape v} and {\itshape w}. Well, the \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} object is also storing an instance of the (empty) functor class, but you shouldn\textquotesingle{}t worry about it as that is a minor implementation detail.

Thus, the operator+ hasn\textquotesingle{}t performed any actual computation. To summarize, the operation {\itshape v} + {\itshape w} just returned an object of type \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} which did nothing else than just storing references to {\itshape v} and {\itshape w}.\hypertarget{_topic_inside_eigen_example_Assignment}{}\doxysubsubsection{The assignment}\label{_topic_inside_eigen_example_Assignment}
 {\bfseries{P\+L\+E\+A\+SE H\+E\+LP US I\+M\+P\+R\+O\+V\+I\+NG T\+H\+IS S\+E\+C\+T\+I\+ON.}} This page reflects how Eigen worked until 3.\+2, but since Eigen 3.\+3 the assignment is more sophisticated as it involves an Assignment expression, and the creation of so called evaluator which are responsible for the evaluation of each kind of expressions. 

At this point, the expression {\itshape v} + {\itshape w} has finished evaluating, so, in the process of compiling the line of code 
\begin{DoxyCode}{0}
\DoxyCodeLine{u = v + w;}
\end{DoxyCode}
 we now enter the operator=.

What operator= is being called here? The vector u is an object of class Vector\+Xf, i.\+e. \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}. In src/\+Core/\+Matrix.\+h, inside the definition of class \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, we see this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{inline} Matrix\& operator=(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  eigen\_assert(m\_storage.data()!=0 \&\& \textcolor{stringliteral}{"you cannot use operator= with a non initialized matrix (instead use set()"});}
\DoxyCodeLine{  \textcolor{keywordflow}{return} Base::operator=(other.derived());}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Here, Base is a typedef for \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$\mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$>$. So, what is being called is the operator= of \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. Let\textquotesingle{}s see its prototype in src/\+Core/\+Matrix\+Base.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{Derived\& operator=(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other);}
\end{DoxyCode}
 Here, {\itshape Derived} is Vector\+Xf (since u is a Vector\+Xf) and {\itshape Other\+Derived} is \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}. More specifically, as explained in the previous section, {\itshape Other\+Derived} is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\end{DoxyCode}
 So the full prototype of the operator= being called is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{VectorXf\& \mbox{\hyperlink{class_eigen_1_1_matrix_base_a706a4dd1ee54786e9210de1a4bf02600}{MatrixBase<VectorXf>::operator=}}(\textcolor{keyword}{const} MatrixBase<CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf> > \& other);}
\end{DoxyCode}
 This operator= literally reads \char`\"{}copying a sum of two Vector\+Xf\textquotesingle{}s into another Vector\+Xf\char`\"{}.

Let\textquotesingle{}s now look at the implementation of this operator=. It resides in the file src/\+Core/\+Assign.\+h.

What we can see there is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{inline} Derived\& \mbox{\hyperlink{class_eigen_1_1_matrix_base_a706a4dd1ee54786e9210de1a4bf02600}{MatrixBase<Derived>}}}
\DoxyCodeLine{\mbox{\hyperlink{class_eigen_1_1_matrix_base_a706a4dd1ee54786e9210de1a4bf02600}{  ::operator=}}(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} internal::assign\_selector<Derived,OtherDerived>::run(derived(), other.derived());}
\DoxyCodeLine{\}}
\end{DoxyCode}


OK so our next task is to understand internal\+::assign\+\_\+selector \+:)

Here is its declaration (all that is still in the same file src/\+Core/\+Assign.\+h) 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived,}
\DoxyCodeLine{         \textcolor{keywordtype}{bool} EvalBeforeAssigning = int(OtherDerived::Flags) \& \mbox{\hyperlink{group__flags_gae4b8ae7db0d83f9bbed26b261e60e139}{EvalBeforeAssigningBit}},}
\DoxyCodeLine{         \textcolor{keywordtype}{bool} NeedToTranspose = Derived::IsVectorAtCompileTime}
\DoxyCodeLine{                \&\& OtherDerived::IsVectorAtCompileTime}
\DoxyCodeLine{                \&\& int(Derived::RowsAtCompileTime) == int(OtherDerived::ColsAtCompileTime)}
\DoxyCodeLine{                \&\& int(Derived::ColsAtCompileTime) == int(OtherDerived::RowsAtCompileTime)}
\DoxyCodeLine{                \&\& int(Derived::SizeAtCompileTime) != 1>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_selector;}
\end{DoxyCode}


So internal\+::assign\+\_\+selector takes 4 template parameters, but the 2 last ones are automatically determined by the 2 first ones.

Eval\+Before\+Assigning is here to enforce the Eval\+Before\+Assigning\+Bit. As explained \href{TopicLazyEvaluation.html}{\texttt{ here}}, certain expressions have this flag which makes them automatically evaluate into temporaries before assigning them to another expression. This is the case of the \mbox{\hyperlink{class_eigen_1_1_product}{Product}} expression, in order to avoid strange aliasing effects when doing \char`\"{}m = m $\ast$ m;\char`\"{} However, of course here our \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} expression doesn\textquotesingle{}t have the Eval\+Before\+Assigning\+Bit\+: we said since the beginning that we didn\textquotesingle{}t want a temporary to be introduced here. So if you go to src/\+Core/\+Cwise\+Binary\+Op.\+h, you\textquotesingle{}ll see that the Flags in \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}}$<$\mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}$>$ don\textquotesingle{}t include the Eval\+Before\+Assigning\+Bit. The Flags member of \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} is then imported from the \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}} by the E\+I\+G\+E\+N\+\_\+\+G\+E\+N\+E\+R\+I\+C\+\_\+\+P\+U\+B\+L\+I\+C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE macro. Anyway, here the template parameter Eval\+Before\+Assigning has the value {\ttfamily false}.

Need\+To\+Transpose is here for the case where the user wants to copy a row-\/vector into a column-\/vector. We allow this as a special exception to the general rule that in assignments we require the dimesions to match. Anyway, here both the left-\/hand and right-\/hand sides are column vectors, in the sense that Cols\+At\+Compile\+Time is equal to 1. So Need\+To\+Transpose is {\ttfamily false} too.

So, here we are in the partial specialization\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal::assign\_selector<Derived, OtherDerived, false, false>}
\end{DoxyCode}


Here\textquotesingle{}s how it is defined\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_selector<Derived,OtherDerived,false,false> \{}
\DoxyCodeLine{  \textcolor{keyword}{static} Derived\& \mbox{\hyperlink{namespace_eigen_a1fb05f2dfd1e1974dc016cff6f349f98}{run}}(Derived\& dst, \textcolor{keyword}{const} OtherDerived\& other) \{ \textcolor{keywordflow}{return} dst.lazyAssign(other.derived()); \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


OK so now our next job is to understand how lazy\+Assign works \+:)


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{inline} Derived\& \mbox{\hyperlink{class_eigen_1_1_dense_base_adf691c9d5e89728815b91e42ebf9758d}{MatrixBase<Derived>}}}
\DoxyCodeLine{\mbox{\hyperlink{class_eigen_1_1_dense_base_adf691c9d5e89728815b91e42ebf9758d}{  ::lazyAssign}}(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  EIGEN\_STATIC\_ASSERT\_SAME\_MATRIX\_SIZE(Derived,OtherDerived)}
\DoxyCodeLine{  eigen\_assert(rows() == other.rows() \&\& cols() == other.cols());}
\DoxyCodeLine{  internal::assign\_impl<Derived, OtherDerived>::run(derived(),other.derived());}
\DoxyCodeLine{  \textcolor{keywordflow}{return} derived();}
\DoxyCodeLine{\}}
\end{DoxyCode}


What do we see here? Some assertions, and then the only interesting line is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal::assign\_impl<Derived, OtherDerived>::run(derived(),other.derived());}
\end{DoxyCode}


OK so now we want to know what is inside internal\+::assign\+\_\+impl.

Here is its declaration\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived1, \textcolor{keyword}{typename} Derived2,}
\DoxyCodeLine{         \textcolor{keywordtype}{int} Vectorization = internal::assign\_traits<Derived1, Derived2>::Vectorization,}
\DoxyCodeLine{         \textcolor{keywordtype}{int} Unrolling = internal::assign\_traits<Derived1, Derived2>::Unrolling>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_impl;}
\end{DoxyCode}
 Again, internal\+::assign\+\_\+selector takes 4 template parameters, but the 2 last ones are automatically determined by the 2 first ones.

These two parameters {\itshape Vectorization} and {\itshape Unrolling} are determined by a helper class internal\+::assign\+\_\+traits. Its job is to determine which vectorization strategy to use (that is {\itshape Vectorization}) and which unrolling strategy to use (that is {\itshape Unrolling}).

We\textquotesingle{}ll not enter into the details of how these strategies are chosen (this is in the implementation of internal\+::assign\+\_\+traits at the top of the same file). Let\textquotesingle{}s just say that here {\itshape Vectorization} has the value {\itshape Linear\+Vectorization}, and {\itshape Unrolling} has the value {\itshape No\+Unrolling} (the latter is obvious since our vectors have dynamic size so there\textquotesingle{}s no way to unroll the loop at compile-\/time).

So the partial specialization of internal\+::assign\+\_\+impl that we\textquotesingle{}re looking at is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal::assign\_impl<Derived1, Derived2, LinearVectorization, NoUnrolling>}
\end{DoxyCode}


Here is how it\textquotesingle{}s defined\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived1, \textcolor{keyword}{typename} Derived2>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_impl<Derived1, Derived2, LinearVectorization, NoUnrolling>}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{namespace_eigen_a1fb05f2dfd1e1974dc016cff6f349f98}{run}}(Derived1 \&dst, \textcolor{keyword}{const} Derived2 \&src)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} size = dst.size();}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} packetSize = internal::packet\_traits<typename Derived1::Scalar>::size;}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} alignedStart = internal::assign\_traits<Derived1,Derived2>::DstIsAligned ? 0}
\DoxyCodeLine{                           : internal::first\_aligned(\&dst.coeffRef(0), size);}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} alignedEnd = alignedStart + ((size-\/alignedStart)/packetSize)*packetSize;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = 0; index < alignedStart; index++)}
\DoxyCodeLine{      dst.copyCoeff(index, src);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedStart; index < alignedEnd; index += packetSize)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      dst.template copyPacket<Derived2, Aligned, internal::assign\_traits<Derived1,Derived2>::SrcAlignment>(index, src);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedEnd; index < size; index++)}
\DoxyCodeLine{      dst.copyCoeff(index, src);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Here\textquotesingle{}s how it works. {\itshape Linear\+Vectorization} means that the left-\/hand and right-\/hand side expression can be accessed linearly i.\+e. you can refer to their coefficients by one integer {\itshape index}, as opposed to having to refer to its coefficients by two integers {\itshape row}, {\itshape column}.

As we said at the beginning, vectorization works with blocks of 4 floats. Here, {\itshape Packet\+Size} is 4.

There are two potential problems that we need to deal with\+: \begin{DoxyItemize}
\item first, vectorization works much better if the packets are 128-\/bit-\/aligned. This is especially important for write access. So when writing to the coefficients of {\itshape dst}, we want to group these coefficients by packets of 4 such that each of these packets is 128-\/bit-\/aligned. In general, this requires to skip a few coefficients at the beginning of {\itshape dst}. This is the purpose of {\itshape aligned\+Start}. We then copy these first few coefficients one by one, not by packets. However, in our case, the {\itshape dst} expression is a Vector\+Xf and remember that in the construction of the vectors we allocated aligned arrays. Thanks to {\itshape Dst\+Is\+Aligned}, \mbox{\hyperlink{namespace_eigen}{Eigen}} remembers that without having to do any runtime check, so {\itshape aligned\+Start} is zero and this part is avoided altogether. \item second, the number of coefficients to copy is not in general a multiple of {\itshape packet\+Size}. Here, there are 50 coefficients to copy and {\itshape packet\+Size} is 4. So we\textquotesingle{}ll have to copy the last 2 coefficients one by one, not by packets. Here, {\itshape aligned\+End} is 48.\end{DoxyItemize}
Now come the actual loops.

First, the vectorized part\+: the 48 first coefficients out of 50 will be copied by packets of 4\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedStart; index < alignedEnd; index += packetSize)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  dst.template copyPacket<Derived2, Aligned, internal::assign\_traits<Derived1,Derived2>::SrcAlignment>(index, src);}
\DoxyCodeLine{\}}
\end{DoxyCode}


What is copy\+Packet? It is defined in src/\+Core/\+Coeffs.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived, \textcolor{keywordtype}{int} StoreMode, \textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} MatrixBase<Derived>::copyPacket(\textcolor{keywordtype}{int} index, \textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  eigen\_internal\_assert(index >= 0 \&\& index < size());}
\DoxyCodeLine{  derived().template writePacket<StoreMode>(index,}
\DoxyCodeLine{    other.derived().template packet<LoadMode>(index));}
\DoxyCodeLine{\}}
\end{DoxyCode}


OK, what are write\+Packet() and packet() here?

First, write\+Packet() here is a method on the left-\/hand side Vector\+Xf. So we go to src/\+Core/\+Matrix.\+h to look at its definition\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode>}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} writePacket(\textcolor{keywordtype}{int} index, \textcolor{keyword}{const} PacketScalar\& x)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  internal::pstoret<Scalar, PacketScalar, StoreMode>(m\_storage.data() + index, x);}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Here, {\itshape Store\+Mode} is {\itshape \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned}}}, indicating that we are doing a 128-\/bit-\/aligned write access, {\itshape Packet\+Scalar} is a type representing a \char`\"{}\+S\+S\+E packet of 4 floats\char`\"{} and internal\+::pstoret is a function writing such a packet in memory. Their definitions are architecture-\/specific, we find them in src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h\+:

The line in src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h that determines the Packet\+Scalar type (via a typedef in Matrix.\+h) is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{struct }internal::packet\_traits<float>  \{ \textcolor{keyword}{typedef} \_\_m128  type; \textcolor{keyword}{enum} \{size=4\}; \};}
\end{DoxyCode}
 Here, \+\_\+\+\_\+m128 is a S\+S\+E-\/specific type. Notice that the enum {\itshape size} here is what was used to define {\itshape packet\+Size} above.

And here is the implementation of internal\+::pstoret\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{void} internal::pstore(\textcolor{keywordtype}{float}*  to, \textcolor{keyword}{const} \_\_m128\&  from) \{ \_mm\_store\_ps(to, from); \}}
\end{DoxyCode}
 Here, \+\_\+\+\_\+mm\+\_\+store\+\_\+ps is a S\+S\+E-\/specific intrinsic function, representing a single S\+SE instruction. The difference between internal\+::pstore and internal\+::pstoret is that internal\+::pstoret is a dispatcher handling both the aligned and unaligned cases, you find its definition in src/\+Core/\+Generic\+Packet\+Math.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Packet, \textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} internal::pstoret(Scalar* to, \textcolor{keyword}{const} \mbox{\hyperlink{class_eigen_1_1_triplet}{Packet}}\& from)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{if}(LoadMode == \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned}})}
\DoxyCodeLine{    internal::pstore(to, from);}
\DoxyCodeLine{  \textcolor{keywordflow}{else}}
\DoxyCodeLine{    internal::pstoreu(to, from);}
\DoxyCodeLine{\}}
\end{DoxyCode}


OK, that explains how write\+Packet() works. Now let\textquotesingle{}s look into the packet() call. Remember that we are analyzing this line of code inside copy\+Packet()\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{derived().template writePacket<StoreMode>(index,}
\DoxyCodeLine{    other.derived().template packet<LoadMode>(index));}
\end{DoxyCode}


Here, {\itshape other} is our sum expression {\itshape v} + {\itshape w}. The .derived() is just casting from \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} to the subclass which here is \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}. So let\textquotesingle{}s go to src/\+Core/\+Cwise\+Binary\+Op.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }CwiseBinaryOp}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{    \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{    \textcolor{keyword}{inline} PacketScalar packet(\textcolor{keywordtype}{int} index)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{    }\{}
\DoxyCodeLine{      \textcolor{keywordflow}{return} m\_functor.packetOp(m\_lhs.template packet<LoadMode>(index), m\_rhs.template packet<LoadMode>(index));}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
 Here, {\itshape m\+\_\+lhs} is the vector {\itshape v}, and {\itshape m\+\_\+rhs} is the vector {\itshape w}. So the packet() function here is Matrix\+::packet(). The template parameter {\itshape Load\+Mode} is {\itshape \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ad37d4c71425bb286e9b4103830538fbf}{Aligned}}}. So we\textquotesingle{}re looking at 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }Matrix}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{    \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{    \textcolor{keyword}{inline} PacketScalar packet(\textcolor{keywordtype}{int} index)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{    }\{}
\DoxyCodeLine{      \textcolor{keywordflow}{return} internal::ploadt<Scalar, LoadMode>(m\_storage.data() + index);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
 We let you look up the definition of internal\+::ploadt in Generic\+Packet\+Math.\+h and the internal\+::pload in src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h. It is very similar to the above for internal\+::pstore.

Let\textquotesingle{}s go back to Cwise\+Binary\+Op\+::packet(). Once the packets from the vectors {\itshape v} and {\itshape w} have been returned, what does this function do? It calls m\+\_\+functor.\+packet\+Op() on them. What is m\+\_\+functor? Here we must remember what particular template specialization of \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} we\textquotesingle{}re dealing with\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\end{DoxyCode}
 So m\+\_\+functor is an object of the empty class internal\+::scalar\+\_\+sum\+\_\+op$<$float$>$. As we mentioned above, don\textquotesingle{}t worry about why we constructed an object of this empty class at all -- it\textquotesingle{}s an implementation detail, the point is that some other functors need to store member data.

Anyway, \mbox{\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal\+::scalar\+\_\+sum\+\_\+op}} is defined in src/\+Core/\+Functors.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }internal::scalar\_sum\_op EIGEN\_EMPTY\_STRUCT \{}
\DoxyCodeLine{  \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar\& a, \textcolor{keyword}{const} Scalar\& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a + b; \}}
\DoxyCodeLine{  \textcolor{keyword}{template}<\textcolor{keyword}{typename} PacketScalar>}
\DoxyCodeLine{  \textcolor{keyword}{inline} \textcolor{keyword}{const} PacketScalar packetOp(\textcolor{keyword}{const} PacketScalar\& a, \textcolor{keyword}{const} PacketScalar\& b)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::padd(a,b); \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
 As you can see, all what packet\+Op() does is to call internal\+::padd on the two packets. Here is the definition of internal\+::padd from src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{inline} \_\_m128  internal::padd(\textcolor{keyword}{const} \_\_m128\&  a, \textcolor{keyword}{const} \_\_m128\&  b) \{ \textcolor{keywordflow}{return} \_mm\_add\_ps(a,b); \}}
\end{DoxyCode}
 Here, \+\_\+mm\+\_\+add\+\_\+ps is a S\+S\+E-\/specific intrinsic function, representing a single S\+SE instruction.

To summarize, the loop 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedStart; index < alignedEnd; index += packetSize)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  dst.template copyPacket<Derived2, Aligned, internal::assign\_traits<Derived1,Derived2>::SrcAlignment>(index, src);}
\DoxyCodeLine{\}}
\end{DoxyCode}
 has been compiled to the following code\+: for {\itshape index} going from 0 to the 11 ( = 48/4 -\/ 1), read the i-\/th packet (of 4 floats) from the vector v and the i-\/th packet from the vector w using two \+\_\+\+\_\+mm\+\_\+load\+\_\+ps S\+SE instructions, then add them together using a \+\_\+\+\_\+mm\+\_\+add\+\_\+ps instruction, then store the result using a \+\_\+\+\_\+mm\+\_\+store\+\_\+ps instruction.

There remains the second loop handling the last few (here, the last 2) coefficients\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedEnd; index < size; index++)}
\DoxyCodeLine{  dst.copyCoeff(index, src);}
\end{DoxyCode}
 However, it works just like the one we just explained, it is just simpler because there is no S\+SE vectorization involved here. copy\+Packet() becomes copy\+Coeff(), packet() becomes coeff(), write\+Packet() becomes coeff\+Ref(). If you followed us this far, you can probably understand this part by yourself.

We see that all the C++ abstraction of \mbox{\hyperlink{namespace_eigen}{Eigen}} goes away during compilation and that we indeed are precisely controlling which assembly instructions we emit. Such is the beauty of C++! Since we have such precise control over the emitted assembly instructions, but such complex logic to choose the right instructions, we can say that \mbox{\hyperlink{namespace_eigen}{Eigen}} really behaves like an optimizing compiler. If you prefer, you could say that \mbox{\hyperlink{namespace_eigen}{Eigen}} behaves like a script for the compiler. In a sense, C++ template metaprogramming is scripting the compiler -- and it\textquotesingle{}s been shown that this scripting language is Turing-\/complete. See \href{http://en.wikipedia.org/wiki/Template_metaprogramming}{\texttt{ Wikipedia}}. \hypertarget{TopicClassHierarchy}{}\doxysubsection{The class hierarchy}\label{TopicClassHierarchy}
This page explains the design of the core classes in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s class hierarchy and how they fit together. Casual users probably need not concern themselves with these details, but it may be useful for both advanced users and \mbox{\hyperlink{namespace_eigen}{Eigen}} developers.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_class_hierarchy_TopicClassHierarchyPrinciples}{}\doxysubsubsection{Principles}\label{_topic_class_hierarchy_TopicClassHierarchyPrinciples}
\mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s class hierarchy is designed so that virtual functions are avoided where their overhead would significantly impair performance. Instead, \mbox{\hyperlink{namespace_eigen}{Eigen}} achieves polymorphism with the Curiously Recurring Template Pattern (C\+R\+TP). In this pattern, the base class (for instance, {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}}) is in fact a template class, and the derived class (for instance, {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}}) inherits the base class with the derived class itself as a template argument (in this case, {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}} inherits from {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$\mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$>$}). This allows \mbox{\hyperlink{namespace_eigen}{Eigen}} to resolve the polymorphic function calls at compile time.

In addition, the design avoids multiple inheritance. One reason for this is that in our experience, some compilers (like M\+S\+VC) fail to perform empty base class optimization, which is crucial for our fixed-\/size types.\hypertarget{_topic_class_hierarchy_TopicClassHierarchyCoreClasses}{}\doxysubsubsection{The core classes}\label{_topic_class_hierarchy_TopicClassHierarchyCoreClasses}
These are the classes that you need to know about if you want to write functions that accept or return \mbox{\hyperlink{namespace_eigen}{Eigen}} objects.


\begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} means plain dense matrix. If {\ttfamily m} is a {\ttfamily Matrix}, then, for instance, {\ttfamily m+m} is no longer a {\ttfamily Matrix}, it is a \char`\"{}matrix expression\char`\"{}.
\item \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} means dense matrix expression. This means that a {\ttfamily Matrix\+Base} is something that can be added, matrix-\/multiplied, L\+U-\/decomposed, Q\+R-\/decomposed... All matrix expression classes, including {\ttfamily Matrix} itself, inherit {\ttfamily Matrix\+Base}.
\item \mbox{\hyperlink{class_eigen_1_1_array}{Array}} means plain dense array. If {\ttfamily x} is an {\ttfamily Array}, then, for instance, {\ttfamily x+x} is no longer an {\ttfamily Array}, it is an \char`\"{}array expression\char`\"{}.
\item \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} means dense array expression. This means that an {\ttfamily Array\+Base} is something that can be added, array-\/multiplied, and on which you can perform all sorts of array operations... All array expression classes, including {\ttfamily Array} itself, inherit {\ttfamily Array\+Base}.
\item \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}} means dense (matrix or array) expression. Both {\ttfamily Array\+Base} and {\ttfamily Matrix\+Base} inherit {\ttfamily Dense\+Base}. {\ttfamily Dense\+Base} is where all the methods go that apply to dense expressions regardless of whether they are matrix or array expressions. For example, the \mbox{\hyperlink{}{block(...) }} methods are in {\ttfamily Dense\+Base}.
\end{DoxyItemize}\hypertarget{_topic_class_hierarchy_TopicClassHierarchyBaseClasses}{}\doxysubsubsection{Base classes}\label{_topic_class_hierarchy_TopicClassHierarchyBaseClasses}
These classes serve as base classes for the five core classes mentioned above. They are more internal and so less interesting for users of the \mbox{\hyperlink{namespace_eigen}{Eigen}} library.


\begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{Plain\+Object\+Base}} means dense (matrix or array) plain object, i.\+e. something that stores its own dense array of coefficients. This is where, for instance, the \mbox{\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize() }} methods go. {\ttfamily Plain\+Object\+Base} is inherited by {\ttfamily Matrix} and by {\ttfamily Array}. But above, we said that {\ttfamily Matrix} inherits {\ttfamily Matrix\+Base} and {\ttfamily Array} inherits {\ttfamily Array\+Base}. So does that mean multiple inheritance? No, because {\ttfamily Plain\+Object\+Base} {\itshape itself} inherits {\ttfamily Matrix\+Base} or {\ttfamily Array\+Base} depending on whether we are in the matrix or array case. When we said above that {\ttfamily Matrix} inherited {\ttfamily Matrix\+Base}, we omitted to say it does so indirectly via {\ttfamily Plain\+Object\+Base}. Same for {\ttfamily Array}.
\item \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{Dense\+Coeffs\+Base}} means something that has dense coefficient accessors. It is a base class for {\ttfamily Dense\+Base}. The reason for {\ttfamily Dense\+Coeffs\+Base} to exist is that the set of available coefficient accessors is very different depending on whether a dense expression has direct memory access or not (the {\ttfamily Direct\+Access\+Bit} flag). For example, if {\ttfamily x} is a plain matrix, then {\ttfamily x} has direct access, and {\ttfamily x.\+transpose()} and {\ttfamily x.\+block(...)} also have direct access, because their coefficients can be read right off memory, but for example, {\ttfamily x+x} does not have direct memory access, because obtaining any of its coefficients requires a computation (an addition), it can\textquotesingle{}t be just read off memory.
\item \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}} means anything that can be evaluated into a plain dense matrix or array (even if that would be a bad idea). {\ttfamily Eigen\+Base} is really the absolute base class for anything that remotely looks like a matrix or array. It is a base class for {\ttfamily Dense\+Coeffs\+Base}, so it sits below all our dense class hierarchy, but it is not limited to dense expressions. For example, {\ttfamily Eigen\+Base} is also inherited by diagonal matrices, sparse matrices, etc...
\end{DoxyItemize}\hypertarget{_topic_class_hierarchy_TopicClassHierarchyInheritanceDiagrams}{}\doxysubsubsection{Inheritance diagrams}\label{_topic_class_hierarchy_TopicClassHierarchyInheritanceDiagrams}
The inheritance diagram for \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<Matrix>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<Matrix>    (direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<Matrix>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_matrix_base}{MatrixBase}}<Matrix>
        <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{PlainObjectBase}}<Matrix>    (matrix case)
          <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}
\end{DoxyPre}


The inheritance diagram for \mbox{\hyperlink{class_eigen_1_1_array}{Array}} looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<Array>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<Array>    (direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<Array>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_array_base}{ArrayBase}}<Array>
        <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{PlainObjectBase}}<Array>    (array case)
          <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_array}{Array}}
\end{DoxyPre}


The inheritance diagram for some other matrix expression class, here denoted by {\ttfamily Some\+Matrix\+Xpr}, looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<SomeMatrixXpr>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<SomeMatrixXpr>    (direct access or no direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<SomeMatrixXpr>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_matrix_base}{MatrixBase}}<SomeMatrixXpr>
        <-\/-\/ SomeMatrixXpr
\end{DoxyPre}


The inheritance diagram for some other array expression class, here denoted by {\ttfamily Some\+Array\+Xpr}, looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<SomeArrayXpr>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<SomeArrayXpr>    (direct access or no direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<SomeArrayXpr>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_array_base}{ArrayBase}}<SomeArrayXpr>
        <-\/-\/ SomeArrayXpr
\end{DoxyPre}


Finally, consider an example of something that is not a dense expression, for instance a diagonal matrix. The corresponding inheritance diagram is\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<DiagonalMatrix>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_diagonal_base}{DiagonalBase}}<DiagonalMatrix>
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_diagonal_matrix}{DiagonalMatrix}}
\end{DoxyPre}
 \hypertarget{TopicLazyEvaluation}{}\doxysubsection{Lazy Evaluation and Aliasing}\label{TopicLazyEvaluation}
Executive summary\+: Eigen has intelligent compile-\/time mechanisms to enable lazy evaluation and removing temporaries where appropriate. It will handle aliasing automatically in most cases, for example with matrix products. The automatic behavior can be overridden manually by using the \mbox{\hyperlink{class_eigen_1_1_dense_base_a5df64c66228ba75bbc66db2584185527}{Matrix\+Base\+::eval()}} and \mbox{\hyperlink{class_eigen_1_1_matrix_base_a7f15120bb9c88c30aa5d993bd6d138e1}{Matrix\+Base\+::noalias()}} methods.

When you write a line of code involving a complex expression such as


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} * (\mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}} + mat5);}
\end{DoxyCode}


Eigen determines automatically, for each sub-\/expression, whether to evaluate it into a temporary variable. Indeed, in certain cases it is better to evaluate a sub-\/expression into a temporary variable, while in other cases it is better to avoid that.

A traditional math library without expression templates always evaluates all sub-\/expressions into temporaries. So with this code,


\begin{DoxyCode}{0}
\DoxyCodeLine{vec1 = \mbox{\hyperlink{group__core__types_gaa1618f51db67eaa145db101d8c8431d8}{vec2}} + \mbox{\hyperlink{group__core__types_ga1c47e8b3386109bc992b6c48e91b0be7}{vec3}};}
\end{DoxyCode}


a traditional library would evaluate {\ttfamily vec2} + vec3 into a temporary {\ttfamily vec4} and then copy {\ttfamily vec4} into {\ttfamily vec1}. This is of course inefficient\+: the arrays are traversed twice, so there are a lot of useless load/store operations.

Expression-\/templates-\/based libraries can avoid evaluating sub-\/expressions into temporaries, which in many cases results in large speed improvements. This is called {\itshape lazy evaluation} as an expression is getting evaluated as late as possible. In Eigen {\bfseries{all expressions are lazy-\/evaluated}}. More precisely, an expression starts to be evaluated once it is assigned to a matrix. Until then nothing happens beyond constructing the abstract expression tree. In contrast to most other expression-\/templates-\/based libraries, however, {\bfseries{Eigen might choose to evaluate some sub-\/expressions into temporaries}}. There are two reasons for that\+: first, pure lazy evaluation is not always a good choice for performance; second, pure lazy evaluation can be very dangerous, for example with matrix products\+: doing {\ttfamily mat = mat$\ast$mat} gives a wrong result if the matrix product is directly evaluated within the destination matrix, because of the way matrix product works.

For these reasons, Eigen has intelligent compile-\/time mechanisms to determine automatically which sub-\/expression should be evaluated into a temporary variable.

So in the basic example,


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}};}
\end{DoxyCode}


Eigen chooses not to introduce any temporary. Thus the arrays are traversed only once, producing optimized code. If you really want to force immediate evaluation, use \mbox{\hyperlink{class_eigen_1_1_dense_base_a5df64c66228ba75bbc66db2584185527}{eval()}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = (\mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}}).eval();}
\end{DoxyCode}


Here is now a more involved example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = -\/\mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} + \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} + 5 * \mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}};}
\end{DoxyCode}


Here again Eigen won\textquotesingle{}t introduce any temporary, thus producing a single {\bfseries{fused}} evaluation loop, which is clearly the correct choice.\hypertarget{_topic_lazy_evaluation_TopicLazyEvaluationWhichExpr}{}\doxysubsubsection{Which sub-\/expressions are evaluated into temporaries?}\label{_topic_lazy_evaluation_TopicLazyEvaluationWhichExpr}
The default evaluation strategy is to fuse the operations in a single loop, and Eigen will choose it except in a few circumstances.

{\bfseries{The first circumstance}} in which Eigen chooses to evaluate a sub-\/expression is when it sees an assignment {\ttfamily a = b;} and the expression {\ttfamily b} has the evaluate-\/before-\/assigning \mbox{\hyperlink{group__flags}{flag}}. The most important example of such an expression is the \mbox{\hyperlink{class_eigen_1_1_product}{matrix product expression}}. For example, when you do


\begin{DoxyCode}{0}
\DoxyCodeLine{mat = mat * mat;}
\end{DoxyCode}


Eigen will evaluate {\ttfamily mat $\ast$ mat} into a temporary matrix, and then copies it into the original {\ttfamily mat}. This guarantees a correct result as we saw above that lazy evaluation gives wrong results with matrix products. It also doesn\textquotesingle{}t cost much, as the cost of the matrix product itself is much higher. Note that this temporary is introduced at evaluation time only, that is, within operator= in this example. The expression {\ttfamily mat $\ast$ mat} still return a abstract product type.

What if you know that the result does no alias the operand of the product and want to force lazy evaluation? Then use \mbox{\hyperlink{class_eigen_1_1_matrix_base_a7f15120bb9c88c30aa5d993bd6d138e1}{.noalias()}} instead. Here is an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1.noalias() = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} * \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}};}
\end{DoxyCode}


Here, since we know that mat2 is not the same matrix as mat1, we know that lazy evaluation is not dangerous, so we may force lazy evaluation. Concretely, the effect of noalias() here is to bypass the evaluate-\/before-\/assigning \mbox{\hyperlink{group__flags}{flag}}.

{\bfseries{The second circumstance}} in which Eigen chooses to evaluate a sub-\/expression, is when it sees a nested expression such as {\ttfamily a + b} where {\ttfamily b} is already an expression having the evaluate-\/before-\/nesting \mbox{\hyperlink{group__flags}{flag}}. Again, the most important example of such an expression is the \mbox{\hyperlink{class_eigen_1_1_product}{matrix product expression}}. For example, when you do


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} * \mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} + \mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}} * mat5;}
\end{DoxyCode}


the products {\ttfamily mat2 $\ast$ mat3} and {\ttfamily mat4 $\ast$ mat5} gets evaluated separately into temporary matrices before being summed up in {\ttfamily mat1}. Indeed, to be efficient matrix products need to be evaluated within a destination matrix at hand, and not as simple \char`\"{}dot products\char`\"{}. For small matrices, however, you might want to enforce a \char`\"{}dot-\/product\char`\"{} based lazy evaluation with lazy\+Product(). Again, it is important to understand that those temporaries are created at evaluation time only, that is in operator =. See Topic\+Pitfalls\+\_\+auto\+\_\+keyword for common pitfalls regarding this remark.

{\bfseries{The third circumstance}} in which Eigen chooses to evaluate a sub-\/expression, is when its cost model shows that the total cost of an operation is reduced if a sub-\/expression gets evaluated into a temporary. Indeed, in certain cases, an intermediate result is sufficiently costly to compute and is reused sufficiently many times, that is worth \char`\"{}caching\char`\"{}. Here is an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = \mbox{\hyperlink{group__core__types_ga8357ec0aab6f8cf69313592492663c3f}{mat2}} * (\mbox{\hyperlink{group__core__types_gadfaff2a7dce5cbf4e77a47ecea42ac5b}{mat3}} + \mbox{\hyperlink{group__core__types_ga7dcd2365c2e368e6af5b7adeb6a9c8df}{mat4}});}
\end{DoxyCode}


Here, provided the matrices have at least 2 rows and 2 columns, each coefficient of the expression {\ttfamily mat3 + mat4} is going to be used several times in the matrix product. Instead of computing the sum every time, it is much better to compute it once and store it in a temporary variable. Eigen understands this and evaluates {\ttfamily mat3 + mat4} into a temporary variable before evaluating the product. \hypertarget{TopicCMakeGuide}{}\doxysection{Using Eigen in C\+Make Projects}\label{TopicCMakeGuide}
Eigen provides native C\+Make support which allows the library to be easily used in C\+Make projects.

\begin{DoxyNote}{Note}
C\+Make 3.\+0 (or later) is required to enable this functionality.
\end{DoxyNote}
Eigen exports a C\+Make target called {\ttfamily Eigen3\+::\+Eigen} which can be imported using the {\ttfamily find\+\_\+package} C\+Make command and used by calling {\ttfamily target\+\_\+link\+\_\+libraries} as in the following example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake\_minimum\_required (VERSION 3.0)}
\DoxyCodeLine{project (myproject)}
\DoxyCodeLine{}
\DoxyCodeLine{find\_package (Eigen3 3.3 REQUIRED NO\_MODULE)}
\DoxyCodeLine{}
\DoxyCodeLine{add\_executable (example example.cpp)}
\DoxyCodeLine{target\_link\_libraries (example Eigen3::Eigen)}
\end{DoxyCode}


The above code snippet must be placed in a file called {\ttfamily C\+Make\+Lists.\+txt} alongside {\ttfamily example.\+cpp}. After running 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ cmake path-\/to-\/example-\/directory}
\end{DoxyCode}
 C\+Make will produce project files that generate an executable called {\ttfamily example} which requires at least version 3.\+3 of Eigen. Here, {\ttfamily path-\/to-\/example-\/directory} is the path to the directory that contains both {\ttfamily C\+Make\+Lists.\+txt} and {\ttfamily example.\+cpp}.

Do not forget to set the \href{https://cmake.org/cmake/help/v3.7/variable/CMAKE_PREFIX_PATH.html}{\texttt{ {\ttfamily C\+M\+A\+K\+E\+\_\+\+P\+R\+E\+F\+I\+X\+\_\+\+P\+A\+TH} }} variable if \mbox{\hyperlink{namespace_eigen}{Eigen}} is not installed in a default location or if you want to pick a specific version. For instance\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ cmake path-\/to-\/example-\/directory -\/DCMAKE\_PREFIX\_PATH=\$HOME/mypackages}
\end{DoxyCode}
 An alternative is to set the {\ttfamily Eigen3\+\_\+\+D\+IR} cmake\textquotesingle{}s variable to the respective path containing the {\ttfamily Eigen3$\ast$}.cmake files. For instance\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ cmake path-\/to-\/example-\/directory -\/DEigen3\_DIR=\$HOME/mypackages/share/eigen3/cmake/}
\end{DoxyCode}


If the {\ttfamily R\+E\+Q\+U\+I\+R\+ED} option is omitted when locating Eigen using {\ttfamily find\+\_\+package}, one can check whether the package was found as follows\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{find\_package (Eigen3 3.3 NO\_MODULE)}
\DoxyCodeLine{}
\DoxyCodeLine{if (TARGET Eigen3::Eigen)}
\DoxyCodeLine{  \# Use the imported target}
\DoxyCodeLine{endif (TARGET Eigen3::Eigen)}
\end{DoxyCode}
 